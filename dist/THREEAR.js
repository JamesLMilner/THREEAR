(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["THREEAR"] = factory();
	else
		root["THREEAR"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/THREEAR.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/asn1.js/lib/asn1.js":
/*!******************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var asn1 = exports;\n\nasn1.bignum = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\n\nasn1.define = __webpack_require__(/*! ./asn1/api */ \"./node_modules/asn1.js/lib/asn1/api.js\").define;\nasn1.base = __webpack_require__(/*! ./asn1/base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\");\nasn1.constants = __webpack_require__(/*! ./asn1/constants */ \"./node_modules/asn1.js/lib/asn1/constants/index.js\");\nasn1.decoders = __webpack_require__(/*! ./asn1/decoders */ \"./node_modules/asn1.js/lib/asn1/decoders/index.js\");\nasn1.encoders = __webpack_require__(/*! ./asn1/encoders */ \"./node_modules/asn1.js/lib/asn1/encoders/index.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/api.js":
/*!**********************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/api.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var asn1 = __webpack_require__(/*! ../asn1 */ \"./node_modules/asn1.js/lib/asn1.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar api = exports;\n\napi.define = function define(name, body) {\n  return new Entity(name, body);\n};\n\nfunction Entity(name, body) {\n  this.name = name;\n  this.body = body;\n\n  this.decoders = {};\n  this.encoders = {};\n};\n\nEntity.prototype._createNamed = function createNamed(base) {\n  var named;\n  try {\n    named = __webpack_require__(/*! vm */ \"./node_modules/vm-browserify/index.js\").runInThisContext(\n      '(function ' + this.name + '(entity) {\\n' +\n      '  this._initNamed(entity);\\n' +\n      '})'\n    );\n  } catch (e) {\n    named = function (entity) {\n      this._initNamed(entity);\n    };\n  }\n  inherits(named, base);\n  named.prototype._initNamed = function initnamed(entity) {\n    base.call(this, entity);\n  };\n\n  return new named(this);\n};\n\nEntity.prototype._getDecoder = function _getDecoder(enc) {\n  enc = enc || 'der';\n  // Lazily create decoder\n  if (!this.decoders.hasOwnProperty(enc))\n    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);\n  return this.decoders[enc];\n};\n\nEntity.prototype.decode = function decode(data, enc, options) {\n  return this._getDecoder(enc).decode(data, options);\n};\n\nEntity.prototype._getEncoder = function _getEncoder(enc) {\n  enc = enc || 'der';\n  // Lazily create encoder\n  if (!this.encoders.hasOwnProperty(enc))\n    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);\n  return this.encoders[enc];\n};\n\nEntity.prototype.encode = function encode(data, enc, /* internal */ reporter) {\n  return this._getEncoder(enc).encode(data, reporter);\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/api.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Reporter = __webpack_require__(/*! ../base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\").Reporter;\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nfunction DecoderBuffer(base, options) {\n  Reporter.call(this, options);\n  if (!Buffer.isBuffer(base)) {\n    this.error('Input not Buffer');\n    return;\n  }\n\n  this.base = base;\n  this.offset = 0;\n  this.length = base.length;\n}\ninherits(DecoderBuffer, Reporter);\nexports.DecoderBuffer = DecoderBuffer;\n\nDecoderBuffer.prototype.save = function save() {\n  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };\n};\n\nDecoderBuffer.prototype.restore = function restore(save) {\n  // Return skipped data\n  var res = new DecoderBuffer(this.base);\n  res.offset = save.offset;\n  res.length = this.offset;\n\n  this.offset = save.offset;\n  Reporter.prototype.restore.call(this, save.reporter);\n\n  return res;\n};\n\nDecoderBuffer.prototype.isEmpty = function isEmpty() {\n  return this.offset === this.length;\n};\n\nDecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {\n  if (this.offset + 1 <= this.length)\n    return this.base.readUInt8(this.offset++, true);\n  else\n    return this.error(fail || 'DecoderBuffer overrun');\n}\n\nDecoderBuffer.prototype.skip = function skip(bytes, fail) {\n  if (!(this.offset + bytes <= this.length))\n    return this.error(fail || 'DecoderBuffer overrun');\n\n  var res = new DecoderBuffer(this.base);\n\n  // Share reporter state\n  res._reporterState = this._reporterState;\n\n  res.offset = this.offset;\n  res.length = this.offset + bytes;\n  this.offset += bytes;\n  return res;\n}\n\nDecoderBuffer.prototype.raw = function raw(save) {\n  return this.base.slice(save ? save.offset : this.offset, this.length);\n}\n\nfunction EncoderBuffer(value, reporter) {\n  if (Array.isArray(value)) {\n    this.length = 0;\n    this.value = value.map(function(item) {\n      if (!(item instanceof EncoderBuffer))\n        item = new EncoderBuffer(item, reporter);\n      this.length += item.length;\n      return item;\n    }, this);\n  } else if (typeof value === 'number') {\n    if (!(0 <= value && value <= 0xff))\n      return reporter.error('non-byte EncoderBuffer value');\n    this.value = value;\n    this.length = 1;\n  } else if (typeof value === 'string') {\n    this.value = value;\n    this.length = Buffer.byteLength(value);\n  } else if (Buffer.isBuffer(value)) {\n    this.value = value;\n    this.length = value.length;\n  } else {\n    return reporter.error('Unsupported type: ' + typeof value);\n  }\n}\nexports.EncoderBuffer = EncoderBuffer;\n\nEncoderBuffer.prototype.join = function join(out, offset) {\n  if (!out)\n    out = new Buffer(this.length);\n  if (!offset)\n    offset = 0;\n\n  if (this.length === 0)\n    return out;\n\n  if (Array.isArray(this.value)) {\n    this.value.forEach(function(item) {\n      item.join(out, offset);\n      offset += item.length;\n    });\n  } else {\n    if (typeof this.value === 'number')\n      out[offset] = this.value;\n    else if (typeof this.value === 'string')\n      out.write(this.value, offset);\n    else if (Buffer.isBuffer(this.value))\n      this.value.copy(out, offset);\n    offset += this.length;\n  }\n\n  return out;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/base/buffer.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var base = exports;\n\nbase.Reporter = __webpack_require__(/*! ./reporter */ \"./node_modules/asn1.js/lib/asn1/base/reporter.js\").Reporter;\nbase.DecoderBuffer = __webpack_require__(/*! ./buffer */ \"./node_modules/asn1.js/lib/asn1/base/buffer.js\").DecoderBuffer;\nbase.EncoderBuffer = __webpack_require__(/*! ./buffer */ \"./node_modules/asn1.js/lib/asn1/base/buffer.js\").EncoderBuffer;\nbase.Node = __webpack_require__(/*! ./node */ \"./node_modules/asn1.js/lib/asn1/base/node.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/base/index.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/node.js":
/*!****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Reporter = __webpack_require__(/*! ../base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\").Reporter;\nvar EncoderBuffer = __webpack_require__(/*! ../base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\").EncoderBuffer;\nvar DecoderBuffer = __webpack_require__(/*! ../base */ \"./node_modules/asn1.js/lib/asn1/base/index.js\").DecoderBuffer;\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\n// Supported tags\nvar tags = [\n  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',\n  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',\n  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',\n  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'\n];\n\n// Public methods list\nvar methods = [\n  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',\n  'any', 'contains'\n].concat(tags);\n\n// Overrided methods list\nvar overrided = [\n  '_peekTag', '_decodeTag', '_use',\n  '_decodeStr', '_decodeObjid', '_decodeTime',\n  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',\n\n  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',\n  '_encodeNull', '_encodeInt', '_encodeBool'\n];\n\nfunction Node(enc, parent) {\n  var state = {};\n  this._baseState = state;\n\n  state.enc = enc;\n\n  state.parent = parent || null;\n  state.children = null;\n\n  // State\n  state.tag = null;\n  state.args = null;\n  state.reverseArgs = null;\n  state.choice = null;\n  state.optional = false;\n  state.any = false;\n  state.obj = false;\n  state.use = null;\n  state.useDecoder = null;\n  state.key = null;\n  state['default'] = null;\n  state.explicit = null;\n  state.implicit = null;\n  state.contains = null;\n\n  // Should create new instance on each method\n  if (!state.parent) {\n    state.children = [];\n    this._wrap();\n  }\n}\nmodule.exports = Node;\n\nvar stateProps = [\n  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',\n  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',\n  'implicit', 'contains'\n];\n\nNode.prototype.clone = function clone() {\n  var state = this._baseState;\n  var cstate = {};\n  stateProps.forEach(function(prop) {\n    cstate[prop] = state[prop];\n  });\n  var res = new this.constructor(cstate.parent);\n  res._baseState = cstate;\n  return res;\n};\n\nNode.prototype._wrap = function wrap() {\n  var state = this._baseState;\n  methods.forEach(function(method) {\n    this[method] = function _wrappedMethod() {\n      var clone = new this.constructor(this);\n      state.children.push(clone);\n      return clone[method].apply(clone, arguments);\n    };\n  }, this);\n};\n\nNode.prototype._init = function init(body) {\n  var state = this._baseState;\n\n  assert(state.parent === null);\n  body.call(this);\n\n  // Filter children\n  state.children = state.children.filter(function(child) {\n    return child._baseState.parent === this;\n  }, this);\n  assert.equal(state.children.length, 1, 'Root node can have only one child');\n};\n\nNode.prototype._useArgs = function useArgs(args) {\n  var state = this._baseState;\n\n  // Filter children and args\n  var children = args.filter(function(arg) {\n    return arg instanceof this.constructor;\n  }, this);\n  args = args.filter(function(arg) {\n    return !(arg instanceof this.constructor);\n  }, this);\n\n  if (children.length !== 0) {\n    assert(state.children === null);\n    state.children = children;\n\n    // Replace parent to maintain backward link\n    children.forEach(function(child) {\n      child._baseState.parent = this;\n    }, this);\n  }\n  if (args.length !== 0) {\n    assert(state.args === null);\n    state.args = args;\n    state.reverseArgs = args.map(function(arg) {\n      if (typeof arg !== 'object' || arg.constructor !== Object)\n        return arg;\n\n      var res = {};\n      Object.keys(arg).forEach(function(key) {\n        if (key == (key | 0))\n          key |= 0;\n        var value = arg[key];\n        res[value] = key;\n      });\n      return res;\n    });\n  }\n};\n\n//\n// Overrided methods\n//\n\noverrided.forEach(function(method) {\n  Node.prototype[method] = function _overrided() {\n    var state = this._baseState;\n    throw new Error(method + ' not implemented for encoding: ' + state.enc);\n  };\n});\n\n//\n// Public methods\n//\n\ntags.forEach(function(tag) {\n  Node.prototype[tag] = function _tagMethod() {\n    var state = this._baseState;\n    var args = Array.prototype.slice.call(arguments);\n\n    assert(state.tag === null);\n    state.tag = tag;\n\n    this._useArgs(args);\n\n    return this;\n  };\n});\n\nNode.prototype.use = function use(item) {\n  assert(item);\n  var state = this._baseState;\n\n  assert(state.use === null);\n  state.use = item;\n\n  return this;\n};\n\nNode.prototype.optional = function optional() {\n  var state = this._baseState;\n\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.def = function def(val) {\n  var state = this._baseState;\n\n  assert(state['default'] === null);\n  state['default'] = val;\n  state.optional = true;\n\n  return this;\n};\n\nNode.prototype.explicit = function explicit(num) {\n  var state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.explicit = num;\n\n  return this;\n};\n\nNode.prototype.implicit = function implicit(num) {\n  var state = this._baseState;\n\n  assert(state.explicit === null && state.implicit === null);\n  state.implicit = num;\n\n  return this;\n};\n\nNode.prototype.obj = function obj() {\n  var state = this._baseState;\n  var args = Array.prototype.slice.call(arguments);\n\n  state.obj = true;\n\n  if (args.length !== 0)\n    this._useArgs(args);\n\n  return this;\n};\n\nNode.prototype.key = function key(newKey) {\n  var state = this._baseState;\n\n  assert(state.key === null);\n  state.key = newKey;\n\n  return this;\n};\n\nNode.prototype.any = function any() {\n  var state = this._baseState;\n\n  state.any = true;\n\n  return this;\n};\n\nNode.prototype.choice = function choice(obj) {\n  var state = this._baseState;\n\n  assert(state.choice === null);\n  state.choice = obj;\n  this._useArgs(Object.keys(obj).map(function(key) {\n    return obj[key];\n  }));\n\n  return this;\n};\n\nNode.prototype.contains = function contains(item) {\n  var state = this._baseState;\n\n  assert(state.use === null);\n  state.contains = item;\n\n  return this;\n};\n\n//\n// Decoding\n//\n\nNode.prototype._decode = function decode(input, options) {\n  var state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return input.wrapResult(state.children[0]._decode(input, options));\n\n  var result = state['default'];\n  var present = true;\n\n  var prevKey = null;\n  if (state.key !== null)\n    prevKey = input.enterKey(state.key);\n\n  // Check if tag is there\n  if (state.optional) {\n    var tag = null;\n    if (state.explicit !== null)\n      tag = state.explicit;\n    else if (state.implicit !== null)\n      tag = state.implicit;\n    else if (state.tag !== null)\n      tag = state.tag;\n\n    if (tag === null && !state.any) {\n      // Trial and Error\n      var save = input.save();\n      try {\n        if (state.choice === null)\n          this._decodeGeneric(state.tag, input, options);\n        else\n          this._decodeChoice(input, options);\n        present = true;\n      } catch (e) {\n        present = false;\n      }\n      input.restore(save);\n    } else {\n      present = this._peekTag(input, tag, state.any);\n\n      if (input.isError(present))\n        return present;\n    }\n  }\n\n  // Push object on stack\n  var prevObj;\n  if (state.obj && present)\n    prevObj = input.enterObject();\n\n  if (present) {\n    // Unwrap explicit values\n    if (state.explicit !== null) {\n      var explicit = this._decodeTag(input, state.explicit);\n      if (input.isError(explicit))\n        return explicit;\n      input = explicit;\n    }\n\n    var start = input.offset;\n\n    // Unwrap implicit and normal values\n    if (state.use === null && state.choice === null) {\n      if (state.any)\n        var save = input.save();\n      var body = this._decodeTag(\n        input,\n        state.implicit !== null ? state.implicit : state.tag,\n        state.any\n      );\n      if (input.isError(body))\n        return body;\n\n      if (state.any)\n        result = input.raw(save);\n      else\n        input = body;\n    }\n\n    if (options && options.track && state.tag !== null)\n      options.track(input.path(), start, input.length, 'tagged');\n\n    if (options && options.track && state.tag !== null)\n      options.track(input.path(), input.offset, input.length, 'content');\n\n    // Select proper method for tag\n    if (state.any)\n      result = result;\n    else if (state.choice === null)\n      result = this._decodeGeneric(state.tag, input, options);\n    else\n      result = this._decodeChoice(input, options);\n\n    if (input.isError(result))\n      return result;\n\n    // Decode children\n    if (!state.any && state.choice === null && state.children !== null) {\n      state.children.forEach(function decodeChildren(child) {\n        // NOTE: We are ignoring errors here, to let parser continue with other\n        // parts of encoded data\n        child._decode(input, options);\n      });\n    }\n\n    // Decode contained/encoded by schema, only in bit or octet strings\n    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {\n      var data = new DecoderBuffer(result);\n      result = this._getUse(state.contains, input._reporterState.obj)\n          ._decode(data, options);\n    }\n  }\n\n  // Pop object\n  if (state.obj && present)\n    result = input.leaveObject(prevObj);\n\n  // Set key\n  if (state.key !== null && (result !== null || present === true))\n    input.leaveKey(prevKey, state.key, result);\n  else if (prevKey !== null)\n    input.exitKey(prevKey);\n\n  return result;\n};\n\nNode.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {\n  var state = this._baseState;\n\n  if (tag === 'seq' || tag === 'set')\n    return null;\n  if (tag === 'seqof' || tag === 'setof')\n    return this._decodeList(input, tag, state.args[0], options);\n  else if (/str$/.test(tag))\n    return this._decodeStr(input, tag, options);\n  else if (tag === 'objid' && state.args)\n    return this._decodeObjid(input, state.args[0], state.args[1], options);\n  else if (tag === 'objid')\n    return this._decodeObjid(input, null, null, options);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._decodeTime(input, tag, options);\n  else if (tag === 'null_')\n    return this._decodeNull(input, options);\n  else if (tag === 'bool')\n    return this._decodeBool(input, options);\n  else if (tag === 'objDesc')\n    return this._decodeStr(input, tag, options);\n  else if (tag === 'int' || tag === 'enum')\n    return this._decodeInt(input, state.args && state.args[0], options);\n\n  if (state.use !== null) {\n    return this._getUse(state.use, input._reporterState.obj)\n        ._decode(input, options);\n  } else {\n    return input.error('unknown tag: ' + tag);\n  }\n};\n\nNode.prototype._getUse = function _getUse(entity, obj) {\n\n  var state = this._baseState;\n  // Create altered use decoder if implicit is set\n  state.useDecoder = this._use(entity, obj);\n  assert(state.useDecoder._baseState.parent === null);\n  state.useDecoder = state.useDecoder._baseState.children[0];\n  if (state.implicit !== state.useDecoder._baseState.implicit) {\n    state.useDecoder = state.useDecoder.clone();\n    state.useDecoder._baseState.implicit = state.implicit;\n  }\n  return state.useDecoder;\n};\n\nNode.prototype._decodeChoice = function decodeChoice(input, options) {\n  var state = this._baseState;\n  var result = null;\n  var match = false;\n\n  Object.keys(state.choice).some(function(key) {\n    var save = input.save();\n    var node = state.choice[key];\n    try {\n      var value = node._decode(input, options);\n      if (input.isError(value))\n        return false;\n\n      result = { type: key, value: value };\n      match = true;\n    } catch (e) {\n      input.restore(save);\n      return false;\n    }\n    return true;\n  }, this);\n\n  if (!match)\n    return input.error('Choice not matched');\n\n  return result;\n};\n\n//\n// Encoding\n//\n\nNode.prototype._createEncoderBuffer = function createEncoderBuffer(data) {\n  return new EncoderBuffer(data, this.reporter);\n};\n\nNode.prototype._encode = function encode(data, reporter, parent) {\n  var state = this._baseState;\n  if (state['default'] !== null && state['default'] === data)\n    return;\n\n  var result = this._encodeValue(data, reporter, parent);\n  if (result === undefined)\n    return;\n\n  if (this._skipDefault(result, reporter, parent))\n    return;\n\n  return result;\n};\n\nNode.prototype._encodeValue = function encode(data, reporter, parent) {\n  var state = this._baseState;\n\n  // Decode root node\n  if (state.parent === null)\n    return state.children[0]._encode(data, reporter || new Reporter());\n\n  var result = null;\n\n  // Set reporter to share it with a child class\n  this.reporter = reporter;\n\n  // Check if data is there\n  if (state.optional && data === undefined) {\n    if (state['default'] !== null)\n      data = state['default']\n    else\n      return;\n  }\n\n  // Encode children first\n  var content = null;\n  var primitive = false;\n  if (state.any) {\n    // Anything that was given is translated to buffer\n    result = this._createEncoderBuffer(data);\n  } else if (state.choice) {\n    result = this._encodeChoice(data, reporter);\n  } else if (state.contains) {\n    content = this._getUse(state.contains, parent)._encode(data, reporter);\n    primitive = true;\n  } else if (state.children) {\n    content = state.children.map(function(child) {\n      if (child._baseState.tag === 'null_')\n        return child._encode(null, reporter, data);\n\n      if (child._baseState.key === null)\n        return reporter.error('Child should have a key');\n      var prevKey = reporter.enterKey(child._baseState.key);\n\n      if (typeof data !== 'object')\n        return reporter.error('Child expected, but input is not object');\n\n      var res = child._encode(data[child._baseState.key], reporter, data);\n      reporter.leaveKey(prevKey);\n\n      return res;\n    }, this).filter(function(child) {\n      return child;\n    });\n    content = this._createEncoderBuffer(content);\n  } else {\n    if (state.tag === 'seqof' || state.tag === 'setof') {\n      // TODO(indutny): this should be thrown on DSL level\n      if (!(state.args && state.args.length === 1))\n        return reporter.error('Too many args for : ' + state.tag);\n\n      if (!Array.isArray(data))\n        return reporter.error('seqof/setof, but data is not Array');\n\n      var child = this.clone();\n      child._baseState.implicit = null;\n      content = this._createEncoderBuffer(data.map(function(item) {\n        var state = this._baseState;\n\n        return this._getUse(state.args[0], data)._encode(item, reporter);\n      }, child));\n    } else if (state.use !== null) {\n      result = this._getUse(state.use, parent)._encode(data, reporter);\n    } else {\n      content = this._encodePrimitive(state.tag, data);\n      primitive = true;\n    }\n  }\n\n  // Encode data itself\n  var result;\n  if (!state.any && state.choice === null) {\n    var tag = state.implicit !== null ? state.implicit : state.tag;\n    var cls = state.implicit === null ? 'universal' : 'context';\n\n    if (tag === null) {\n      if (state.use === null)\n        reporter.error('Tag could be omitted only for .use()');\n    } else {\n      if (state.use === null)\n        result = this._encodeComposite(tag, primitive, cls, content);\n    }\n  }\n\n  // Wrap in explicit\n  if (state.explicit !== null)\n    result = this._encodeComposite(state.explicit, false, 'context', result);\n\n  return result;\n};\n\nNode.prototype._encodeChoice = function encodeChoice(data, reporter) {\n  var state = this._baseState;\n\n  var node = state.choice[data.type];\n  if (!node) {\n    assert(\n        false,\n        data.type + ' not found in ' +\n            JSON.stringify(Object.keys(state.choice)));\n  }\n  return node._encode(data.value, reporter);\n};\n\nNode.prototype._encodePrimitive = function encodePrimitive(tag, data) {\n  var state = this._baseState;\n\n  if (/str$/.test(tag))\n    return this._encodeStr(data, tag);\n  else if (tag === 'objid' && state.args)\n    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);\n  else if (tag === 'objid')\n    return this._encodeObjid(data, null, null);\n  else if (tag === 'gentime' || tag === 'utctime')\n    return this._encodeTime(data, tag);\n  else if (tag === 'null_')\n    return this._encodeNull();\n  else if (tag === 'int' || tag === 'enum')\n    return this._encodeInt(data, state.args && state.reverseArgs[0]);\n  else if (tag === 'bool')\n    return this._encodeBool(data);\n  else if (tag === 'objDesc')\n    return this._encodeStr(data, tag);\n  else\n    throw new Error('Unsupported tag: ' + tag);\n};\n\nNode.prototype._isNumstr = function isNumstr(str) {\n  return /^[0-9 ]*$/.test(str);\n};\n\nNode.prototype._isPrintstr = function isPrintstr(str) {\n  return /^[A-Za-z0-9 '\\(\\)\\+,\\-\\.\\/:=\\?]*$/.test(str);\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/base/node.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/reporter.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/reporter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nfunction Reporter(options) {\n  this._reporterState = {\n    obj: null,\n    path: [],\n    options: options || {},\n    errors: []\n  };\n}\nexports.Reporter = Reporter;\n\nReporter.prototype.isError = function isError(obj) {\n  return obj instanceof ReporterError;\n};\n\nReporter.prototype.save = function save() {\n  var state = this._reporterState;\n\n  return { obj: state.obj, pathLen: state.path.length };\n};\n\nReporter.prototype.restore = function restore(data) {\n  var state = this._reporterState;\n\n  state.obj = data.obj;\n  state.path = state.path.slice(0, data.pathLen);\n};\n\nReporter.prototype.enterKey = function enterKey(key) {\n  return this._reporterState.path.push(key);\n};\n\nReporter.prototype.exitKey = function exitKey(index) {\n  var state = this._reporterState;\n\n  state.path = state.path.slice(0, index - 1);\n};\n\nReporter.prototype.leaveKey = function leaveKey(index, key, value) {\n  var state = this._reporterState;\n\n  this.exitKey(index);\n  if (state.obj !== null)\n    state.obj[key] = value;\n};\n\nReporter.prototype.path = function path() {\n  return this._reporterState.path.join('/');\n};\n\nReporter.prototype.enterObject = function enterObject() {\n  var state = this._reporterState;\n\n  var prev = state.obj;\n  state.obj = {};\n  return prev;\n};\n\nReporter.prototype.leaveObject = function leaveObject(prev) {\n  var state = this._reporterState;\n\n  var now = state.obj;\n  state.obj = prev;\n  return now;\n};\n\nReporter.prototype.error = function error(msg) {\n  var err;\n  var state = this._reporterState;\n\n  var inherited = msg instanceof ReporterError;\n  if (inherited) {\n    err = msg;\n  } else {\n    err = new ReporterError(state.path.map(function(elem) {\n      return '[' + JSON.stringify(elem) + ']';\n    }).join(''), msg.message || msg, msg.stack);\n  }\n\n  if (!state.options.partial)\n    throw err;\n\n  if (!inherited)\n    state.errors.push(err);\n\n  return err;\n};\n\nReporter.prototype.wrapResult = function wrapResult(result) {\n  var state = this._reporterState;\n  if (!state.options.partial)\n    return result;\n\n  return {\n    result: this.isError(result) ? null : result,\n    errors: state.errors\n  };\n};\n\nfunction ReporterError(path, msg) {\n  this.path = path;\n  this.rethrow(msg);\n};\ninherits(ReporterError, Error);\n\nReporterError.prototype.rethrow = function rethrow(msg) {\n  this.message = msg + ' at: ' + (this.path || '(shallow)');\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, ReporterError);\n\n  if (!this.stack) {\n    try {\n      // IE only adds stack when thrown\n      throw new Error(this.message);\n    } catch (e) {\n      this.stack = e.stack;\n    }\n  }\n  return this;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/base/reporter.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/der.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/der.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constants = __webpack_require__(/*! ../constants */ \"./node_modules/asn1.js/lib/asn1/constants/index.js\");\n\nexports.tagClass = {\n  0: 'universal',\n  1: 'application',\n  2: 'context',\n  3: 'private'\n};\nexports.tagClassByName = constants._reverse(exports.tagClass);\n\nexports.tag = {\n  0x00: 'end',\n  0x01: 'bool',\n  0x02: 'int',\n  0x03: 'bitstr',\n  0x04: 'octstr',\n  0x05: 'null_',\n  0x06: 'objid',\n  0x07: 'objDesc',\n  0x08: 'external',\n  0x09: 'real',\n  0x0a: 'enum',\n  0x0b: 'embed',\n  0x0c: 'utf8str',\n  0x0d: 'relativeOid',\n  0x10: 'seq',\n  0x11: 'set',\n  0x12: 'numstr',\n  0x13: 'printstr',\n  0x14: 't61str',\n  0x15: 'videostr',\n  0x16: 'ia5str',\n  0x17: 'utctime',\n  0x18: 'gentime',\n  0x19: 'graphstr',\n  0x1a: 'iso646str',\n  0x1b: 'genstr',\n  0x1c: 'unistr',\n  0x1d: 'charstr',\n  0x1e: 'bmpstr'\n};\nexports.tagByName = constants._reverse(exports.tag);\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/constants/der.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var constants = exports;\n\n// Helper\nconstants._reverse = function reverse(map) {\n  var res = {};\n\n  Object.keys(map).forEach(function(key) {\n    // Convert key to integer if it is stringified\n    if ((key | 0) == key)\n      key = key | 0;\n\n    var value = map[key];\n    res[value] = key;\n  });\n\n  return res;\n};\n\nconstants.der = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/constants/der.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/constants/index.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar asn1 = __webpack_require__(/*! ../../asn1 */ \"./node_modules/asn1.js/lib/asn1.js\");\nvar base = asn1.base;\nvar bignum = asn1.bignum;\n\n// Import DER constants\nvar der = asn1.constants.der;\n\nfunction DERDecoder(entity) {\n  this.enc = 'der';\n  this.name = entity.name;\n  this.entity = entity;\n\n  // Construct base tree\n  this.tree = new DERNode();\n  this.tree._init(entity.body);\n};\nmodule.exports = DERDecoder;\n\nDERDecoder.prototype.decode = function decode(data, options) {\n  if (!(data instanceof base.DecoderBuffer))\n    data = new base.DecoderBuffer(data, options);\n\n  return this.tree._decode(data, options);\n};\n\n// Tree methods\n\nfunction DERNode(parent) {\n  base.Node.call(this, 'der', parent);\n}\ninherits(DERNode, base.Node);\n\nDERNode.prototype._peekTag = function peekTag(buffer, tag, any) {\n  if (buffer.isEmpty())\n    return false;\n\n  var state = buffer.save();\n  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: \"' + tag + '\"');\n  if (buffer.isError(decodedTag))\n    return decodedTag;\n\n  buffer.restore(state);\n\n  return decodedTag.tag === tag || decodedTag.tagStr === tag ||\n    (decodedTag.tagStr + 'of') === tag || any;\n};\n\nDERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {\n  var decodedTag = derDecodeTag(buffer,\n                                'Failed to decode tag of \"' + tag + '\"');\n  if (buffer.isError(decodedTag))\n    return decodedTag;\n\n  var len = derDecodeLen(buffer,\n                         decodedTag.primitive,\n                         'Failed to get length of \"' + tag + '\"');\n\n  // Failure\n  if (buffer.isError(len))\n    return len;\n\n  if (!any &&\n      decodedTag.tag !== tag &&\n      decodedTag.tagStr !== tag &&\n      decodedTag.tagStr + 'of' !== tag) {\n    return buffer.error('Failed to match tag: \"' + tag + '\"');\n  }\n\n  if (decodedTag.primitive || len !== null)\n    return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n\n  // Indefinite length... find END tag\n  var state = buffer.save();\n  var res = this._skipUntilEnd(\n      buffer,\n      'Failed to skip indefinite length body: \"' + this.tag + '\"');\n  if (buffer.isError(res))\n    return res;\n\n  len = buffer.offset - state.offset;\n  buffer.restore(state);\n  return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n};\n\nDERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {\n  while (true) {\n    var tag = derDecodeTag(buffer, fail);\n    if (buffer.isError(tag))\n      return tag;\n    var len = derDecodeLen(buffer, tag.primitive, fail);\n    if (buffer.isError(len))\n      return len;\n\n    var res;\n    if (tag.primitive || len !== null)\n      res = buffer.skip(len)\n    else\n      res = this._skipUntilEnd(buffer, fail);\n\n    // Failure\n    if (buffer.isError(res))\n      return res;\n\n    if (tag.tagStr === 'end')\n      break;\n  }\n};\n\nDERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,\n                                                    options) {\n  var result = [];\n  while (!buffer.isEmpty()) {\n    var possibleEnd = this._peekTag(buffer, 'end');\n    if (buffer.isError(possibleEnd))\n      return possibleEnd;\n\n    var res = decoder.decode(buffer, 'der', options);\n    if (buffer.isError(res) && possibleEnd)\n      break;\n    result.push(res);\n  }\n  return result;\n};\n\nDERNode.prototype._decodeStr = function decodeStr(buffer, tag) {\n  if (tag === 'bitstr') {\n    var unused = buffer.readUInt8();\n    if (buffer.isError(unused))\n      return unused;\n    return { unused: unused, data: buffer.raw() };\n  } else if (tag === 'bmpstr') {\n    var raw = buffer.raw();\n    if (raw.length % 2 === 1)\n      return buffer.error('Decoding of string type: bmpstr length mismatch');\n\n    var str = '';\n    for (var i = 0; i < raw.length / 2; i++) {\n      str += String.fromCharCode(raw.readUInt16BE(i * 2));\n    }\n    return str;\n  } else if (tag === 'numstr') {\n    var numstr = buffer.raw().toString('ascii');\n    if (!this._isNumstr(numstr)) {\n      return buffer.error('Decoding of string type: ' +\n                          'numstr unsupported characters');\n    }\n    return numstr;\n  } else if (tag === 'octstr') {\n    return buffer.raw();\n  } else if (tag === 'objDesc') {\n    return buffer.raw();\n  } else if (tag === 'printstr') {\n    var printstr = buffer.raw().toString('ascii');\n    if (!this._isPrintstr(printstr)) {\n      return buffer.error('Decoding of string type: ' +\n                          'printstr unsupported characters');\n    }\n    return printstr;\n  } else if (/str$/.test(tag)) {\n    return buffer.raw().toString();\n  } else {\n    return buffer.error('Decoding of string type: ' + tag + ' unsupported');\n  }\n};\n\nDERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {\n  var result;\n  var identifiers = [];\n  var ident = 0;\n  while (!buffer.isEmpty()) {\n    var subident = buffer.readUInt8();\n    ident <<= 7;\n    ident |= subident & 0x7f;\n    if ((subident & 0x80) === 0) {\n      identifiers.push(ident);\n      ident = 0;\n    }\n  }\n  if (subident & 0x80)\n    identifiers.push(ident);\n\n  var first = (identifiers[0] / 40) | 0;\n  var second = identifiers[0] % 40;\n\n  if (relative)\n    result = identifiers;\n  else\n    result = [first, second].concat(identifiers.slice(1));\n\n  if (values) {\n    var tmp = values[result.join(' ')];\n    if (tmp === undefined)\n      tmp = values[result.join('.')];\n    if (tmp !== undefined)\n      result = tmp;\n  }\n\n  return result;\n};\n\nDERNode.prototype._decodeTime = function decodeTime(buffer, tag) {\n  var str = buffer.raw().toString();\n  if (tag === 'gentime') {\n    var year = str.slice(0, 4) | 0;\n    var mon = str.slice(4, 6) | 0;\n    var day = str.slice(6, 8) | 0;\n    var hour = str.slice(8, 10) | 0;\n    var min = str.slice(10, 12) | 0;\n    var sec = str.slice(12, 14) | 0;\n  } else if (tag === 'utctime') {\n    var year = str.slice(0, 2) | 0;\n    var mon = str.slice(2, 4) | 0;\n    var day = str.slice(4, 6) | 0;\n    var hour = str.slice(6, 8) | 0;\n    var min = str.slice(8, 10) | 0;\n    var sec = str.slice(10, 12) | 0;\n    if (year < 70)\n      year = 2000 + year;\n    else\n      year = 1900 + year;\n  } else {\n    return buffer.error('Decoding ' + tag + ' time is not supported yet');\n  }\n\n  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);\n};\n\nDERNode.prototype._decodeNull = function decodeNull(buffer) {\n  return null;\n};\n\nDERNode.prototype._decodeBool = function decodeBool(buffer) {\n  var res = buffer.readUInt8();\n  if (buffer.isError(res))\n    return res;\n  else\n    return res !== 0;\n};\n\nDERNode.prototype._decodeInt = function decodeInt(buffer, values) {\n  // Bigint, return as it is (assume big endian)\n  var raw = buffer.raw();\n  var res = new bignum(raw);\n\n  if (values)\n    res = values[res.toString(10)] || res;\n\n  return res;\n};\n\nDERNode.prototype._use = function use(entity, obj) {\n  if (typeof entity === 'function')\n    entity = entity(obj);\n  return entity._getDecoder('der').tree;\n};\n\n// Utility methods\n\nfunction derDecodeTag(buf, fail) {\n  var tag = buf.readUInt8(fail);\n  if (buf.isError(tag))\n    return tag;\n\n  var cls = der.tagClass[tag >> 6];\n  var primitive = (tag & 0x20) === 0;\n\n  // Multi-octet tag - load\n  if ((tag & 0x1f) === 0x1f) {\n    var oct = tag;\n    tag = 0;\n    while ((oct & 0x80) === 0x80) {\n      oct = buf.readUInt8(fail);\n      if (buf.isError(oct))\n        return oct;\n\n      tag <<= 7;\n      tag |= oct & 0x7f;\n    }\n  } else {\n    tag &= 0x1f;\n  }\n  var tagStr = der.tag[tag];\n\n  return {\n    cls: cls,\n    primitive: primitive,\n    tag: tag,\n    tagStr: tagStr\n  };\n}\n\nfunction derDecodeLen(buf, primitive, fail) {\n  var len = buf.readUInt8(fail);\n  if (buf.isError(len))\n    return len;\n\n  // Indefinite form\n  if (!primitive && len === 0x80)\n    return null;\n\n  // Definite form\n  if ((len & 0x80) === 0) {\n    // Short form\n    return len;\n  }\n\n  // Long form\n  var num = len & 0x7f;\n  if (num > 4)\n    return buf.error('length octect is too long');\n\n  len = 0;\n  for (var i = 0; i < num; i++) {\n    len <<= 8;\n    var j = buf.readUInt8(fail);\n    if (buf.isError(j))\n      return j;\n    len |= j;\n  }\n\n  return len;\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/decoders/der.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var decoders = exports;\n\ndecoders.der = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/decoders/der.js\");\ndecoders.pem = __webpack_require__(/*! ./pem */ \"./node_modules/asn1.js/lib/asn1/decoders/pem.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/decoders/index.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar DERDecoder = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/decoders/der.js\");\n\nfunction PEMDecoder(entity) {\n  DERDecoder.call(this, entity);\n  this.enc = 'pem';\n};\ninherits(PEMDecoder, DERDecoder);\nmodule.exports = PEMDecoder;\n\nPEMDecoder.prototype.decode = function decode(data, options) {\n  var lines = data.toString().split(/[\\r\\n]+/g);\n\n  var label = options.label.toUpperCase();\n\n  var re = /^-----(BEGIN|END) ([^-]+)-----$/;\n  var start = -1;\n  var end = -1;\n  for (var i = 0; i < lines.length; i++) {\n    var match = lines[i].match(re);\n    if (match === null)\n      continue;\n\n    if (match[2] !== label)\n      continue;\n\n    if (start === -1) {\n      if (match[1] !== 'BEGIN')\n        break;\n      start = i;\n    } else {\n      if (match[1] !== 'END')\n        break;\n      end = i;\n      break;\n    }\n  }\n  if (start === -1 || end === -1)\n    throw new Error('PEM section not found for: ' + label);\n\n  var base64 = lines.slice(start + 1, end).join('');\n  // Remove excessive symbols\n  base64.replace(/[^a-z0-9\\+\\/=]+/gi, '');\n\n  var input = new Buffer(base64, 'base64');\n  return DERDecoder.prototype.decode.call(this, input, options);\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/decoders/pem.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar asn1 = __webpack_require__(/*! ../../asn1 */ \"./node_modules/asn1.js/lib/asn1.js\");\nvar base = asn1.base;\n\n// Import DER constants\nvar der = asn1.constants.der;\n\nfunction DEREncoder(entity) {\n  this.enc = 'der';\n  this.name = entity.name;\n  this.entity = entity;\n\n  // Construct base tree\n  this.tree = new DERNode();\n  this.tree._init(entity.body);\n};\nmodule.exports = DEREncoder;\n\nDEREncoder.prototype.encode = function encode(data, reporter) {\n  return this.tree._encode(data, reporter).join();\n};\n\n// Tree methods\n\nfunction DERNode(parent) {\n  base.Node.call(this, 'der', parent);\n}\ninherits(DERNode, base.Node);\n\nDERNode.prototype._encodeComposite = function encodeComposite(tag,\n                                                              primitive,\n                                                              cls,\n                                                              content) {\n  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);\n\n  // Short form\n  if (content.length < 0x80) {\n    var header = new Buffer(2);\n    header[0] = encodedTag;\n    header[1] = content.length;\n    return this._createEncoderBuffer([ header, content ]);\n  }\n\n  // Long form\n  // Count octets required to store length\n  var lenOctets = 1;\n  for (var i = content.length; i >= 0x100; i >>= 8)\n    lenOctets++;\n\n  var header = new Buffer(1 + 1 + lenOctets);\n  header[0] = encodedTag;\n  header[1] = 0x80 | lenOctets;\n\n  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)\n    header[i] = j & 0xff;\n\n  return this._createEncoderBuffer([ header, content ]);\n};\n\nDERNode.prototype._encodeStr = function encodeStr(str, tag) {\n  if (tag === 'bitstr') {\n    return this._createEncoderBuffer([ str.unused | 0, str.data ]);\n  } else if (tag === 'bmpstr') {\n    var buf = new Buffer(str.length * 2);\n    for (var i = 0; i < str.length; i++) {\n      buf.writeUInt16BE(str.charCodeAt(i), i * 2);\n    }\n    return this._createEncoderBuffer(buf);\n  } else if (tag === 'numstr') {\n    if (!this._isNumstr(str)) {\n      return this.reporter.error('Encoding of string type: numstr supports ' +\n                                 'only digits and space');\n    }\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'printstr') {\n    if (!this._isPrintstr(str)) {\n      return this.reporter.error('Encoding of string type: printstr supports ' +\n                                 'only latin upper and lower case letters, ' +\n                                 'digits, space, apostrophe, left and rigth ' +\n                                 'parenthesis, plus sign, comma, hyphen, ' +\n                                 'dot, slash, colon, equal sign, ' +\n                                 'question mark');\n    }\n    return this._createEncoderBuffer(str);\n  } else if (/str$/.test(tag)) {\n    return this._createEncoderBuffer(str);\n  } else if (tag === 'objDesc') {\n    return this._createEncoderBuffer(str);\n  } else {\n    return this.reporter.error('Encoding of string type: ' + tag +\n                               ' unsupported');\n  }\n};\n\nDERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {\n  if (typeof id === 'string') {\n    if (!values)\n      return this.reporter.error('string objid given, but no values map found');\n    if (!values.hasOwnProperty(id))\n      return this.reporter.error('objid not found in values map');\n    id = values[id].split(/[\\s\\.]+/g);\n    for (var i = 0; i < id.length; i++)\n      id[i] |= 0;\n  } else if (Array.isArray(id)) {\n    id = id.slice();\n    for (var i = 0; i < id.length; i++)\n      id[i] |= 0;\n  }\n\n  if (!Array.isArray(id)) {\n    return this.reporter.error('objid() should be either array or string, ' +\n                               'got: ' + JSON.stringify(id));\n  }\n\n  if (!relative) {\n    if (id[1] >= 40)\n      return this.reporter.error('Second objid identifier OOB');\n    id.splice(0, 2, id[0] * 40 + id[1]);\n  }\n\n  // Count number of octets\n  var size = 0;\n  for (var i = 0; i < id.length; i++) {\n    var ident = id[i];\n    for (size++; ident >= 0x80; ident >>= 7)\n      size++;\n  }\n\n  var objid = new Buffer(size);\n  var offset = objid.length - 1;\n  for (var i = id.length - 1; i >= 0; i--) {\n    var ident = id[i];\n    objid[offset--] = ident & 0x7f;\n    while ((ident >>= 7) > 0)\n      objid[offset--] = 0x80 | (ident & 0x7f);\n  }\n\n  return this._createEncoderBuffer(objid);\n};\n\nfunction two(num) {\n  if (num < 10)\n    return '0' + num;\n  else\n    return num;\n}\n\nDERNode.prototype._encodeTime = function encodeTime(time, tag) {\n  var str;\n  var date = new Date(time);\n\n  if (tag === 'gentime') {\n    str = [\n      two(date.getFullYear()),\n      two(date.getUTCMonth() + 1),\n      two(date.getUTCDate()),\n      two(date.getUTCHours()),\n      two(date.getUTCMinutes()),\n      two(date.getUTCSeconds()),\n      'Z'\n    ].join('');\n  } else if (tag === 'utctime') {\n    str = [\n      two(date.getFullYear() % 100),\n      two(date.getUTCMonth() + 1),\n      two(date.getUTCDate()),\n      two(date.getUTCHours()),\n      two(date.getUTCMinutes()),\n      two(date.getUTCSeconds()),\n      'Z'\n    ].join('');\n  } else {\n    this.reporter.error('Encoding ' + tag + ' time is not supported yet');\n  }\n\n  return this._encodeStr(str, 'octstr');\n};\n\nDERNode.prototype._encodeNull = function encodeNull() {\n  return this._createEncoderBuffer('');\n};\n\nDERNode.prototype._encodeInt = function encodeInt(num, values) {\n  if (typeof num === 'string') {\n    if (!values)\n      return this.reporter.error('String int or enum given, but no values map');\n    if (!values.hasOwnProperty(num)) {\n      return this.reporter.error('Values map doesn\\'t contain: ' +\n                                 JSON.stringify(num));\n    }\n    num = values[num];\n  }\n\n  // Bignum, assume big endian\n  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {\n    var numArray = num.toArray();\n    if (!num.sign && numArray[0] & 0x80) {\n      numArray.unshift(0);\n    }\n    num = new Buffer(numArray);\n  }\n\n  if (Buffer.isBuffer(num)) {\n    var size = num.length;\n    if (num.length === 0)\n      size++;\n\n    var out = new Buffer(size);\n    num.copy(out);\n    if (num.length === 0)\n      out[0] = 0\n    return this._createEncoderBuffer(out);\n  }\n\n  if (num < 0x80)\n    return this._createEncoderBuffer(num);\n\n  if (num < 0x100)\n    return this._createEncoderBuffer([0, num]);\n\n  var size = 1;\n  for (var i = num; i >= 0x100; i >>= 8)\n    size++;\n\n  var out = new Array(size);\n  for (var i = out.length - 1; i >= 0; i--) {\n    out[i] = num & 0xff;\n    num >>= 8;\n  }\n  if(out[0] & 0x80) {\n    out.unshift(0);\n  }\n\n  return this._createEncoderBuffer(new Buffer(out));\n};\n\nDERNode.prototype._encodeBool = function encodeBool(value) {\n  return this._createEncoderBuffer(value ? 0xff : 0);\n};\n\nDERNode.prototype._use = function use(entity, obj) {\n  if (typeof entity === 'function')\n    entity = entity(obj);\n  return entity._getEncoder('der').tree;\n};\n\nDERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {\n  var state = this._baseState;\n  var i;\n  if (state['default'] === null)\n    return false;\n\n  var data = dataBuffer.join();\n  if (state.defaultBuffer === undefined)\n    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();\n\n  if (data.length !== state.defaultBuffer.length)\n    return false;\n\n  for (i=0; i < data.length; i++)\n    if (data[i] !== state.defaultBuffer[i])\n      return false;\n\n  return true;\n};\n\n// Utility methods\n\nfunction encodeTag(tag, primitive, cls, reporter) {\n  var res;\n\n  if (tag === 'seqof')\n    tag = 'seq';\n  else if (tag === 'setof')\n    tag = 'set';\n\n  if (der.tagByName.hasOwnProperty(tag))\n    res = der.tagByName[tag];\n  else if (typeof tag === 'number' && (tag | 0) === tag)\n    res = tag;\n  else\n    return reporter.error('Unknown tag: ' + tag);\n\n  if (res >= 0x1f)\n    return reporter.error('Multi-octet tag encoding unsupported');\n\n  if (!primitive)\n    res |= 0x20;\n\n  res |= (der.tagClassByName[cls || 'universal'] << 6);\n\n  return res;\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/encoders/der.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var encoders = exports;\n\nencoders.der = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/encoders/der.js\");\nencoders.pem = __webpack_require__(/*! ./pem */ \"./node_modules/asn1.js/lib/asn1/encoders/pem.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/encoders/index.js?");

/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar DEREncoder = __webpack_require__(/*! ./der */ \"./node_modules/asn1.js/lib/asn1/encoders/der.js\");\n\nfunction PEMEncoder(entity) {\n  DEREncoder.call(this, entity);\n  this.enc = 'pem';\n};\ninherits(PEMEncoder, DEREncoder);\nmodule.exports = PEMEncoder;\n\nPEMEncoder.prototype.encode = function encode(data, options) {\n  var buf = DEREncoder.prototype.encode.call(this, data);\n\n  var p = buf.toString('base64');\n  var out = [ '-----BEGIN ' + options.label + '-----' ];\n  for (var i = 0; i < p.length; i += 64)\n    out.push(p.slice(i, i + 64));\n  out.push('-----END ' + options.label + '-----');\n  return out.join('\\n');\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/asn1.js/lib/asn1/encoders/pem.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    Buffer = __webpack_require__(/*! buffer */ 2).Buffer;\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this.strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex (str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r <<= 4;\n\n      // 'a' - 'f'\n      if (c >= 49 && c <= 54) {\n        r |= c - 49 + 0xa;\n\n      // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        r |= c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r |= c & 0xf;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    // Scan 24-bit chunks and add them to the number\n    var off = 0;\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n      off += 24;\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= (w << off) & 0x3ffffff;\n      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n    }\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toBuffer = function toBuffer (endian, length) {\n    assert(typeof Buffer !== 'undefined');\n    return this.toArrayLike(Buffer, endian, length);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new ArrayType(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      r.strip();\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://THREEAR/./node_modules/bn.js/lib/bn.js?");

/***/ }),

/***/ "./node_modules/brorand/index.js":
/*!***************************************!*\
  !*** ./node_modules/brorand/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var r;\n\nmodule.exports = function rand(len) {\n  if (!r)\n    r = new Rand(null);\n\n  return r.generate(len);\n};\n\nfunction Rand(rand) {\n  this.rand = rand;\n}\nmodule.exports.Rand = Rand;\n\nRand.prototype.generate = function generate(len) {\n  return this._rand(len);\n};\n\n// Emulate crypto API using randy\nRand.prototype._rand = function _rand(n) {\n  if (this.rand.getBytes)\n    return this.rand.getBytes(n);\n\n  var res = new Uint8Array(n);\n  for (var i = 0; i < res.length; i++)\n    res[i] = this.rand.getByte();\n  return res;\n};\n\nif (typeof self === 'object') {\n  if (self.crypto && self.crypto.getRandomValues) {\n    // Modern browsers\n    Rand.prototype._rand = function _rand(n) {\n      var arr = new Uint8Array(n);\n      self.crypto.getRandomValues(arr);\n      return arr;\n    };\n  } else if (self.msCrypto && self.msCrypto.getRandomValues) {\n    // IE\n    Rand.prototype._rand = function _rand(n) {\n      var arr = new Uint8Array(n);\n      self.msCrypto.getRandomValues(arr);\n      return arr;\n    };\n\n  // Safari's WebWorkers do not have `crypto`\n  } else if (typeof window === 'object') {\n    // Old junk\n    Rand.prototype._rand = function() {\n      throw new Error('Not implemented yet');\n    };\n  }\n} else {\n  // Node.js or Web worker with no crypto support\n  try {\n    var crypto = __webpack_require__(/*! crypto */ 3);\n    if (typeof crypto.randomBytes !== 'function')\n      throw new Error('Not supported');\n\n    Rand.prototype._rand = function _rand(n) {\n      return crypto.randomBytes(n);\n    };\n  } catch (e) {\n  }\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/brorand/index.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/aes.js":
/*!********************************************!*\
  !*** ./node_modules/browserify-aes/aes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// based on the aes implimentation in triple sec\n// https://github.com/keybase/triplesec\n// which is in turn based on the one from crypto-js\n// https://code.google.com/p/crypto-js/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nfunction asUInt32Array (buf) {\n  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n\n  var len = (buf.length / 4) | 0\n  var out = new Array(len)\n\n  for (var i = 0; i < len; i++) {\n    out[i] = buf.readUInt32BE(i * 4)\n  }\n\n  return out\n}\n\nfunction scrubVec (v) {\n  for (var i = 0; i < v.length; v++) {\n    v[i] = 0\n  }\n}\n\nfunction cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {\n  var SUB_MIX0 = SUB_MIX[0]\n  var SUB_MIX1 = SUB_MIX[1]\n  var SUB_MIX2 = SUB_MIX[2]\n  var SUB_MIX3 = SUB_MIX[3]\n\n  var s0 = M[0] ^ keySchedule[0]\n  var s1 = M[1] ^ keySchedule[1]\n  var s2 = M[2] ^ keySchedule[2]\n  var s3 = M[3] ^ keySchedule[3]\n  var t0, t1, t2, t3\n  var ksRow = 4\n\n  for (var round = 1; round < nRounds; round++) {\n    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]\n    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]\n    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]\n    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]\n    s0 = t0\n    s1 = t1\n    s2 = t2\n    s3 = t3\n  }\n\n  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]\n  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]\n  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]\n  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]\n  t0 = t0 >>> 0\n  t1 = t1 >>> 0\n  t2 = t2 >>> 0\n  t3 = t3 >>> 0\n\n  return [t0, t1, t2, t3]\n}\n\n// AES constants\nvar RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]\nvar G = (function () {\n  // Compute double table\n  var d = new Array(256)\n  for (var j = 0; j < 256; j++) {\n    if (j < 128) {\n      d[j] = j << 1\n    } else {\n      d[j] = (j << 1) ^ 0x11b\n    }\n  }\n\n  var SBOX = []\n  var INV_SBOX = []\n  var SUB_MIX = [[], [], [], []]\n  var INV_SUB_MIX = [[], [], [], []]\n\n  // Walk GF(2^8)\n  var x = 0\n  var xi = 0\n  for (var i = 0; i < 256; ++i) {\n    // Compute sbox\n    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)\n    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63\n    SBOX[x] = sx\n    INV_SBOX[sx] = x\n\n    // Compute multiplication\n    var x2 = d[x]\n    var x4 = d[x2]\n    var x8 = d[x4]\n\n    // Compute sub bytes, mix columns tables\n    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)\n    SUB_MIX[0][x] = (t << 24) | (t >>> 8)\n    SUB_MIX[1][x] = (t << 16) | (t >>> 16)\n    SUB_MIX[2][x] = (t << 8) | (t >>> 24)\n    SUB_MIX[3][x] = t\n\n    // Compute inv sub bytes, inv mix columns tables\n    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)\n    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)\n    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)\n    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)\n    INV_SUB_MIX[3][sx] = t\n\n    if (x === 0) {\n      x = xi = 1\n    } else {\n      x = x2 ^ d[d[d[x8 ^ x2]]]\n      xi ^= d[d[xi]]\n    }\n  }\n\n  return {\n    SBOX: SBOX,\n    INV_SBOX: INV_SBOX,\n    SUB_MIX: SUB_MIX,\n    INV_SUB_MIX: INV_SUB_MIX\n  }\n})()\n\nfunction AES (key) {\n  this._key = asUInt32Array(key)\n  this._reset()\n}\n\nAES.blockSize = 4 * 4\nAES.keySize = 256 / 8\nAES.prototype.blockSize = AES.blockSize\nAES.prototype.keySize = AES.keySize\nAES.prototype._reset = function () {\n  var keyWords = this._key\n  var keySize = keyWords.length\n  var nRounds = keySize + 6\n  var ksRows = (nRounds + 1) * 4\n\n  var keySchedule = []\n  for (var k = 0; k < keySize; k++) {\n    keySchedule[k] = keyWords[k]\n  }\n\n  for (k = keySize; k < ksRows; k++) {\n    var t = keySchedule[k - 1]\n\n    if (k % keySize === 0) {\n      t = (t << 8) | (t >>> 24)\n      t =\n        (G.SBOX[t >>> 24] << 24) |\n        (G.SBOX[(t >>> 16) & 0xff] << 16) |\n        (G.SBOX[(t >>> 8) & 0xff] << 8) |\n        (G.SBOX[t & 0xff])\n\n      t ^= RCON[(k / keySize) | 0] << 24\n    } else if (keySize > 6 && k % keySize === 4) {\n      t =\n        (G.SBOX[t >>> 24] << 24) |\n        (G.SBOX[(t >>> 16) & 0xff] << 16) |\n        (G.SBOX[(t >>> 8) & 0xff] << 8) |\n        (G.SBOX[t & 0xff])\n    }\n\n    keySchedule[k] = keySchedule[k - keySize] ^ t\n  }\n\n  var invKeySchedule = []\n  for (var ik = 0; ik < ksRows; ik++) {\n    var ksR = ksRows - ik\n    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]\n\n    if (ik < 4 || ksR <= 4) {\n      invKeySchedule[ik] = tt\n    } else {\n      invKeySchedule[ik] =\n        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^\n        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^\n        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^\n        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]\n    }\n  }\n\n  this._nRounds = nRounds\n  this._keySchedule = keySchedule\n  this._invKeySchedule = invKeySchedule\n}\n\nAES.prototype.encryptBlockRaw = function (M) {\n  M = asUInt32Array(M)\n  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)\n}\n\nAES.prototype.encryptBlock = function (M) {\n  var out = this.encryptBlockRaw(M)\n  var buf = Buffer.allocUnsafe(16)\n  buf.writeUInt32BE(out[0], 0)\n  buf.writeUInt32BE(out[1], 4)\n  buf.writeUInt32BE(out[2], 8)\n  buf.writeUInt32BE(out[3], 12)\n  return buf\n}\n\nAES.prototype.decryptBlock = function (M) {\n  M = asUInt32Array(M)\n\n  // swap\n  var m1 = M[1]\n  M[1] = M[3]\n  M[3] = m1\n\n  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)\n  var buf = Buffer.allocUnsafe(16)\n  buf.writeUInt32BE(out[0], 0)\n  buf.writeUInt32BE(out[3], 4)\n  buf.writeUInt32BE(out[2], 8)\n  buf.writeUInt32BE(out[1], 12)\n  return buf\n}\n\nAES.prototype.scrub = function () {\n  scrubVec(this._keySchedule)\n  scrubVec(this._invKeySchedule)\n  scrubVec(this._key)\n}\n\nmodule.exports.AES = AES\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/aes.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/authCipher.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/authCipher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var aes = __webpack_require__(/*! ./aes */ \"./node_modules/browserify-aes/aes.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar Transform = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar GHASH = __webpack_require__(/*! ./ghash */ \"./node_modules/browserify-aes/ghash.js\")\nvar xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\nvar incr32 = __webpack_require__(/*! ./incr32 */ \"./node_modules/browserify-aes/incr32.js\")\n\nfunction xorTest (a, b) {\n  var out = 0\n  if (a.length !== b.length) out++\n\n  var len = Math.min(a.length, b.length)\n  for (var i = 0; i < len; ++i) {\n    out += (a[i] ^ b[i])\n  }\n\n  return out\n}\n\nfunction calcIv (self, iv, ck) {\n  if (iv.length === 12) {\n    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])\n    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])\n  }\n  var ghash = new GHASH(ck)\n  var len = iv.length\n  var toPad = len % 16\n  ghash.update(iv)\n  if (toPad) {\n    toPad = 16 - toPad\n    ghash.update(Buffer.alloc(toPad, 0))\n  }\n  ghash.update(Buffer.alloc(8, 0))\n  var ivBits = len * 8\n  var tail = Buffer.alloc(8)\n  tail.writeUIntBE(ivBits, 0, 8)\n  ghash.update(tail)\n  self._finID = ghash.state\n  var out = Buffer.from(self._finID)\n  incr32(out)\n  return out\n}\nfunction StreamCipher (mode, key, iv, decrypt) {\n  Transform.call(this)\n\n  var h = Buffer.alloc(4, 0)\n\n  this._cipher = new aes.AES(key)\n  var ck = this._cipher.encryptBlock(h)\n  this._ghash = new GHASH(ck)\n  iv = calcIv(this, iv, ck)\n\n  this._prev = Buffer.from(iv)\n  this._cache = Buffer.allocUnsafe(0)\n  this._secCache = Buffer.allocUnsafe(0)\n  this._decrypt = decrypt\n  this._alen = 0\n  this._len = 0\n  this._mode = mode\n\n  this._authTag = null\n  this._called = false\n}\n\ninherits(StreamCipher, Transform)\n\nStreamCipher.prototype._update = function (chunk) {\n  if (!this._called && this._alen) {\n    var rump = 16 - (this._alen % 16)\n    if (rump < 16) {\n      rump = Buffer.alloc(rump, 0)\n      this._ghash.update(rump)\n    }\n  }\n\n  this._called = true\n  var out = this._mode.encrypt(this, chunk)\n  if (this._decrypt) {\n    this._ghash.update(chunk)\n  } else {\n    this._ghash.update(out)\n  }\n  this._len += chunk.length\n  return out\n}\n\nStreamCipher.prototype._final = function () {\n  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')\n\n  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))\n  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')\n\n  this._authTag = tag\n  this._cipher.scrub()\n}\n\nStreamCipher.prototype.getAuthTag = function getAuthTag () {\n  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')\n\n  return this._authTag\n}\n\nStreamCipher.prototype.setAuthTag = function setAuthTag (tag) {\n  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')\n\n  this._authTag = tag\n}\n\nStreamCipher.prototype.setAAD = function setAAD (buf) {\n  if (this._called) throw new Error('Attempting to set AAD in unsupported state')\n\n  this._ghash.update(buf)\n  this._alen += buf.length\n}\n\nmodule.exports = StreamCipher\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/authCipher.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/browser.js":
/*!************************************************!*\
  !*** ./node_modules/browserify-aes/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ciphers = __webpack_require__(/*! ./encrypter */ \"./node_modules/browserify-aes/encrypter.js\")\nvar deciphers = __webpack_require__(/*! ./decrypter */ \"./node_modules/browserify-aes/decrypter.js\")\nvar modes = __webpack_require__(/*! ./modes/list.json */ \"./node_modules/browserify-aes/modes/list.json\")\n\nfunction getCiphers () {\n  return Object.keys(modes)\n}\n\nexports.createCipher = exports.Cipher = ciphers.createCipher\nexports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv\nexports.createDecipher = exports.Decipher = deciphers.createDecipher\nexports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv\nexports.listCiphers = exports.getCiphers = getCiphers\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/browser.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/decrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/decrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var AuthCipher = __webpack_require__(/*! ./authCipher */ \"./node_modules/browserify-aes/authCipher.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar MODES = __webpack_require__(/*! ./modes */ \"./node_modules/browserify-aes/modes/index.js\")\nvar StreamCipher = __webpack_require__(/*! ./streamCipher */ \"./node_modules/browserify-aes/streamCipher.js\")\nvar Transform = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar aes = __webpack_require__(/*! ./aes */ \"./node_modules/browserify-aes/aes.js\")\nvar ebtk = __webpack_require__(/*! evp_bytestokey */ \"./node_modules/evp_bytestokey/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction Decipher (mode, key, iv) {\n  Transform.call(this)\n\n  this._cache = new Splitter()\n  this._last = void 0\n  this._cipher = new aes.AES(key)\n  this._prev = Buffer.from(iv)\n  this._mode = mode\n  this._autopadding = true\n}\n\ninherits(Decipher, Transform)\n\nDecipher.prototype._update = function (data) {\n  this._cache.add(data)\n  var chunk\n  var thing\n  var out = []\n  while ((chunk = this._cache.get(this._autopadding))) {\n    thing = this._mode.decrypt(this, chunk)\n    out.push(thing)\n  }\n  return Buffer.concat(out)\n}\n\nDecipher.prototype._final = function () {\n  var chunk = this._cache.flush()\n  if (this._autopadding) {\n    return unpad(this._mode.decrypt(this, chunk))\n  } else if (chunk) {\n    throw new Error('data not multiple of block length')\n  }\n}\n\nDecipher.prototype.setAutoPadding = function (setTo) {\n  this._autopadding = !!setTo\n  return this\n}\n\nfunction Splitter () {\n  this.cache = Buffer.allocUnsafe(0)\n}\n\nSplitter.prototype.add = function (data) {\n  this.cache = Buffer.concat([this.cache, data])\n}\n\nSplitter.prototype.get = function (autoPadding) {\n  var out\n  if (autoPadding) {\n    if (this.cache.length > 16) {\n      out = this.cache.slice(0, 16)\n      this.cache = this.cache.slice(16)\n      return out\n    }\n  } else {\n    if (this.cache.length >= 16) {\n      out = this.cache.slice(0, 16)\n      this.cache = this.cache.slice(16)\n      return out\n    }\n  }\n\n  return null\n}\n\nSplitter.prototype.flush = function () {\n  if (this.cache.length) return this.cache\n}\n\nfunction unpad (last) {\n  var padded = last[15]\n  if (padded < 1 || padded > 16) {\n    throw new Error('unable to decrypt data')\n  }\n  var i = -1\n  while (++i < padded) {\n    if (last[(i + (16 - padded))] !== padded) {\n      throw new Error('unable to decrypt data')\n    }\n  }\n  if (padded === 16) return\n\n  return last.slice(0, 16 - padded)\n}\n\nfunction createDecipheriv (suite, password, iv) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  if (typeof iv === 'string') iv = Buffer.from(iv)\n  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)\n\n  if (typeof password === 'string') password = Buffer.from(password)\n  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)\n\n  if (config.type === 'stream') {\n    return new StreamCipher(config.module, password, iv, true)\n  } else if (config.type === 'auth') {\n    return new AuthCipher(config.module, password, iv, true)\n  }\n\n  return new Decipher(config.module, password, iv)\n}\n\nfunction createDecipher (suite, password) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  var keys = ebtk(password, false, config.key, config.iv)\n  return createDecipheriv(suite, keys.key, keys.iv)\n}\n\nexports.createDecipher = createDecipher\nexports.createDecipheriv = createDecipheriv\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/decrypter.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/encrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/encrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var MODES = __webpack_require__(/*! ./modes */ \"./node_modules/browserify-aes/modes/index.js\")\nvar AuthCipher = __webpack_require__(/*! ./authCipher */ \"./node_modules/browserify-aes/authCipher.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar StreamCipher = __webpack_require__(/*! ./streamCipher */ \"./node_modules/browserify-aes/streamCipher.js\")\nvar Transform = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar aes = __webpack_require__(/*! ./aes */ \"./node_modules/browserify-aes/aes.js\")\nvar ebtk = __webpack_require__(/*! evp_bytestokey */ \"./node_modules/evp_bytestokey/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction Cipher (mode, key, iv) {\n  Transform.call(this)\n\n  this._cache = new Splitter()\n  this._cipher = new aes.AES(key)\n  this._prev = Buffer.from(iv)\n  this._mode = mode\n  this._autopadding = true\n}\n\ninherits(Cipher, Transform)\n\nCipher.prototype._update = function (data) {\n  this._cache.add(data)\n  var chunk\n  var thing\n  var out = []\n\n  while ((chunk = this._cache.get())) {\n    thing = this._mode.encrypt(this, chunk)\n    out.push(thing)\n  }\n\n  return Buffer.concat(out)\n}\n\nvar PADDING = Buffer.alloc(16, 0x10)\n\nCipher.prototype._final = function () {\n  var chunk = this._cache.flush()\n  if (this._autopadding) {\n    chunk = this._mode.encrypt(this, chunk)\n    this._cipher.scrub()\n    return chunk\n  }\n\n  if (!chunk.equals(PADDING)) {\n    this._cipher.scrub()\n    throw new Error('data not multiple of block length')\n  }\n}\n\nCipher.prototype.setAutoPadding = function (setTo) {\n  this._autopadding = !!setTo\n  return this\n}\n\nfunction Splitter () {\n  this.cache = Buffer.allocUnsafe(0)\n}\n\nSplitter.prototype.add = function (data) {\n  this.cache = Buffer.concat([this.cache, data])\n}\n\nSplitter.prototype.get = function () {\n  if (this.cache.length > 15) {\n    var out = this.cache.slice(0, 16)\n    this.cache = this.cache.slice(16)\n    return out\n  }\n  return null\n}\n\nSplitter.prototype.flush = function () {\n  var len = 16 - this.cache.length\n  var padBuff = Buffer.allocUnsafe(len)\n\n  var i = -1\n  while (++i < len) {\n    padBuff.writeUInt8(len, i)\n  }\n\n  return Buffer.concat([this.cache, padBuff])\n}\n\nfunction createCipheriv (suite, password, iv) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  if (typeof password === 'string') password = Buffer.from(password)\n  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)\n\n  if (typeof iv === 'string') iv = Buffer.from(iv)\n  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)\n\n  if (config.type === 'stream') {\n    return new StreamCipher(config.module, password, iv)\n  } else if (config.type === 'auth') {\n    return new AuthCipher(config.module, password, iv)\n  }\n\n  return new Cipher(config.module, password, iv)\n}\n\nfunction createCipher (suite, password) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  var keys = ebtk(password, false, config.key, config.iv)\n  return createCipheriv(suite, keys.key, keys.iv)\n}\n\nexports.createCipheriv = createCipheriv\nexports.createCipher = createCipher\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/encrypter.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/ghash.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-aes/ghash.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar ZEROES = Buffer.alloc(16, 0)\n\nfunction toArray (buf) {\n  return [\n    buf.readUInt32BE(0),\n    buf.readUInt32BE(4),\n    buf.readUInt32BE(8),\n    buf.readUInt32BE(12)\n  ]\n}\n\nfunction fromArray (out) {\n  var buf = Buffer.allocUnsafe(16)\n  buf.writeUInt32BE(out[0] >>> 0, 0)\n  buf.writeUInt32BE(out[1] >>> 0, 4)\n  buf.writeUInt32BE(out[2] >>> 0, 8)\n  buf.writeUInt32BE(out[3] >>> 0, 12)\n  return buf\n}\n\nfunction GHASH (key) {\n  this.h = key\n  this.state = Buffer.alloc(16, 0)\n  this.cache = Buffer.allocUnsafe(0)\n}\n\n// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html\n// by Juho Vh-Herttua\nGHASH.prototype.ghash = function (block) {\n  var i = -1\n  while (++i < block.length) {\n    this.state[i] ^= block[i]\n  }\n  this._multiply()\n}\n\nGHASH.prototype._multiply = function () {\n  var Vi = toArray(this.h)\n  var Zi = [0, 0, 0, 0]\n  var j, xi, lsbVi\n  var i = -1\n  while (++i < 128) {\n    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0\n    if (xi) {\n      // Z_i+1 = Z_i ^ V_i\n      Zi[0] ^= Vi[0]\n      Zi[1] ^= Vi[1]\n      Zi[2] ^= Vi[2]\n      Zi[3] ^= Vi[3]\n    }\n\n    // Store the value of LSB(V_i)\n    lsbVi = (Vi[3] & 1) !== 0\n\n    // V_i+1 = V_i >> 1\n    for (j = 3; j > 0; j--) {\n      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)\n    }\n    Vi[0] = Vi[0] >>> 1\n\n    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R\n    if (lsbVi) {\n      Vi[0] = Vi[0] ^ (0xe1 << 24)\n    }\n  }\n  this.state = fromArray(Zi)\n}\n\nGHASH.prototype.update = function (buf) {\n  this.cache = Buffer.concat([this.cache, buf])\n  var chunk\n  while (this.cache.length >= 16) {\n    chunk = this.cache.slice(0, 16)\n    this.cache = this.cache.slice(16)\n    this.ghash(chunk)\n  }\n}\n\nGHASH.prototype.final = function (abl, bl) {\n  if (this.cache.length) {\n    this.ghash(Buffer.concat([this.cache, ZEROES], 16))\n  }\n\n  this.ghash(fromArray([0, abl, 0, bl]))\n  return this.state\n}\n\nmodule.exports = GHASH\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/ghash.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/incr32.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-aes/incr32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function incr32 (iv) {\n  var len = iv.length\n  var item\n  while (len--) {\n    item = iv.readUInt8(len)\n    if (item === 255) {\n      iv.writeUInt8(0, len)\n    } else {\n      item++\n      iv.writeUInt8(item, len)\n      break\n    }\n  }\n}\nmodule.exports = incr32\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/incr32.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/cbc.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cbc.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\n\nexports.encrypt = function (self, block) {\n  var data = xor(block, self._prev)\n\n  self._prev = self._cipher.encryptBlock(data)\n  return self._prev\n}\n\nexports.decrypt = function (self, block) {\n  var pad = self._prev\n\n  self._prev = block\n  var out = self._cipher.decryptBlock(block)\n\n  return xor(out, pad)\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/modes/cbc.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\n\nfunction encryptStart (self, data, decrypt) {\n  var len = data.length\n  var out = xor(data, self._cache)\n  self._cache = self._cache.slice(len)\n  self._prev = Buffer.concat([self._prev, decrypt ? data : out])\n  return out\n}\n\nexports.encrypt = function (self, data, decrypt) {\n  var out = Buffer.allocUnsafe(0)\n  var len\n\n  while (data.length) {\n    if (self._cache.length === 0) {\n      self._cache = self._cipher.encryptBlock(self._prev)\n      self._prev = Buffer.allocUnsafe(0)\n    }\n\n    if (self._cache.length <= data.length) {\n      len = self._cache.length\n      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])\n      data = data.slice(len)\n    } else {\n      out = Buffer.concat([out, encryptStart(self, data, decrypt)])\n      break\n    }\n  }\n\n  return out\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/modes/cfb.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb1.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb1.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nfunction encryptByte (self, byteParam, decrypt) {\n  var pad\n  var i = -1\n  var len = 8\n  var out = 0\n  var bit, value\n  while (++i < len) {\n    pad = self._cipher.encryptBlock(self._prev)\n    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0\n    value = pad[0] ^ bit\n    out += ((value & 0x80) >> (i % 8))\n    self._prev = shiftIn(self._prev, decrypt ? bit : value)\n  }\n  return out\n}\n\nfunction shiftIn (buffer, value) {\n  var len = buffer.length\n  var i = -1\n  var out = Buffer.allocUnsafe(buffer.length)\n  buffer = Buffer.concat([buffer, Buffer.from([value])])\n\n  while (++i < len) {\n    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)\n  }\n\n  return out\n}\n\nexports.encrypt = function (self, chunk, decrypt) {\n  var len = chunk.length\n  var out = Buffer.allocUnsafe(len)\n  var i = -1\n\n  while (++i < len) {\n    out[i] = encryptByte(self, chunk[i], decrypt)\n  }\n\n  return out\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/modes/cfb1.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb8.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nfunction encryptByte (self, byteParam, decrypt) {\n  var pad = self._cipher.encryptBlock(self._prev)\n  var out = pad[0] ^ byteParam\n\n  self._prev = Buffer.concat([\n    self._prev.slice(1),\n    Buffer.from([decrypt ? byteParam : out])\n  ])\n\n  return out\n}\n\nexports.encrypt = function (self, chunk, decrypt) {\n  var len = chunk.length\n  var out = Buffer.allocUnsafe(len)\n  var i = -1\n\n  while (++i < len) {\n    out[i] = encryptByte(self, chunk[i], decrypt)\n  }\n\n  return out\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/modes/cfb8.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ctr.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ctr.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar incr32 = __webpack_require__(/*! ../incr32 */ \"./node_modules/browserify-aes/incr32.js\")\n\nfunction getBlock (self) {\n  var out = self._cipher.encryptBlockRaw(self._prev)\n  incr32(self._prev)\n  return out\n}\n\nvar blockSize = 16\nexports.encrypt = function (self, chunk) {\n  var chunkNum = Math.ceil(chunk.length / blockSize)\n  var start = self._cache.length\n  self._cache = Buffer.concat([\n    self._cache,\n    Buffer.allocUnsafe(chunkNum * blockSize)\n  ])\n  for (var i = 0; i < chunkNum; i++) {\n    var out = getBlock(self)\n    var offset = start + i * blockSize\n    self._cache.writeUInt32BE(out[0], offset + 0)\n    self._cache.writeUInt32BE(out[1], offset + 4)\n    self._cache.writeUInt32BE(out[2], offset + 8)\n    self._cache.writeUInt32BE(out[3], offset + 12)\n  }\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/modes/ctr.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ecb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ecb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.encrypt = function (self, block) {\n  return self._cipher.encryptBlock(block)\n}\n\nexports.decrypt = function (self, block) {\n  return self._cipher.decryptBlock(block)\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/modes/ecb.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/index.js":
/*!****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var modeModules = {\n  ECB: __webpack_require__(/*! ./ecb */ \"./node_modules/browserify-aes/modes/ecb.js\"),\n  CBC: __webpack_require__(/*! ./cbc */ \"./node_modules/browserify-aes/modes/cbc.js\"),\n  CFB: __webpack_require__(/*! ./cfb */ \"./node_modules/browserify-aes/modes/cfb.js\"),\n  CFB8: __webpack_require__(/*! ./cfb8 */ \"./node_modules/browserify-aes/modes/cfb8.js\"),\n  CFB1: __webpack_require__(/*! ./cfb1 */ \"./node_modules/browserify-aes/modes/cfb1.js\"),\n  OFB: __webpack_require__(/*! ./ofb */ \"./node_modules/browserify-aes/modes/ofb.js\"),\n  CTR: __webpack_require__(/*! ./ctr */ \"./node_modules/browserify-aes/modes/ctr.js\"),\n  GCM: __webpack_require__(/*! ./ctr */ \"./node_modules/browserify-aes/modes/ctr.js\")\n}\n\nvar modes = __webpack_require__(/*! ./list.json */ \"./node_modules/browserify-aes/modes/list.json\")\n\nfor (var key in modes) {\n  modes[key].module = modeModules[modes[key].mode]\n}\n\nmodule.exports = modes\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/modes/index.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/list.json":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/list.json ***!
  \*****************************************************/
/*! exports provided: aes-128-ecb, aes-192-ecb, aes-256-ecb, aes-128-cbc, aes-192-cbc, aes-256-cbc, aes128, aes192, aes256, aes-128-cfb, aes-192-cfb, aes-256-cfb, aes-128-cfb8, aes-192-cfb8, aes-256-cfb8, aes-128-cfb1, aes-192-cfb1, aes-256-cfb1, aes-128-ofb, aes-192-ofb, aes-256-ofb, aes-128-ctr, aes-192-ctr, aes-256-ctr, aes-128-gcm, aes-192-gcm, aes-256-gcm, default */
/***/ (function(module) {

eval("module.exports = {\"aes-128-ecb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-192-ecb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-256-ecb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-128-cbc\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-192-cbc\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-256-cbc\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes128\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes192\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes256\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-128-cfb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-192-cfb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-256-cfb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-128-cfb8\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-192-cfb8\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-256-cfb8\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-128-cfb1\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-192-cfb1\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-256-cfb1\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-128-ofb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-192-ofb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-256-ofb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-128-ctr\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-192-ctr\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-256-ctr\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-128-gcm\":{\"cipher\":\"AES\",\"key\":128,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"},\"aes-192-gcm\":{\"cipher\":\"AES\",\"key\":192,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"},\"aes-256-gcm\":{\"cipher\":\"AES\",\"key\":256,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"}};\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/modes/list.json?");

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ofb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ofb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(/*! buffer-xor */ \"./node_modules/buffer-xor/index.js\")\n\nfunction getBlock (self) {\n  self._prev = self._cipher.encryptBlock(self._prev)\n  return self._prev\n}\n\nexports.encrypt = function (self, chunk) {\n  while (self._cache.length < chunk.length) {\n    self._cache = Buffer.concat([self._cache, getBlock(self)])\n  }\n\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/modes/ofb.js?");

/***/ }),

/***/ "./node_modules/browserify-aes/streamCipher.js":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/streamCipher.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var aes = __webpack_require__(/*! ./aes */ \"./node_modules/browserify-aes/aes.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar Transform = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction StreamCipher (mode, key, iv, decrypt) {\n  Transform.call(this)\n\n  this._cipher = new aes.AES(key)\n  this._prev = Buffer.from(iv)\n  this._cache = Buffer.allocUnsafe(0)\n  this._secCache = Buffer.allocUnsafe(0)\n  this._decrypt = decrypt\n  this._mode = mode\n}\n\ninherits(StreamCipher, Transform)\n\nStreamCipher.prototype._update = function (chunk) {\n  return this._mode.encrypt(this, chunk, this._decrypt)\n}\n\nStreamCipher.prototype._final = function () {\n  this._cipher.scrub()\n}\n\nmodule.exports = StreamCipher\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-aes/streamCipher.js?");

/***/ }),

/***/ "./node_modules/browserify-cipher/browser.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-cipher/browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var DES = __webpack_require__(/*! browserify-des */ \"./node_modules/browserify-des/index.js\")\nvar aes = __webpack_require__(/*! browserify-aes/browser */ \"./node_modules/browserify-aes/browser.js\")\nvar aesModes = __webpack_require__(/*! browserify-aes/modes */ \"./node_modules/browserify-aes/modes/index.js\")\nvar desModes = __webpack_require__(/*! browserify-des/modes */ \"./node_modules/browserify-des/modes.js\")\nvar ebtk = __webpack_require__(/*! evp_bytestokey */ \"./node_modules/evp_bytestokey/index.js\")\n\nfunction createCipher (suite, password) {\n  suite = suite.toLowerCase()\n\n  var keyLen, ivLen\n  if (aesModes[suite]) {\n    keyLen = aesModes[suite].key\n    ivLen = aesModes[suite].iv\n  } else if (desModes[suite]) {\n    keyLen = desModes[suite].key * 8\n    ivLen = desModes[suite].iv\n  } else {\n    throw new TypeError('invalid suite type')\n  }\n\n  var keys = ebtk(password, false, keyLen, ivLen)\n  return createCipheriv(suite, keys.key, keys.iv)\n}\n\nfunction createDecipher (suite, password) {\n  suite = suite.toLowerCase()\n\n  var keyLen, ivLen\n  if (aesModes[suite]) {\n    keyLen = aesModes[suite].key\n    ivLen = aesModes[suite].iv\n  } else if (desModes[suite]) {\n    keyLen = desModes[suite].key * 8\n    ivLen = desModes[suite].iv\n  } else {\n    throw new TypeError('invalid suite type')\n  }\n\n  var keys = ebtk(password, false, keyLen, ivLen)\n  return createDecipheriv(suite, keys.key, keys.iv)\n}\n\nfunction createCipheriv (suite, key, iv) {\n  suite = suite.toLowerCase()\n  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)\n  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })\n\n  throw new TypeError('invalid suite type')\n}\n\nfunction createDecipheriv (suite, key, iv) {\n  suite = suite.toLowerCase()\n  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)\n  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })\n\n  throw new TypeError('invalid suite type')\n}\n\nfunction getCiphers () {\n  return Object.keys(desModes).concat(aes.getCiphers())\n}\n\nexports.createCipher = exports.Cipher = createCipher\nexports.createCipheriv = exports.Cipheriv = createCipheriv\nexports.createDecipher = exports.Decipher = createDecipher\nexports.createDecipheriv = exports.Decipheriv = createDecipheriv\nexports.listCiphers = exports.getCiphers = getCiphers\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-cipher/browser.js?");

/***/ }),

/***/ "./node_modules/browserify-des/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var CipherBase = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar des = __webpack_require__(/*! des.js */ \"./node_modules/des.js/lib/des.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar modes = {\n  'des-ede3-cbc': des.CBC.instantiate(des.EDE),\n  'des-ede3': des.EDE,\n  'des-ede-cbc': des.CBC.instantiate(des.EDE),\n  'des-ede': des.EDE,\n  'des-cbc': des.CBC.instantiate(des.DES),\n  'des-ecb': des.DES\n}\nmodes.des = modes['des-cbc']\nmodes.des3 = modes['des-ede3-cbc']\nmodule.exports = DES\ninherits(DES, CipherBase)\nfunction DES (opts) {\n  CipherBase.call(this)\n  var modeName = opts.mode.toLowerCase()\n  var mode = modes[modeName]\n  var type\n  if (opts.decrypt) {\n    type = 'decrypt'\n  } else {\n    type = 'encrypt'\n  }\n  var key = opts.key\n  if (!Buffer.isBuffer(key)) {\n    key = Buffer.from(key)\n  }\n  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {\n    key = Buffer.concat([key, key.slice(0, 8)])\n  }\n  var iv = opts.iv\n  if (!Buffer.isBuffer(iv)) {\n    iv = Buffer.from(iv)\n  }\n  this._des = mode.create({\n    key: key,\n    iv: iv,\n    type: type\n  })\n}\nDES.prototype._update = function (data) {\n  return Buffer.from(this._des.update(data))\n}\nDES.prototype._final = function () {\n  return Buffer.from(this._des.final())\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-des/index.js?");

/***/ }),

/***/ "./node_modules/browserify-des/modes.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/modes.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports['des-ecb'] = {\n  key: 8,\n  iv: 0\n}\nexports['des-cbc'] = exports.des = {\n  key: 8,\n  iv: 8\n}\nexports['des-ede3-cbc'] = exports.des3 = {\n  key: 24,\n  iv: 8\n}\nexports['des-ede3'] = {\n  key: 24,\n  iv: 0\n}\nexports['des-ede-cbc'] = {\n  key: 16,\n  iv: 8\n}\nexports['des-ede'] = {\n  key: 16,\n  iv: 0\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-des/modes.js?");

/***/ }),

/***/ "./node_modules/browserify-rsa/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-rsa/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar randomBytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\nmodule.exports = crt;\nfunction blind(priv) {\n  var r = getr(priv);\n  var blinder = r.toRed(bn.mont(priv.modulus))\n  .redPow(new bn(priv.publicExponent)).fromRed();\n  return {\n    blinder: blinder,\n    unblinder:r.invm(priv.modulus)\n  };\n}\nfunction crt(msg, priv) {\n  var blinds = blind(priv);\n  var len = priv.modulus.byteLength();\n  var mod = bn.mont(priv.modulus);\n  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);\n  var c1 = blinded.toRed(bn.mont(priv.prime1));\n  var c2 = blinded.toRed(bn.mont(priv.prime2));\n  var qinv = priv.coefficient;\n  var p = priv.prime1;\n  var q = priv.prime2;\n  var m1 = c1.redPow(priv.exponent1);\n  var m2 = c2.redPow(priv.exponent2);\n  m1 = m1.fromRed();\n  m2 = m2.fromRed();\n  var h = m1.isub(m2).imul(qinv).umod(p);\n  h.imul(q);\n  m2.iadd(h);\n  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));\n}\ncrt.getr = getr;\nfunction getr(priv) {\n  var len = priv.modulus.byteLength();\n  var r = new bn(randomBytes(len));\n  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {\n    r = new bn(randomBytes(len));\n  }\n  return r;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-rsa/index.js?");

/***/ }),

/***/ "./node_modules/browserify-sign/algos.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-sign/algos.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./browser/algorithms.json */ \"./node_modules/browserify-sign/browser/algorithms.json\")\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-sign/algos.js?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/algorithms.json":
/*!**************************************************************!*\
  !*** ./node_modules/browserify-sign/browser/algorithms.json ***!
  \**************************************************************/
/*! exports provided: sha224WithRSAEncryption, RSA-SHA224, sha256WithRSAEncryption, RSA-SHA256, sha384WithRSAEncryption, RSA-SHA384, sha512WithRSAEncryption, RSA-SHA512, RSA-SHA1, ecdsa-with-SHA1, sha256, sha224, sha384, sha512, DSA-SHA, DSA-SHA1, DSA, DSA-WITH-SHA224, DSA-SHA224, DSA-WITH-SHA256, DSA-SHA256, DSA-WITH-SHA384, DSA-SHA384, DSA-WITH-SHA512, DSA-SHA512, DSA-RIPEMD160, ripemd160WithRSA, RSA-RIPEMD160, md5WithRSAEncryption, RSA-MD5, default */
/***/ (function(module) {

eval("module.exports = {\"sha224WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha224\",\"id\":\"302d300d06096086480165030402040500041c\"},\"RSA-SHA224\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha224\",\"id\":\"302d300d06096086480165030402040500041c\"},\"sha256WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha256\",\"id\":\"3031300d060960864801650304020105000420\"},\"RSA-SHA256\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha256\",\"id\":\"3031300d060960864801650304020105000420\"},\"sha384WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha384\",\"id\":\"3041300d060960864801650304020205000430\"},\"RSA-SHA384\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha384\",\"id\":\"3041300d060960864801650304020205000430\"},\"sha512WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha512\",\"id\":\"3051300d060960864801650304020305000440\"},\"RSA-SHA512\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha512\",\"id\":\"3051300d060960864801650304020305000440\"},\"RSA-SHA1\":{\"sign\":\"rsa\",\"hash\":\"sha1\",\"id\":\"3021300906052b0e03021a05000414\"},\"ecdsa-with-SHA1\":{\"sign\":\"ecdsa\",\"hash\":\"sha1\",\"id\":\"\"},\"sha256\":{\"sign\":\"ecdsa\",\"hash\":\"sha256\",\"id\":\"\"},\"sha224\":{\"sign\":\"ecdsa\",\"hash\":\"sha224\",\"id\":\"\"},\"sha384\":{\"sign\":\"ecdsa\",\"hash\":\"sha384\",\"id\":\"\"},\"sha512\":{\"sign\":\"ecdsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-SHA\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA-SHA1\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA-WITH-SHA224\":{\"sign\":\"dsa\",\"hash\":\"sha224\",\"id\":\"\"},\"DSA-SHA224\":{\"sign\":\"dsa\",\"hash\":\"sha224\",\"id\":\"\"},\"DSA-WITH-SHA256\":{\"sign\":\"dsa\",\"hash\":\"sha256\",\"id\":\"\"},\"DSA-SHA256\":{\"sign\":\"dsa\",\"hash\":\"sha256\",\"id\":\"\"},\"DSA-WITH-SHA384\":{\"sign\":\"dsa\",\"hash\":\"sha384\",\"id\":\"\"},\"DSA-SHA384\":{\"sign\":\"dsa\",\"hash\":\"sha384\",\"id\":\"\"},\"DSA-WITH-SHA512\":{\"sign\":\"dsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-SHA512\":{\"sign\":\"dsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-RIPEMD160\":{\"sign\":\"dsa\",\"hash\":\"rmd160\",\"id\":\"\"},\"ripemd160WithRSA\":{\"sign\":\"rsa\",\"hash\":\"rmd160\",\"id\":\"3021300906052b2403020105000414\"},\"RSA-RIPEMD160\":{\"sign\":\"rsa\",\"hash\":\"rmd160\",\"id\":\"3021300906052b2403020105000414\"},\"md5WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"md5\",\"id\":\"3020300c06082a864886f70d020505000410\"},\"RSA-MD5\":{\"sign\":\"rsa\",\"hash\":\"md5\",\"id\":\"3020300c06082a864886f70d020505000410\"}};\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-sign/browser/algorithms.json?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/curves.json":
/*!**********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/curves.json ***!
  \**********************************************************/
/*! exports provided: 1.3.132.0.10, 1.3.132.0.33, 1.2.840.10045.3.1.1, 1.2.840.10045.3.1.7, 1.3.132.0.34, 1.3.132.0.35, default */
/***/ (function(module) {

eval("module.exports = {\"1.3.132.0.10\":\"secp256k1\",\"1.3.132.0.33\":\"p224\",\"1.2.840.10045.3.1.1\":\"p192\",\"1.2.840.10045.3.1.7\":\"p256\",\"1.3.132.0.34\":\"p384\",\"1.3.132.0.35\":\"p521\"};\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-sign/browser/curves.json?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\nvar stream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\")\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar sign = __webpack_require__(/*! ./sign */ \"./node_modules/browserify-sign/browser/sign.js\")\nvar verify = __webpack_require__(/*! ./verify */ \"./node_modules/browserify-sign/browser/verify.js\")\n\nvar algorithms = __webpack_require__(/*! ./algorithms.json */ \"./node_modules/browserify-sign/browser/algorithms.json\")\nObject.keys(algorithms).forEach(function (key) {\n  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')\n  algorithms[key.toLowerCase()] = algorithms[key]\n})\n\nfunction Sign (algorithm) {\n  stream.Writable.call(this)\n\n  var data = algorithms[algorithm]\n  if (!data) throw new Error('Unknown message digest')\n\n  this._hashType = data.hash\n  this._hash = createHash(data.hash)\n  this._tag = data.id\n  this._signType = data.sign\n}\ninherits(Sign, stream.Writable)\n\nSign.prototype._write = function _write (data, _, done) {\n  this._hash.update(data)\n  done()\n}\n\nSign.prototype.update = function update (data, enc) {\n  if (typeof data === 'string') data = new Buffer(data, enc)\n\n  this._hash.update(data)\n  return this\n}\n\nSign.prototype.sign = function signMethod (key, enc) {\n  this.end()\n  var hash = this._hash.digest()\n  var sig = sign(hash, key, this._hashType, this._signType, this._tag)\n\n  return enc ? sig.toString(enc) : sig\n}\n\nfunction Verify (algorithm) {\n  stream.Writable.call(this)\n\n  var data = algorithms[algorithm]\n  if (!data) throw new Error('Unknown message digest')\n\n  this._hash = createHash(data.hash)\n  this._tag = data.id\n  this._signType = data.sign\n}\ninherits(Verify, stream.Writable)\n\nVerify.prototype._write = function _write (data, _, done) {\n  this._hash.update(data)\n  done()\n}\n\nVerify.prototype.update = function update (data, enc) {\n  if (typeof data === 'string') data = new Buffer(data, enc)\n\n  this._hash.update(data)\n  return this\n}\n\nVerify.prototype.verify = function verifyMethod (key, sig, enc) {\n  if (typeof sig === 'string') sig = new Buffer(sig, enc)\n\n  this.end()\n  var hash = this._hash.digest()\n  return verify(sig, hash, key, this._signType, this._tag)\n}\n\nfunction createSign (algorithm) {\n  return new Sign(algorithm)\n}\n\nfunction createVerify (algorithm) {\n  return new Verify(algorithm)\n}\n\nmodule.exports = {\n  Sign: createSign,\n  Verify: createVerify,\n  createSign: createSign,\n  createVerify: createVerify\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-sign/browser/index.js?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/sign.js":
/*!******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/sign.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\nvar createHmac = __webpack_require__(/*! create-hmac */ \"./node_modules/create-hmac/browser.js\")\nvar crt = __webpack_require__(/*! browserify-rsa */ \"./node_modules/browserify-rsa/index.js\")\nvar EC = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\").ec\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\nvar parseKeys = __webpack_require__(/*! parse-asn1 */ \"./node_modules/parse-asn1/index.js\")\nvar curves = __webpack_require__(/*! ./curves.json */ \"./node_modules/browserify-sign/browser/curves.json\")\n\nfunction sign (hash, key, hashType, signType, tag) {\n  var priv = parseKeys(key)\n  if (priv.curve) {\n    // rsa keys can be interpreted as ecdsa ones in openssl\n    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')\n    return ecSign(hash, priv)\n  } else if (priv.type === 'dsa') {\n    if (signType !== 'dsa') throw new Error('wrong private key type')\n    return dsaSign(hash, priv, hashType)\n  } else {\n    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')\n  }\n  hash = Buffer.concat([tag, hash])\n  var len = priv.modulus.byteLength()\n  var pad = [ 0, 1 ]\n  while (hash.length + pad.length + 1 < len) pad.push(0xff)\n  pad.push(0x00)\n  var i = -1\n  while (++i < hash.length) pad.push(hash[i])\n\n  var out = crt(pad, priv)\n  return out\n}\n\nfunction ecSign (hash, priv) {\n  var curveId = curves[priv.curve.join('.')]\n  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))\n\n  var curve = new EC(curveId)\n  var key = curve.keyFromPrivate(priv.privateKey)\n  var out = key.sign(hash)\n\n  return new Buffer(out.toDER())\n}\n\nfunction dsaSign (hash, priv, algo) {\n  var x = priv.params.priv_key\n  var p = priv.params.p\n  var q = priv.params.q\n  var g = priv.params.g\n  var r = new BN(0)\n  var k\n  var H = bits2int(hash, q).mod(q)\n  var s = false\n  var kv = getKey(x, q, hash, algo)\n  while (s === false) {\n    k = makeKey(q, kv, algo)\n    r = makeR(g, k, p, q)\n    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)\n    if (s.cmpn(0) === 0) {\n      s = false\n      r = new BN(0)\n    }\n  }\n  return toDER(r, s)\n}\n\nfunction toDER (r, s) {\n  r = r.toArray()\n  s = s.toArray()\n\n  // Pad values\n  if (r[0] & 0x80) r = [ 0 ].concat(r)\n  if (s[0] & 0x80) s = [ 0 ].concat(s)\n\n  var total = r.length + s.length + 4\n  var res = [ 0x30, total, 0x02, r.length ]\n  res = res.concat(r, [ 0x02, s.length ], s)\n  return new Buffer(res)\n}\n\nfunction getKey (x, q, hash, algo) {\n  x = new Buffer(x.toArray())\n  if (x.length < q.byteLength()) {\n    var zeros = new Buffer(q.byteLength() - x.length)\n    zeros.fill(0)\n    x = Buffer.concat([ zeros, x ])\n  }\n  var hlen = hash.length\n  var hbits = bits2octets(hash, q)\n  var v = new Buffer(hlen)\n  v.fill(1)\n  var k = new Buffer(hlen)\n  k.fill(0)\n  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()\n  v = createHmac(algo, k).update(v).digest()\n  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()\n  v = createHmac(algo, k).update(v).digest()\n  return { k: k, v: v }\n}\n\nfunction bits2int (obits, q) {\n  var bits = new BN(obits)\n  var shift = (obits.length << 3) - q.bitLength()\n  if (shift > 0) bits.ishrn(shift)\n  return bits\n}\n\nfunction bits2octets (bits, q) {\n  bits = bits2int(bits, q)\n  bits = bits.mod(q)\n  var out = new Buffer(bits.toArray())\n  if (out.length < q.byteLength()) {\n    var zeros = new Buffer(q.byteLength() - out.length)\n    zeros.fill(0)\n    out = Buffer.concat([ zeros, out ])\n  }\n  return out\n}\n\nfunction makeKey (q, kv, algo) {\n  var t\n  var k\n\n  do {\n    t = new Buffer(0)\n\n    while (t.length * 8 < q.bitLength()) {\n      kv.v = createHmac(algo, kv.k).update(kv.v).digest()\n      t = Buffer.concat([ t, kv.v ])\n    }\n\n    k = bits2int(t, q)\n    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()\n    kv.v = createHmac(algo, kv.k).update(kv.v).digest()\n  } while (k.cmp(q) !== -1)\n\n  return k\n}\n\nfunction makeR (g, k, p, q) {\n  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)\n}\n\nmodule.exports = sign\nmodule.exports.getKey = getKey\nmodule.exports.makeKey = makeKey\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-sign/browser/sign.js?");

/***/ }),

/***/ "./node_modules/browserify-sign/browser/verify.js":
/*!********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/verify.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\nvar EC = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\").ec\nvar parseKeys = __webpack_require__(/*! parse-asn1 */ \"./node_modules/parse-asn1/index.js\")\nvar curves = __webpack_require__(/*! ./curves.json */ \"./node_modules/browserify-sign/browser/curves.json\")\n\nfunction verify (sig, hash, key, signType, tag) {\n  var pub = parseKeys(key)\n  if (pub.type === 'ec') {\n    // rsa keys can be interpreted as ecdsa ones in openssl\n    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\n    return ecVerify(sig, hash, pub)\n  } else if (pub.type === 'dsa') {\n    if (signType !== 'dsa') throw new Error('wrong public key type')\n    return dsaVerify(sig, hash, pub)\n  } else {\n    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\n  }\n  hash = Buffer.concat([tag, hash])\n  var len = pub.modulus.byteLength()\n  var pad = [ 1 ]\n  var padNum = 0\n  while (hash.length + pad.length + 2 < len) {\n    pad.push(0xff)\n    padNum++\n  }\n  pad.push(0x00)\n  var i = -1\n  while (++i < hash.length) {\n    pad.push(hash[i])\n  }\n  pad = new Buffer(pad)\n  var red = BN.mont(pub.modulus)\n  sig = new BN(sig).toRed(red)\n\n  sig = sig.redPow(new BN(pub.publicExponent))\n  sig = new Buffer(sig.fromRed().toArray())\n  var out = padNum < 8 ? 1 : 0\n  len = Math.min(sig.length, pad.length)\n  if (sig.length !== pad.length) out = 1\n\n  i = -1\n  while (++i < len) out |= sig[i] ^ pad[i]\n  return out === 0\n}\n\nfunction ecVerify (sig, hash, pub) {\n  var curveId = curves[pub.data.algorithm.curve.join('.')]\n  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))\n\n  var curve = new EC(curveId)\n  var pubkey = pub.data.subjectPrivateKey.data\n\n  return curve.verify(hash, sig, pubkey)\n}\n\nfunction dsaVerify (sig, hash, pub) {\n  var p = pub.data.p\n  var q = pub.data.q\n  var g = pub.data.g\n  var y = pub.data.pub_key\n  var unpacked = parseKeys.signature.decode(sig, 'der')\n  var s = unpacked.s\n  var r = unpacked.r\n  checkValue(s, q)\n  checkValue(r, q)\n  var montp = BN.mont(p)\n  var w = s.invm(q)\n  var v = g.toRed(montp)\n    .redPow(new BN(hash).mul(w).mod(q))\n    .fromRed()\n    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())\n    .mod(p)\n    .mod(q)\n  return v.cmp(r) === 0\n}\n\nfunction checkValue (b, q) {\n  if (b.cmpn(0) <= 0) throw new Error('invalid sig')\n  if (b.cmp(q) >= q) throw new Error('invalid sig')\n}\n\nmodule.exports = verify\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/browserify-sign/browser/verify.js?");

/***/ }),

/***/ "./node_modules/buffer-xor/index.js":
/*!******************************************!*\
  !*** ./node_modules/buffer-xor/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {\n  var length = Math.min(a.length, b.length)\n  var buffer = new Buffer(length)\n\n  for (var i = 0; i < length; ++i) {\n    buffer[i] = a[i] ^ b[i]\n  }\n\n  return buffer\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/buffer-xor/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/cipher-base/index.js":
/*!*******************************************!*\
  !*** ./node_modules/cipher-base/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar Transform = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\").Transform\nvar StringDecoder = __webpack_require__(/*! string_decoder */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction CipherBase (hashMode) {\n  Transform.call(this)\n  this.hashMode = typeof hashMode === 'string'\n  if (this.hashMode) {\n    this[hashMode] = this._finalOrDigest\n  } else {\n    this.final = this._finalOrDigest\n  }\n  if (this._final) {\n    this.__final = this._final\n    this._final = null\n  }\n  this._decoder = null\n  this._encoding = null\n}\ninherits(CipherBase, Transform)\n\nCipherBase.prototype.update = function (data, inputEnc, outputEnc) {\n  if (typeof data === 'string') {\n    data = Buffer.from(data, inputEnc)\n  }\n\n  var outData = this._update(data)\n  if (this.hashMode) return this\n\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc)\n  }\n\n  return outData\n}\n\nCipherBase.prototype.setAutoPadding = function () {}\nCipherBase.prototype.getAuthTag = function () {\n  throw new Error('trying to get auth tag in unsupported state')\n}\n\nCipherBase.prototype.setAuthTag = function () {\n  throw new Error('trying to set auth tag in unsupported state')\n}\n\nCipherBase.prototype.setAAD = function () {\n  throw new Error('trying to set aad in unsupported state')\n}\n\nCipherBase.prototype._transform = function (data, _, next) {\n  var err\n  try {\n    if (this.hashMode) {\n      this._update(data)\n    } else {\n      this.push(this._update(data))\n    }\n  } catch (e) {\n    err = e\n  } finally {\n    next(err)\n  }\n}\nCipherBase.prototype._flush = function (done) {\n  var err\n  try {\n    this.push(this.__final())\n  } catch (e) {\n    err = e\n  }\n\n  done(err)\n}\nCipherBase.prototype._finalOrDigest = function (outputEnc) {\n  var outData = this.__final() || Buffer.alloc(0)\n  if (outputEnc) {\n    outData = this._toString(outData, outputEnc, true)\n  }\n  return outData\n}\n\nCipherBase.prototype._toString = function (value, enc, fin) {\n  if (!this._decoder) {\n    this._decoder = new StringDecoder(enc)\n    this._encoding = enc\n  }\n\n  if (this._encoding !== enc) throw new Error('can\\'t switch encodings')\n\n  var out = this._decoder.write(value)\n  if (fin) {\n    out += this._decoder.end()\n  }\n\n  return out\n}\n\nmodule.exports = CipherBase\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/cipher-base/index.js?");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/core-util-is/lib/util.js?");

/***/ }),

/***/ "./node_modules/create-ecdh/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-ecdh/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(/*! elliptic */ \"./node_modules/elliptic/lib/elliptic.js\")\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\n\nmodule.exports = function createECDH (curve) {\n  return new ECDH(curve)\n}\n\nvar aliases = {\n  secp256k1: {\n    name: 'secp256k1',\n    byteLength: 32\n  },\n  secp224r1: {\n    name: 'p224',\n    byteLength: 28\n  },\n  prime256v1: {\n    name: 'p256',\n    byteLength: 32\n  },\n  prime192v1: {\n    name: 'p192',\n    byteLength: 24\n  },\n  ed25519: {\n    name: 'ed25519',\n    byteLength: 32\n  },\n  secp384r1: {\n    name: 'p384',\n    byteLength: 48\n  },\n  secp521r1: {\n    name: 'p521',\n    byteLength: 66\n  }\n}\n\naliases.p224 = aliases.secp224r1\naliases.p256 = aliases.secp256r1 = aliases.prime256v1\naliases.p192 = aliases.secp192r1 = aliases.prime192v1\naliases.p384 = aliases.secp384r1\naliases.p521 = aliases.secp521r1\n\nfunction ECDH (curve) {\n  this.curveType = aliases[curve]\n  if (!this.curveType) {\n    this.curveType = {\n      name: curve\n    }\n  }\n  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap\n  this.keys = void 0\n}\n\nECDH.prototype.generateKeys = function (enc, format) {\n  this.keys = this.curve.genKeyPair()\n  return this.getPublicKey(enc, format)\n}\n\nECDH.prototype.computeSecret = function (other, inenc, enc) {\n  inenc = inenc || 'utf8'\n  if (!Buffer.isBuffer(other)) {\n    other = new Buffer(other, inenc)\n  }\n  var otherPub = this.curve.keyFromPublic(other).getPublic()\n  var out = otherPub.mul(this.keys.getPrivate()).getX()\n  return formatReturnValue(out, enc, this.curveType.byteLength)\n}\n\nECDH.prototype.getPublicKey = function (enc, format) {\n  var key = this.keys.getPublic(format === 'compressed', true)\n  if (format === 'hybrid') {\n    if (key[key.length - 1] % 2) {\n      key[0] = 7\n    } else {\n      key[0] = 6\n    }\n  }\n  return formatReturnValue(key, enc)\n}\n\nECDH.prototype.getPrivateKey = function (enc) {\n  return formatReturnValue(this.keys.getPrivate(), enc)\n}\n\nECDH.prototype.setPublicKey = function (pub, enc) {\n  enc = enc || 'utf8'\n  if (!Buffer.isBuffer(pub)) {\n    pub = new Buffer(pub, enc)\n  }\n  this.keys._importPublic(pub)\n  return this\n}\n\nECDH.prototype.setPrivateKey = function (priv, enc) {\n  enc = enc || 'utf8'\n  if (!Buffer.isBuffer(priv)) {\n    priv = new Buffer(priv, enc)\n  }\n\n  var _priv = new BN(priv)\n  _priv = _priv.toString(16)\n  this.keys = this.curve.genKeyPair()\n  this.keys._importPrivate(_priv)\n  return this\n}\n\nfunction formatReturnValue (bn, enc, len) {\n  if (!Array.isArray(bn)) {\n    bn = bn.toArray()\n  }\n  var buf = new Buffer(bn)\n  if (len && buf.length < len) {\n    var zeros = new Buffer(len - buf.length)\n    zeros.fill(0)\n    buf = Buffer.concat([zeros, buf])\n  }\n  if (!enc) {\n    return buf\n  } else {\n    return buf.toString(enc)\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/create-ecdh/browser.js?");

/***/ }),

/***/ "./node_modules/create-hash/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hash/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar MD5 = __webpack_require__(/*! md5.js */ \"./node_modules/md5.js/index.js\")\nvar RIPEMD160 = __webpack_require__(/*! ripemd160 */ \"./node_modules/ripemd160/index.js\")\nvar sha = __webpack_require__(/*! sha.js */ \"./node_modules/sha.js/index.js\")\nvar Base = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\n\nfunction Hash (hash) {\n  Base.call(this, 'digest')\n\n  this._hash = hash\n}\n\ninherits(Hash, Base)\n\nHash.prototype._update = function (data) {\n  this._hash.update(data)\n}\n\nHash.prototype._final = function () {\n  return this._hash.digest()\n}\n\nmodule.exports = function createHash (alg) {\n  alg = alg.toLowerCase()\n  if (alg === 'md5') return new MD5()\n  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()\n\n  return new Hash(sha(alg))\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/create-hash/browser.js?");

/***/ }),

/***/ "./node_modules/create-hash/md5.js":
/*!*****************************************!*\
  !*** ./node_modules/create-hash/md5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var MD5 = __webpack_require__(/*! md5.js */ \"./node_modules/md5.js/index.js\")\n\nmodule.exports = function (buffer) {\n  return new MD5().update(buffer).digest()\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/create-hash/md5.js?");

/***/ }),

/***/ "./node_modules/create-hmac/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hmac/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Legacy = __webpack_require__(/*! ./legacy */ \"./node_modules/create-hmac/legacy.js\")\nvar Base = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar md5 = __webpack_require__(/*! create-hash/md5 */ \"./node_modules/create-hash/md5.js\")\nvar RIPEMD160 = __webpack_require__(/*! ripemd160 */ \"./node_modules/ripemd160/index.js\")\n\nvar sha = __webpack_require__(/*! sha.js */ \"./node_modules/sha.js/index.js\")\n\nvar ZEROS = Buffer.alloc(128)\n\nfunction Hmac (alg, key) {\n  Base.call(this, 'digest')\n  if (typeof key === 'string') {\n    key = Buffer.from(key)\n  }\n\n  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64\n\n  this._alg = alg\n  this._key = key\n  if (key.length > blocksize) {\n    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)\n    key = hash.update(key).digest()\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize)\n  }\n\n  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)\n  var opad = this._opad = Buffer.allocUnsafe(blocksize)\n\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)\n  this._hash.update(ipad)\n}\n\ninherits(Hmac, Base)\n\nHmac.prototype._update = function (data) {\n  this._hash.update(data)\n}\n\nHmac.prototype._final = function () {\n  var h = this._hash.digest()\n  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)\n  return hash.update(this._opad).update(h).digest()\n}\n\nmodule.exports = function createHmac (alg, key) {\n  alg = alg.toLowerCase()\n  if (alg === 'rmd160' || alg === 'ripemd160') {\n    return new Hmac('rmd160', key)\n  }\n  if (alg === 'md5') {\n    return new Legacy(md5, key)\n  }\n  return new Hmac(alg, key)\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/create-hmac/browser.js?");

/***/ }),

/***/ "./node_modules/create-hmac/legacy.js":
/*!********************************************!*\
  !*** ./node_modules/create-hmac/legacy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar Base = __webpack_require__(/*! cipher-base */ \"./node_modules/cipher-base/index.js\")\n\nvar ZEROS = Buffer.alloc(128)\nvar blocksize = 64\n\nfunction Hmac (alg, key) {\n  Base.call(this, 'digest')\n  if (typeof key === 'string') {\n    key = Buffer.from(key)\n  }\n\n  this._alg = alg\n  this._key = key\n\n  if (key.length > blocksize) {\n    key = alg(key)\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize)\n  }\n\n  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)\n  var opad = this._opad = Buffer.allocUnsafe(blocksize)\n\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  this._hash = [ipad]\n}\n\ninherits(Hmac, Base)\n\nHmac.prototype._update = function (data) {\n  this._hash.push(data)\n}\n\nHmac.prototype._final = function () {\n  var h = this._alg(Buffer.concat(this._hash))\n  return this._alg(Buffer.concat([this._opad, h]))\n}\nmodule.exports = Hmac\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/create-hmac/legacy.js?");

/***/ }),

/***/ "./node_modules/crypto-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\")\nexports.createHash = exports.Hash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\nexports.createHmac = exports.Hmac = __webpack_require__(/*! create-hmac */ \"./node_modules/create-hmac/browser.js\")\n\nvar algos = __webpack_require__(/*! browserify-sign/algos */ \"./node_modules/browserify-sign/algos.js\")\nvar algoKeys = Object.keys(algos)\nvar hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)\nexports.getHashes = function () {\n  return hashes\n}\n\nvar p = __webpack_require__(/*! pbkdf2 */ \"./node_modules/pbkdf2/browser.js\")\nexports.pbkdf2 = p.pbkdf2\nexports.pbkdf2Sync = p.pbkdf2Sync\n\nvar aes = __webpack_require__(/*! browserify-cipher */ \"./node_modules/browserify-cipher/browser.js\")\n\nexports.Cipher = aes.Cipher\nexports.createCipher = aes.createCipher\nexports.Cipheriv = aes.Cipheriv\nexports.createCipheriv = aes.createCipheriv\nexports.Decipher = aes.Decipher\nexports.createDecipher = aes.createDecipher\nexports.Decipheriv = aes.Decipheriv\nexports.createDecipheriv = aes.createDecipheriv\nexports.getCiphers = aes.getCiphers\nexports.listCiphers = aes.listCiphers\n\nvar dh = __webpack_require__(/*! diffie-hellman */ \"./node_modules/diffie-hellman/browser.js\")\n\nexports.DiffieHellmanGroup = dh.DiffieHellmanGroup\nexports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup\nexports.getDiffieHellman = dh.getDiffieHellman\nexports.createDiffieHellman = dh.createDiffieHellman\nexports.DiffieHellman = dh.DiffieHellman\n\nvar sign = __webpack_require__(/*! browserify-sign */ \"./node_modules/browserify-sign/browser/index.js\")\n\nexports.createSign = sign.createSign\nexports.Sign = sign.Sign\nexports.createVerify = sign.createVerify\nexports.Verify = sign.Verify\n\nexports.createECDH = __webpack_require__(/*! create-ecdh */ \"./node_modules/create-ecdh/browser.js\")\n\nvar publicEncrypt = __webpack_require__(/*! public-encrypt */ \"./node_modules/public-encrypt/browser.js\")\n\nexports.publicEncrypt = publicEncrypt.publicEncrypt\nexports.privateEncrypt = publicEncrypt.privateEncrypt\nexports.publicDecrypt = publicEncrypt.publicDecrypt\nexports.privateDecrypt = publicEncrypt.privateDecrypt\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n// ;[\n//   'createCredentials'\n// ].forEach(function (name) {\n//   exports[name] = function () {\n//     throw new Error([\n//       'sorry, ' + name + ' is not implemented yet',\n//       'we accept pull requests',\n//       'https://github.com/crypto-browserify/crypto-browserify'\n//     ].join('\\n'))\n//   }\n// })\n\nvar rf = __webpack_require__(/*! randomfill */ \"./node_modules/randomfill/browser.js\")\n\nexports.randomFill = rf.randomFill\nexports.randomFillSync = rf.randomFillSync\n\nexports.createCredentials = function () {\n  throw new Error([\n    'sorry, createCredentials is not implemented yet',\n    'we accept pull requests',\n    'https://github.com/crypto-browserify/crypto-browserify'\n  ].join('\\n'))\n}\n\nexports.constants = {\n  'DH_CHECK_P_NOT_SAFE_PRIME': 2,\n  'DH_CHECK_P_NOT_PRIME': 1,\n  'DH_UNABLE_TO_CHECK_GENERATOR': 4,\n  'DH_NOT_SUITABLE_GENERATOR': 8,\n  'NPN_ENABLED': 1,\n  'ALPN_ENABLED': 1,\n  'RSA_PKCS1_PADDING': 1,\n  'RSA_SSLV23_PADDING': 2,\n  'RSA_NO_PADDING': 3,\n  'RSA_PKCS1_OAEP_PADDING': 4,\n  'RSA_X931_PADDING': 5,\n  'RSA_PKCS1_PSS_PADDING': 6,\n  'POINT_CONVERSION_COMPRESSED': 2,\n  'POINT_CONVERSION_UNCOMPRESSED': 4,\n  'POINT_CONVERSION_HYBRID': 6\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/crypto-browserify/index.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des.js":
/*!****************************************!*\
  !*** ./node_modules/des.js/lib/des.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.utils = __webpack_require__(/*! ./des/utils */ \"./node_modules/des.js/lib/des/utils.js\");\nexports.Cipher = __webpack_require__(/*! ./des/cipher */ \"./node_modules/des.js/lib/des/cipher.js\");\nexports.DES = __webpack_require__(/*! ./des/des */ \"./node_modules/des.js/lib/des/des.js\");\nexports.CBC = __webpack_require__(/*! ./des/cbc */ \"./node_modules/des.js/lib/des/cbc.js\");\nexports.EDE = __webpack_require__(/*! ./des/ede */ \"./node_modules/des.js/lib/des/ede.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/des.js/lib/des.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/cbc.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/cbc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar proto = {};\n\nfunction CBCState(iv) {\n  assert.equal(iv.length, 8, 'Invalid IV length');\n\n  this.iv = new Array(8);\n  for (var i = 0; i < this.iv.length; i++)\n    this.iv[i] = iv[i];\n}\n\nfunction instantiate(Base) {\n  function CBC(options) {\n    Base.call(this, options);\n    this._cbcInit();\n  }\n  inherits(CBC, Base);\n\n  var keys = Object.keys(proto);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    CBC.prototype[key] = proto[key];\n  }\n\n  CBC.create = function create(options) {\n    return new CBC(options);\n  };\n\n  return CBC;\n}\n\nexports.instantiate = instantiate;\n\nproto._cbcInit = function _cbcInit() {\n  var state = new CBCState(this.options.iv);\n  this._cbcState = state;\n};\n\nproto._update = function _update(inp, inOff, out, outOff) {\n  var state = this._cbcState;\n  var superProto = this.constructor.super_.prototype;\n\n  var iv = state.iv;\n  if (this.type === 'encrypt') {\n    for (var i = 0; i < this.blockSize; i++)\n      iv[i] ^= inp[inOff + i];\n\n    superProto._update.call(this, iv, 0, out, outOff);\n\n    for (var i = 0; i < this.blockSize; i++)\n      iv[i] = out[outOff + i];\n  } else {\n    superProto._update.call(this, inp, inOff, out, outOff);\n\n    for (var i = 0; i < this.blockSize; i++)\n      out[outOff + i] ^= iv[i];\n\n    for (var i = 0; i < this.blockSize; i++)\n      iv[i] = inp[inOff + i];\n  }\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/des.js/lib/des/cbc.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/des.js/lib/des/cipher.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction Cipher(options) {\n  this.options = options;\n\n  this.type = this.options.type;\n  this.blockSize = 8;\n  this._init();\n\n  this.buffer = new Array(this.blockSize);\n  this.bufferOff = 0;\n}\nmodule.exports = Cipher;\n\nCipher.prototype._init = function _init() {\n  // Might be overrided\n};\n\nCipher.prototype.update = function update(data) {\n  if (data.length === 0)\n    return [];\n\n  if (this.type === 'decrypt')\n    return this._updateDecrypt(data);\n  else\n    return this._updateEncrypt(data);\n};\n\nCipher.prototype._buffer = function _buffer(data, off) {\n  // Append data to buffer\n  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\n  for (var i = 0; i < min; i++)\n    this.buffer[this.bufferOff + i] = data[off + i];\n  this.bufferOff += min;\n\n  // Shift next\n  return min;\n};\n\nCipher.prototype._flushBuffer = function _flushBuffer(out, off) {\n  this._update(this.buffer, 0, out, off);\n  this.bufferOff = 0;\n  return this.blockSize;\n};\n\nCipher.prototype._updateEncrypt = function _updateEncrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;\n  var out = new Array(count * this.blockSize);\n\n  if (this.bufferOff !== 0) {\n    inputOff += this._buffer(data, inputOff);\n\n    if (this.bufferOff === this.buffer.length)\n      outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Write blocks\n  var max = data.length - ((data.length - inputOff) % this.blockSize);\n  for (; inputOff < max; inputOff += this.blockSize) {\n    this._update(data, inputOff, out, outputOff);\n    outputOff += this.blockSize;\n  }\n\n  // Queue rest\n  for (; inputOff < data.length; inputOff++, this.bufferOff++)\n    this.buffer[this.bufferOff] = data[inputOff];\n\n  return out;\n};\n\nCipher.prototype._updateDecrypt = function _updateDecrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\n  var out = new Array(count * this.blockSize);\n\n  // TODO(indutny): optimize it, this is far from optimal\n  for (; count > 0; count--) {\n    inputOff += this._buffer(data, inputOff);\n    outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Buffer rest of the input\n  inputOff += this._buffer(data, inputOff);\n\n  return out;\n};\n\nCipher.prototype.final = function final(buffer) {\n  var first;\n  if (buffer)\n    first = this.update(buffer);\n\n  var last;\n  if (this.type === 'encrypt')\n    last = this._finalEncrypt();\n  else\n    last = this._finalDecrypt();\n\n  if (first)\n    return first.concat(last);\n  else\n    return last;\n};\n\nCipher.prototype._pad = function _pad(buffer, off) {\n  if (off === 0)\n    return false;\n\n  while (off < buffer.length)\n    buffer[off++] = 0;\n\n  return true;\n};\n\nCipher.prototype._finalEncrypt = function _finalEncrypt() {\n  if (!this._pad(this.buffer, this.bufferOff))\n    return [];\n\n  var out = new Array(this.blockSize);\n  this._update(this.buffer, 0, out, 0);\n  return out;\n};\n\nCipher.prototype._unpad = function _unpad(buffer) {\n  return buffer;\n};\n\nCipher.prototype._finalDecrypt = function _finalDecrypt() {\n  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\n  var out = new Array(this.blockSize);\n  this._flushBuffer(out, 0);\n\n  return this._unpad(out);\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/des.js/lib/des/cipher.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/des.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/des.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar des = __webpack_require__(/*! ../des */ \"./node_modules/des.js/lib/des.js\");\nvar utils = des.utils;\nvar Cipher = des.Cipher;\n\nfunction DESState() {\n  this.tmp = new Array(2);\n  this.keys = null;\n}\n\nfunction DES(options) {\n  Cipher.call(this, options);\n\n  var state = new DESState();\n  this._desState = state;\n\n  this.deriveKeys(state, options.key);\n}\ninherits(DES, Cipher);\nmodule.exports = DES;\n\nDES.create = function create(options) {\n  return new DES(options);\n};\n\nvar shiftTable = [\n  1, 1, 2, 2, 2, 2, 2, 2,\n  1, 2, 2, 2, 2, 2, 2, 1\n];\n\nDES.prototype.deriveKeys = function deriveKeys(state, key) {\n  state.keys = new Array(16 * 2);\n\n  assert.equal(key.length, this.blockSize, 'Invalid key length');\n\n  var kL = utils.readUInt32BE(key, 0);\n  var kR = utils.readUInt32BE(key, 4);\n\n  utils.pc1(kL, kR, state.tmp, 0);\n  kL = state.tmp[0];\n  kR = state.tmp[1];\n  for (var i = 0; i < state.keys.length; i += 2) {\n    var shift = shiftTable[i >>> 1];\n    kL = utils.r28shl(kL, shift);\n    kR = utils.r28shl(kR, shift);\n    utils.pc2(kL, kR, state.keys, i);\n  }\n};\n\nDES.prototype._update = function _update(inp, inOff, out, outOff) {\n  var state = this._desState;\n\n  var l = utils.readUInt32BE(inp, inOff);\n  var r = utils.readUInt32BE(inp, inOff + 4);\n\n  // Initial Permutation\n  utils.ip(l, r, state.tmp, 0);\n  l = state.tmp[0];\n  r = state.tmp[1];\n\n  if (this.type === 'encrypt')\n    this._encrypt(state, l, r, state.tmp, 0);\n  else\n    this._decrypt(state, l, r, state.tmp, 0);\n\n  l = state.tmp[0];\n  r = state.tmp[1];\n\n  utils.writeUInt32BE(out, l, outOff);\n  utils.writeUInt32BE(out, r, outOff + 4);\n};\n\nDES.prototype._pad = function _pad(buffer, off) {\n  var value = buffer.length - off;\n  for (var i = off; i < buffer.length; i++)\n    buffer[i] = value;\n\n  return true;\n};\n\nDES.prototype._unpad = function _unpad(buffer) {\n  var pad = buffer[buffer.length - 1];\n  for (var i = buffer.length - pad; i < buffer.length; i++)\n    assert.equal(buffer[i], pad);\n\n  return buffer.slice(0, buffer.length - pad);\n};\n\nDES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {\n  var l = lStart;\n  var r = rStart;\n\n  // Apply f() x16 times\n  for (var i = 0; i < state.keys.length; i += 2) {\n    var keyL = state.keys[i];\n    var keyR = state.keys[i + 1];\n\n    // f(r, k)\n    utils.expand(r, state.tmp, 0);\n\n    keyL ^= state.tmp[0];\n    keyR ^= state.tmp[1];\n    var s = utils.substitute(keyL, keyR);\n    var f = utils.permute(s);\n\n    var t = r;\n    r = (l ^ f) >>> 0;\n    l = t;\n  }\n\n  // Reverse Initial Permutation\n  utils.rip(r, l, out, off);\n};\n\nDES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {\n  var l = rStart;\n  var r = lStart;\n\n  // Apply f() x16 times\n  for (var i = state.keys.length - 2; i >= 0; i -= 2) {\n    var keyL = state.keys[i];\n    var keyR = state.keys[i + 1];\n\n    // f(r, k)\n    utils.expand(l, state.tmp, 0);\n\n    keyL ^= state.tmp[0];\n    keyR ^= state.tmp[1];\n    var s = utils.substitute(keyL, keyR);\n    var f = utils.permute(s);\n\n    var t = l;\n    l = (r ^ f) >>> 0;\n    r = t;\n  }\n\n  // Reverse Initial Permutation\n  utils.rip(l, r, out, off);\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/des.js/lib/des/des.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/ede.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/ede.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nvar des = __webpack_require__(/*! ../des */ \"./node_modules/des.js/lib/des.js\");\nvar Cipher = des.Cipher;\nvar DES = des.DES;\n\nfunction EDEState(type, key) {\n  assert.equal(key.length, 24, 'Invalid key length');\n\n  var k1 = key.slice(0, 8);\n  var k2 = key.slice(8, 16);\n  var k3 = key.slice(16, 24);\n\n  if (type === 'encrypt') {\n    this.ciphers = [\n      DES.create({ type: 'encrypt', key: k1 }),\n      DES.create({ type: 'decrypt', key: k2 }),\n      DES.create({ type: 'encrypt', key: k3 })\n    ];\n  } else {\n    this.ciphers = [\n      DES.create({ type: 'decrypt', key: k3 }),\n      DES.create({ type: 'encrypt', key: k2 }),\n      DES.create({ type: 'decrypt', key: k1 })\n    ];\n  }\n}\n\nfunction EDE(options) {\n  Cipher.call(this, options);\n\n  var state = new EDEState(this.type, this.options.key);\n  this._edeState = state;\n}\ninherits(EDE, Cipher);\n\nmodule.exports = EDE;\n\nEDE.create = function create(options) {\n  return new EDE(options);\n};\n\nEDE.prototype._update = function _update(inp, inOff, out, outOff) {\n  var state = this._edeState;\n\n  state.ciphers[0]._update(inp, inOff, out, outOff);\n  state.ciphers[1]._update(out, outOff, out, outOff);\n  state.ciphers[2]._update(out, outOff, out, outOff);\n};\n\nEDE.prototype._pad = DES.prototype._pad;\nEDE.prototype._unpad = DES.prototype._unpad;\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/des.js/lib/des/ede.js?");

/***/ }),

/***/ "./node_modules/des.js/lib/des/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/des.js/lib/des/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.readUInt32BE = function readUInt32BE(bytes, off) {\n  var res =  (bytes[0 + off] << 24) |\n             (bytes[1 + off] << 16) |\n             (bytes[2 + off] << 8) |\n             bytes[3 + off];\n  return res >>> 0;\n};\n\nexports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {\n  bytes[0 + off] = value >>> 24;\n  bytes[1 + off] = (value >>> 16) & 0xff;\n  bytes[2 + off] = (value >>> 8) & 0xff;\n  bytes[3 + off] = value & 0xff;\n};\n\nexports.ip = function ip(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  for (var i = 6; i >= 0; i -= 2) {\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inR >>> (j + i)) & 1;\n    }\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inL >>> (j + i)) & 1;\n    }\n  }\n\n  for (var i = 6; i >= 0; i -= 2) {\n    for (var j = 1; j <= 25; j += 8) {\n      outR <<= 1;\n      outR |= (inR >>> (j + i)) & 1;\n    }\n    for (var j = 1; j <= 25; j += 8) {\n      outR <<= 1;\n      outR |= (inL >>> (j + i)) & 1;\n    }\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.rip = function rip(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  for (var i = 0; i < 4; i++) {\n    for (var j = 24; j >= 0; j -= 8) {\n      outL <<= 1;\n      outL |= (inR >>> (j + i)) & 1;\n      outL <<= 1;\n      outL |= (inL >>> (j + i)) & 1;\n    }\n  }\n  for (var i = 4; i < 8; i++) {\n    for (var j = 24; j >= 0; j -= 8) {\n      outR <<= 1;\n      outR |= (inR >>> (j + i)) & 1;\n      outR <<= 1;\n      outR |= (inL >>> (j + i)) & 1;\n    }\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.pc1 = function pc1(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  // 7, 15, 23, 31, 39, 47, 55, 63\n  // 6, 14, 22, 30, 39, 47, 55, 63\n  // 5, 13, 21, 29, 39, 47, 55, 63\n  // 4, 12, 20, 28\n  for (var i = 7; i >= 5; i--) {\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inR >> (j + i)) & 1;\n    }\n    for (var j = 0; j <= 24; j += 8) {\n      outL <<= 1;\n      outL |= (inL >> (j + i)) & 1;\n    }\n  }\n  for (var j = 0; j <= 24; j += 8) {\n    outL <<= 1;\n    outL |= (inR >> (j + i)) & 1;\n  }\n\n  // 1, 9, 17, 25, 33, 41, 49, 57\n  // 2, 10, 18, 26, 34, 42, 50, 58\n  // 3, 11, 19, 27, 35, 43, 51, 59\n  // 36, 44, 52, 60\n  for (var i = 1; i <= 3; i++) {\n    for (var j = 0; j <= 24; j += 8) {\n      outR <<= 1;\n      outR |= (inR >> (j + i)) & 1;\n    }\n    for (var j = 0; j <= 24; j += 8) {\n      outR <<= 1;\n      outR |= (inL >> (j + i)) & 1;\n    }\n  }\n  for (var j = 0; j <= 24; j += 8) {\n    outR <<= 1;\n    outR |= (inL >> (j + i)) & 1;\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.r28shl = function r28shl(num, shift) {\n  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));\n};\n\nvar pc2table = [\n  // inL => outL\n  14, 11, 17, 4, 27, 23, 25, 0,\n  13, 22, 7, 18, 5, 9, 16, 24,\n  2, 20, 12, 21, 1, 8, 15, 26,\n\n  // inR => outR\n  15, 4, 25, 19, 9, 1, 26, 16,\n  5, 11, 23, 8, 12, 7, 17, 0,\n  22, 3, 10, 14, 6, 20, 27, 24\n];\n\nexports.pc2 = function pc2(inL, inR, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  var len = pc2table.length >>> 1;\n  for (var i = 0; i < len; i++) {\n    outL <<= 1;\n    outL |= (inL >>> pc2table[i]) & 0x1;\n  }\n  for (var i = len; i < pc2table.length; i++) {\n    outR <<= 1;\n    outR |= (inR >>> pc2table[i]) & 0x1;\n  }\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nexports.expand = function expand(r, out, off) {\n  var outL = 0;\n  var outR = 0;\n\n  outL = ((r & 1) << 5) | (r >>> 27);\n  for (var i = 23; i >= 15; i -= 4) {\n    outL <<= 6;\n    outL |= (r >>> i) & 0x3f;\n  }\n  for (var i = 11; i >= 3; i -= 4) {\n    outR |= (r >>> i) & 0x3f;\n    outR <<= 6;\n  }\n  outR |= ((r & 0x1f) << 1) | (r >>> 31);\n\n  out[off + 0] = outL >>> 0;\n  out[off + 1] = outR >>> 0;\n};\n\nvar sTable = [\n  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,\n  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,\n  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,\n  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,\n\n  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,\n  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,\n  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,\n  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,\n\n  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,\n  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,\n  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,\n  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,\n\n  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,\n  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,\n  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,\n  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,\n\n  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,\n  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,\n  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,\n  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,\n\n  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,\n  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,\n  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,\n  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,\n\n  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,\n  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,\n  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,\n  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,\n\n  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,\n  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,\n  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,\n  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11\n];\n\nexports.substitute = function substitute(inL, inR) {\n  var out = 0;\n  for (var i = 0; i < 4; i++) {\n    var b = (inL >>> (18 - i * 6)) & 0x3f;\n    var sb = sTable[i * 0x40 + b];\n\n    out <<= 4;\n    out |= sb;\n  }\n  for (var i = 0; i < 4; i++) {\n    var b = (inR >>> (18 - i * 6)) & 0x3f;\n    var sb = sTable[4 * 0x40 + i * 0x40 + b];\n\n    out <<= 4;\n    out |= sb;\n  }\n  return out >>> 0;\n};\n\nvar permuteTable = [\n  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,\n  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7\n];\n\nexports.permute = function permute(num) {\n  var out = 0;\n  for (var i = 0; i < permuteTable.length; i++) {\n    out <<= 1;\n    out |= (num >>> permuteTable[i]) & 0x1;\n  }\n  return out >>> 0;\n};\n\nexports.padSplit = function padSplit(num, size, group) {\n  var str = num.toString(2);\n  while (str.length < size)\n    str = '0' + str;\n\n  var out = [];\n  for (var i = 0; i < size; i += group)\n    out.push(str.slice(i, i + group));\n  return out.join(' ');\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/des.js/lib/des/utils.js?");

/***/ }),

/***/ "./node_modules/diffie-hellman/browser.js":
/*!************************************************!*\
  !*** ./node_modules/diffie-hellman/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(/*! ./lib/generatePrime */ \"./node_modules/diffie-hellman/lib/generatePrime.js\")\nvar primes = __webpack_require__(/*! ./lib/primes.json */ \"./node_modules/diffie-hellman/lib/primes.json\")\n\nvar DH = __webpack_require__(/*! ./lib/dh */ \"./node_modules/diffie-hellman/lib/dh.js\")\n\nfunction getDiffieHellman (mod) {\n  var prime = new Buffer(primes[mod].prime, 'hex')\n  var gen = new Buffer(primes[mod].gen, 'hex')\n\n  return new DH(prime, gen)\n}\n\nvar ENCODINGS = {\n  'binary': true, 'hex': true, 'base64': true\n}\n\nfunction createDiffieHellman (prime, enc, generator, genc) {\n  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {\n    return createDiffieHellman(prime, 'binary', enc, generator)\n  }\n\n  enc = enc || 'binary'\n  genc = genc || 'binary'\n  generator = generator || new Buffer([2])\n\n  if (!Buffer.isBuffer(generator)) {\n    generator = new Buffer(generator, genc)\n  }\n\n  if (typeof prime === 'number') {\n    return new DH(generatePrime(prime, generator), generator, true)\n  }\n\n  if (!Buffer.isBuffer(prime)) {\n    prime = new Buffer(prime, enc)\n  }\n\n  return new DH(prime, generator, true)\n}\n\nexports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman\nexports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/diffie-hellman/browser.js?");

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/dh.js":
/*!***********************************************!*\
  !*** ./node_modules/diffie-hellman/lib/dh.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar MillerRabin = __webpack_require__(/*! miller-rabin */ \"./node_modules/miller-rabin/lib/mr.js\");\nvar millerRabin = new MillerRabin();\nvar TWENTYFOUR = new BN(24);\nvar ELEVEN = new BN(11);\nvar TEN = new BN(10);\nvar THREE = new BN(3);\nvar SEVEN = new BN(7);\nvar primes = __webpack_require__(/*! ./generatePrime */ \"./node_modules/diffie-hellman/lib/generatePrime.js\");\nvar randomBytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\nmodule.exports = DH;\n\nfunction setPublicKey(pub, enc) {\n  enc = enc || 'utf8';\n  if (!Buffer.isBuffer(pub)) {\n    pub = new Buffer(pub, enc);\n  }\n  this._pub = new BN(pub);\n  return this;\n}\n\nfunction setPrivateKey(priv, enc) {\n  enc = enc || 'utf8';\n  if (!Buffer.isBuffer(priv)) {\n    priv = new Buffer(priv, enc);\n  }\n  this._priv = new BN(priv);\n  return this;\n}\n\nvar primeCache = {};\nfunction checkPrime(prime, generator) {\n  var gen = generator.toString('hex');\n  var hex = [gen, prime.toString(16)].join('_');\n  if (hex in primeCache) {\n    return primeCache[hex];\n  }\n  var error = 0;\n\n  if (prime.isEven() ||\n    !primes.simpleSieve ||\n    !primes.fermatTest(prime) ||\n    !millerRabin.test(prime)) {\n    //not a prime so +1\n    error += 1;\n\n    if (gen === '02' || gen === '05') {\n      // we'd be able to check the generator\n      // it would fail so +8\n      error += 8;\n    } else {\n      //we wouldn't be able to test the generator\n      // so +4\n      error += 4;\n    }\n    primeCache[hex] = error;\n    return error;\n  }\n  if (!millerRabin.test(prime.shrn(1))) {\n    //not a safe prime\n    error += 2;\n  }\n  var rem;\n  switch (gen) {\n    case '02':\n      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {\n        // unsuidable generator\n        error += 8;\n      }\n      break;\n    case '05':\n      rem = prime.mod(TEN);\n      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {\n        // prime mod 10 needs to equal 3 or 7\n        error += 8;\n      }\n      break;\n    default:\n      error += 4;\n  }\n  primeCache[hex] = error;\n  return error;\n}\n\nfunction DH(prime, generator, malleable) {\n  this.setGenerator(generator);\n  this.__prime = new BN(prime);\n  this._prime = BN.mont(this.__prime);\n  this._primeLen = prime.length;\n  this._pub = undefined;\n  this._priv = undefined;\n  this._primeCode = undefined;\n  if (malleable) {\n    this.setPublicKey = setPublicKey;\n    this.setPrivateKey = setPrivateKey;\n  } else {\n    this._primeCode = 8;\n  }\n}\nObject.defineProperty(DH.prototype, 'verifyError', {\n  enumerable: true,\n  get: function () {\n    if (typeof this._primeCode !== 'number') {\n      this._primeCode = checkPrime(this.__prime, this.__gen);\n    }\n    return this._primeCode;\n  }\n});\nDH.prototype.generateKeys = function () {\n  if (!this._priv) {\n    this._priv = new BN(randomBytes(this._primeLen));\n  }\n  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();\n  return this.getPublicKey();\n};\n\nDH.prototype.computeSecret = function (other) {\n  other = new BN(other);\n  other = other.toRed(this._prime);\n  var secret = other.redPow(this._priv).fromRed();\n  var out = new Buffer(secret.toArray());\n  var prime = this.getPrime();\n  if (out.length < prime.length) {\n    var front = new Buffer(prime.length - out.length);\n    front.fill(0);\n    out = Buffer.concat([front, out]);\n  }\n  return out;\n};\n\nDH.prototype.getPublicKey = function getPublicKey(enc) {\n  return formatReturnValue(this._pub, enc);\n};\n\nDH.prototype.getPrivateKey = function getPrivateKey(enc) {\n  return formatReturnValue(this._priv, enc);\n};\n\nDH.prototype.getPrime = function (enc) {\n  return formatReturnValue(this.__prime, enc);\n};\n\nDH.prototype.getGenerator = function (enc) {\n  return formatReturnValue(this._gen, enc);\n};\n\nDH.prototype.setGenerator = function (gen, enc) {\n  enc = enc || 'utf8';\n  if (!Buffer.isBuffer(gen)) {\n    gen = new Buffer(gen, enc);\n  }\n  this.__gen = gen;\n  this._gen = new BN(gen);\n  return this;\n};\n\nfunction formatReturnValue(bn, enc) {\n  var buf = new Buffer(bn.toArray());\n  if (!enc) {\n    return buf;\n  } else {\n    return buf.toString(enc);\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/diffie-hellman/lib/dh.js?");

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/generatePrime.js":
/*!**********************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/generatePrime.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var randomBytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\");\nmodule.exports = findPrime;\nfindPrime.simpleSieve = simpleSieve;\nfindPrime.fermatTest = fermatTest;\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar TWENTYFOUR = new BN(24);\nvar MillerRabin = __webpack_require__(/*! miller-rabin */ \"./node_modules/miller-rabin/lib/mr.js\");\nvar millerRabin = new MillerRabin();\nvar ONE = new BN(1);\nvar TWO = new BN(2);\nvar FIVE = new BN(5);\nvar SIXTEEN = new BN(16);\nvar EIGHT = new BN(8);\nvar TEN = new BN(10);\nvar THREE = new BN(3);\nvar SEVEN = new BN(7);\nvar ELEVEN = new BN(11);\nvar FOUR = new BN(4);\nvar TWELVE = new BN(12);\nvar primes = null;\n\nfunction _getPrimes() {\n  if (primes !== null)\n    return primes;\n\n  var limit = 0x100000;\n  var res = [];\n  res[0] = 2;\n  for (var i = 1, k = 3; k < limit; k += 2) {\n    var sqrt = Math.ceil(Math.sqrt(k));\n    for (var j = 0; j < i && res[j] <= sqrt; j++)\n      if (k % res[j] === 0)\n        break;\n\n    if (i !== j && res[j] <= sqrt)\n      continue;\n\n    res[i++] = k;\n  }\n  primes = res;\n  return res;\n}\n\nfunction simpleSieve(p) {\n  var primes = _getPrimes();\n\n  for (var i = 0; i < primes.length; i++)\n    if (p.modn(primes[i]) === 0) {\n      if (p.cmpn(primes[i]) === 0) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n  return true;\n}\n\nfunction fermatTest(p) {\n  var red = BN.mont(p);\n  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;\n}\n\nfunction findPrime(bits, gen) {\n  if (bits < 16) {\n    // this is what openssl does\n    if (gen === 2 || gen === 5) {\n      return new BN([0x8c, 0x7b]);\n    } else {\n      return new BN([0x8c, 0x27]);\n    }\n  }\n  gen = new BN(gen);\n\n  var num, n2;\n\n  while (true) {\n    num = new BN(randomBytes(Math.ceil(bits / 8)));\n    while (num.bitLength() > bits) {\n      num.ishrn(1);\n    }\n    if (num.isEven()) {\n      num.iadd(ONE);\n    }\n    if (!num.testn(1)) {\n      num.iadd(TWO);\n    }\n    if (!gen.cmp(TWO)) {\n      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {\n        num.iadd(FOUR);\n      }\n    } else if (!gen.cmp(FIVE)) {\n      while (num.mod(TEN).cmp(THREE)) {\n        num.iadd(FOUR);\n      }\n    }\n    n2 = num.shrn(1);\n    if (simpleSieve(n2) && simpleSieve(num) &&\n      fermatTest(n2) && fermatTest(num) &&\n      millerRabin.test(n2) && millerRabin.test(num)) {\n      return num;\n    }\n  }\n\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/diffie-hellman/lib/generatePrime.js?");

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/primes.json":
/*!*****************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/primes.json ***!
  \*****************************************************/
/*! exports provided: modp1, modp2, modp5, modp14, modp15, modp16, modp17, modp18, default */
/***/ (function(module) {

eval("module.exports = {\"modp1\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff\"},\"modp2\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff\"},\"modp5\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff\"},\"modp14\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\"},\"modp15\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff\"},\"modp16\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff\"},\"modp17\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff\"},\"modp18\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff\"}};\n\n//# sourceURL=webpack://THREEAR/./node_modules/diffie-hellman/lib/primes.json?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic.js":
/*!***********************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar elliptic = exports;\n\nelliptic.version = __webpack_require__(/*! ../package.json */ \"./node_modules/elliptic/package.json\").version;\nelliptic.utils = __webpack_require__(/*! ./elliptic/utils */ \"./node_modules/elliptic/lib/elliptic/utils.js\");\nelliptic.rand = __webpack_require__(/*! brorand */ \"./node_modules/brorand/index.js\");\nelliptic.curve = __webpack_require__(/*! ./elliptic/curve */ \"./node_modules/elliptic/lib/elliptic/curve/index.js\");\nelliptic.curves = __webpack_require__(/*! ./elliptic/curves */ \"./node_modules/elliptic/lib/elliptic/curves.js\");\n\n// Protocols\nelliptic.ec = __webpack_require__(/*! ./elliptic/ec */ \"./node_modules/elliptic/lib/elliptic/ec/index.js\");\nelliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ \"./node_modules/elliptic/lib/elliptic/eddsa/index.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  for (var j = 0; j < naf.length; j += doubles.step) {\n    var nafW = 0;\n    for (var k = j + doubles.step - 1; k >= j; k--)\n      nafW = (nafW << 1) + naf[k];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (var j = 0; j < repr.length; j++) {\n      var nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var k = 0; i >= 0 && naf[i] === 0; i--)\n      k++;\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n                                                       points,\n                                                       coeffs,\n                                                       len,\n                                                       jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  for (var i = 0; i < len; i++) {\n    var p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (var i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a]);\n      naf[b] = getNAF(coeffs[b], wndWidth[b]);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b] /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (var j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (var i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (var j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (var j = 0; j < len; j++) {\n      var z = tmp[j];\n      var p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (var i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n                          bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/curve/base.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!*************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curve = __webpack_require__(/*! ../curve */ \"./node_modules/elliptic/lib/elliptic/curve/index.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Base = curve.base;\n\nvar assert = elliptic.utils.assert;\n\nfunction EdwardsCurve(conf) {\n  // NOTE: Important as we are creating point in Base.call()\n  this.twisted = (conf.a | 0) !== 1;\n  this.mOneA = this.twisted && (conf.a | 0) === -1;\n  this.extended = this.mOneA;\n\n  Base.call(this, 'edwards', conf);\n\n  this.a = new BN(conf.a, 16).umod(this.red.m);\n  this.a = this.a.toRed(this.red);\n  this.c = new BN(conf.c, 16).toRed(this.red);\n  this.c2 = this.c.redSqr();\n  this.d = new BN(conf.d, 16).toRed(this.red);\n  this.dd = this.d.redAdd(this.d);\n\n  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);\n  this.oneC = (conf.c | 0) === 1;\n}\ninherits(EdwardsCurve, Base);\nmodule.exports = EdwardsCurve;\n\nEdwardsCurve.prototype._mulA = function _mulA(num) {\n  if (this.mOneA)\n    return num.redNeg();\n  else\n    return this.a.redMul(num);\n};\n\nEdwardsCurve.prototype._mulC = function _mulC(num) {\n  if (this.oneC)\n    return num;\n  else\n    return this.c.redMul(num);\n};\n\n// Just for compatibility with Short curve\nEdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {\n  return this.point(x, y, z, t);\n};\n\nEdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var x2 = x.redSqr();\n  var rhs = this.c2.redSub(this.a.redMul(x2));\n  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));\n\n  var y2 = rhs.redMul(lhs.redInvm());\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nEdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {\n  y = new BN(y, 16);\n  if (!y.red)\n    y = y.toRed(this.red);\n\n  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)\n  var y2 = y.redSqr();\n  var lhs = y2.redSub(this.c2);\n  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);\n  var x2 = lhs.redMul(rhs.redInvm());\n\n  if (x2.cmp(this.zero) === 0) {\n    if (odd)\n      throw new Error('invalid point');\n    else\n      return this.point(this.zero, y);\n  }\n\n  var x = x2.redSqrt();\n  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  if (x.fromRed().isOdd() !== odd)\n    x = x.redNeg();\n\n  return this.point(x, y);\n};\n\nEdwardsCurve.prototype.validate = function validate(point) {\n  if (point.isInfinity())\n    return true;\n\n  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)\n  point.normalize();\n\n  var x2 = point.x.redSqr();\n  var y2 = point.y.redSqr();\n  var lhs = x2.redMul(this.a).redAdd(y2);\n  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));\n\n  return lhs.cmp(rhs) === 0;\n};\n\nfunction Point(curve, x, y, z, t) {\n  Base.BasePoint.call(this, curve, 'projective');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.zero;\n    this.y = this.curve.one;\n    this.z = this.curve.one;\n    this.t = this.curve.zero;\n    this.zOne = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = z ? new BN(z, 16) : this.curve.one;\n    this.t = t && new BN(t, 16);\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n    if (this.t && !this.t.red)\n      this.t = this.t.toRed(this.curve.red);\n    this.zOne = this.z === this.curve.one;\n\n    // Use extended coordinates\n    if (this.curve.extended && !this.t) {\n      this.t = this.x.redMul(this.y);\n      if (!this.zOne)\n        this.t = this.t.redMul(this.z.redInvm());\n    }\n  }\n}\ninherits(Point, Base.BasePoint);\n\nEdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\n  return Point.fromJSON(this, obj);\n};\n\nEdwardsCurve.prototype.point = function point(x, y, z, t) {\n  return new Point(this, x, y, z, t);\n};\n\nPoint.fromJSON = function fromJSON(curve, obj) {\n  return new Point(curve, obj[0], obj[1], obj[2]);\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) +\n      ' z: ' + this.z.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.x.cmpn(0) === 0 &&\n    (this.y.cmp(this.z) === 0 ||\n    (this.zOne && this.y.cmp(this.curve.c) === 0));\n};\n\nPoint.prototype._extDbl = function _extDbl() {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html\n  //     #doubling-dbl-2008-hwcd\n  // 4M + 4S\n\n  // A = X1^2\n  var a = this.x.redSqr();\n  // B = Y1^2\n  var b = this.y.redSqr();\n  // C = 2 * Z1^2\n  var c = this.z.redSqr();\n  c = c.redIAdd(c);\n  // D = a * A\n  var d = this.curve._mulA(a);\n  // E = (X1 + Y1)^2 - A - B\n  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);\n  // G = D + B\n  var g = d.redAdd(b);\n  // F = G - C\n  var f = g.redSub(c);\n  // H = D - B\n  var h = d.redSub(b);\n  // X3 = E * F\n  var nx = e.redMul(f);\n  // Y3 = G * H\n  var ny = g.redMul(h);\n  // T3 = E * H\n  var nt = e.redMul(h);\n  // Z3 = F * G\n  var nz = f.redMul(g);\n  return this.curve.point(nx, ny, nz, nt);\n};\n\nPoint.prototype._projDbl = function _projDbl() {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html\n  //     #doubling-dbl-2008-bbjlp\n  //     #doubling-dbl-2007-bl\n  // and others\n  // Generally 3M + 4S or 2M + 4S\n\n  // B = (X1 + Y1)^2\n  var b = this.x.redAdd(this.y).redSqr();\n  // C = X1^2\n  var c = this.x.redSqr();\n  // D = Y1^2\n  var d = this.y.redSqr();\n\n  var nx;\n  var ny;\n  var nz;\n  if (this.curve.twisted) {\n    // E = a * C\n    var e = this.curve._mulA(c);\n    // F = E + D\n    var f = e.redAdd(d);\n    if (this.zOne) {\n      // X3 = (B - C - D) * (F - 2)\n      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));\n      // Y3 = F * (E - D)\n      ny = f.redMul(e.redSub(d));\n      // Z3 = F^2 - 2 * F\n      nz = f.redSqr().redSub(f).redSub(f);\n    } else {\n      // H = Z1^2\n      var h = this.z.redSqr();\n      // J = F - 2 * H\n      var j = f.redSub(h).redISub(h);\n      // X3 = (B-C-D)*J\n      nx = b.redSub(c).redISub(d).redMul(j);\n      // Y3 = F * (E - D)\n      ny = f.redMul(e.redSub(d));\n      // Z3 = F * J\n      nz = f.redMul(j);\n    }\n  } else {\n    // E = C + D\n    var e = c.redAdd(d);\n    // H = (c * Z1)^2\n    var h = this.curve._mulC(this.z).redSqr();\n    // J = E - 2 * H\n    var j = e.redSub(h).redSub(h);\n    // X3 = c * (B - E) * J\n    nx = this.curve._mulC(b.redISub(e)).redMul(j);\n    // Y3 = c * E * (C - D)\n    ny = this.curve._mulC(e).redMul(c.redISub(d));\n    // Z3 = E * J\n    nz = e.redMul(j);\n  }\n  return this.curve.point(nx, ny, nz);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  // Double in extended coordinates\n  if (this.curve.extended)\n    return this._extDbl();\n  else\n    return this._projDbl();\n};\n\nPoint.prototype._extAdd = function _extAdd(p) {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html\n  //     #addition-add-2008-hwcd-3\n  // 8M\n\n  // A = (Y1 - X1) * (Y2 - X2)\n  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));\n  // B = (Y1 + X1) * (Y2 + X2)\n  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));\n  // C = T1 * k * T2\n  var c = this.t.redMul(this.curve.dd).redMul(p.t);\n  // D = Z1 * 2 * Z2\n  var d = this.z.redMul(p.z.redAdd(p.z));\n  // E = B - A\n  var e = b.redSub(a);\n  // F = D - C\n  var f = d.redSub(c);\n  // G = D + C\n  var g = d.redAdd(c);\n  // H = B + A\n  var h = b.redAdd(a);\n  // X3 = E * F\n  var nx = e.redMul(f);\n  // Y3 = G * H\n  var ny = g.redMul(h);\n  // T3 = E * H\n  var nt = e.redMul(h);\n  // Z3 = F * G\n  var nz = f.redMul(g);\n  return this.curve.point(nx, ny, nz, nt);\n};\n\nPoint.prototype._projAdd = function _projAdd(p) {\n  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html\n  //     #addition-add-2008-bbjlp\n  //     #addition-add-2007-bl\n  // 10M + 1S\n\n  // A = Z1 * Z2\n  var a = this.z.redMul(p.z);\n  // B = A^2\n  var b = a.redSqr();\n  // C = X1 * X2\n  var c = this.x.redMul(p.x);\n  // D = Y1 * Y2\n  var d = this.y.redMul(p.y);\n  // E = d * C * D\n  var e = this.curve.d.redMul(c).redMul(d);\n  // F = B - E\n  var f = b.redSub(e);\n  // G = B + E\n  var g = b.redAdd(e);\n  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)\n  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);\n  var nx = a.redMul(f).redMul(tmp);\n  var ny;\n  var nz;\n  if (this.curve.twisted) {\n    // Y3 = A * G * (D - a * C)\n    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));\n    // Z3 = F * G\n    nz = f.redMul(g);\n  } else {\n    // Y3 = A * G * (D - C)\n    ny = a.redMul(g).redMul(d.redSub(c));\n    // Z3 = c * F * G\n    nz = this.curve._mulC(f).redMul(g);\n  }\n  return this.curve.point(nx, ny, nz);\n};\n\nPoint.prototype.add = function add(p) {\n  if (this.isInfinity())\n    return p;\n  if (p.isInfinity())\n    return this;\n\n  if (this.curve.extended)\n    return this._extAdd(p);\n  else\n    return this._projAdd(p);\n};\n\nPoint.prototype.mul = function mul(k) {\n  if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p, k2) {\n  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p, k2) {\n  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);\n};\n\nPoint.prototype.normalize = function normalize() {\n  if (this.zOne)\n    return this;\n\n  // Normalize coordinates\n  var zi = this.z.redInvm();\n  this.x = this.x.redMul(zi);\n  this.y = this.y.redMul(zi);\n  if (this.t)\n    this.t = this.t.redMul(zi);\n  this.z = this.curve.one;\n  this.zOne = true;\n  return this;\n};\n\nPoint.prototype.neg = function neg() {\n  return this.curve.point(this.x.redNeg(),\n                          this.y,\n                          this.z,\n                          this.t && this.t.redNeg());\n};\n\nPoint.prototype.getX = function getX() {\n  this.normalize();\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  this.normalize();\n  return this.y.fromRed();\n};\n\nPoint.prototype.eq = function eq(other) {\n  return this === other ||\n         this.getX().cmp(other.getX()) === 0 &&\n         this.getY().cmp(other.getY()) === 0;\n};\n\nPoint.prototype.eqXToP = function eqXToP(x) {\n  var rx = x.toRed(this.curve.red).redMul(this.z);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(this.z);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\n// Compatibility with BaseCurve\nPoint.prototype.toP = Point.prototype.normalize;\nPoint.prototype.mixedAdd = Point.prototype.add;\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/curve/edwards.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curve = exports;\n\ncurve.base = __webpack_require__(/*! ./base */ \"./node_modules/elliptic/lib/elliptic/curve/base.js\");\ncurve.short = __webpack_require__(/*! ./short */ \"./node_modules/elliptic/lib/elliptic/curve/short.js\");\ncurve.mont = __webpack_require__(/*! ./mont */ \"./node_modules/elliptic/lib/elliptic/curve/mont.js\");\ncurve.edwards = __webpack_require__(/*! ./edwards */ \"./node_modules/elliptic/lib/elliptic/curve/edwards.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/curve/index.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curve = __webpack_require__(/*! ../curve */ \"./node_modules/elliptic/lib/elliptic/curve/index.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Base = curve.base;\n\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\n\nfunction MontCurve(conf) {\n  Base.call(this, 'mont', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.i4 = new BN(4).toRed(this.red).redInvm();\n  this.two = new BN(2).toRed(this.red);\n  this.a24 = this.i4.redMul(this.a.redAdd(this.two));\n}\ninherits(MontCurve, Base);\nmodule.exports = MontCurve;\n\nMontCurve.prototype.validate = function validate(point) {\n  var x = point.normalize().x;\n  var x2 = x.redSqr();\n  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);\n  var y = rhs.redSqrt();\n\n  return y.redSqr().cmp(rhs) === 0;\n};\n\nfunction Point(curve, x, z) {\n  Base.BasePoint.call(this, curve, 'projective');\n  if (x === null && z === null) {\n    this.x = this.curve.one;\n    this.z = this.curve.zero;\n  } else {\n    this.x = new BN(x, 16);\n    this.z = new BN(z, 16);\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n  }\n}\ninherits(Point, Base.BasePoint);\n\nMontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  return this.point(utils.toArray(bytes, enc), 1);\n};\n\nMontCurve.prototype.point = function point(x, z) {\n  return new Point(this, x, z);\n};\n\nMontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {\n  return Point.fromJSON(this, obj);\n};\n\nPoint.prototype.precompute = function precompute() {\n  // No-op\n};\n\nPoint.prototype._encode = function _encode() {\n  return this.getX().toArray('be', this.curve.p.byteLength());\n};\n\nPoint.fromJSON = function fromJSON(curve, obj) {\n  return new Point(curve, obj[0], obj[1] || curve.one);\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' z: ' + this.z.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\nPoint.prototype.dbl = function dbl() {\n  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3\n  // 2M + 2S + 4A\n\n  // A = X1 + Z1\n  var a = this.x.redAdd(this.z);\n  // AA = A^2\n  var aa = a.redSqr();\n  // B = X1 - Z1\n  var b = this.x.redSub(this.z);\n  // BB = B^2\n  var bb = b.redSqr();\n  // C = AA - BB\n  var c = aa.redSub(bb);\n  // X3 = AA * BB\n  var nx = aa.redMul(bb);\n  // Z3 = C * (BB + A24 * C)\n  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));\n  return this.curve.point(nx, nz);\n};\n\nPoint.prototype.add = function add() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\nPoint.prototype.diffAdd = function diffAdd(p, diff) {\n  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3\n  // 4M + 2S + 6A\n\n  // A = X2 + Z2\n  var a = this.x.redAdd(this.z);\n  // B = X2 - Z2\n  var b = this.x.redSub(this.z);\n  // C = X3 + Z3\n  var c = p.x.redAdd(p.z);\n  // D = X3 - Z3\n  var d = p.x.redSub(p.z);\n  // DA = D * A\n  var da = d.redMul(a);\n  // CB = C * B\n  var cb = c.redMul(b);\n  // X5 = Z1 * (DA + CB)^2\n  var nx = diff.z.redMul(da.redAdd(cb).redSqr());\n  // Z5 = X1 * (DA - CB)^2\n  var nz = diff.x.redMul(da.redISub(cb).redSqr());\n  return this.curve.point(nx, nz);\n};\n\nPoint.prototype.mul = function mul(k) {\n  var t = k.clone();\n  var a = this; // (N / 2) * Q + Q\n  var b = this.curve.point(null, null); // (N / 2) * Q\n  var c = this; // Q\n\n  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))\n    bits.push(t.andln(1));\n\n  for (var i = bits.length - 1; i >= 0; i--) {\n    if (bits[i] === 0) {\n      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q\n      a = a.diffAdd(b, c);\n      // N * Q = 2 * ((N / 2) * Q + Q))\n      b = b.dbl();\n    } else {\n      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)\n      b = a.diffAdd(b, c);\n      // N * Q + Q = 2 * ((N / 2) * Q + Q)\n      a = a.dbl();\n    }\n  }\n  return b;\n};\n\nPoint.prototype.mulAdd = function mulAdd() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\nPoint.prototype.jumlAdd = function jumlAdd() {\n  throw new Error('Not supported on Montgomery curve');\n};\n\nPoint.prototype.eq = function eq(other) {\n  return this.getX().cmp(other.getX()) === 0;\n};\n\nPoint.prototype.normalize = function normalize() {\n  this.x = this.x.redMul(this.z.redInvm());\n  this.z = this.curve.one;\n  return this;\n};\n\nPoint.prototype.getX = function getX() {\n  // Normalize coordinates\n  this.normalize();\n\n  return this.x.fromRed();\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/curve/mont.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/short.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curve = __webpack_require__(/*! ../curve */ \"./node_modules/elliptic/lib/elliptic/curve/index.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\nvar Base = curve.base;\n\nvar assert = elliptic.utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16)\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 }\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n  var npoints = this._endoWnafT1;\n  var ncoeffs = this._endoWnafT2;\n  for (var i = 0; i < points.length; i++) {\n    var split = this._endoSplit(coeffs[i]);\n    var p = points[i];\n    var beta = p._getBeta();\n\n    if (split.k1.negative) {\n      split.k1.ineg();\n      p = p.neg(true);\n    }\n    if (split.k2.negative) {\n      split.k2.ineg();\n      beta = beta.neg(true);\n    }\n\n    npoints[i * 2] = p;\n    npoints[i * 2 + 1] = beta;\n    ncoeffs[i * 2] = split.k1;\n    ncoeffs[i * 2 + 1] = split.k2;\n  }\n  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n  // Clean-up references to points and coefficients\n  for (var j = 0; j < i * 2; j++) {\n    npoints[j] = null;\n    ncoeffs[j] = null;\n  }\n  return res;\n};\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul)\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul)\n      }\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1)\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1)\n    }\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point))\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point))\n    }\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n\n  if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate)\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate)\n      }\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (var i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (var i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/curve/short.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curves.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curves.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar curves = exports;\n\nvar hash = __webpack_require__(/*! hash.js */ \"./node_modules/hash.js/lib/hash.js\");\nvar elliptic = __webpack_require__(/*! ../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\n\nvar assert = elliptic.utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new elliptic.curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new elliptic.curve.edwards(options);\n  else\n    this.curve = new elliptic.curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve\n      });\n      return curve;\n    }\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'\n  ]\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'\n  ]\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'\n  ]\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'\n  ]\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650'\n  ]\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9'\n  ]\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658'\n  ]\n});\n\nvar pre;\ntry {\n  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ \"./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js\");\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3'\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15'\n    }\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre\n  ]\n});\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/curves.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/index.js":
/*!********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar HmacDRBG = __webpack_require__(/*! hmac-drbg */ \"./node_modules/hmac-drbg/lib/hmac-drbg.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\n\nvar KeyPair = __webpack_require__(/*! ./key */ \"./node_modules/elliptic/lib/elliptic/ec/key.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"./node_modules/elliptic/lib/elliptic/ec/signature.js\");\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);\n\n    options = elliptic.curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof elliptic.curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray()\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  do {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  } while (true);\n};\n\nEC.prototype._truncateToN = function truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8'\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; true; iter++) {\n    var k = options.k ?\n        options.k(iter) :\n        new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n\n  if (!this.curve._maxwellTrick) {\n    var p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  var p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/ec/index.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/key.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/ec/key.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\n\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n  }\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0 && (r[1] & 0x80)) {\n    r = r.slice(1);\n  }\n  if (s[0] === 0 && (s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/ec/signature.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar hash = __webpack_require__(/*! hash.js */ \"./node_modules/hash.js/lib/hash.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar KeyPair = __webpack_require__(/*! ./key */ \"./node_modules/elliptic/lib/elliptic/eddsa/key.js\");\nvar Signature = __webpack_require__(/*! ./signature */ \"./node_modules/elliptic/lib/elliptic/eddsa/signature.js\");\n\nfunction EDDSA(curve) {\n  assert(curve === 'ed25519', 'only tested with ed25519 so far');\n\n  if (!(this instanceof EDDSA))\n    return new EDDSA(curve);\n\n  var curve = elliptic.curves[curve].curve;\n  this.curve = curve;\n  this.g = curve.g;\n  this.g.precompute(curve.n.bitLength() + 1);\n\n  this.pointClass = curve.point().constructor;\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\n  this.hash = hash.sha512;\n}\n\nmodule.exports = EDDSA;\n\n/**\n* @param {Array|String} message - message bytes\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\n* @returns {Signature} - signature\n*/\nEDDSA.prototype.sign = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  var r = this.hashInt(key.messagePrefix(), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)\n               .mul(key.priv());\n  var S = r.add(s_).umod(this.curve.n);\n  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });\n};\n\n/**\n* @param {Array} message - message bytes\n* @param {Array|String|Signature} sig - sig bytes\n* @param {Array|String|Point|KeyPair} pub - public key\n* @returns {Boolean} - true if public key matches sig of message\n*/\nEDDSA.prototype.verify = function verify(message, sig, pub) {\n  message = parseBytes(message);\n  sig = this.makeSignature(sig);\n  var key = this.keyFromPublic(pub);\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n  var SG = this.g.mul(sig.S());\n  var RplusAh = sig.R().add(key.pub().mul(h));\n  return RplusAh.eq(SG);\n};\n\nEDDSA.prototype.hashInt = function hashInt() {\n  var hash = this.hash();\n  for (var i = 0; i < arguments.length; i++)\n    hash.update(arguments[i]);\n  return utils.intFromLE(hash.digest()).umod(this.curve.n);\n};\n\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n  return KeyPair.fromPublic(this, pub);\n};\n\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n  return KeyPair.fromSecret(this, secret);\n};\n\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\n  if (sig instanceof Signature)\n    return sig;\n  return new Signature(this, sig);\n};\n\n/**\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\n*\n* EDDSA defines methods for encoding and decoding points and integers. These are\n* helper convenience methods, that pass along to utility functions implied\n* parameters.\n*\n*/\nEDDSA.prototype.encodePoint = function encodePoint(point) {\n  var enc = point.getY().toArray('le', this.encodingLength);\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n};\n\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\n  bytes = utils.parseBytes(bytes);\n\n  var lastIx = bytes.length - 1;\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n\n  var y = utils.intFromLE(normed);\n  return this.curve.pointFromY(y, xIsOdd);\n};\n\nEDDSA.prototype.encodeInt = function encodeInt(num) {\n  return num.toArray('le', this.encodingLength);\n};\n\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\n  return utils.intFromLE(bytes);\n};\n\nEDDSA.prototype.isPoint = function isPoint(val) {\n  return val instanceof this.pointClass;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/eddsa/index.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!*********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar cachedProperty = utils.cachedProperty;\n\n/**\n* @param {EDDSA} eddsa - instance\n* @param {Object} params - public/private key parameters\n*\n* @param {Array<Byte>} [params.secret] - secret seed bytes\n* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)\n* @param {Array<Byte>} [params.pub] - public key point encoded as bytes\n*\n*/\nfunction KeyPair(eddsa, params) {\n  this.eddsa = eddsa;\n  this._secret = parseBytes(params.secret);\n  if (eddsa.isPoint(params.pub))\n    this._pub = params.pub;\n  else\n    this._pubBytes = parseBytes(params.pub);\n}\n\nKeyPair.fromPublic = function fromPublic(eddsa, pub) {\n  if (pub instanceof KeyPair)\n    return pub;\n  return new KeyPair(eddsa, { pub: pub });\n};\n\nKeyPair.fromSecret = function fromSecret(eddsa, secret) {\n  if (secret instanceof KeyPair)\n    return secret;\n  return new KeyPair(eddsa, { secret: secret });\n};\n\nKeyPair.prototype.secret = function secret() {\n  return this._secret;\n};\n\ncachedProperty(KeyPair, 'pubBytes', function pubBytes() {\n  return this.eddsa.encodePoint(this.pub());\n});\n\ncachedProperty(KeyPair, 'pub', function pub() {\n  if (this._pubBytes)\n    return this.eddsa.decodePoint(this._pubBytes);\n  return this.eddsa.g.mul(this.priv());\n});\n\ncachedProperty(KeyPair, 'privBytes', function privBytes() {\n  var eddsa = this.eddsa;\n  var hash = this.hash();\n  var lastIx = eddsa.encodingLength - 1;\n\n  var a = hash.slice(0, eddsa.encodingLength);\n  a[0] &= 248;\n  a[lastIx] &= 127;\n  a[lastIx] |= 64;\n\n  return a;\n});\n\ncachedProperty(KeyPair, 'priv', function priv() {\n  return this.eddsa.decodeInt(this.privBytes());\n});\n\ncachedProperty(KeyPair, 'hash', function hash() {\n  return this.eddsa.hash().update(this.secret()).digest();\n});\n\ncachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {\n  return this.hash().slice(this.eddsa.encodingLength);\n});\n\nKeyPair.prototype.sign = function sign(message) {\n  assert(this._secret, 'KeyPair can only verify');\n  return this.eddsa.sign(message, this);\n};\n\nKeyPair.prototype.verify = function verify(message, sig) {\n  return this.eddsa.verify(message, sig, this);\n};\n\nKeyPair.prototype.getSecret = function getSecret(enc) {\n  assert(this._secret, 'KeyPair is public only');\n  return utils.encode(this.secret(), enc);\n};\n\nKeyPair.prototype.getPublic = function getPublic(enc) {\n  return utils.encode(this.pubBytes(), enc);\n};\n\nmodule.exports = KeyPair;\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/eddsa/key.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!***************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar elliptic = __webpack_require__(/*! ../../elliptic */ \"./node_modules/elliptic/lib/elliptic.js\");\nvar utils = elliptic.utils;\nvar assert = utils.assert;\nvar cachedProperty = utils.cachedProperty;\nvar parseBytes = utils.parseBytes;\n\n/**\n* @param {EDDSA} eddsa - eddsa instance\n* @param {Array<Bytes>|Object} sig -\n* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes\n* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes\n* @param {Array<Bytes>} [sig.Rencoded] - R point encoded\n* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded\n*/\nfunction Signature(eddsa, sig) {\n  this.eddsa = eddsa;\n\n  if (typeof sig !== 'object')\n    sig = parseBytes(sig);\n\n  if (Array.isArray(sig)) {\n    sig = {\n      R: sig.slice(0, eddsa.encodingLength),\n      S: sig.slice(eddsa.encodingLength)\n    };\n  }\n\n  assert(sig.R && sig.S, 'Signature without R or S');\n\n  if (eddsa.isPoint(sig.R))\n    this._R = sig.R;\n  if (sig.S instanceof BN)\n    this._S = sig.S;\n\n  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;\n  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;\n}\n\ncachedProperty(Signature, 'S', function S() {\n  return this.eddsa.decodeInt(this.Sencoded());\n});\n\ncachedProperty(Signature, 'R', function R() {\n  return this.eddsa.decodePoint(this.Rencoded());\n});\n\ncachedProperty(Signature, 'Rencoded', function Rencoded() {\n  return this.eddsa.encodePoint(this.R());\n});\n\ncachedProperty(Signature, 'Sencoded', function Sencoded() {\n  return this.eddsa.encodeInt(this.S());\n});\n\nSignature.prototype.toBytes = function toBytes() {\n  return this.Rencoded().concat(this.Sencoded());\n};\n\nSignature.prototype.toHex = function toHex() {\n  return utils.encode(this.toBytes(), 'hex').toUpperCase();\n};\n\nmodule.exports = Signature;\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/eddsa/signature.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  doubles: {\n    step: 4,\n    points: [\n      [\n        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',\n        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'\n      ],\n      [\n        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',\n        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'\n      ],\n      [\n        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',\n        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'\n      ],\n      [\n        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',\n        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'\n      ],\n      [\n        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',\n        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'\n      ],\n      [\n        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',\n        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'\n      ],\n      [\n        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',\n        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'\n      ],\n      [\n        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',\n        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'\n      ],\n      [\n        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',\n        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'\n      ],\n      [\n        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',\n        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'\n      ],\n      [\n        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',\n        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'\n      ],\n      [\n        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',\n        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'\n      ],\n      [\n        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',\n        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'\n      ],\n      [\n        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',\n        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'\n      ],\n      [\n        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',\n        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'\n      ],\n      [\n        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',\n        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'\n      ],\n      [\n        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',\n        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'\n      ],\n      [\n        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',\n        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'\n      ],\n      [\n        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',\n        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'\n      ],\n      [\n        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',\n        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'\n      ],\n      [\n        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',\n        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'\n      ],\n      [\n        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',\n        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'\n      ],\n      [\n        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',\n        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'\n      ],\n      [\n        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',\n        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'\n      ],\n      [\n        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',\n        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'\n      ],\n      [\n        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',\n        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'\n      ],\n      [\n        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',\n        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'\n      ],\n      [\n        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',\n        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'\n      ],\n      [\n        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',\n        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'\n      ],\n      [\n        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',\n        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'\n      ],\n      [\n        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',\n        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'\n      ],\n      [\n        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',\n        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'\n      ],\n      [\n        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',\n        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'\n      ],\n      [\n        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',\n        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'\n      ],\n      [\n        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',\n        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'\n      ],\n      [\n        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',\n        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'\n      ],\n      [\n        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',\n        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'\n      ],\n      [\n        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',\n        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'\n      ],\n      [\n        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',\n        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'\n      ],\n      [\n        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',\n        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'\n      ],\n      [\n        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',\n        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'\n      ],\n      [\n        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',\n        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'\n      ],\n      [\n        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',\n        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'\n      ],\n      [\n        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',\n        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'\n      ],\n      [\n        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',\n        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'\n      ],\n      [\n        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',\n        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'\n      ],\n      [\n        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',\n        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'\n      ],\n      [\n        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',\n        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'\n      ],\n      [\n        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',\n        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'\n      ],\n      [\n        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',\n        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'\n      ],\n      [\n        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',\n        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'\n      ],\n      [\n        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',\n        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'\n      ],\n      [\n        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',\n        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'\n      ],\n      [\n        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',\n        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'\n      ],\n      [\n        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',\n        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'\n      ],\n      [\n        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',\n        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'\n      ],\n      [\n        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',\n        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'\n      ],\n      [\n        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',\n        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'\n      ],\n      [\n        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',\n        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'\n      ],\n      [\n        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',\n        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'\n      ],\n      [\n        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',\n        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'\n      ],\n      [\n        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',\n        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'\n      ],\n      [\n        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',\n        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'\n      ],\n      [\n        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',\n        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'\n      ],\n      [\n        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',\n        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'\n      ]\n    ]\n  },\n  naf: {\n    wnd: 7,\n    points: [\n      [\n        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',\n        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'\n      ],\n      [\n        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',\n        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'\n      ],\n      [\n        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',\n        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'\n      ],\n      [\n        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',\n        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'\n      ],\n      [\n        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',\n        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'\n      ],\n      [\n        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',\n        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'\n      ],\n      [\n        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',\n        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'\n      ],\n      [\n        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',\n        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'\n      ],\n      [\n        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',\n        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'\n      ],\n      [\n        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',\n        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'\n      ],\n      [\n        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',\n        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'\n      ],\n      [\n        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',\n        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'\n      ],\n      [\n        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',\n        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'\n      ],\n      [\n        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',\n        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'\n      ],\n      [\n        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',\n        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'\n      ],\n      [\n        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',\n        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'\n      ],\n      [\n        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',\n        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'\n      ],\n      [\n        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',\n        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'\n      ],\n      [\n        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',\n        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'\n      ],\n      [\n        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',\n        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'\n      ],\n      [\n        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',\n        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'\n      ],\n      [\n        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',\n        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'\n      ],\n      [\n        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',\n        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'\n      ],\n      [\n        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',\n        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'\n      ],\n      [\n        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',\n        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'\n      ],\n      [\n        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',\n        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'\n      ],\n      [\n        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',\n        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'\n      ],\n      [\n        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',\n        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'\n      ],\n      [\n        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',\n        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'\n      ],\n      [\n        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',\n        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'\n      ],\n      [\n        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',\n        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'\n      ],\n      [\n        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',\n        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'\n      ],\n      [\n        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',\n        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'\n      ],\n      [\n        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',\n        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'\n      ],\n      [\n        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',\n        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'\n      ],\n      [\n        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',\n        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'\n      ],\n      [\n        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',\n        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'\n      ],\n      [\n        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',\n        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'\n      ],\n      [\n        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',\n        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'\n      ],\n      [\n        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',\n        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'\n      ],\n      [\n        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',\n        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'\n      ],\n      [\n        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',\n        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'\n      ],\n      [\n        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',\n        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'\n      ],\n      [\n        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',\n        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'\n      ],\n      [\n        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',\n        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'\n      ],\n      [\n        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',\n        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'\n      ],\n      [\n        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',\n        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'\n      ],\n      [\n        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',\n        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'\n      ],\n      [\n        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',\n        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'\n      ],\n      [\n        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',\n        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'\n      ],\n      [\n        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',\n        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'\n      ],\n      [\n        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',\n        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'\n      ],\n      [\n        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',\n        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'\n      ],\n      [\n        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',\n        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'\n      ],\n      [\n        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',\n        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'\n      ],\n      [\n        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',\n        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'\n      ],\n      [\n        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',\n        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'\n      ],\n      [\n        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',\n        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'\n      ],\n      [\n        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',\n        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'\n      ],\n      [\n        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',\n        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'\n      ],\n      [\n        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',\n        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'\n      ],\n      [\n        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',\n        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'\n      ],\n      [\n        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',\n        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'\n      ],\n      [\n        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',\n        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'\n      ],\n      [\n        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',\n        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'\n      ],\n      [\n        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',\n        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'\n      ],\n      [\n        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',\n        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'\n      ],\n      [\n        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',\n        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'\n      ],\n      [\n        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',\n        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'\n      ],\n      [\n        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',\n        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'\n      ],\n      [\n        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',\n        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'\n      ],\n      [\n        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',\n        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'\n      ],\n      [\n        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',\n        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'\n      ],\n      [\n        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',\n        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'\n      ],\n      [\n        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',\n        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'\n      ],\n      [\n        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',\n        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'\n      ],\n      [\n        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',\n        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'\n      ],\n      [\n        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',\n        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'\n      ],\n      [\n        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',\n        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'\n      ],\n      [\n        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',\n        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'\n      ],\n      [\n        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',\n        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'\n      ],\n      [\n        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',\n        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'\n      ],\n      [\n        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',\n        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'\n      ],\n      [\n        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',\n        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'\n      ],\n      [\n        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',\n        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'\n      ],\n      [\n        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',\n        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'\n      ],\n      [\n        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',\n        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'\n      ],\n      [\n        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',\n        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'\n      ],\n      [\n        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',\n        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'\n      ],\n      [\n        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',\n        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'\n      ],\n      [\n        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',\n        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'\n      ],\n      [\n        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',\n        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'\n      ],\n      [\n        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',\n        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'\n      ],\n      [\n        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',\n        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'\n      ],\n      [\n        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',\n        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'\n      ],\n      [\n        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',\n        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'\n      ],\n      [\n        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',\n        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'\n      ],\n      [\n        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',\n        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'\n      ],\n      [\n        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',\n        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'\n      ],\n      [\n        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',\n        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'\n      ],\n      [\n        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',\n        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'\n      ],\n      [\n        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',\n        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'\n      ],\n      [\n        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',\n        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'\n      ],\n      [\n        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',\n        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'\n      ],\n      [\n        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',\n        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'\n      ],\n      [\n        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',\n        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'\n      ],\n      [\n        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',\n        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'\n      ],\n      [\n        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',\n        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'\n      ],\n      [\n        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',\n        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'\n      ],\n      [\n        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',\n        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'\n      ],\n      [\n        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',\n        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'\n      ],\n      [\n        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',\n        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'\n      ],\n      [\n        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',\n        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'\n      ],\n      [\n        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',\n        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'\n      ],\n      [\n        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',\n        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'\n      ],\n      [\n        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',\n        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'\n      ],\n      [\n        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',\n        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'\n      ],\n      [\n        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',\n        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'\n      ],\n      [\n        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',\n        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'\n      ],\n      [\n        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',\n        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'\n      ],\n      [\n        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',\n        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'\n      ],\n      [\n        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',\n        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'\n      ],\n      [\n        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',\n        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'\n      ],\n      [\n        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',\n        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'\n      ],\n      [\n        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',\n        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'\n      ],\n      [\n        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',\n        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'\n      ],\n      [\n        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',\n        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'\n      ]\n    ]\n  }\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js?");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = exports;\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar minAssert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ \"./node_modules/minimalistic-crypto-utils/lib/utils.js\");\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w) {\n  var naf = [];\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n  while (k.cmpn(1) >= 0) {\n    var z;\n    if (k.isOdd()) {\n      var mod = k.andln(ws - 1);\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n    naf.push(z);\n\n    // Optimization, shift by word if possible\n    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;\n    for (var i = 1; i < shift; i++)\n      naf.push(0);\n    k.iushrn(shift);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    []\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      var m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      var m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n           this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n                                     bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/lib/elliptic/utils.js?");

/***/ }),

/***/ "./node_modules/elliptic/package.json":
/*!********************************************!*\
  !*** ./node_modules/elliptic/package.json ***!
  \********************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, files, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = {\"_from\":\"elliptic@^6.0.0\",\"_id\":\"elliptic@6.4.1\",\"_inBundle\":false,\"_integrity\":\"sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==\",\"_location\":\"/elliptic\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"range\",\"registry\":true,\"raw\":\"elliptic@^6.0.0\",\"name\":\"elliptic\",\"escapedName\":\"elliptic\",\"rawSpec\":\"^6.0.0\",\"saveSpec\":null,\"fetchSpec\":\"^6.0.0\"},\"_requiredBy\":[\"/browserify-sign\",\"/create-ecdh\"],\"_resolved\":\"https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz\",\"_shasum\":\"c2d0b7776911b86722c632c3c06c60f2f819939a\",\"_spec\":\"elliptic@^6.0.0\",\"_where\":\"/home/james/Code/ar.ts/node_modules/browserify-sign\",\"author\":{\"name\":\"Fedor Indutny\",\"email\":\"fedor@indutny.com\"},\"bugs\":{\"url\":\"https://github.com/indutny/elliptic/issues\"},\"bundleDependencies\":false,\"dependencies\":{\"bn.js\":\"^4.4.0\",\"brorand\":\"^1.0.1\",\"hash.js\":\"^1.0.0\",\"hmac-drbg\":\"^1.0.0\",\"inherits\":\"^2.0.1\",\"minimalistic-assert\":\"^1.0.0\",\"minimalistic-crypto-utils\":\"^1.0.0\"},\"deprecated\":false,\"description\":\"EC cryptography\",\"devDependencies\":{\"brfs\":\"^1.4.3\",\"coveralls\":\"^2.11.3\",\"grunt\":\"^0.4.5\",\"grunt-browserify\":\"^5.0.0\",\"grunt-cli\":\"^1.2.0\",\"grunt-contrib-connect\":\"^1.0.0\",\"grunt-contrib-copy\":\"^1.0.0\",\"grunt-contrib-uglify\":\"^1.0.1\",\"grunt-mocha-istanbul\":\"^3.0.1\",\"grunt-saucelabs\":\"^8.6.2\",\"istanbul\":\"^0.4.2\",\"jscs\":\"^2.9.0\",\"jshint\":\"^2.6.0\",\"mocha\":\"^2.1.0\"},\"files\":[\"lib\"],\"homepage\":\"https://github.com/indutny/elliptic\",\"keywords\":[\"EC\",\"Elliptic\",\"curve\",\"Cryptography\"],\"license\":\"MIT\",\"main\":\"lib/elliptic.js\",\"name\":\"elliptic\",\"repository\":{\"type\":\"git\",\"url\":\"git+ssh://git@github.com/indutny/elliptic.git\"},\"scripts\":{\"jscs\":\"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\"jshint\":\"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\"lint\":\"npm run jscs && npm run jshint\",\"test\":\"npm run lint && npm run unit\",\"unit\":\"istanbul test _mocha --reporter=spec test/index.js\",\"version\":\"grunt dist && git add dist/\"},\"version\":\"6.4.1\"};\n\n//# sourceURL=webpack://THREEAR/./node_modules/elliptic/package.json?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/evp_bytestokey/index.js":
/*!**********************************************!*\
  !*** ./node_modules/evp_bytestokey/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar MD5 = __webpack_require__(/*! md5.js */ \"./node_modules/md5.js/index.js\")\n\n/* eslint-disable camelcase */\nfunction EVP_BytesToKey (password, salt, keyBits, ivLen) {\n  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')\n  if (salt) {\n    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')\n    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')\n  }\n\n  var keyLen = keyBits / 8\n  var key = Buffer.alloc(keyLen)\n  var iv = Buffer.alloc(ivLen || 0)\n  var tmp = Buffer.alloc(0)\n\n  while (keyLen > 0 || ivLen > 0) {\n    var hash = new MD5()\n    hash.update(tmp)\n    hash.update(password)\n    if (salt) hash.update(salt)\n    tmp = hash.digest()\n\n    var used = 0\n\n    if (keyLen > 0) {\n      var keyStart = key.length - keyLen\n      used = Math.min(keyLen, tmp.length)\n      tmp.copy(key, keyStart, 0, used)\n      keyLen -= used\n    }\n\n    if (used < tmp.length && ivLen > 0) {\n      var ivStart = iv.length - ivLen\n      var length = Math.min(ivLen, tmp.length - used)\n      tmp.copy(iv, ivStart, used, used + length)\n      ivLen -= length\n    }\n  }\n\n  tmp.fill(0)\n  return { key: key, iv: iv }\n}\n\nmodule.exports = EVP_BytesToKey\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/evp_bytestokey/index.js?");

/***/ }),

/***/ "./node_modules/hash-base/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar Transform = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\").Transform\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction throwIfNotStringOrBuffer (val, prefix) {\n  if (!Buffer.isBuffer(val) && typeof val !== 'string') {\n    throw new TypeError(prefix + ' must be a string or a buffer')\n  }\n}\n\nfunction HashBase (blockSize) {\n  Transform.call(this)\n\n  this._block = Buffer.allocUnsafe(blockSize)\n  this._blockSize = blockSize\n  this._blockOffset = 0\n  this._length = [0, 0, 0, 0]\n\n  this._finalized = false\n}\n\ninherits(HashBase, Transform)\n\nHashBase.prototype._transform = function (chunk, encoding, callback) {\n  var error = null\n  try {\n    this.update(chunk, encoding)\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype._flush = function (callback) {\n  var error = null\n  try {\n    this.push(this.digest())\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype.update = function (data, encoding) {\n  throwIfNotStringOrBuffer(data, 'Data')\n  if (this._finalized) throw new Error('Digest already called')\n  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n  // consume data\n  var block = this._block\n  var offset = 0\n  while (this._blockOffset + data.length - offset >= this._blockSize) {\n    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]\n    this._update()\n    this._blockOffset = 0\n  }\n  while (offset < data.length) block[this._blockOffset++] = data[offset++]\n\n  // update length\n  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {\n    this._length[j] += carry\n    carry = (this._length[j] / 0x0100000000) | 0\n    if (carry > 0) this._length[j] -= 0x0100000000 * carry\n  }\n\n  return this\n}\n\nHashBase.prototype._update = function () {\n  throw new Error('_update is not implemented')\n}\n\nHashBase.prototype.digest = function (encoding) {\n  if (this._finalized) throw new Error('Digest already called')\n  this._finalized = true\n\n  var digest = this._digest()\n  if (encoding !== undefined) digest = digest.toString(encoding)\n\n  // reset state\n  this._block.fill(0)\n  this._blockOffset = 0\n  for (var i = 0; i < 4; ++i) this._length[i] = 0\n\n  return digest\n}\n\nHashBase.prototype._digest = function () {\n  throw new Error('_digest is not implemented')\n}\n\nmodule.exports = HashBase\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash-base/index.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var hash = exports;\n\nhash.utils = __webpack_require__(/*! ./hash/utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nhash.common = __webpack_require__(/*! ./hash/common */ \"./node_modules/hash.js/lib/hash/common.js\");\nhash.sha = __webpack_require__(/*! ./hash/sha */ \"./node_modules/hash.js/lib/hash/sha.js\");\nhash.ripemd = __webpack_require__(/*! ./hash/ripemd */ \"./node_modules/hash.js/lib/hash/ripemd.js\");\nhash.hmac = __webpack_require__(/*! ./hash/hmac */ \"./node_modules/hash.js/lib/hash/hmac.js\");\n\n// Proxy hash functions to the main object\nhash.sha1 = hash.sha.sha1;\nhash.sha256 = hash.sha.sha256;\nhash.sha224 = hash.sha.sha224;\nhash.sha384 = hash.sha.sha384;\nhash.sha512 = hash.sha.sha512;\nhash.ripemd160 = hash.ripemd.ripemd160;\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction BlockHash() {\n  this.pending = null;\n  this.pendingTotal = 0;\n  this.blockSize = this.constructor.blockSize;\n  this.outSize = this.constructor.outSize;\n  this.hmacStrength = this.constructor.hmacStrength;\n  this.padLength = this.constructor.padLength / 8;\n  this.endian = 'big';\n\n  this._delta8 = this.blockSize / 8;\n  this._delta32 = this.blockSize / 32;\n}\nexports.BlockHash = BlockHash;\n\nBlockHash.prototype.update = function update(msg, enc) {\n  // Convert message to array, pad it, and join into 32bit blocks\n  msg = utils.toArray(msg, enc);\n  if (!this.pending)\n    this.pending = msg;\n  else\n    this.pending = this.pending.concat(msg);\n  this.pendingTotal += msg.length;\n\n  // Enough data, try updating\n  if (this.pending.length >= this._delta8) {\n    msg = this.pending;\n\n    // Process pending data in blocks\n    var r = msg.length % this._delta8;\n    this.pending = msg.slice(msg.length - r, msg.length);\n    if (this.pending.length === 0)\n      this.pending = null;\n\n    msg = utils.join32(msg, 0, msg.length - r, this.endian);\n    for (var i = 0; i < msg.length; i += this._delta32)\n      this._update(msg, i, i + this._delta32);\n  }\n\n  return this;\n};\n\nBlockHash.prototype.digest = function digest(enc) {\n  this.update(this._pad());\n  assert(this.pending === null);\n\n  return this._digest(enc);\n};\n\nBlockHash.prototype._pad = function pad() {\n  var len = this.pendingTotal;\n  var bytes = this._delta8;\n  var k = bytes - ((len + this.padLength) % bytes);\n  var res = new Array(k + this.padLength);\n  res[0] = 0x80;\n  for (var i = 1; i < k; i++)\n    res[i] = 0;\n\n  // Append length\n  len <<= 3;\n  if (this.endian === 'big') {\n    for (var t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = len & 0xff;\n  } else {\n    res[i++] = len & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n\n    for (t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n  }\n\n  return res;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/common.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction Hmac(hash, key, enc) {\n  if (!(this instanceof Hmac))\n    return new Hmac(hash, key, enc);\n  this.Hash = hash;\n  this.blockSize = hash.blockSize / 8;\n  this.outSize = hash.outSize / 8;\n  this.inner = null;\n  this.outer = null;\n\n  this._init(utils.toArray(key, enc));\n}\nmodule.exports = Hmac;\n\nHmac.prototype._init = function init(key) {\n  // Shorten key, if needed\n  if (key.length > this.blockSize)\n    key = new this.Hash().update(key).digest();\n  assert(key.length <= this.blockSize);\n\n  // Add padding to key\n  for (var i = key.length; i < this.blockSize; i++)\n    key.push(0);\n\n  for (i = 0; i < key.length; i++)\n    key[i] ^= 0x36;\n  this.inner = new this.Hash().update(key);\n\n  // 0x36 ^ 0x5c = 0x6a\n  for (i = 0; i < key.length; i++)\n    key[i] ^= 0x6a;\n  this.outer = new this.Hash().update(key);\n};\n\nHmac.prototype.update = function update(msg, enc) {\n  this.inner.update(msg, enc);\n  return this;\n};\n\nHmac.prototype.digest = function digest(enc) {\n  this.outer.update(this.inner.digest());\n  return this.outer.digest(enc);\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/hmac.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/common.js\");\n\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_3 = utils.sum32_3;\nvar sum32_4 = utils.sum32_4;\nvar BlockHash = common.BlockHash;\n\nfunction RIPEMD160() {\n  if (!(this instanceof RIPEMD160))\n    return new RIPEMD160();\n\n  BlockHash.call(this);\n\n  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];\n  this.endian = 'little';\n}\nutils.inherits(RIPEMD160, BlockHash);\nexports.ripemd160 = RIPEMD160;\n\nRIPEMD160.blockSize = 512;\nRIPEMD160.outSize = 160;\nRIPEMD160.hmacStrength = 192;\nRIPEMD160.padLength = 64;\n\nRIPEMD160.prototype._update = function update(msg, start) {\n  var A = this.h[0];\n  var B = this.h[1];\n  var C = this.h[2];\n  var D = this.h[3];\n  var E = this.h[4];\n  var Ah = A;\n  var Bh = B;\n  var Ch = C;\n  var Dh = D;\n  var Eh = E;\n  for (var j = 0; j < 80; j++) {\n    var T = sum32(\n      rotl32(\n        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),\n        s[j]),\n      E);\n    A = E;\n    E = D;\n    D = rotl32(C, 10);\n    C = B;\n    B = T;\n    T = sum32(\n      rotl32(\n        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\n        sh[j]),\n      Eh);\n    Ah = Eh;\n    Eh = Dh;\n    Dh = rotl32(Ch, 10);\n    Ch = Bh;\n    Bh = T;\n  }\n  T = sum32_3(this.h[1], C, Dh);\n  this.h[1] = sum32_3(this.h[2], D, Eh);\n  this.h[2] = sum32_3(this.h[3], E, Ah);\n  this.h[3] = sum32_3(this.h[4], A, Bh);\n  this.h[4] = sum32_3(this.h[0], B, Ch);\n  this.h[0] = T;\n};\n\nRIPEMD160.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'little');\n  else\n    return utils.split32(this.h, 'little');\n};\n\nfunction f(j, x, y, z) {\n  if (j <= 15)\n    return x ^ y ^ z;\n  else if (j <= 31)\n    return (x & y) | ((~x) & z);\n  else if (j <= 47)\n    return (x | (~y)) ^ z;\n  else if (j <= 63)\n    return (x & z) | (y & (~z));\n  else\n    return x ^ (y | (~z));\n}\n\nfunction K(j) {\n  if (j <= 15)\n    return 0x00000000;\n  else if (j <= 31)\n    return 0x5a827999;\n  else if (j <= 47)\n    return 0x6ed9eba1;\n  else if (j <= 63)\n    return 0x8f1bbcdc;\n  else\n    return 0xa953fd4e;\n}\n\nfunction Kh(j) {\n  if (j <= 15)\n    return 0x50a28be6;\n  else if (j <= 31)\n    return 0x5c4dd124;\n  else if (j <= 47)\n    return 0x6d703ef3;\n  else if (j <= 63)\n    return 0x7a6d76e9;\n  else\n    return 0x00000000;\n}\n\nvar r = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n];\n\nvar rh = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n];\n\nvar s = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n];\n\nvar sh = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n];\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/ripemd.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.sha1 = __webpack_require__(/*! ./sha/1 */ \"./node_modules/hash.js/lib/hash/sha/1.js\");\nexports.sha224 = __webpack_require__(/*! ./sha/224 */ \"./node_modules/hash.js/lib/hash/sha/224.js\");\nexports.sha256 = __webpack_require__(/*! ./sha/256 */ \"./node_modules/hash.js/lib/hash/sha/256.js\");\nexports.sha384 = __webpack_require__(/*! ./sha/384 */ \"./node_modules/hash.js/lib/hash/sha/384.js\");\nexports.sha512 = __webpack_require__(/*! ./sha/512 */ \"./node_modules/hash.js/lib/hash/sha/512.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/sha.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar shaCommon = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/sha/common.js\");\n\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_5 = utils.sum32_5;\nvar ft_1 = shaCommon.ft_1;\nvar BlockHash = common.BlockHash;\n\nvar sha1_K = [\n  0x5A827999, 0x6ED9EBA1,\n  0x8F1BBCDC, 0xCA62C1D6\n];\n\nfunction SHA1() {\n  if (!(this instanceof SHA1))\n    return new SHA1();\n\n  BlockHash.call(this);\n  this.h = [\n    0x67452301, 0xefcdab89, 0x98badcfe,\n    0x10325476, 0xc3d2e1f0 ];\n  this.W = new Array(80);\n}\n\nutils.inherits(SHA1, BlockHash);\nmodule.exports = SHA1;\n\nSHA1.blockSize = 512;\nSHA1.outSize = 160;\nSHA1.hmacStrength = 80;\nSHA1.padLength = 64;\n\nSHA1.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n\n  for(; i < W.length; i++)\n    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n\n  for (i = 0; i < W.length; i++) {\n    var s = ~~(i / 20);\n    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n    e = d;\n    d = c;\n    c = rotl32(b, 30);\n    b = a;\n    a = t;\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n};\n\nSHA1.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/sha/1.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar SHA256 = __webpack_require__(/*! ./256 */ \"./node_modules/hash.js/lib/hash/sha/256.js\");\n\nfunction SHA224() {\n  if (!(this instanceof SHA224))\n    return new SHA224();\n\n  SHA256.call(this);\n  this.h = [\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];\n}\nutils.inherits(SHA224, SHA256);\nmodule.exports = SHA224;\n\nSHA224.blockSize = 512;\nSHA224.outSize = 224;\nSHA224.hmacStrength = 192;\nSHA224.padLength = 64;\n\nSHA224.prototype._digest = function digest(enc) {\n  // Just truncate output\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 7), 'big');\n  else\n    return utils.split32(this.h.slice(0, 7), 'big');\n};\n\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/sha/224.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar shaCommon = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/sha/common.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nvar sum32 = utils.sum32;\nvar sum32_4 = utils.sum32_4;\nvar sum32_5 = utils.sum32_5;\nvar ch32 = shaCommon.ch32;\nvar maj32 = shaCommon.maj32;\nvar s0_256 = shaCommon.s0_256;\nvar s1_256 = shaCommon.s1_256;\nvar g0_256 = shaCommon.g0_256;\nvar g1_256 = shaCommon.g1_256;\n\nvar BlockHash = common.BlockHash;\n\nvar sha256_K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\nfunction SHA256() {\n  if (!(this instanceof SHA256))\n    return new SHA256();\n\n  BlockHash.call(this);\n  this.h = [\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n  ];\n  this.k = sha256_K;\n  this.W = new Array(64);\n}\nutils.inherits(SHA256, BlockHash);\nmodule.exports = SHA256;\n\nSHA256.blockSize = 512;\nSHA256.outSize = 256;\nSHA256.hmacStrength = 192;\nSHA256.padLength = 64;\n\nSHA256.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i++)\n    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n  var f = this.h[5];\n  var g = this.h[6];\n  var h = this.h[7];\n\n  assert(this.k.length === W.length);\n  for (i = 0; i < W.length; i++) {\n    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);\n    var T2 = sum32(s0_256(a), maj32(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = sum32(d, T1);\n    d = c;\n    c = b;\n    b = a;\n    a = sum32(T1, T2);\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n  this.h[5] = sum32(this.h[5], f);\n  this.h[6] = sum32(this.h[6], g);\n  this.h[7] = sum32(this.h[7], h);\n};\n\nSHA256.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/sha/256.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\n\nvar SHA512 = __webpack_require__(/*! ./512 */ \"./node_modules/hash.js/lib/hash/sha/512.js\");\n\nfunction SHA384() {\n  if (!(this instanceof SHA384))\n    return new SHA384();\n\n  SHA512.call(this);\n  this.h = [\n    0xcbbb9d5d, 0xc1059ed8,\n    0x629a292a, 0x367cd507,\n    0x9159015a, 0x3070dd17,\n    0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31,\n    0x8eb44a87, 0x68581511,\n    0xdb0c2e0d, 0x64f98fa7,\n    0x47b5481d, 0xbefa4fa4 ];\n}\nutils.inherits(SHA384, SHA512);\nmodule.exports = SHA384;\n\nSHA384.blockSize = 1024;\nSHA384.outSize = 384;\nSHA384.hmacStrength = 192;\nSHA384.padLength = 128;\n\nSHA384.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 12), 'big');\n  else\n    return utils.split32(this.h.slice(0, 12), 'big');\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/sha/384.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nvar rotr64_hi = utils.rotr64_hi;\nvar rotr64_lo = utils.rotr64_lo;\nvar shr64_hi = utils.shr64_hi;\nvar shr64_lo = utils.shr64_lo;\nvar sum64 = utils.sum64;\nvar sum64_hi = utils.sum64_hi;\nvar sum64_lo = utils.sum64_lo;\nvar sum64_4_hi = utils.sum64_4_hi;\nvar sum64_4_lo = utils.sum64_4_lo;\nvar sum64_5_hi = utils.sum64_5_hi;\nvar sum64_5_lo = utils.sum64_5_lo;\n\nvar BlockHash = common.BlockHash;\n\nvar sha512_K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction SHA512() {\n  if (!(this instanceof SHA512))\n    return new SHA512();\n\n  BlockHash.call(this);\n  this.h = [\n    0x6a09e667, 0xf3bcc908,\n    0xbb67ae85, 0x84caa73b,\n    0x3c6ef372, 0xfe94f82b,\n    0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1,\n    0x9b05688c, 0x2b3e6c1f,\n    0x1f83d9ab, 0xfb41bd6b,\n    0x5be0cd19, 0x137e2179 ];\n  this.k = sha512_K;\n  this.W = new Array(160);\n}\nutils.inherits(SHA512, BlockHash);\nmodule.exports = SHA512;\n\nSHA512.blockSize = 1024;\nSHA512.outSize = 512;\nSHA512.hmacStrength = 192;\nSHA512.padLength = 128;\n\nSHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n  var W = this.W;\n\n  // 32 x 32bit words\n  for (var i = 0; i < 32; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i += 2) {\n    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2\n    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n    var c1_hi = W[i - 14];  // i - 7\n    var c1_lo = W[i - 13];\n    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15\n    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n    var c3_hi = W[i - 32];  // i - 16\n    var c3_lo = W[i - 31];\n\n    W[i] = sum64_4_hi(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo);\n    W[i + 1] = sum64_4_lo(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo);\n  }\n};\n\nSHA512.prototype._update = function _update(msg, start) {\n  this._prepareBlock(msg, start);\n\n  var W = this.W;\n\n  var ah = this.h[0];\n  var al = this.h[1];\n  var bh = this.h[2];\n  var bl = this.h[3];\n  var ch = this.h[4];\n  var cl = this.h[5];\n  var dh = this.h[6];\n  var dl = this.h[7];\n  var eh = this.h[8];\n  var el = this.h[9];\n  var fh = this.h[10];\n  var fl = this.h[11];\n  var gh = this.h[12];\n  var gl = this.h[13];\n  var hh = this.h[14];\n  var hl = this.h[15];\n\n  assert(this.k.length === W.length);\n  for (var i = 0; i < W.length; i += 2) {\n    var c0_hi = hh;\n    var c0_lo = hl;\n    var c1_hi = s1_512_hi(eh, el);\n    var c1_lo = s1_512_lo(eh, el);\n    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n    var c3_hi = this.k[i];\n    var c3_lo = this.k[i + 1];\n    var c4_hi = W[i];\n    var c4_lo = W[i + 1];\n\n    var T1_hi = sum64_5_hi(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo,\n      c4_hi, c4_lo);\n    var T1_lo = sum64_5_lo(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo,\n      c4_hi, c4_lo);\n\n    c0_hi = s0_512_hi(ah, al);\n    c0_lo = s0_512_lo(ah, al);\n    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n\n    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);\n    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n\n    hh = gh;\n    hl = gl;\n\n    gh = fh;\n    gl = fl;\n\n    fh = eh;\n    fl = el;\n\n    eh = sum64_hi(dh, dl, T1_hi, T1_lo);\n    el = sum64_lo(dl, dl, T1_hi, T1_lo);\n\n    dh = ch;\n    dl = cl;\n\n    ch = bh;\n    cl = bl;\n\n    bh = ah;\n    bl = al;\n\n    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);\n    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n  }\n\n  sum64(this.h, 0, ah, al);\n  sum64(this.h, 2, bh, bl);\n  sum64(this.h, 4, ch, cl);\n  sum64(this.h, 6, dh, dl);\n  sum64(this.h, 8, eh, el);\n  sum64(this.h, 10, fh, fl);\n  sum64(this.h, 12, gh, gl);\n  sum64(this.h, 14, hh, hl);\n};\n\nSHA512.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\nfunction ch64_hi(xh, xl, yh, yl, zh) {\n  var r = (xh & yh) ^ ((~xh) & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ ((~xl) & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_hi(xh, xl, yh, yl, zh) {\n  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 28);\n  var c1_hi = rotr64_hi(xl, xh, 2);  // 34\n  var c2_hi = rotr64_hi(xl, xh, 7);  // 39\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 28);\n  var c1_lo = rotr64_lo(xl, xh, 2);  // 34\n  var c2_lo = rotr64_lo(xl, xh, 7);  // 39\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 14);\n  var c1_hi = rotr64_hi(xh, xl, 18);\n  var c2_hi = rotr64_hi(xl, xh, 9);  // 41\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 14);\n  var c1_lo = rotr64_lo(xh, xl, 18);\n  var c2_lo = rotr64_lo(xl, xh, 9);  // 41\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 1);\n  var c1_hi = rotr64_hi(xh, xl, 8);\n  var c2_hi = shr64_hi(xh, xl, 7);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 1);\n  var c1_lo = rotr64_lo(xh, xl, 8);\n  var c2_lo = shr64_lo(xh, xl, 7);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 19);\n  var c1_hi = rotr64_hi(xl, xh, 29);  // 61\n  var c2_hi = shr64_hi(xh, xl, 6);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 19);\n  var c1_lo = rotr64_lo(xl, xh, 29);  // 61\n  var c2_lo = shr64_lo(xh, xl, 6);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/sha/512.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar rotr32 = utils.rotr32;\n\nfunction ft_1(s, x, y, z) {\n  if (s === 0)\n    return ch32(x, y, z);\n  if (s === 1 || s === 3)\n    return p32(x, y, z);\n  if (s === 2)\n    return maj32(x, y, z);\n}\nexports.ft_1 = ft_1;\n\nfunction ch32(x, y, z) {\n  return (x & y) ^ ((~x) & z);\n}\nexports.ch32 = ch32;\n\nfunction maj32(x, y, z) {\n  return (x & y) ^ (x & z) ^ (y & z);\n}\nexports.maj32 = maj32;\n\nfunction p32(x, y, z) {\n  return x ^ y ^ z;\n}\nexports.p32 = p32;\n\nfunction s0_256(x) {\n  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n}\nexports.s0_256 = s0_256;\n\nfunction s1_256(x) {\n  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n}\nexports.s1_256 = s1_256;\n\nfunction g0_256(x) {\n  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);\n}\nexports.g0_256 = g0_256;\n\nfunction g1_256(x) {\n  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);\n}\nexports.g1_256 = g1_256;\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/sha/common.js?");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/utils.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports.inherits = inherits;\n\nfunction isSurrogatePair(msg, i) {\n  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {\n    return false;\n  }\n  if (i < 0 || i + 1 >= msg.length) {\n    return false;\n  }\n  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;\n}\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg === 'string') {\n    if (!enc) {\n      // Inspired by stringToUtf8ByteArray() in closure-library by Google\n      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n      // Apache License 2.0\n      // https://github.com/google/closure-library/blob/master/LICENSE\n      var p = 0;\n      for (var i = 0; i < msg.length; i++) {\n        var c = msg.charCodeAt(i);\n        if (c < 128) {\n          res[p++] = c;\n        } else if (c < 2048) {\n          res[p++] = (c >> 6) | 192;\n          res[p++] = (c & 63) | 128;\n        } else if (isSurrogatePair(msg, i)) {\n          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);\n          res[p++] = (c >> 18) | 240;\n          res[p++] = ((c >> 12) & 63) | 128;\n          res[p++] = ((c >> 6) & 63) | 128;\n          res[p++] = (c & 63) | 128;\n        } else {\n          res[p++] = (c >> 12) | 224;\n          res[p++] = ((c >> 6) & 63) | 128;\n          res[p++] = (c & 63) | 128;\n        }\n      }\n    } else if (enc === 'hex') {\n      msg = msg.replace(/[^a-z0-9]+/ig, '');\n      if (msg.length % 2 !== 0)\n        msg = '0' + msg;\n      for (i = 0; i < msg.length; i += 2)\n        res.push(parseInt(msg[i] + msg[i + 1], 16));\n    }\n  } else {\n    for (i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n  }\n  return res;\n}\nexports.toArray = toArray;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nexports.toHex = toHex;\n\nfunction htonl(w) {\n  var res = (w >>> 24) |\n            ((w >>> 8) & 0xff00) |\n            ((w << 8) & 0xff0000) |\n            ((w & 0xff) << 24);\n  return res >>> 0;\n}\nexports.htonl = htonl;\n\nfunction toHex32(msg, endian) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++) {\n    var w = msg[i];\n    if (endian === 'little')\n      w = htonl(w);\n    res += zero8(w.toString(16));\n  }\n  return res;\n}\nexports.toHex32 = toHex32;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nexports.zero2 = zero2;\n\nfunction zero8(word) {\n  if (word.length === 7)\n    return '0' + word;\n  else if (word.length === 6)\n    return '00' + word;\n  else if (word.length === 5)\n    return '000' + word;\n  else if (word.length === 4)\n    return '0000' + word;\n  else if (word.length === 3)\n    return '00000' + word;\n  else if (word.length === 2)\n    return '000000' + word;\n  else if (word.length === 1)\n    return '0000000' + word;\n  else\n    return word;\n}\nexports.zero8 = zero8;\n\nfunction join32(msg, start, end, endian) {\n  var len = end - start;\n  assert(len % 4 === 0);\n  var res = new Array(len / 4);\n  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n    var w;\n    if (endian === 'big')\n      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n    else\n      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n    res[i] = w >>> 0;\n  }\n  return res;\n}\nexports.join32 = join32;\n\nfunction split32(msg, endian) {\n  var res = new Array(msg.length * 4);\n  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n    var m = msg[i];\n    if (endian === 'big') {\n      res[k] = m >>> 24;\n      res[k + 1] = (m >>> 16) & 0xff;\n      res[k + 2] = (m >>> 8) & 0xff;\n      res[k + 3] = m & 0xff;\n    } else {\n      res[k + 3] = m >>> 24;\n      res[k + 2] = (m >>> 16) & 0xff;\n      res[k + 1] = (m >>> 8) & 0xff;\n      res[k] = m & 0xff;\n    }\n  }\n  return res;\n}\nexports.split32 = split32;\n\nfunction rotr32(w, b) {\n  return (w >>> b) | (w << (32 - b));\n}\nexports.rotr32 = rotr32;\n\nfunction rotl32(w, b) {\n  return (w << b) | (w >>> (32 - b));\n}\nexports.rotl32 = rotl32;\n\nfunction sum32(a, b) {\n  return (a + b) >>> 0;\n}\nexports.sum32 = sum32;\n\nfunction sum32_3(a, b, c) {\n  return (a + b + c) >>> 0;\n}\nexports.sum32_3 = sum32_3;\n\nfunction sum32_4(a, b, c, d) {\n  return (a + b + c + d) >>> 0;\n}\nexports.sum32_4 = sum32_4;\n\nfunction sum32_5(a, b, c, d, e) {\n  return (a + b + c + d + e) >>> 0;\n}\nexports.sum32_5 = sum32_5;\n\nfunction sum64(buf, pos, ah, al) {\n  var bh = buf[pos];\n  var bl = buf[pos + 1];\n\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  buf[pos] = hi >>> 0;\n  buf[pos + 1] = lo;\n}\nexports.sum64 = sum64;\n\nfunction sum64_hi(ah, al, bh, bl) {\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  return hi >>> 0;\n}\nexports.sum64_hi = sum64_hi;\n\nfunction sum64_lo(ah, al, bh, bl) {\n  var lo = al + bl;\n  return lo >>> 0;\n}\nexports.sum64_lo = sum64_lo;\n\nfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + carry;\n  return hi >>> 0;\n}\nexports.sum64_4_hi = sum64_4_hi;\n\nfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n  var lo = al + bl + cl + dl;\n  return lo >>> 0;\n}\nexports.sum64_4_lo = sum64_4_lo;\n\nfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n  lo = (lo + el) >>> 0;\n  carry += lo < el ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + eh + carry;\n  return hi >>> 0;\n}\nexports.sum64_5_hi = sum64_5_hi;\n\nfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var lo = al + bl + cl + dl + el;\n\n  return lo >>> 0;\n}\nexports.sum64_5_lo = sum64_5_lo;\n\nfunction rotr64_hi(ah, al, num) {\n  var r = (al << (32 - num)) | (ah >>> num);\n  return r >>> 0;\n}\nexports.rotr64_hi = rotr64_hi;\n\nfunction rotr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n}\nexports.rotr64_lo = rotr64_lo;\n\nfunction shr64_hi(ah, al, num) {\n  return ah >>> num;\n}\nexports.shr64_hi = shr64_hi;\n\nfunction shr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n}\nexports.shr64_lo = shr64_lo;\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hash.js/lib/hash/utils.js?");

/***/ }),

/***/ "./node_modules/hmac-drbg/lib/hmac-drbg.js":
/*!*************************************************!*\
  !*** ./node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar hash = __webpack_require__(/*! hash.js */ \"./node_modules/hash.js/lib/hash.js\");\nvar utils = __webpack_require__(/*! minimalistic-crypto-utils */ \"./node_modules/minimalistic-crypto-utils/lib/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/hmac-drbg/lib/hmac-drbg.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n//# sourceURL=webpack://THREEAR/./node_modules/indexof/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/md5.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/md5.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar HashBase = __webpack_require__(/*! hash-base */ \"./node_modules/hash-base/index.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar ARRAY16 = new Array(16)\n\nfunction MD5 () {\n  HashBase.call(this, 64)\n\n  // state\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n}\n\ninherits(MD5, HashBase)\n\nMD5.prototype._update = function () {\n  var M = ARRAY16\n  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)\n\n  var a = this._a\n  var b = this._b\n  var c = this._c\n  var d = this._d\n\n  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)\n  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)\n  c = fnF(c, d, a, b, M[2], 0x242070db, 17)\n  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)\n  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)\n  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)\n  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)\n  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)\n  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)\n  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)\n  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)\n  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)\n  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)\n  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)\n  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)\n  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)\n\n  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)\n  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)\n  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)\n  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)\n  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)\n  d = fnG(d, a, b, c, M[10], 0x02441453, 9)\n  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)\n  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)\n  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)\n  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)\n  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)\n  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)\n  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)\n  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)\n  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)\n  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)\n\n  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)\n  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)\n  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)\n  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)\n  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)\n  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)\n  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)\n  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)\n  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)\n  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)\n  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)\n  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)\n  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)\n  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)\n  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)\n  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)\n\n  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)\n  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)\n  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)\n  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)\n  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)\n  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)\n  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)\n  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)\n  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)\n  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)\n  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)\n  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)\n  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)\n  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)\n  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)\n  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)\n\n  this._a = (this._a + a) | 0\n  this._b = (this._b + b) | 0\n  this._c = (this._c + c) | 0\n  this._d = (this._d + d) | 0\n}\n\nMD5.prototype._digest = function () {\n  // create padding and handle blocks\n  this._block[this._blockOffset++] = 0x80\n  if (this._blockOffset > 56) {\n    this._block.fill(0, this._blockOffset, 64)\n    this._update()\n    this._blockOffset = 0\n  }\n\n  this._block.fill(0, this._blockOffset, 56)\n  this._block.writeUInt32LE(this._length[0], 56)\n  this._block.writeUInt32LE(this._length[1], 60)\n  this._update()\n\n  // produce result\n  var buffer = Buffer.allocUnsafe(16)\n  buffer.writeInt32LE(this._a, 0)\n  buffer.writeInt32LE(this._b, 4)\n  buffer.writeInt32LE(this._c, 8)\n  buffer.writeInt32LE(this._d, 12)\n  return buffer\n}\n\nfunction rotl (x, n) {\n  return (x << n) | (x >>> (32 - n))\n}\n\nfunction fnF (a, b, c, d, m, k, s) {\n  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0\n}\n\nfunction fnG (a, b, c, d, m, k, s) {\n  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0\n}\n\nfunction fnH (a, b, c, d, m, k, s) {\n  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0\n}\n\nfunction fnI (a, b, c, d, m, k, s) {\n  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0\n}\n\nmodule.exports = MD5\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/md5.js/index.js?");

/***/ }),

/***/ "./node_modules/miller-rabin/lib/mr.js":
/*!*********************************************!*\
  !*** ./node_modules/miller-rabin/lib/mr.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var bn = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\nvar brorand = __webpack_require__(/*! brorand */ \"./node_modules/brorand/index.js\");\n\nfunction MillerRabin(rand) {\n  this.rand = rand || new brorand.Rand();\n}\nmodule.exports = MillerRabin;\n\nMillerRabin.create = function create(rand) {\n  return new MillerRabin(rand);\n};\n\nMillerRabin.prototype._randbelow = function _randbelow(n) {\n  var len = n.bitLength();\n  var min_bytes = Math.ceil(len / 8);\n\n  // Generage random bytes until a number less than n is found.\n  // This ensures that 0..n-1 have an equal probability of being selected.\n  do\n    var a = new bn(this.rand.generate(min_bytes));\n  while (a.cmp(n) >= 0);\n\n  return a;\n};\n\nMillerRabin.prototype._randrange = function _randrange(start, stop) {\n  // Generate a random number greater than or equal to start and less than stop.\n  var size = stop.sub(start);\n  return start.add(this._randbelow(size));\n};\n\nMillerRabin.prototype.test = function test(n, k, cb) {\n  var len = n.bitLength();\n  var red = bn.mont(n);\n  var rone = new bn(1).toRed(red);\n\n  if (!k)\n    k = Math.max(1, (len / 48) | 0);\n\n  // Find d and s, (n - 1) = (2 ^ s) * d;\n  var n1 = n.subn(1);\n  for (var s = 0; !n1.testn(s); s++) {}\n  var d = n.shrn(s);\n\n  var rn1 = n1.toRed(red);\n\n  var prime = true;\n  for (; k > 0; k--) {\n    var a = this._randrange(new bn(2), n1);\n    if (cb)\n      cb(a);\n\n    var x = a.toRed(red).redPow(d);\n    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)\n      continue;\n\n    for (var i = 1; i < s; i++) {\n      x = x.redSqr();\n\n      if (x.cmp(rone) === 0)\n        return false;\n      if (x.cmp(rn1) === 0)\n        break;\n    }\n\n    if (i === s)\n      return false;\n  }\n\n  return prime;\n};\n\nMillerRabin.prototype.getDivisor = function getDivisor(n, k) {\n  var len = n.bitLength();\n  var red = bn.mont(n);\n  var rone = new bn(1).toRed(red);\n\n  if (!k)\n    k = Math.max(1, (len / 48) | 0);\n\n  // Find d and s, (n - 1) = (2 ^ s) * d;\n  var n1 = n.subn(1);\n  for (var s = 0; !n1.testn(s); s++) {}\n  var d = n.shrn(s);\n\n  var rn1 = n1.toRed(red);\n\n  for (; k > 0; k--) {\n    var a = this._randrange(new bn(2), n1);\n\n    var g = n.gcd(a);\n    if (g.cmpn(1) !== 0)\n      return g;\n\n    var x = a.toRed(red).redPow(d);\n    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)\n      continue;\n\n    for (var i = 1; i < s; i++) {\n      x = x.redSqr();\n\n      if (x.cmp(rone) === 0)\n        return x.fromRed().subn(1).gcd(n);\n      if (x.cmp(rn1) === 0)\n        break;\n    }\n\n    if (i === s) {\n      x = x.redSqr();\n      return x.fromRed().subn(1).gcd(n);\n    }\n  }\n\n  return false;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/miller-rabin/lib/mr.js?");

/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/minimalistic-assert/index.js?");

/***/ }),

/***/ "./node_modules/minimalistic-crypto-utils/lib/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/minimalistic-crypto-utils/lib/utils.js?");

/***/ }),

/***/ "./node_modules/parse-asn1/aesid.json":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/aesid.json ***!
  \********************************************/
/*! exports provided: 2.16.840.1.101.3.4.1.1, 2.16.840.1.101.3.4.1.2, 2.16.840.1.101.3.4.1.3, 2.16.840.1.101.3.4.1.4, 2.16.840.1.101.3.4.1.21, 2.16.840.1.101.3.4.1.22, 2.16.840.1.101.3.4.1.23, 2.16.840.1.101.3.4.1.24, 2.16.840.1.101.3.4.1.41, 2.16.840.1.101.3.4.1.42, 2.16.840.1.101.3.4.1.43, 2.16.840.1.101.3.4.1.44, default */
/***/ (function(module) {

eval("module.exports = {\"2.16.840.1.101.3.4.1.1\":\"aes-128-ecb\",\"2.16.840.1.101.3.4.1.2\":\"aes-128-cbc\",\"2.16.840.1.101.3.4.1.3\":\"aes-128-ofb\",\"2.16.840.1.101.3.4.1.4\":\"aes-128-cfb\",\"2.16.840.1.101.3.4.1.21\":\"aes-192-ecb\",\"2.16.840.1.101.3.4.1.22\":\"aes-192-cbc\",\"2.16.840.1.101.3.4.1.23\":\"aes-192-ofb\",\"2.16.840.1.101.3.4.1.24\":\"aes-192-cfb\",\"2.16.840.1.101.3.4.1.41\":\"aes-256-ecb\",\"2.16.840.1.101.3.4.1.42\":\"aes-256-cbc\",\"2.16.840.1.101.3.4.1.43\":\"aes-256-ofb\",\"2.16.840.1.101.3.4.1.44\":\"aes-256-cfb\"};\n\n//# sourceURL=webpack://THREEAR/./node_modules/parse-asn1/aesid.json?");

/***/ }),

/***/ "./node_modules/parse-asn1/asn1.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-asn1/asn1.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js\n// Fedor, you are amazing.\n\n\nvar asn1 = __webpack_require__(/*! asn1.js */ \"./node_modules/asn1.js/lib/asn1.js\")\n\nexports.certificate = __webpack_require__(/*! ./certificate */ \"./node_modules/parse-asn1/certificate.js\")\n\nvar RSAPrivateKey = asn1.define('RSAPrivateKey', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('modulus').int(),\n    this.key('publicExponent').int(),\n    this.key('privateExponent').int(),\n    this.key('prime1').int(),\n    this.key('prime2').int(),\n    this.key('exponent1').int(),\n    this.key('exponent2').int(),\n    this.key('coefficient').int()\n  )\n})\nexports.RSAPrivateKey = RSAPrivateKey\n\nvar RSAPublicKey = asn1.define('RSAPublicKey', function () {\n  this.seq().obj(\n    this.key('modulus').int(),\n    this.key('publicExponent').int()\n  )\n})\nexports.RSAPublicKey = RSAPublicKey\n\nvar PublicKey = asn1.define('SubjectPublicKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPublicKey').bitstr()\n  )\n})\nexports.PublicKey = PublicKey\n\nvar AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {\n  this.seq().obj(\n    this.key('algorithm').objid(),\n    this.key('none').null_().optional(),\n    this.key('curve').objid().optional(),\n    this.key('params').seq().obj(\n      this.key('p').int(),\n      this.key('q').int(),\n      this.key('g').int()\n    ).optional()\n  )\n})\n\nvar PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPrivateKey').octstr()\n  )\n})\nexports.PrivateKey = PrivateKeyInfo\nvar EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').seq().obj(\n      this.key('id').objid(),\n      this.key('decrypt').seq().obj(\n        this.key('kde').seq().obj(\n          this.key('id').objid(),\n          this.key('kdeparams').seq().obj(\n            this.key('salt').octstr(),\n            this.key('iters').int()\n          )\n        ),\n        this.key('cipher').seq().obj(\n          this.key('algo').objid(),\n          this.key('iv').octstr()\n        )\n      )\n    ),\n    this.key('subjectPrivateKey').octstr()\n  )\n})\n\nexports.EncryptedPrivateKey = EncryptedPrivateKeyInfo\n\nvar DSAPrivateKey = asn1.define('DSAPrivateKey', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('p').int(),\n    this.key('q').int(),\n    this.key('g').int(),\n    this.key('pub_key').int(),\n    this.key('priv_key').int()\n  )\n})\nexports.DSAPrivateKey = DSAPrivateKey\n\nexports.DSAparam = asn1.define('DSAparam', function () {\n  this.int()\n})\n\nvar ECPrivateKey = asn1.define('ECPrivateKey', function () {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').optional().explicit(0).use(ECParameters),\n    this.key('publicKey').optional().explicit(1).bitstr()\n  )\n})\nexports.ECPrivateKey = ECPrivateKey\n\nvar ECParameters = asn1.define('ECParameters', function () {\n  this.choice({\n    namedCurve: this.objid()\n  })\n})\n\nexports.signature = asn1.define('signature', function () {\n  this.seq().obj(\n    this.key('r').int(),\n    this.key('s').int()\n  )\n})\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/parse-asn1/asn1.js?");

/***/ }),

/***/ "./node_modules/parse-asn1/certificate.js":
/*!************************************************!*\
  !*** ./node_modules/parse-asn1/certificate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js\n// thanks to @Rantanen\n\n\n\nvar asn = __webpack_require__(/*! asn1.js */ \"./node_modules/asn1.js/lib/asn1.js\")\n\nvar Time = asn.define('Time', function () {\n  this.choice({\n    utcTime: this.utctime(),\n    generalTime: this.gentime()\n  })\n})\n\nvar AttributeTypeValue = asn.define('AttributeTypeValue', function () {\n  this.seq().obj(\n    this.key('type').objid(),\n    this.key('value').any()\n  )\n})\n\nvar AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {\n  this.seq().obj(\n    this.key('algorithm').objid(),\n    this.key('parameters').optional(),\n    this.key('curve').objid().optional()\n  )\n})\n\nvar SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {\n  this.seq().obj(\n    this.key('algorithm').use(AlgorithmIdentifier),\n    this.key('subjectPublicKey').bitstr()\n  )\n})\n\nvar RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {\n  this.setof(AttributeTypeValue)\n})\n\nvar RDNSequence = asn.define('RDNSequence', function () {\n  this.seqof(RelativeDistinguishedName)\n})\n\nvar Name = asn.define('Name', function () {\n  this.choice({\n    rdnSequence: this.use(RDNSequence)\n  })\n})\n\nvar Validity = asn.define('Validity', function () {\n  this.seq().obj(\n    this.key('notBefore').use(Time),\n    this.key('notAfter').use(Time)\n  )\n})\n\nvar Extension = asn.define('Extension', function () {\n  this.seq().obj(\n    this.key('extnID').objid(),\n    this.key('critical').bool().def(false),\n    this.key('extnValue').octstr()\n  )\n})\n\nvar TBSCertificate = asn.define('TBSCertificate', function () {\n  this.seq().obj(\n    this.key('version').explicit(0).int().optional(),\n    this.key('serialNumber').int(),\n    this.key('signature').use(AlgorithmIdentifier),\n    this.key('issuer').use(Name),\n    this.key('validity').use(Validity),\n    this.key('subject').use(Name),\n    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),\n    this.key('issuerUniqueID').implicit(1).bitstr().optional(),\n    this.key('subjectUniqueID').implicit(2).bitstr().optional(),\n    this.key('extensions').explicit(3).seqof(Extension).optional()\n  )\n})\n\nvar X509Certificate = asn.define('X509Certificate', function () {\n  this.seq().obj(\n    this.key('tbsCertificate').use(TBSCertificate),\n    this.key('signatureAlgorithm').use(AlgorithmIdentifier),\n    this.key('signatureValue').bitstr()\n  )\n})\n\nmodule.exports = X509Certificate\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/parse-asn1/certificate.js?");

/***/ }),

/***/ "./node_modules/parse-asn1/fixProc.js":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/fixProc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// adapted from https://github.com/apatil/pemstrip\nvar findProc = /Proc-Type: 4,ENCRYPTED[\\n\\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\\n\\r]+([0-9A-z\\n\\r\\+\\/\\=]+)[\\n\\r]+/m\nvar startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m\nvar fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\\n\\r\\+\\/\\=]+)-----END \\1-----$/m\nvar evp = __webpack_require__(/*! evp_bytestokey */ \"./node_modules/evp_bytestokey/index.js\")\nvar ciphers = __webpack_require__(/*! browserify-aes */ \"./node_modules/browserify-aes/browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nmodule.exports = function (okey, password) {\n  var key = okey.toString()\n  var match = key.match(findProc)\n  var decrypted\n  if (!match) {\n    var match2 = key.match(fullRegex)\n    decrypted = new Buffer(match2[2].replace(/[\\r\\n]/g, ''), 'base64')\n  } else {\n    var suite = 'aes' + match[1]\n    var iv = Buffer.from(match[2], 'hex')\n    var cipherText = Buffer.from(match[3].replace(/[\\r\\n]/g, ''), 'base64')\n    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key\n    var out = []\n    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)\n    out.push(cipher.update(cipherText))\n    out.push(cipher.final())\n    decrypted = Buffer.concat(out)\n  }\n  var tag = key.match(startRegex)[1]\n  return {\n    tag: tag,\n    data: decrypted\n  }\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/parse-asn1/fixProc.js?");

/***/ }),

/***/ "./node_modules/parse-asn1/index.js":
/*!******************************************!*\
  !*** ./node_modules/parse-asn1/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var asn1 = __webpack_require__(/*! ./asn1 */ \"./node_modules/parse-asn1/asn1.js\")\nvar aesid = __webpack_require__(/*! ./aesid.json */ \"./node_modules/parse-asn1/aesid.json\")\nvar fixProc = __webpack_require__(/*! ./fixProc */ \"./node_modules/parse-asn1/fixProc.js\")\nvar ciphers = __webpack_require__(/*! browserify-aes */ \"./node_modules/browserify-aes/browser.js\")\nvar compat = __webpack_require__(/*! pbkdf2 */ \"./node_modules/pbkdf2/browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nmodule.exports = parseKeys\n\nfunction parseKeys (buffer) {\n  var password\n  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {\n    password = buffer.passphrase\n    buffer = buffer.key\n  }\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer)\n  }\n\n  var stripped = fixProc(buffer, password)\n\n  var type = stripped.tag\n  var data = stripped.data\n  var subtype, ndata\n  switch (type) {\n    case 'CERTIFICATE':\n      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo\n      // falls through\n    case 'PUBLIC KEY':\n      if (!ndata) {\n        ndata = asn1.PublicKey.decode(data, 'der')\n      }\n      subtype = ndata.algorithm.algorithm.join('.')\n      switch (subtype) {\n        case '1.2.840.113549.1.1.1':\n          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')\n        case '1.2.840.10045.2.1':\n          ndata.subjectPrivateKey = ndata.subjectPublicKey\n          return {\n            type: 'ec',\n            data: ndata\n          }\n        case '1.2.840.10040.4.1':\n          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')\n          return {\n            type: 'dsa',\n            data: ndata.algorithm.params\n          }\n        default: throw new Error('unknown key id ' + subtype)\n      }\n      throw new Error('unknown key type ' + type)\n    case 'ENCRYPTED PRIVATE KEY':\n      data = asn1.EncryptedPrivateKey.decode(data, 'der')\n      data = decrypt(data, password)\n      // falls through\n    case 'PRIVATE KEY':\n      ndata = asn1.PrivateKey.decode(data, 'der')\n      subtype = ndata.algorithm.algorithm.join('.')\n      switch (subtype) {\n        case '1.2.840.113549.1.1.1':\n          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')\n        case '1.2.840.10045.2.1':\n          return {\n            curve: ndata.algorithm.curve,\n            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey\n          }\n        case '1.2.840.10040.4.1':\n          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')\n          return {\n            type: 'dsa',\n            params: ndata.algorithm.params\n          }\n        default: throw new Error('unknown key id ' + subtype)\n      }\n      throw new Error('unknown key type ' + type)\n    case 'RSA PUBLIC KEY':\n      return asn1.RSAPublicKey.decode(data, 'der')\n    case 'RSA PRIVATE KEY':\n      return asn1.RSAPrivateKey.decode(data, 'der')\n    case 'DSA PRIVATE KEY':\n      return {\n        type: 'dsa',\n        params: asn1.DSAPrivateKey.decode(data, 'der')\n      }\n    case 'EC PRIVATE KEY':\n      data = asn1.ECPrivateKey.decode(data, 'der')\n      return {\n        curve: data.parameters.value,\n        privateKey: data.privateKey\n      }\n    default: throw new Error('unknown key type ' + type)\n  }\n}\nparseKeys.signature = asn1.signature\nfunction decrypt (data, password) {\n  var salt = data.algorithm.decrypt.kde.kdeparams.salt\n  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)\n  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]\n  var iv = data.algorithm.decrypt.cipher.iv\n  var cipherText = data.subjectPrivateKey\n  var keylen = parseInt(algo.split('-')[1], 10) / 8\n  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')\n  var cipher = ciphers.createDecipheriv(algo, key, iv)\n  var out = []\n  out.push(cipher.update(cipherText))\n  out.push(cipher.final())\n  return Buffer.concat(out)\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/parse-asn1/index.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/browser.js":
/*!****************************************!*\
  !*** ./node_modules/pbkdf2/browser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.pbkdf2 = __webpack_require__(/*! ./lib/async */ \"./node_modules/pbkdf2/lib/async.js\")\nexports.pbkdf2Sync = __webpack_require__(/*! ./lib/sync */ \"./node_modules/pbkdf2/lib/sync-browser.js\")\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/pbkdf2/browser.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/lib/async.js":
/*!******************************************!*\
  !*** ./node_modules/pbkdf2/lib/async.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {var checkParameters = __webpack_require__(/*! ./precondition */ \"./node_modules/pbkdf2/lib/precondition.js\")\nvar defaultEncoding = __webpack_require__(/*! ./default-encoding */ \"./node_modules/pbkdf2/lib/default-encoding.js\")\nvar sync = __webpack_require__(/*! ./sync */ \"./node_modules/pbkdf2/lib/sync-browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar ZERO_BUF\nvar subtle = global.crypto && global.crypto.subtle\nvar toBrowser = {\n  'sha': 'SHA-1',\n  'sha-1': 'SHA-1',\n  'sha1': 'SHA-1',\n  'sha256': 'SHA-256',\n  'sha-256': 'SHA-256',\n  'sha384': 'SHA-384',\n  'sha-384': 'SHA-384',\n  'sha-512': 'SHA-512',\n  'sha512': 'SHA-512'\n}\nvar checks = []\nfunction checkNative (algo) {\n  if (global.process && !global.process.browser) {\n    return Promise.resolve(false)\n  }\n  if (!subtle || !subtle.importKey || !subtle.deriveBits) {\n    return Promise.resolve(false)\n  }\n  if (checks[algo] !== undefined) {\n    return checks[algo]\n  }\n  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)\n  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)\n    .then(function () {\n      return true\n    }).catch(function () {\n      return false\n    })\n  checks[algo] = prom\n  return prom\n}\n\nfunction browserPbkdf2 (password, salt, iterations, length, algo) {\n  return subtle.importKey(\n    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']\n  ).then(function (key) {\n    return subtle.deriveBits({\n      name: 'PBKDF2',\n      salt: salt,\n      iterations: iterations,\n      hash: {\n        name: algo\n      }\n    }, key, length << 3)\n  }).then(function (res) {\n    return Buffer.from(res)\n  })\n}\n\nfunction resolvePromise (promise, callback) {\n  promise.then(function (out) {\n    process.nextTick(function () {\n      callback(null, out)\n    })\n  }, function (e) {\n    process.nextTick(function () {\n      callback(e)\n    })\n  })\n}\nmodule.exports = function (password, salt, iterations, keylen, digest, callback) {\n  if (typeof digest === 'function') {\n    callback = digest\n    digest = undefined\n  }\n\n  digest = digest || 'sha1'\n  var algo = toBrowser[digest.toLowerCase()]\n\n  if (!algo || typeof global.Promise !== 'function') {\n    return process.nextTick(function () {\n      var out\n      try {\n        out = sync(password, salt, iterations, keylen, digest)\n      } catch (e) {\n        return callback(e)\n      }\n      callback(null, out)\n    })\n  }\n\n  checkParameters(password, salt, iterations, keylen)\n  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')\n  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)\n  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)\n\n  resolvePromise(checkNative(algo).then(function (resp) {\n    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)\n\n    return sync(password, salt, iterations, keylen, digest)\n  }), callback)\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/pbkdf2/lib/async.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/lib/default-encoding.js":
/*!*****************************************************!*\
  !*** ./node_modules/pbkdf2/lib/default-encoding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding\n/* istanbul ignore next */\nif (process.browser) {\n  defaultEncoding = 'utf-8'\n} else {\n  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)\n\n  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'\n}\nmodule.exports = defaultEncoding\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/pbkdf2/lib/default-encoding.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/lib/precondition.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/precondition.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs\n\nfunction checkBuffer (buf, name) {\n  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {\n    throw new TypeError(name + ' must be a buffer or string')\n  }\n}\n\nmodule.exports = function (password, salt, iterations, keylen) {\n  checkBuffer(password, 'Password')\n  checkBuffer(salt, 'Salt')\n\n  if (typeof iterations !== 'number') {\n    throw new TypeError('Iterations not a number')\n  }\n\n  if (iterations < 0) {\n    throw new TypeError('Bad iterations')\n  }\n\n  if (typeof keylen !== 'number') {\n    throw new TypeError('Key length not a number')\n  }\n\n  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */\n    throw new TypeError('Bad key length')\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./node_modules/pbkdf2/lib/precondition.js?");

/***/ }),

/***/ "./node_modules/pbkdf2/lib/sync-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/sync-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var md5 = __webpack_require__(/*! create-hash/md5 */ \"./node_modules/create-hash/md5.js\")\nvar RIPEMD160 = __webpack_require__(/*! ripemd160 */ \"./node_modules/ripemd160/index.js\")\nvar sha = __webpack_require__(/*! sha.js */ \"./node_modules/sha.js/index.js\")\n\nvar checkParameters = __webpack_require__(/*! ./precondition */ \"./node_modules/pbkdf2/lib/precondition.js\")\nvar defaultEncoding = __webpack_require__(/*! ./default-encoding */ \"./node_modules/pbkdf2/lib/default-encoding.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar ZEROS = Buffer.alloc(128)\nvar sizes = {\n  md5: 16,\n  sha1: 20,\n  sha224: 28,\n  sha256: 32,\n  sha384: 48,\n  sha512: 64,\n  rmd160: 20,\n  ripemd160: 20\n}\n\nfunction Hmac (alg, key, saltLen) {\n  var hash = getDigest(alg)\n  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64\n\n  if (key.length > blocksize) {\n    key = hash(key)\n  } else if (key.length < blocksize) {\n    key = Buffer.concat([key, ZEROS], blocksize)\n  }\n\n  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])\n  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])\n  for (var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)\n  ipad.copy(ipad1, 0, 0, blocksize)\n  this.ipad1 = ipad1\n  this.ipad2 = ipad\n  this.opad = opad\n  this.alg = alg\n  this.blocksize = blocksize\n  this.hash = hash\n  this.size = sizes[alg]\n}\n\nHmac.prototype.run = function (data, ipad) {\n  data.copy(ipad, this.blocksize)\n  var h = this.hash(ipad)\n  h.copy(this.opad, this.blocksize)\n  return this.hash(this.opad)\n}\n\nfunction getDigest (alg) {\n  function shaFunc (data) {\n    return sha(alg).update(data).digest()\n  }\n  function rmd160Func (data) {\n    return new RIPEMD160().update(data).digest()\n  }\n\n  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func\n  if (alg === 'md5') return md5\n  return shaFunc\n}\n\nfunction pbkdf2 (password, salt, iterations, keylen, digest) {\n  checkParameters(password, salt, iterations, keylen)\n\n  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)\n  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)\n\n  digest = digest || 'sha1'\n\n  var hmac = new Hmac(digest, password, salt.length)\n\n  var DK = Buffer.allocUnsafe(keylen)\n  var block1 = Buffer.allocUnsafe(salt.length + 4)\n  salt.copy(block1, 0, 0, salt.length)\n\n  var destPos = 0\n  var hLen = sizes[digest]\n  var l = Math.ceil(keylen / hLen)\n\n  for (var i = 1; i <= l; i++) {\n    block1.writeUInt32BE(i, salt.length)\n\n    var T = hmac.run(block1, hmac.ipad1)\n    var U = T\n\n    for (var j = 1; j < iterations; j++) {\n      U = hmac.run(U, hmac.ipad2)\n      for (var k = 0; k < hLen; k++) T[k] ^= U[k]\n    }\n\n    T.copy(DK, destPos)\n    destPos += hLen\n  }\n\n  return DK\n}\n\nmodule.exports = pbkdf2\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/pbkdf2/lib/sync-browser.js?");

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/process-nextick-args/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/browser.js":
/*!************************************************!*\
  !*** ./node_modules/public-encrypt/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.publicEncrypt = __webpack_require__(/*! ./publicEncrypt */ \"./node_modules/public-encrypt/publicEncrypt.js\")\nexports.privateDecrypt = __webpack_require__(/*! ./privateDecrypt */ \"./node_modules/public-encrypt/privateDecrypt.js\")\n\nexports.privateEncrypt = function privateEncrypt (key, buf) {\n  return exports.publicEncrypt(key, buf, true)\n}\n\nexports.publicDecrypt = function publicDecrypt (key, buf) {\n  return exports.privateDecrypt(key, buf, true)\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/public-encrypt/browser.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/mgf.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/mgf.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nmodule.exports = function (seed, len) {\n  var t = Buffer.alloc(0)\n  var i = 0\n  var c\n  while (t.length < len) {\n    c = i2ops(i++)\n    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])\n  }\n  return t.slice(0, len)\n}\n\nfunction i2ops (c) {\n  var out = Buffer.allocUnsafe(4)\n  out.writeUInt32BE(c, 0)\n  return out\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/public-encrypt/mgf.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/privateDecrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/public-encrypt/privateDecrypt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parseKeys = __webpack_require__(/*! parse-asn1 */ \"./node_modules/parse-asn1/index.js\")\nvar mgf = __webpack_require__(/*! ./mgf */ \"./node_modules/public-encrypt/mgf.js\")\nvar xor = __webpack_require__(/*! ./xor */ \"./node_modules/public-encrypt/xor.js\")\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\nvar crt = __webpack_require__(/*! browserify-rsa */ \"./node_modules/browserify-rsa/index.js\")\nvar createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\nvar withPublic = __webpack_require__(/*! ./withPublic */ \"./node_modules/public-encrypt/withPublic.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nmodule.exports = function privateDecrypt (privateKey, enc, reverse) {\n  var padding\n  if (privateKey.padding) {\n    padding = privateKey.padding\n  } else if (reverse) {\n    padding = 1\n  } else {\n    padding = 4\n  }\n\n  var key = parseKeys(privateKey)\n  var k = key.modulus.byteLength()\n  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {\n    throw new Error('decryption error')\n  }\n  var msg\n  if (reverse) {\n    msg = withPublic(new BN(enc), key)\n  } else {\n    msg = crt(enc, key)\n  }\n  var zBuffer = Buffer.alloc(k - msg.length)\n  msg = Buffer.concat([zBuffer, msg], k)\n  if (padding === 4) {\n    return oaep(key, msg)\n  } else if (padding === 1) {\n    return pkcs1(key, msg, reverse)\n  } else if (padding === 3) {\n    return msg\n  } else {\n    throw new Error('unknown padding')\n  }\n}\n\nfunction oaep (key, msg) {\n  var k = key.modulus.byteLength()\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\n  var hLen = iHash.length\n  if (msg[0] !== 0) {\n    throw new Error('decryption error')\n  }\n  var maskedSeed = msg.slice(1, hLen + 1)\n  var maskedDb = msg.slice(hLen + 1)\n  var seed = xor(maskedSeed, mgf(maskedDb, hLen))\n  var db = xor(maskedDb, mgf(seed, k - hLen - 1))\n  if (compare(iHash, db.slice(0, hLen))) {\n    throw new Error('decryption error')\n  }\n  var i = hLen\n  while (db[i] === 0) {\n    i++\n  }\n  if (db[i++] !== 1) {\n    throw new Error('decryption error')\n  }\n  return db.slice(i)\n}\n\nfunction pkcs1 (key, msg, reverse) {\n  var p1 = msg.slice(0, 2)\n  var i = 2\n  var status = 0\n  while (msg[i++] !== 0) {\n    if (i >= msg.length) {\n      status++\n      break\n    }\n  }\n  var ps = msg.slice(2, i - 1)\n\n  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {\n    status++\n  }\n  if (ps.length < 8) {\n    status++\n  }\n  if (status) {\n    throw new Error('decryption error')\n  }\n  return msg.slice(i)\n}\nfunction compare (a, b) {\n  a = Buffer.from(a)\n  b = Buffer.from(b)\n  var dif = 0\n  var len = a.length\n  if (a.length !== b.length) {\n    dif++\n    len = Math.min(a.length, b.length)\n  }\n  var i = -1\n  while (++i < len) {\n    dif += (a[i] ^ b[i])\n  }\n  return dif\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/public-encrypt/privateDecrypt.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/publicEncrypt.js":
/*!******************************************************!*\
  !*** ./node_modules/public-encrypt/publicEncrypt.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parseKeys = __webpack_require__(/*! parse-asn1 */ \"./node_modules/parse-asn1/index.js\")\nvar randomBytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\")\nvar createHash = __webpack_require__(/*! create-hash */ \"./node_modules/create-hash/browser.js\")\nvar mgf = __webpack_require__(/*! ./mgf */ \"./node_modules/public-encrypt/mgf.js\")\nvar xor = __webpack_require__(/*! ./xor */ \"./node_modules/public-encrypt/xor.js\")\nvar BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\nvar withPublic = __webpack_require__(/*! ./withPublic */ \"./node_modules/public-encrypt/withPublic.js\")\nvar crt = __webpack_require__(/*! browserify-rsa */ \"./node_modules/browserify-rsa/index.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nmodule.exports = function publicEncrypt (publicKey, msg, reverse) {\n  var padding\n  if (publicKey.padding) {\n    padding = publicKey.padding\n  } else if (reverse) {\n    padding = 1\n  } else {\n    padding = 4\n  }\n  var key = parseKeys(publicKey)\n  var paddedMsg\n  if (padding === 4) {\n    paddedMsg = oaep(key, msg)\n  } else if (padding === 1) {\n    paddedMsg = pkcs1(key, msg, reverse)\n  } else if (padding === 3) {\n    paddedMsg = new BN(msg)\n    if (paddedMsg.cmp(key.modulus) >= 0) {\n      throw new Error('data too long for modulus')\n    }\n  } else {\n    throw new Error('unknown padding')\n  }\n  if (reverse) {\n    return crt(paddedMsg, key)\n  } else {\n    return withPublic(paddedMsg, key)\n  }\n}\n\nfunction oaep (key, msg) {\n  var k = key.modulus.byteLength()\n  var mLen = msg.length\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\n  var hLen = iHash.length\n  var hLen2 = 2 * hLen\n  if (mLen > k - hLen2 - 2) {\n    throw new Error('message too long')\n  }\n  var ps = Buffer.alloc(k - mLen - hLen2 - 2)\n  var dblen = k - hLen - 1\n  var seed = randomBytes(hLen)\n  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))\n  var maskedSeed = xor(seed, mgf(maskedDb, hLen))\n  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))\n}\nfunction pkcs1 (key, msg, reverse) {\n  var mLen = msg.length\n  var k = key.modulus.byteLength()\n  if (mLen > k - 11) {\n    throw new Error('message too long')\n  }\n  var ps\n  if (reverse) {\n    ps = Buffer.alloc(k - mLen - 3, 0xff)\n  } else {\n    ps = nonZero(k - mLen - 3)\n  }\n  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))\n}\nfunction nonZero (len) {\n  var out = Buffer.allocUnsafe(len)\n  var i = 0\n  var cache = randomBytes(len * 2)\n  var cur = 0\n  var num\n  while (i < len) {\n    if (cur === cache.length) {\n      cache = randomBytes(len * 2)\n      cur = 0\n    }\n    num = cache[cur++]\n    if (num) {\n      out[i++] = num\n    }\n  }\n  return out\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/public-encrypt/publicEncrypt.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/withPublic.js":
/*!***************************************************!*\
  !*** ./node_modules/public-encrypt/withPublic.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var BN = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nfunction withPublic (paddedMsg, key) {\n  return Buffer.from(paddedMsg\n    .toRed(BN.mont(key.modulus))\n    .redPow(new BN(key.publicExponent))\n    .fromRed()\n    .toArray())\n}\n\nmodule.exports = withPublic\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/public-encrypt/withPublic.js?");

/***/ }),

/***/ "./node_modules/public-encrypt/xor.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/xor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function xor (a, b) {\n  var len = a.length\n  var i = -1\n  while (++i < len) {\n    a[i] ^= b[i]\n  }\n  return a\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/public-encrypt/xor.js?");

/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n\nfunction oldBrowser () {\n  throw new Error('Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11')\n}\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nvar crypto = global.crypto || global.msCrypto\n\nif (crypto && crypto.getRandomValues) {\n  module.exports = randomBytes\n} else {\n  module.exports = oldBrowser\n}\n\nfunction randomBytes (size, cb) {\n  // phantomjs needs to throw\n  if (size > 65536) throw new Error('requested too many random bytes')\n  // in case browserify  isn't using the Uint8Array version\n  var rawBytes = new global.Uint8Array(size)\n\n  // This will not work in older browsers.\n  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n  if (size > 0) {  // getRandomValues fails on IE if size == 0\n    crypto.getRandomValues(rawBytes)\n  }\n\n  // XXX: phantomjs doesn't like a buffer being passed here\n  var bytes = Buffer.from(rawBytes.buffer)\n\n  if (typeof cb === 'function') {\n    return process.nextTick(function () {\n      cb(null, bytes)\n    })\n  }\n\n  return bytes\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/randombytes/browser.js?");

/***/ }),

/***/ "./node_modules/randomfill/browser.js":
/*!********************************************!*\
  !*** ./node_modules/randomfill/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {\n\nfunction oldBrowser () {\n  throw new Error('secure random number generation not supported by this browser\\nuse chrome, FireFox or Internet Explorer 11')\n}\nvar safeBuffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\")\nvar randombytes = __webpack_require__(/*! randombytes */ \"./node_modules/randombytes/browser.js\")\nvar Buffer = safeBuffer.Buffer\nvar kBufferMaxLength = safeBuffer.kMaxLength\nvar crypto = global.crypto || global.msCrypto\nvar kMaxUint32 = Math.pow(2, 32) - 1\nfunction assertOffset (offset, length) {\n  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare\n    throw new TypeError('offset must be a number')\n  }\n\n  if (offset > kMaxUint32 || offset < 0) {\n    throw new TypeError('offset must be a uint32')\n  }\n\n  if (offset > kBufferMaxLength || offset > length) {\n    throw new RangeError('offset out of range')\n  }\n}\n\nfunction assertSize (size, offset, length) {\n  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare\n    throw new TypeError('size must be a number')\n  }\n\n  if (size > kMaxUint32 || size < 0) {\n    throw new TypeError('size must be a uint32')\n  }\n\n  if (size + offset > length || size > kBufferMaxLength) {\n    throw new RangeError('buffer too small')\n  }\n}\nif ((crypto && crypto.getRandomValues) || !process.browser) {\n  exports.randomFill = randomFill\n  exports.randomFillSync = randomFillSync\n} else {\n  exports.randomFill = oldBrowser\n  exports.randomFillSync = oldBrowser\n}\nfunction randomFill (buf, offset, size, cb) {\n  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {\n    throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array')\n  }\n\n  if (typeof offset === 'function') {\n    cb = offset\n    offset = 0\n    size = buf.length\n  } else if (typeof size === 'function') {\n    cb = size\n    size = buf.length - offset\n  } else if (typeof cb !== 'function') {\n    throw new TypeError('\"cb\" argument must be a function')\n  }\n  assertOffset(offset, buf.length)\n  assertSize(size, offset, buf.length)\n  return actualFill(buf, offset, size, cb)\n}\n\nfunction actualFill (buf, offset, size, cb) {\n  if (process.browser) {\n    var ourBuf = buf.buffer\n    var uint = new Uint8Array(ourBuf, offset, size)\n    crypto.getRandomValues(uint)\n    if (cb) {\n      process.nextTick(function () {\n        cb(null, buf)\n      })\n      return\n    }\n    return buf\n  }\n  if (cb) {\n    randombytes(size, function (err, bytes) {\n      if (err) {\n        return cb(err)\n      }\n      bytes.copy(buf, offset)\n      cb(null, buf)\n    })\n    return\n  }\n  var bytes = randombytes(size)\n  bytes.copy(buf, offset)\n  return buf\n}\nfunction randomFillSync (buf, offset, size) {\n  if (typeof offset === 'undefined') {\n    offset = 0\n  }\n  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {\n    throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array')\n  }\n\n  assertOffset(offset, buf.length)\n\n  if (size === undefined) size = buf.length - offset\n\n  assertSize(size, offset, buf.length)\n\n  return actualFill(buf, offset, size)\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/randomfill/browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/duplex-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ 0);\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"./node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar util = __webpack_require__(/*! util */ 1);\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/lib/internal/streams/BufferList.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").PassThrough\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/readable-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").Transform\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/readable-stream/writable-browser.js?");

/***/ }),

/***/ "./node_modules/ripemd160/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar HashBase = __webpack_require__(/*! hash-base */ \"./node_modules/hash-base/index.js\")\n\nvar ARRAY16 = new Array(16)\n\nvar zl = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n]\n\nvar zr = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n]\n\nvar sl = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n]\n\nvar sr = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n]\n\nvar hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]\nvar hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]\n\nfunction RIPEMD160 () {\n  HashBase.call(this, 64)\n\n  // state\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n}\n\ninherits(RIPEMD160, HashBase)\n\nRIPEMD160.prototype._update = function () {\n  var words = ARRAY16\n  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)\n\n  var al = this._a | 0\n  var bl = this._b | 0\n  var cl = this._c | 0\n  var dl = this._d | 0\n  var el = this._e | 0\n\n  var ar = this._a | 0\n  var br = this._b | 0\n  var cr = this._c | 0\n  var dr = this._d | 0\n  var er = this._e | 0\n\n  // computation\n  for (var i = 0; i < 80; i += 1) {\n    var tl\n    var tr\n    if (i < 16) {\n      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])\n      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])\n    } else if (i < 32) {\n      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])\n      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])\n    } else if (i < 48) {\n      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])\n      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])\n    } else if (i < 64) {\n      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])\n      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])\n    } else { // if (i<80) {\n      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])\n      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])\n    }\n\n    al = el\n    el = dl\n    dl = rotl(cl, 10)\n    cl = bl\n    bl = tl\n\n    ar = er\n    er = dr\n    dr = rotl(cr, 10)\n    cr = br\n    br = tr\n  }\n\n  // update state\n  var t = (this._b + cl + dr) | 0\n  this._b = (this._c + dl + er) | 0\n  this._c = (this._d + el + ar) | 0\n  this._d = (this._e + al + br) | 0\n  this._e = (this._a + bl + cr) | 0\n  this._a = t\n}\n\nRIPEMD160.prototype._digest = function () {\n  // create padding and handle blocks\n  this._block[this._blockOffset++] = 0x80\n  if (this._blockOffset > 56) {\n    this._block.fill(0, this._blockOffset, 64)\n    this._update()\n    this._blockOffset = 0\n  }\n\n  this._block.fill(0, this._blockOffset, 56)\n  this._block.writeUInt32LE(this._length[0], 56)\n  this._block.writeUInt32LE(this._length[1], 60)\n  this._update()\n\n  // produce result\n  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)\n  buffer.writeInt32LE(this._a, 0)\n  buffer.writeInt32LE(this._b, 4)\n  buffer.writeInt32LE(this._c, 8)\n  buffer.writeInt32LE(this._d, 12)\n  buffer.writeInt32LE(this._e, 16)\n  return buffer\n}\n\nfunction rotl (x, n) {\n  return (x << n) | (x >>> (32 - n))\n}\n\nfunction fn1 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn2 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn3 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn4 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn5 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0\n}\n\nmodule.exports = RIPEMD160\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/ripemd160/index.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\n// prototype class for hash functions\nfunction Hash (blockSize, finalSize) {\n  this._block = Buffer.alloc(blockSize)\n  this._finalSize = finalSize\n  this._blockSize = blockSize\n  this._len = 0\n}\n\nHash.prototype.update = function (data, enc) {\n  if (typeof data === 'string') {\n    enc = enc || 'utf8'\n    data = Buffer.from(data, enc)\n  }\n\n  var block = this._block\n  var blockSize = this._blockSize\n  var length = data.length\n  var accum = this._len\n\n  for (var offset = 0; offset < length;) {\n    var assigned = accum % blockSize\n    var remainder = Math.min(length - offset, blockSize - assigned)\n\n    for (var i = 0; i < remainder; i++) {\n      block[assigned + i] = data[offset + i]\n    }\n\n    accum += remainder\n    offset += remainder\n\n    if ((accum % blockSize) === 0) {\n      this._update(block)\n    }\n  }\n\n  this._len += length\n  return this\n}\n\nHash.prototype.digest = function (enc) {\n  var rem = this._len % this._blockSize\n\n  this._block[rem] = 0x80\n\n  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\n  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\n  this._block.fill(0, rem + 1)\n\n  if (rem >= this._finalSize) {\n    this._update(this._block)\n    this._block.fill(0)\n  }\n\n  var bits = this._len * 8\n\n  // uint32\n  if (bits <= 0xffffffff) {\n    this._block.writeUInt32BE(bits, this._blockSize - 4)\n\n  // uint64\n  } else {\n    var lowBits = (bits & 0xffffffff) >>> 0\n    var highBits = (bits - lowBits) / 0x100000000\n\n    this._block.writeUInt32BE(highBits, this._blockSize - 8)\n    this._block.writeUInt32BE(lowBits, this._blockSize - 4)\n  }\n\n  this._update(this._block)\n  var hash = this._hash()\n\n  return enc ? hash.toString(enc) : hash\n}\n\nHash.prototype._update = function () {\n  throw new Error('_update must be implemented by subclass')\n}\n\nmodule.exports = Hash\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/sha.js/hash.js?");

/***/ }),

/***/ "./node_modules/sha.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var exports = module.exports = function SHA (algorithm) {\n  algorithm = algorithm.toLowerCase()\n\n  var Algorithm = exports[algorithm]\n  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')\n\n  return new Algorithm()\n}\n\nexports.sha = __webpack_require__(/*! ./sha */ \"./node_modules/sha.js/sha.js\")\nexports.sha1 = __webpack_require__(/*! ./sha1 */ \"./node_modules/sha.js/sha1.js\")\nexports.sha224 = __webpack_require__(/*! ./sha224 */ \"./node_modules/sha.js/sha224.js\")\nexports.sha256 = __webpack_require__(/*! ./sha256 */ \"./node_modules/sha.js/sha256.js\")\nexports.sha384 = __webpack_require__(/*! ./sha384 */ \"./node_modules/sha.js/sha384.js\")\nexports.sha512 = __webpack_require__(/*! ./sha512 */ \"./node_modules/sha.js/sha512.js\")\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/sha.js/index.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha.js":
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined\n * in FIPS PUB 180-1\n * This source code is derived from sha1.js of the same repository.\n * The difference between SHA-0 and SHA-1 is just a bitwise rotate left\n * operation was added.\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar K = [\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\n]\n\nvar W = new Array(80)\n\nfunction Sha () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha, Hash)\n\nSha.prototype.init = function () {\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n\n  return this\n}\n\nfunction rotl5 (num) {\n  return (num << 5) | (num >>> 27)\n}\n\nfunction rotl30 (num) {\n  return (num << 30) | (num >>> 2)\n}\n\nfunction ft (s, b, c, d) {\n  if (s === 0) return (b & c) | ((~b) & d)\n  if (s === 2) return (b & c) | (b & d) | (c & d)\n  return b ^ c ^ d\n}\n\nSha.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]\n\n  for (var j = 0; j < 80; ++j) {\n    var s = ~~(j / 20)\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\n\n    e = d\n    d = c\n    c = rotl30(b)\n    b = a\n    a = t\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/sha.js/sha.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar K = [\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\n]\n\nvar W = new Array(80)\n\nfunction Sha1 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha1, Hash)\n\nSha1.prototype.init = function () {\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n\n  return this\n}\n\nfunction rotl1 (num) {\n  return (num << 1) | (num >>> 31)\n}\n\nfunction rotl5 (num) {\n  return (num << 5) | (num >>> 27)\n}\n\nfunction rotl30 (num) {\n  return (num << 30) | (num >>> 2)\n}\n\nfunction ft (s, b, c, d) {\n  if (s === 0) return (b & c) | ((~b) & d)\n  if (s === 2) return (b & c) | (b & d) | (c & d)\n  return b ^ c ^ d\n}\n\nSha1.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])\n\n  for (var j = 0; j < 80; ++j) {\n    var s = ~~(j / 20)\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\n\n    e = d\n    d = c\n    c = rotl30(b)\n    b = a\n    a = t\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha1.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha1\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/sha.js/sha1.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha224.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Sha256 = __webpack_require__(/*! ./sha256 */ \"./node_modules/sha.js/sha256.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar W = new Array(64)\n\nfunction Sha224 () {\n  this.init()\n\n  this._w = W // new Array(64)\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha224, Sha256)\n\nSha224.prototype.init = function () {\n  this._a = 0xc1059ed8\n  this._b = 0x367cd507\n  this._c = 0x3070dd17\n  this._d = 0xf70e5939\n  this._e = 0xffc00b31\n  this._f = 0x68581511\n  this._g = 0x64f98fa7\n  this._h = 0xbefa4fa4\n\n  return this\n}\n\nSha224.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(28)\n\n  H.writeInt32BE(this._a, 0)\n  H.writeInt32BE(this._b, 4)\n  H.writeInt32BE(this._c, 8)\n  H.writeInt32BE(this._d, 12)\n  H.writeInt32BE(this._e, 16)\n  H.writeInt32BE(this._f, 20)\n  H.writeInt32BE(this._g, 24)\n\n  return H\n}\n\nmodule.exports = Sha224\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/sha.js/sha224.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar K = [\n  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n]\n\nvar W = new Array(64)\n\nfunction Sha256 () {\n  this.init()\n\n  this._w = W // new Array(64)\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha256, Hash)\n\nSha256.prototype.init = function () {\n  this._a = 0x6a09e667\n  this._b = 0xbb67ae85\n  this._c = 0x3c6ef372\n  this._d = 0xa54ff53a\n  this._e = 0x510e527f\n  this._f = 0x9b05688c\n  this._g = 0x1f83d9ab\n  this._h = 0x5be0cd19\n\n  return this\n}\n\nfunction ch (x, y, z) {\n  return z ^ (x & (y ^ z))\n}\n\nfunction maj (x, y, z) {\n  return (x & y) | (z & (x | y))\n}\n\nfunction sigma0 (x) {\n  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)\n}\n\nfunction sigma1 (x) {\n  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)\n}\n\nfunction gamma0 (x) {\n  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)\n}\n\nfunction gamma1 (x) {\n  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)\n}\n\nSha256.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n  var f = this._f | 0\n  var g = this._g | 0\n  var h = this._h | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0\n\n  for (var j = 0; j < 64; ++j) {\n    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0\n    var T2 = (sigma0(a) + maj(a, b, c)) | 0\n\n    h = g\n    g = f\n    f = e\n    e = (d + T1) | 0\n    d = c\n    c = b\n    b = a\n    a = (T1 + T2) | 0\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n  this._f = (f + this._f) | 0\n  this._g = (g + this._g) | 0\n  this._h = (h + this._h) | 0\n}\n\nSha256.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(32)\n\n  H.writeInt32BE(this._a, 0)\n  H.writeInt32BE(this._b, 4)\n  H.writeInt32BE(this._c, 8)\n  H.writeInt32BE(this._d, 12)\n  H.writeInt32BE(this._e, 16)\n  H.writeInt32BE(this._f, 20)\n  H.writeInt32BE(this._g, 24)\n  H.writeInt32BE(this._h, 28)\n\n  return H\n}\n\nmodule.exports = Sha256\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/sha.js/sha256.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha384.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar SHA512 = __webpack_require__(/*! ./sha512 */ \"./node_modules/sha.js/sha512.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar W = new Array(160)\n\nfunction Sha384 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 128, 112)\n}\n\ninherits(Sha384, SHA512)\n\nSha384.prototype.init = function () {\n  this._ah = 0xcbbb9d5d\n  this._bh = 0x629a292a\n  this._ch = 0x9159015a\n  this._dh = 0x152fecd8\n  this._eh = 0x67332667\n  this._fh = 0x8eb44a87\n  this._gh = 0xdb0c2e0d\n  this._hh = 0x47b5481d\n\n  this._al = 0xc1059ed8\n  this._bl = 0x367cd507\n  this._cl = 0x3070dd17\n  this._dl = 0xf70e5939\n  this._el = 0xffc00b31\n  this._fl = 0x68581511\n  this._gl = 0x64f98fa7\n  this._hl = 0xbefa4fa4\n\n  return this\n}\n\nSha384.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(48)\n\n  function writeInt64BE (h, l, offset) {\n    H.writeInt32BE(h, offset)\n    H.writeInt32BE(l, offset + 4)\n  }\n\n  writeInt64BE(this._ah, this._al, 0)\n  writeInt64BE(this._bh, this._bl, 8)\n  writeInt64BE(this._ch, this._cl, 16)\n  writeInt64BE(this._dh, this._dl, 24)\n  writeInt64BE(this._eh, this._el, 32)\n  writeInt64BE(this._fh, this._fl, 40)\n\n  return H\n}\n\nmodule.exports = Sha384\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/sha.js/sha384.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha512.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n]\n\nvar W = new Array(160)\n\nfunction Sha512 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 128, 112)\n}\n\ninherits(Sha512, Hash)\n\nSha512.prototype.init = function () {\n  this._ah = 0x6a09e667\n  this._bh = 0xbb67ae85\n  this._ch = 0x3c6ef372\n  this._dh = 0xa54ff53a\n  this._eh = 0x510e527f\n  this._fh = 0x9b05688c\n  this._gh = 0x1f83d9ab\n  this._hh = 0x5be0cd19\n\n  this._al = 0xf3bcc908\n  this._bl = 0x84caa73b\n  this._cl = 0xfe94f82b\n  this._dl = 0x5f1d36f1\n  this._el = 0xade682d1\n  this._fl = 0x2b3e6c1f\n  this._gl = 0xfb41bd6b\n  this._hl = 0x137e2179\n\n  return this\n}\n\nfunction Ch (x, y, z) {\n  return z ^ (x & (y ^ z))\n}\n\nfunction maj (x, y, z) {\n  return (x & y) | (z & (x | y))\n}\n\nfunction sigma0 (x, xl) {\n  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)\n}\n\nfunction sigma1 (x, xl) {\n  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)\n}\n\nfunction Gamma0 (x, xl) {\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)\n}\n\nfunction Gamma0l (x, xl) {\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)\n}\n\nfunction Gamma1 (x, xl) {\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)\n}\n\nfunction Gamma1l (x, xl) {\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)\n}\n\nfunction getCarry (a, b) {\n  return (a >>> 0) < (b >>> 0) ? 1 : 0\n}\n\nSha512.prototype._update = function (M) {\n  var W = this._w\n\n  var ah = this._ah | 0\n  var bh = this._bh | 0\n  var ch = this._ch | 0\n  var dh = this._dh | 0\n  var eh = this._eh | 0\n  var fh = this._fh | 0\n  var gh = this._gh | 0\n  var hh = this._hh | 0\n\n  var al = this._al | 0\n  var bl = this._bl | 0\n  var cl = this._cl | 0\n  var dl = this._dl | 0\n  var el = this._el | 0\n  var fl = this._fl | 0\n  var gl = this._gl | 0\n  var hl = this._hl | 0\n\n  for (var i = 0; i < 32; i += 2) {\n    W[i] = M.readInt32BE(i * 4)\n    W[i + 1] = M.readInt32BE(i * 4 + 4)\n  }\n  for (; i < 160; i += 2) {\n    var xh = W[i - 15 * 2]\n    var xl = W[i - 15 * 2 + 1]\n    var gamma0 = Gamma0(xh, xl)\n    var gamma0l = Gamma0l(xl, xh)\n\n    xh = W[i - 2 * 2]\n    xl = W[i - 2 * 2 + 1]\n    var gamma1 = Gamma1(xh, xl)\n    var gamma1l = Gamma1l(xl, xh)\n\n    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n    var Wi7h = W[i - 7 * 2]\n    var Wi7l = W[i - 7 * 2 + 1]\n\n    var Wi16h = W[i - 16 * 2]\n    var Wi16l = W[i - 16 * 2 + 1]\n\n    var Wil = (gamma0l + Wi7l) | 0\n    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0\n    Wil = (Wil + gamma1l) | 0\n    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0\n    Wil = (Wil + Wi16l) | 0\n    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0\n\n    W[i] = Wih\n    W[i + 1] = Wil\n  }\n\n  for (var j = 0; j < 160; j += 2) {\n    Wih = W[j]\n    Wil = W[j + 1]\n\n    var majh = maj(ah, bh, ch)\n    var majl = maj(al, bl, cl)\n\n    var sigma0h = sigma0(ah, al)\n    var sigma0l = sigma0(al, ah)\n    var sigma1h = sigma1(eh, el)\n    var sigma1l = sigma1(el, eh)\n\n    // t1 = h + sigma1 + ch + K[j] + W[j]\n    var Kih = K[j]\n    var Kil = K[j + 1]\n\n    var chh = Ch(eh, fh, gh)\n    var chl = Ch(el, fl, gl)\n\n    var t1l = (hl + sigma1l) | 0\n    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0\n    t1l = (t1l + chl) | 0\n    t1h = (t1h + chh + getCarry(t1l, chl)) | 0\n    t1l = (t1l + Kil) | 0\n    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0\n    t1l = (t1l + Wil) | 0\n    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0\n\n    // t2 = sigma0 + maj\n    var t2l = (sigma0l + majl) | 0\n    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0\n\n    hh = gh\n    hl = gl\n    gh = fh\n    gl = fl\n    fh = eh\n    fl = el\n    el = (dl + t1l) | 0\n    eh = (dh + t1h + getCarry(el, dl)) | 0\n    dh = ch\n    dl = cl\n    ch = bh\n    cl = bl\n    bh = ah\n    bl = al\n    al = (t1l + t2l) | 0\n    ah = (t1h + t2h + getCarry(al, t1l)) | 0\n  }\n\n  this._al = (this._al + al) | 0\n  this._bl = (this._bl + bl) | 0\n  this._cl = (this._cl + cl) | 0\n  this._dl = (this._dl + dl) | 0\n  this._el = (this._el + el) | 0\n  this._fl = (this._fl + fl) | 0\n  this._gl = (this._gl + gl) | 0\n  this._hl = (this._hl + hl) | 0\n\n  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0\n  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0\n  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0\n  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0\n  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0\n  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0\n  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0\n  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0\n}\n\nSha512.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(64)\n\n  function writeInt64BE (h, l, offset) {\n    H.writeInt32BE(h, offset)\n    H.writeInt32BE(l, offset + 4)\n  }\n\n  writeInt64BE(this._ah, this._al, 0)\n  writeInt64BE(this._bh, this._bl, 8)\n  writeInt64BE(this._ch, this._cl, 16)\n  writeInt64BE(this._dh, this._dl, 24)\n  writeInt64BE(this._eh, this._el, 32)\n  writeInt64BE(this._fh, this._fl, 40)\n  writeInt64BE(this._gh, this._gl, 48)\n  writeInt64BE(this._hh, this._hl, 56)\n\n  return H\n}\n\nmodule.exports = Sha512\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/sha.js/sha512.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\ninherits(Stream, EE);\nStream.Readable = __webpack_require__(/*! readable-stream/readable.js */ \"./node_modules/readable-stream/readable-browser.js\");\nStream.Writable = __webpack_require__(/*! readable-stream/writable.js */ \"./node_modules/readable-stream/writable-browser.js\");\nStream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ \"./node_modules/readable-stream/duplex-browser.js\");\nStream.Transform = __webpack_require__(/*! readable-stream/transform.js */ \"./node_modules/readable-stream/transform.js\");\nStream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ \"./node_modules/readable-stream/passthrough.js\");\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/stream-browserify/index.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://THREEAR/./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/*! exports provided: WebGLMultisampleRenderTarget, WebGLRenderTargetCube, WebGLRenderTarget, WebGLRenderer, ShaderLib, UniformsLib, UniformsUtils, ShaderChunk, FogExp2, Fog, Scene, Sprite, LOD, SkinnedMesh, Skeleton, Bone, Mesh, LineSegments, LineLoop, Line, Points, Group, VideoTexture, DataTexture, DataTexture3D, CompressedTexture, CubeTexture, CanvasTexture, DepthTexture, Texture, AnimationLoader, CompressedTextureLoader, DataTextureLoader, CubeTextureLoader, TextureLoader, ObjectLoader, MaterialLoader, BufferGeometryLoader, DefaultLoadingManager, LoadingManager, ImageLoader, ImageBitmapLoader, FontLoader, FileLoader, Loader, LoaderUtils, Cache, AudioLoader, SpotLightShadow, SpotLight, PointLight, RectAreaLight, HemisphereLight, DirectionalLightShadow, DirectionalLight, AmbientLight, LightShadow, Light, StereoCamera, PerspectiveCamera, OrthographicCamera, CubeCamera, ArrayCamera, Camera, AudioListener, PositionalAudio, AudioContext, AudioAnalyser, Audio, VectorKeyframeTrack, StringKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, ColorKeyframeTrack, BooleanKeyframeTrack, PropertyMixer, PropertyBinding, KeyframeTrack, AnimationUtils, AnimationObjectGroup, AnimationMixer, AnimationClip, Uniform, InstancedBufferGeometry, BufferGeometry, Geometry, InterleavedBufferAttribute, InstancedInterleavedBuffer, InterleavedBuffer, InstancedBufferAttribute, Face3, Object3D, Raycaster, Layers, EventDispatcher, Clock, QuaternionLinearInterpolant, LinearInterpolant, DiscreteInterpolant, CubicInterpolant, Interpolant, Triangle, Math, Spherical, Cylindrical, Plane, Frustum, Sphere, Ray, Matrix4, Matrix3, Box3, Box2, Line3, Euler, Vector4, Vector3, Vector2, Quaternion, Color, ImmediateRenderObject, VertexNormalsHelper, SpotLightHelper, SkeletonHelper, PointLightHelper, RectAreaLightHelper, HemisphereLightHelper, GridHelper, PolarGridHelper, FaceNormalsHelper, DirectionalLightHelper, CameraHelper, BoxHelper, Box3Helper, PlaneHelper, ArrowHelper, AxesHelper, Shape, Path, ShapePath, Font, CurvePath, Curve, ImageUtils, ShapeUtils, WebGLUtils, WireframeGeometry, ParametricGeometry, ParametricBufferGeometry, TetrahedronGeometry, TetrahedronBufferGeometry, OctahedronGeometry, OctahedronBufferGeometry, IcosahedronGeometry, IcosahedronBufferGeometry, DodecahedronGeometry, DodecahedronBufferGeometry, PolyhedronGeometry, PolyhedronBufferGeometry, TubeGeometry, TubeBufferGeometry, TorusKnotGeometry, TorusKnotBufferGeometry, TorusGeometry, TorusBufferGeometry, TextGeometry, TextBufferGeometry, SphereGeometry, SphereBufferGeometry, RingGeometry, RingBufferGeometry, PlaneGeometry, PlaneBufferGeometry, LatheGeometry, LatheBufferGeometry, ShapeGeometry, ShapeBufferGeometry, ExtrudeGeometry, ExtrudeBufferGeometry, EdgesGeometry, ConeGeometry, ConeBufferGeometry, CylinderGeometry, CylinderBufferGeometry, CircleGeometry, CircleBufferGeometry, BoxGeometry, CubeGeometry, BoxBufferGeometry, ShadowMaterial, SpriteMaterial, RawShaderMaterial, ShaderMaterial, PointsMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshPhongMaterial, MeshToonMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshBasicMaterial, MeshMatcapMaterial, LineDashedMaterial, LineBasicMaterial, Material, Float64BufferAttribute, Float32BufferAttribute, Uint32BufferAttribute, Int32BufferAttribute, Uint16BufferAttribute, Int16BufferAttribute, Uint8ClampedBufferAttribute, Uint8BufferAttribute, Int8BufferAttribute, BufferAttribute, ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve, REVISION, MOUSE, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, FrontFaceDirectionCW, FrontFaceDirectionCCW, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoColors, FaceColors, VertexColors, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, Uncharted2ToneMapping, CineonToneMapping, ACESFilmicToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, SphericalReflectionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipMapNearestFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipMapNearestFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RedFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, Face4, LineStrip, LinePieces, MeshFaceMaterial, MultiMaterial, PointCloud, Particle, ParticleSystem, PointCloudMaterial, ParticleBasicMaterial, ParticleSystemMaterial, Vertex, DynamicBufferAttribute, Int8Attribute, Uint8Attribute, Uint8ClampedAttribute, Int16Attribute, Uint16Attribute, Int32Attribute, Uint32Attribute, Float32Attribute, Float64Attribute, ClosedSplineCurve3, SplineCurve3, Spline, AxisHelper, BoundingBoxHelper, EdgesHelper, WireframeHelper, XHRLoader, BinaryTextureLoader, GeometryUtils, Projector, CanvasRenderer, JSONLoader, SceneUtils, LensFlare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLMultisampleRenderTarget\", function() { return WebGLMultisampleRenderTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLRenderTargetCube\", function() { return WebGLRenderTargetCube; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLRenderTarget\", function() { return WebGLRenderTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLRenderer\", function() { return WebGLRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderLib\", function() { return ShaderLib; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformsLib\", function() { return UniformsLib; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UniformsUtils\", function() { return UniformsUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderChunk\", function() { return ShaderChunk; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FogExp2\", function() { return FogExp2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fog\", function() { return Fog; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sprite\", function() { return Sprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOD\", function() { return LOD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SkinnedMesh\", function() { return SkinnedMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Skeleton\", function() { return Skeleton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bone\", function() { return Bone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return Mesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineSegments\", function() { return LineSegments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineLoop\", function() { return LineLoop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return Line; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Points\", function() { return Points; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Group\", function() { return Group; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VideoTexture\", function() { return VideoTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTexture\", function() { return DataTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTexture3D\", function() { return DataTexture3D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompressedTexture\", function() { return CompressedTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeTexture\", function() { return CubeTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasTexture\", function() { return CanvasTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DepthTexture\", function() { return DepthTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return Texture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationLoader\", function() { return AnimationLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompressedTextureLoader\", function() { return CompressedTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataTextureLoader\", function() { return DataTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeTextureLoader\", function() { return CubeTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextureLoader\", function() { return TextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectLoader\", function() { return ObjectLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaterialLoader\", function() { return MaterialLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferGeometryLoader\", function() { return BufferGeometryLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultLoadingManager\", function() { return DefaultLoadingManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoadingManager\", function() { return LoadingManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageLoader\", function() { return ImageLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageBitmapLoader\", function() { return ImageBitmapLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FontLoader\", function() { return FontLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FileLoader\", function() { return FileLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Loader\", function() { return Loader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoaderUtils\", function() { return LoaderUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cache\", function() { return Cache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioLoader\", function() { return AudioLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpotLightShadow\", function() { return SpotLightShadow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpotLight\", function() { return SpotLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointLight\", function() { return PointLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RectAreaLight\", function() { return RectAreaLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HemisphereLight\", function() { return HemisphereLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectionalLightShadow\", function() { return DirectionalLightShadow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectionalLight\", function() { return DirectionalLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AmbientLight\", function() { return AmbientLight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LightShadow\", function() { return LightShadow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Light\", function() { return Light; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StereoCamera\", function() { return StereoCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PerspectiveCamera\", function() { return PerspectiveCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OrthographicCamera\", function() { return OrthographicCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeCamera\", function() { return CubeCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayCamera\", function() { return ArrayCamera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return Camera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioListener\", function() { return AudioListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PositionalAudio\", function() { return PositionalAudio; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioContext\", function() { return AudioContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AudioAnalyser\", function() { return AudioAnalyser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Audio\", function() { return Audio; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VectorKeyframeTrack\", function() { return VectorKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringKeyframeTrack\", function() { return StringKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuaternionKeyframeTrack\", function() { return QuaternionKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NumberKeyframeTrack\", function() { return NumberKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorKeyframeTrack\", function() { return ColorKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BooleanKeyframeTrack\", function() { return BooleanKeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyMixer\", function() { return PropertyMixer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyBinding\", function() { return PropertyBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyframeTrack\", function() { return KeyframeTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationUtils\", function() { return AnimationUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationObjectGroup\", function() { return AnimationObjectGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationMixer\", function() { return AnimationMixer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimationClip\", function() { return AnimationClip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uniform\", function() { return Uniform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedBufferGeometry\", function() { return InstancedBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferGeometry\", function() { return BufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Geometry\", function() { return Geometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterleavedBufferAttribute\", function() { return InterleavedBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedInterleavedBuffer\", function() { return InstancedInterleavedBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterleavedBuffer\", function() { return InterleavedBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedBufferAttribute\", function() { return InstancedBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Face3\", function() { return Face3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Object3D\", function() { return Object3D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Raycaster\", function() { return Raycaster; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layers\", function() { return Layers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDispatcher\", function() { return EventDispatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Clock\", function() { return Clock; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuaternionLinearInterpolant\", function() { return QuaternionLinearInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearInterpolant\", function() { return LinearInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiscreteInterpolant\", function() { return DiscreteInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubicInterpolant\", function() { return CubicInterpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interpolant\", function() { return Interpolant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Triangle\", function() { return Triangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Math\", function() { return _Math; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Spherical\", function() { return Spherical; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cylindrical\", function() { return Cylindrical; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plane\", function() { return Plane; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Frustum\", function() { return Frustum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sphere\", function() { return Sphere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ray\", function() { return Ray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix4\", function() { return Matrix4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix3\", function() { return Matrix3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box3\", function() { return Box3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box2\", function() { return Box2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line3\", function() { return Line3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Euler\", function() { return Euler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector4\", function() { return Vector4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector3\", function() { return Vector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector2\", function() { return Vector2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quaternion\", function() { return Quaternion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return Color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImmediateRenderObject\", function() { return ImmediateRenderObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexNormalsHelper\", function() { return VertexNormalsHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpotLightHelper\", function() { return SpotLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SkeletonHelper\", function() { return SkeletonHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointLightHelper\", function() { return PointLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RectAreaLightHelper\", function() { return RectAreaLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HemisphereLightHelper\", function() { return HemisphereLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GridHelper\", function() { return GridHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolarGridHelper\", function() { return PolarGridHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FaceNormalsHelper\", function() { return FaceNormalsHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectionalLightHelper\", function() { return DirectionalLightHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CameraHelper\", function() { return CameraHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxHelper\", function() { return BoxHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box3Helper\", function() { return Box3Helper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneHelper\", function() { return PlaneHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrowHelper\", function() { return ArrowHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AxesHelper\", function() { return AxesHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Shape\", function() { return Shape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Path\", function() { return Path; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapePath\", function() { return ShapePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Font\", function() { return Font; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CurvePath\", function() { return CurvePath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Curve\", function() { return Curve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageUtils\", function() { return ImageUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeUtils\", function() { return ShapeUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLUtils\", function() { return WebGLUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WireframeGeometry\", function() { return WireframeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParametricGeometry\", function() { return ParametricGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParametricBufferGeometry\", function() { return ParametricBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TetrahedronGeometry\", function() { return TetrahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TetrahedronBufferGeometry\", function() { return TetrahedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OctahedronGeometry\", function() { return OctahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OctahedronBufferGeometry\", function() { return OctahedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IcosahedronGeometry\", function() { return IcosahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IcosahedronBufferGeometry\", function() { return IcosahedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DodecahedronGeometry\", function() { return DodecahedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DodecahedronBufferGeometry\", function() { return DodecahedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolyhedronGeometry\", function() { return PolyhedronGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolyhedronBufferGeometry\", function() { return PolyhedronBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TubeGeometry\", function() { return TubeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TubeBufferGeometry\", function() { return TubeBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusKnotGeometry\", function() { return TorusKnotGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusKnotBufferGeometry\", function() { return TorusKnotBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusGeometry\", function() { return TorusGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusBufferGeometry\", function() { return TorusBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextGeometry\", function() { return TextGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextBufferGeometry\", function() { return TextBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphereGeometry\", function() { return SphereGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphereBufferGeometry\", function() { return SphereBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RingGeometry\", function() { return RingGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RingBufferGeometry\", function() { return RingBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneGeometry\", function() { return PlaneGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneBufferGeometry\", function() { return PlaneBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatheGeometry\", function() { return LatheGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatheBufferGeometry\", function() { return LatheBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeGeometry\", function() { return ShapeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeBufferGeometry\", function() { return ShapeBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtrudeGeometry\", function() { return ExtrudeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtrudeBufferGeometry\", function() { return ExtrudeBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgesGeometry\", function() { return EdgesGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConeGeometry\", function() { return ConeGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConeBufferGeometry\", function() { return ConeBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CylinderGeometry\", function() { return CylinderGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CylinderBufferGeometry\", function() { return CylinderBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CircleGeometry\", function() { return CircleGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CircleBufferGeometry\", function() { return CircleBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxGeometry\", function() { return BoxGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeGeometry\", function() { return BoxGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxBufferGeometry\", function() { return BoxBufferGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShadowMaterial\", function() { return ShadowMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpriteMaterial\", function() { return SpriteMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RawShaderMaterial\", function() { return RawShaderMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderMaterial\", function() { return ShaderMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointsMaterial\", function() { return PointsMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshPhysicalMaterial\", function() { return MeshPhysicalMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshStandardMaterial\", function() { return MeshStandardMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshPhongMaterial\", function() { return MeshPhongMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshToonMaterial\", function() { return MeshToonMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshNormalMaterial\", function() { return MeshNormalMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshLambertMaterial\", function() { return MeshLambertMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshDepthMaterial\", function() { return MeshDepthMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshDistanceMaterial\", function() { return MeshDistanceMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshBasicMaterial\", function() { return MeshBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshMatcapMaterial\", function() { return MeshMatcapMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineDashedMaterial\", function() { return LineDashedMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineBasicMaterial\", function() { return LineBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Material\", function() { return Material; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float64BufferAttribute\", function() { return Float64BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float32BufferAttribute\", function() { return Float32BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint32BufferAttribute\", function() { return Uint32BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int32BufferAttribute\", function() { return Int32BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint16BufferAttribute\", function() { return Uint16BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int16BufferAttribute\", function() { return Int16BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8ClampedBufferAttribute\", function() { return Uint8ClampedBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8BufferAttribute\", function() { return Uint8BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int8BufferAttribute\", function() { return Int8BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferAttribute\", function() { return BufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArcCurve\", function() { return ArcCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CatmullRomCurve3\", function() { return CatmullRomCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubicBezierCurve\", function() { return CubicBezierCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubicBezierCurve3\", function() { return CubicBezierCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EllipseCurve\", function() { return EllipseCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineCurve\", function() { return LineCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineCurve3\", function() { return LineCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuadraticBezierCurve\", function() { return QuadraticBezierCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QuadraticBezierCurve3\", function() { return QuadraticBezierCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SplineCurve\", function() { return SplineCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"REVISION\", function() { return REVISION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MOUSE\", function() { return MOUSE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceNone\", function() { return CullFaceNone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceBack\", function() { return CullFaceBack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceFront\", function() { return CullFaceFront; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CullFaceFrontBack\", function() { return CullFaceFrontBack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FrontFaceDirectionCW\", function() { return FrontFaceDirectionCW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FrontFaceDirectionCCW\", function() { return FrontFaceDirectionCCW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicShadowMap\", function() { return BasicShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PCFShadowMap\", function() { return PCFShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PCFSoftShadowMap\", function() { return PCFSoftShadowMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FrontSide\", function() { return FrontSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BackSide\", function() { return BackSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DoubleSide\", function() { return DoubleSide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlatShading\", function() { return FlatShading; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SmoothShading\", function() { return SmoothShading; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoColors\", function() { return NoColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FaceColors\", function() { return FaceColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexColors\", function() { return VertexColors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoBlending\", function() { return NoBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NormalBlending\", function() { return NormalBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AdditiveBlending\", function() { return AdditiveBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubtractiveBlending\", function() { return SubtractiveBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiplyBlending\", function() { return MultiplyBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CustomBlending\", function() { return CustomBlending; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddEquation\", function() { return AddEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubtractEquation\", function() { return SubtractEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReverseSubtractEquation\", function() { return ReverseSubtractEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MinEquation\", function() { return MinEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MaxEquation\", function() { return MaxEquation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroFactor\", function() { return ZeroFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneFactor\", function() { return OneFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SrcColorFactor\", function() { return SrcColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusSrcColorFactor\", function() { return OneMinusSrcColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SrcAlphaFactor\", function() { return SrcAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusSrcAlphaFactor\", function() { return OneMinusSrcAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DstAlphaFactor\", function() { return DstAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusDstAlphaFactor\", function() { return OneMinusDstAlphaFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DstColorFactor\", function() { return DstColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMinusDstColorFactor\", function() { return OneMinusDstColorFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SrcAlphaSaturateFactor\", function() { return SrcAlphaSaturateFactor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NeverDepth\", function() { return NeverDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlwaysDepth\", function() { return AlwaysDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LessDepth\", function() { return LessDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LessEqualDepth\", function() { return LessEqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EqualDepth\", function() { return EqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GreaterEqualDepth\", function() { return GreaterEqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GreaterDepth\", function() { return GreaterDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotEqualDepth\", function() { return NotEqualDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiplyOperation\", function() { return MultiplyOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MixOperation\", function() { return MixOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddOperation\", function() { return AddOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoToneMapping\", function() { return NoToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearToneMapping\", function() { return LinearToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReinhardToneMapping\", function() { return ReinhardToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uncharted2ToneMapping\", function() { return Uncharted2ToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CineonToneMapping\", function() { return CineonToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ACESFilmicToneMapping\", function() { return ACESFilmicToneMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UVMapping\", function() { return UVMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeReflectionMapping\", function() { return CubeReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeRefractionMapping\", function() { return CubeRefractionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EquirectangularReflectionMapping\", function() { return EquirectangularReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EquirectangularRefractionMapping\", function() { return EquirectangularRefractionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphericalReflectionMapping\", function() { return SphericalReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeUVReflectionMapping\", function() { return CubeUVReflectionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CubeUVRefractionMapping\", function() { return CubeUVRefractionMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RepeatWrapping\", function() { return RepeatWrapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClampToEdgeWrapping\", function() { return ClampToEdgeWrapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MirroredRepeatWrapping\", function() { return MirroredRepeatWrapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestFilter\", function() { return NearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestMipMapNearestFilter\", function() { return NearestMipMapNearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NearestMipMapLinearFilter\", function() { return NearestMipMapLinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearFilter\", function() { return LinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearMipMapNearestFilter\", function() { return LinearMipMapNearestFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearMipMapLinearFilter\", function() { return LinearMipMapLinearFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedByteType\", function() { return UnsignedByteType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ByteType\", function() { return ByteType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShortType\", function() { return ShortType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShortType\", function() { return UnsignedShortType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IntType\", function() { return IntType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedIntType\", function() { return UnsignedIntType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FloatType\", function() { return FloatType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HalfFloatType\", function() { return HalfFloatType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShort4444Type\", function() { return UnsignedShort4444Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShort5551Type\", function() { return UnsignedShort5551Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedShort565Type\", function() { return UnsignedShort565Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsignedInt248Type\", function() { return UnsignedInt248Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlphaFormat\", function() { return AlphaFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBFormat\", function() { return RGBFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBAFormat\", function() { return RGBAFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LuminanceFormat\", function() { return LuminanceFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LuminanceAlphaFormat\", function() { return LuminanceAlphaFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBEFormat\", function() { return RGBEFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DepthFormat\", function() { return DepthFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DepthStencilFormat\", function() { return DepthStencilFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RedFormat\", function() { return RedFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_S3TC_DXT1_Format\", function() { return RGB_S3TC_DXT1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_S3TC_DXT1_Format\", function() { return RGBA_S3TC_DXT1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_S3TC_DXT3_Format\", function() { return RGBA_S3TC_DXT3_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_S3TC_DXT5_Format\", function() { return RGBA_S3TC_DXT5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_PVRTC_4BPPV1_Format\", function() { return RGB_PVRTC_4BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_PVRTC_2BPPV1_Format\", function() { return RGB_PVRTC_2BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_PVRTC_4BPPV1_Format\", function() { return RGBA_PVRTC_4BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_PVRTC_2BPPV1_Format\", function() { return RGBA_PVRTC_2BPPV1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGB_ETC1_Format\", function() { return RGB_ETC1_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_4x4_Format\", function() { return RGBA_ASTC_4x4_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_5x4_Format\", function() { return RGBA_ASTC_5x4_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_5x5_Format\", function() { return RGBA_ASTC_5x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_6x5_Format\", function() { return RGBA_ASTC_6x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_6x6_Format\", function() { return RGBA_ASTC_6x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_8x5_Format\", function() { return RGBA_ASTC_8x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_8x6_Format\", function() { return RGBA_ASTC_8x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_8x8_Format\", function() { return RGBA_ASTC_8x8_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x5_Format\", function() { return RGBA_ASTC_10x5_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x6_Format\", function() { return RGBA_ASTC_10x6_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x8_Format\", function() { return RGBA_ASTC_10x8_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_10x10_Format\", function() { return RGBA_ASTC_10x10_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_12x10_Format\", function() { return RGBA_ASTC_12x10_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBA_ASTC_12x12_Format\", function() { return RGBA_ASTC_12x12_Format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoopOnce\", function() { return LoopOnce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoopRepeat\", function() { return LoopRepeat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoopPingPong\", function() { return LoopPingPong; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolateDiscrete\", function() { return InterpolateDiscrete; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolateLinear\", function() { return InterpolateLinear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolateSmooth\", function() { return InterpolateSmooth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroCurvatureEnding\", function() { return ZeroCurvatureEnding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ZeroSlopeEnding\", function() { return ZeroSlopeEnding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WrapAroundEnding\", function() { return WrapAroundEnding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TrianglesDrawMode\", function() { return TrianglesDrawMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriangleStripDrawMode\", function() { return TriangleStripDrawMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriangleFanDrawMode\", function() { return TriangleFanDrawMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearEncoding\", function() { return LinearEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sRGBEncoding\", function() { return sRGBEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GammaEncoding\", function() { return GammaEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBEEncoding\", function() { return RGBEEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LogLuvEncoding\", function() { return LogLuvEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBM7Encoding\", function() { return RGBM7Encoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBM16Encoding\", function() { return RGBM16Encoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBDEncoding\", function() { return RGBDEncoding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicDepthPacking\", function() { return BasicDepthPacking; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBADepthPacking\", function() { return RGBADepthPacking; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TangentSpaceNormalMap\", function() { return TangentSpaceNormalMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObjectSpaceNormalMap\", function() { return ObjectSpaceNormalMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Face4\", function() { return Face4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineStrip\", function() { return LineStrip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinePieces\", function() { return LinePieces; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshFaceMaterial\", function() { return MeshFaceMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiMaterial\", function() { return MultiMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointCloud\", function() { return PointCloud; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Particle\", function() { return Particle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleSystem\", function() { return ParticleSystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointCloudMaterial\", function() { return PointCloudMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleBasicMaterial\", function() { return ParticleBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleSystemMaterial\", function() { return ParticleSystemMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vertex\", function() { return Vertex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DynamicBufferAttribute\", function() { return DynamicBufferAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int8Attribute\", function() { return Int8Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8Attribute\", function() { return Uint8Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8ClampedAttribute\", function() { return Uint8ClampedAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int16Attribute\", function() { return Int16Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint16Attribute\", function() { return Uint16Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int32Attribute\", function() { return Int32Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint32Attribute\", function() { return Uint32Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float32Attribute\", function() { return Float32Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Float64Attribute\", function() { return Float64Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClosedSplineCurve3\", function() { return ClosedSplineCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SplineCurve3\", function() { return SplineCurve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Spline\", function() { return Spline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AxisHelper\", function() { return AxisHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundingBoxHelper\", function() { return BoundingBoxHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgesHelper\", function() { return EdgesHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WireframeHelper\", function() { return WireframeHelper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XHRLoader\", function() { return XHRLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryTextureLoader\", function() { return BinaryTextureLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeometryUtils\", function() { return GeometryUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Projector\", function() { return Projector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasRenderer\", function() { return CanvasRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JSONLoader\", function() { return JSONLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SceneUtils\", function() { return SceneUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LensFlare\", function() { return LensFlare; });\n// Polyfills\n\nif ( Number.EPSILON === undefined ) {\n\n\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n}\n\nif ( Number.isInteger === undefined ) {\n\n\t// Missing in IE\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n\n\tNumber.isInteger = function ( value ) {\n\n\t\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\n\n\t};\n\n}\n\n//\n\nif ( Math.sign === undefined ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\tMath.sign = function ( x ) {\n\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t};\n\n}\n\nif ( 'name' in Function.prototype === false ) {\n\n\t// Missing in IE\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\tget: function () {\n\n\t\t\treturn this.toString().match( /^\\s*function\\s*([^\\(\\s]*)/ )[ 1 ];\n\n\t\t}\n\n\t} );\n\n}\n\nif ( Object.assign === undefined ) {\n\n\t// Missing in IE\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t( function () {\n\n\t\tObject.assign = function ( target ) {\n\n\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t}\n\n\t\t\tvar output = Object( target );\n\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t};\n\n\t} )();\n\n}\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nfunction EventDispatcher() {}\n\nObject.assign( EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tvar array = listenerArray.slice( 0 );\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\nvar REVISION = '101';\nvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\nvar CullFaceNone = 0;\nvar CullFaceBack = 1;\nvar CullFaceFront = 2;\nvar CullFaceFrontBack = 3;\nvar FrontFaceDirectionCW = 0;\nvar FrontFaceDirectionCCW = 1;\nvar BasicShadowMap = 0;\nvar PCFShadowMap = 1;\nvar PCFSoftShadowMap = 2;\nvar FrontSide = 0;\nvar BackSide = 1;\nvar DoubleSide = 2;\nvar FlatShading = 1;\nvar SmoothShading = 2;\nvar NoColors = 0;\nvar FaceColors = 1;\nvar VertexColors = 2;\nvar NoBlending = 0;\nvar NormalBlending = 1;\nvar AdditiveBlending = 2;\nvar SubtractiveBlending = 3;\nvar MultiplyBlending = 4;\nvar CustomBlending = 5;\nvar AddEquation = 100;\nvar SubtractEquation = 101;\nvar ReverseSubtractEquation = 102;\nvar MinEquation = 103;\nvar MaxEquation = 104;\nvar ZeroFactor = 200;\nvar OneFactor = 201;\nvar SrcColorFactor = 202;\nvar OneMinusSrcColorFactor = 203;\nvar SrcAlphaFactor = 204;\nvar OneMinusSrcAlphaFactor = 205;\nvar DstAlphaFactor = 206;\nvar OneMinusDstAlphaFactor = 207;\nvar DstColorFactor = 208;\nvar OneMinusDstColorFactor = 209;\nvar SrcAlphaSaturateFactor = 210;\nvar NeverDepth = 0;\nvar AlwaysDepth = 1;\nvar LessDepth = 2;\nvar LessEqualDepth = 3;\nvar EqualDepth = 4;\nvar GreaterEqualDepth = 5;\nvar GreaterDepth = 6;\nvar NotEqualDepth = 7;\nvar MultiplyOperation = 0;\nvar MixOperation = 1;\nvar AddOperation = 2;\nvar NoToneMapping = 0;\nvar LinearToneMapping = 1;\nvar ReinhardToneMapping = 2;\nvar Uncharted2ToneMapping = 3;\nvar CineonToneMapping = 4;\nvar ACESFilmicToneMapping = 5;\n\nvar UVMapping = 300;\nvar CubeReflectionMapping = 301;\nvar CubeRefractionMapping = 302;\nvar EquirectangularReflectionMapping = 303;\nvar EquirectangularRefractionMapping = 304;\nvar SphericalReflectionMapping = 305;\nvar CubeUVReflectionMapping = 306;\nvar CubeUVRefractionMapping = 307;\nvar RepeatWrapping = 1000;\nvar ClampToEdgeWrapping = 1001;\nvar MirroredRepeatWrapping = 1002;\nvar NearestFilter = 1003;\nvar NearestMipMapNearestFilter = 1004;\nvar NearestMipMapLinearFilter = 1005;\nvar LinearFilter = 1006;\nvar LinearMipMapNearestFilter = 1007;\nvar LinearMipMapLinearFilter = 1008;\nvar UnsignedByteType = 1009;\nvar ByteType = 1010;\nvar ShortType = 1011;\nvar UnsignedShortType = 1012;\nvar IntType = 1013;\nvar UnsignedIntType = 1014;\nvar FloatType = 1015;\nvar HalfFloatType = 1016;\nvar UnsignedShort4444Type = 1017;\nvar UnsignedShort5551Type = 1018;\nvar UnsignedShort565Type = 1019;\nvar UnsignedInt248Type = 1020;\nvar AlphaFormat = 1021;\nvar RGBFormat = 1022;\nvar RGBAFormat = 1023;\nvar LuminanceFormat = 1024;\nvar LuminanceAlphaFormat = 1025;\nvar RGBEFormat = RGBAFormat;\nvar DepthFormat = 1026;\nvar DepthStencilFormat = 1027;\nvar RedFormat = 1028;\nvar RGB_S3TC_DXT1_Format = 33776;\nvar RGBA_S3TC_DXT1_Format = 33777;\nvar RGBA_S3TC_DXT3_Format = 33778;\nvar RGBA_S3TC_DXT5_Format = 33779;\nvar RGB_PVRTC_4BPPV1_Format = 35840;\nvar RGB_PVRTC_2BPPV1_Format = 35841;\nvar RGBA_PVRTC_4BPPV1_Format = 35842;\nvar RGBA_PVRTC_2BPPV1_Format = 35843;\nvar RGB_ETC1_Format = 36196;\nvar RGBA_ASTC_4x4_Format = 37808;\nvar RGBA_ASTC_5x4_Format = 37809;\nvar RGBA_ASTC_5x5_Format = 37810;\nvar RGBA_ASTC_6x5_Format = 37811;\nvar RGBA_ASTC_6x6_Format = 37812;\nvar RGBA_ASTC_8x5_Format = 37813;\nvar RGBA_ASTC_8x6_Format = 37814;\nvar RGBA_ASTC_8x8_Format = 37815;\nvar RGBA_ASTC_10x5_Format = 37816;\nvar RGBA_ASTC_10x6_Format = 37817;\nvar RGBA_ASTC_10x8_Format = 37818;\nvar RGBA_ASTC_10x10_Format = 37819;\nvar RGBA_ASTC_12x10_Format = 37820;\nvar RGBA_ASTC_12x12_Format = 37821;\nvar LoopOnce = 2200;\nvar LoopRepeat = 2201;\nvar LoopPingPong = 2202;\nvar InterpolateDiscrete = 2300;\nvar InterpolateLinear = 2301;\nvar InterpolateSmooth = 2302;\nvar ZeroCurvatureEnding = 2400;\nvar ZeroSlopeEnding = 2401;\nvar WrapAroundEnding = 2402;\nvar TrianglesDrawMode = 0;\nvar TriangleStripDrawMode = 1;\nvar TriangleFanDrawMode = 2;\nvar LinearEncoding = 3000;\nvar sRGBEncoding = 3001;\nvar GammaEncoding = 3007;\nvar RGBEEncoding = 3002;\nvar LogLuvEncoding = 3003;\nvar RGBM7Encoding = 3004;\nvar RGBM16Encoding = 3005;\nvar RGBDEncoding = 3006;\nvar BasicDepthPacking = 3200;\nvar RGBADepthPacking = 3201;\nvar TangentSpaceNormalMap = 0;\nvar ObjectSpaceNormalMap = 1;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar _Math = {\n\n\tDEG2RAD: Math.PI / 180,\n\tRAD2DEG: 180 / Math.PI,\n\n\tgenerateUUID: ( function () {\n\n\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\t\tvar lut = [];\n\n\t\tfor ( var i = 0; i < 256; i ++ ) {\n\n\t\t\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\n\n\t\t}\n\n\t\treturn function generateUUID() {\n\n\t\t\tvar d0 = Math.random() * 0xffffffff | 0;\n\t\t\tvar d1 = Math.random() * 0xffffffff | 0;\n\t\t\tvar d2 = Math.random() * 0xffffffff | 0;\n\t\t\tvar d3 = Math.random() * 0xffffffff | 0;\n\t\t\tvar uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\n\t\t\t\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\n\n\t\t\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\n\t\t\treturn uuid.toUpperCase();\n\n\t\t};\n\n\t} )(),\n\n\tclamp: function ( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t},\n\n\t// compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\teuclideanModulo: function ( n, m ) {\n\n\t\treturn ( ( n % m ) + m ) % m;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\tlerp: function ( x, y, t ) {\n\n\t\treturn ( 1 - t ) * x + t * y;\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * ( 3 - 2 * x );\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tdegToRad: function ( degrees ) {\n\n\t\treturn degrees * _Math.DEG2RAD;\n\n\t},\n\n\tradToDeg: function ( radians ) {\n\n\t\treturn radians * _Math.RAD2DEG;\n\n\t},\n\n\tisPowerOfTwo: function ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t},\n\n\tceilPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tfloorPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nfunction Vector2( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n}\n\nObject.defineProperties( Vector2.prototype, {\n\n\t\"width\": {\n\n\t\tget: function () {\n\n\t\t\treturn this.x;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.x = value;\n\n\t\t}\n\n\t},\n\n\t\"height\": {\n\n\t\tget: function () {\n\n\t\t\treturn this.y;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis.y = value;\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( Vector2.prototype, {\n\n\tisVector2: true,\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min = new Vector2();\n\t\tvar max = new Vector2();\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tmin.set( minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tcross: function ( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tmanhattanLength: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t},\n\n\tangle: function () {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\treturn angle;\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tmanhattanDistanceTo: function ( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t},\n\n\tfromBufferAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t},\n\n\trotateAround: function ( center, angle ) {\n\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tvar x = this.x - center.x;\n\t\tvar y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Matrix4() {\n\n\tthis.elements = [\n\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\n\t];\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n}\n\nObject.assign( Matrix4.prototype, {\n\n\tisMatrix4: true,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function extractRotation( m ) {\n\n\t\t\t// this method does not support reflection matrices\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\t\tte[ 3 ] = 0;\n\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\t\tte[ 7 ] = 0;\n\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationFromQuaternion: function () {\n\n\t\tvar zero = new Vector3( 0, 0, 0 );\n\t\tvar one = new Vector3( 1, 1, 1 );\n\n\t\treturn function makeRotationFromQuaternion( q ) {\n\n\t\t\treturn this.compose( zero, q, one );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar x = new Vector3();\n\t\tvar y = new Vector3();\n\t\tvar z = new Vector3();\n\n\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target );\n\n\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\t// eye and target are in the same position\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tz.normalize();\n\t\t\tx.crossVectors( up, z );\n\n\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\t// up and z are parallel\n\n\t\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t\tz.x += 0.0001;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz.z += 0.0001;\n\n\t\t\t\t}\n\n\t\t\t\tz.normalize();\n\t\t\t\tx.crossVectors( up, z );\n\n\t\t\t}\n\n\t\t\tx.normalize();\n\t\t\ty.crossVectors( z, x );\n\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tapplyToBufferAttribute: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function applyToBufferAttribute( attribute ) {\n\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\tv1.x = attribute.getX( i );\n\t\t\t\tv1.y = attribute.getY( i );\n\t\t\t\tv1.z = attribute.getZ( i );\n\n\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn attribute;\n\n\t\t};\n\n\t}(),\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 12 ] = v.x;\n\t\tte[ 13 ] = v.y;\n\t\tte[ 14 ] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements,\n\t\t\tme = m.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeShear: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, y, z, 0,\n\t\t\tx, 1, z, 0,\n\t\t\tx, y, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tvar x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tvar sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t        te[ 1 ] = ( xy + wz ) * sx;\n\t        te[ 2 ] = ( xz - wy ) * sx;\n\t        te[ 3 ] = 0;\n\n\t        te[ 4 ] = ( xy - wz ) * sy;\n\t        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t        te[ 6 ] = ( yz + wx ) * sy;\n\t        te[ 7 ] = 0;\n\n\t        te[ 8 ] = ( xz + wy ) * sz;\n\t        te[ 9 ] = ( yz - wx ) * sz;\n\t        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t        te[ 11 ] = 0;\n\n\t        te[ 12 ] = position.x;\n\t        te[ 13 ] = position.y;\n\t        te[ 14 ] = position.z;\n\t        te[ 15 ] = 1;\n\n\t        return this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector = new Vector3();\n\t\tvar matrix = new Matrix4();\n\n\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif ( det < 0 ) sx = - sx;\n\n\t\t\tposition.x = te[ 12 ];\n\t\t\tposition.y = te[ 13 ];\n\t\t\tposition.z = te[ 14 ];\n\n\t\t\t// scale the rotation part\n\t\t\tmatrix.copy( this );\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakePerspective: function ( left, right, top, bottom, near, far ) {\n\n\t\tif ( far === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = 1.0 / ( right - left );\n\t\tvar h = 1.0 / ( top - bottom );\n\t\tvar p = 1.0 / ( far - near );\n\n\t\tvar x = ( right + left ) * w;\n\t\tvar y = ( top + bottom ) * h;\n\t\tvar z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nfunction Quaternion( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n}\n\nObject.assign( Quaternion, {\n\n\tslerp: function ( qa, qb, qm, t ) {\n\n\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t},\n\n\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tvar s = 1 - t,\n\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tvar tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n} );\n\nObject.defineProperties( Quaternion.prototype, {\n\n\tx: {\n\n\t\tget: function () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t}\n\n\t},\n\n\ty: {\n\n\t\tget: function () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t}\n\n\t},\n\n\tz: {\n\n\t\tget: function () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t}\n\n\t},\n\n\tw: {\n\n\t\tget: function () {\n\n\t\t\treturn this._w;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._w = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( Quaternion.prototype, {\n\n\tisQuaternion: true,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar cos = Math.cos;\n\t\tvar sin = Math.sin;\n\n\t\tvar c1 = cos( x / 2 );\n\t\tvar c2 = cos( y / 2 );\n\t\tvar c3 = cos( z / 2 );\n\n\t\tvar s1 = sin( x / 2 );\n\t\tvar s2 = sin( y / 2 );\n\t\tvar s3 = sin( z / 2 );\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromUnitVectors: function () {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tvar v1 = new Vector3();\n\t\tvar r;\n\n\t\tvar EPS = 0.000001;\n\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\n\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\tif ( r < EPS ) {\n\n\t\t\t\tr = 0;\n\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t}\n\n\t\t\tthis._x = v1.x;\n\t\t\tthis._y = v1.y;\n\t\t\tthis._z = v1.z;\n\t\t\tthis._w = r;\n\n\t\t\treturn this.normalize();\n\n\t\t};\n\n\t}(),\n\n\tangleTo: function ( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t},\n\n\trotateTowards: function ( q, step ) {\n\n\t\tvar angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tvar t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t},\n\n\tinverse: function () {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tpremultiply: function ( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tvar s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\treturn this.normalize();\n\n\t\t}\n\n\t\tvar sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Vector3( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n}\n\nObject.assign( Vector3.prototype, {\n\n\tisVector3: true,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function applyEuler( euler ) {\n\n\t\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix = qw * x + qy * z - qz * y;\n\t\tvar iy = qw * y + qz * x - qx * z;\n\t\tvar iz = qw * z + qx * y - qy * x;\n\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t},\n\n\tproject: function ( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t},\n\n\tunproject: function () {\n\n\t\tvar matrix = new Matrix4();\n\n\t\treturn function unproject( camera ) {\n\n\t\t\treturn this.applyMatrix4( matrix.getInverse( camera.projectionMatrix ) ).applyMatrix4( camera.matrixWorld );\n\n\t\t};\n\n\t}(),\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min = new Vector3();\n\t\tvar max = new Vector3();\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\t// TODO lengthSquared?\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tmanhattanLength: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\treturn this.crossVectors( this, v );\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tprojectOnVector: function ( vector ) {\n\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\n\t},\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t};\n\n\t}(),\n\n\treflect: function () {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function reflect( normal ) {\n\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t};\n\n\t}(),\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tmanhattanDistanceTo: function ( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t},\n\n\tsetFromSpherical: function ( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t},\n\n\tsetFromSphericalCoords: function ( radius, phi, theta ) {\n\n\t\tvar sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCylindrical: function ( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t},\n\n\tsetFromCylindricalCoords: function ( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t},\n\n\tfromBufferAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author tschw\n */\n\nfunction Matrix3() {\n\n\tthis.elements = [\n\n\t\t1, 0, 0,\n\t\t0, 1, 0,\n\t\t0, 0, 1\n\n\t];\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n}\n\nObject.assign( Matrix3.prototype, {\n\n\tisMatrix3: true,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix4: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tapplyToBufferAttribute: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function applyToBufferAttribute( attribute ) {\n\n\t\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\tv1.x = attribute.getX( i );\n\t\t\t\tv1.y = attribute.getY( i );\n\t\t\t\tv1.z = attribute.getZ( i );\n\n\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn attribute;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\tif ( matrix && matrix.isMatrix4 ) {\n\n\t\t\tconsole.error( \"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\" );\n\n\t\t}\n\n\t\tvar me = matrix.elements,\n\t\t\tte = this.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate === true ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tvar c = Math.cos( rotation );\n\t\tvar s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t},\n\n\tscale: function ( sx, sy ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\n\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\n\n\t\treturn this;\n\n\t},\n\n\trotate: function ( theta ) {\n\n\t\tvar c = Math.cos( theta );\n\t\tvar s = Math.sin( theta );\n\n\t\tvar te = this.elements;\n\n\t\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\n\t\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\n\n\t\tte[ 0 ] = c * a11 + s * a21;\n\t\tte[ 3 ] = c * a12 + s * a22;\n\t\tte[ 6 ] = c * a13 + s * a23;\n\n\t\tte[ 1 ] = - s * a11 + c * a21;\n\t\tte[ 4 ] = - s * a12 + c * a22;\n\t\tte[ 7 ] = - s * a13 + c * a23;\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( tx, ty ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\n\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tfor ( var i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nvar _canvas;\n\nvar ImageUtils = {\n\n\tgetDataURL: function ( image ) {\n\n\t\tvar canvas;\n\n\t\tif ( typeof HTMLCanvasElement == 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t} else if ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tvar context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nvar textureId = 0;\n\nfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : RGBAFormat;\n\tthis.type = type !== undefined ? type : UnsignedByteType;\n\n\tthis.offset = new Vector2( 0, 0 );\n\tthis.repeat = new Vector2( 1, 1 );\n\tthis.center = new Vector2( 0, 0 );\n\tthis.rotation = 0;\n\n\tthis.matrixAutoUpdate = true;\n\tthis.matrix = new Matrix3();\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\n\nTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Texture,\n\n\tisTexture: true,\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tvar output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\ttype: this.type,\n\t\t\tencoding: this.encoding,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tvar image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = _Math.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tvar url;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\t// process array of images e.g. CubeTexture\n\n\t\t\t\t\turl = [];\n\n\t\t\t\t\tfor ( var i = 0, l = image.length; i < l; i ++ ) {\n\n\t\t\t\t\t\turl.push( ImageUtils.getDataURL( image[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// process single image\n\n\t\t\t\t\turl = ImageUtils.getDataURL( image );\n\n\t\t\t\t}\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: url\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n} );\n\nObject.defineProperty( Texture.prototype, \"needsUpdate\", {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Vector4( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n}\n\nObject.assign( Vector4.prototype, {\n\n\tisVector4: true,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new Vector4();\n\t\t\t\tmax = new Vector4();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tmanhattanLength: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t},\n\n\tfromBufferAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n * @author Marius Kintel / https://github.com/kintel\n */\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nfunction WebGLRenderTarget( width, height, options ) {\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.scissor = new Vector4( 0, 0, width, height );\n\tthis.scissorTest = false;\n\n\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\toptions = options || {};\n\n\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n}\n\nWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: WebGLRenderTarget,\n\n\tisWebGLRenderTarget: true,\n\n\tsetSize: function ( width, height ) {\n\n\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n * @author Matt DesLauriers / @mattdesl\n */\n\nfunction WebGLMultisampleRenderTarget( width, height, options ) {\n\n\tWebGLRenderTarget.call( this, width, height, options );\n\n\tthis.samples = 4;\n\n}\n\nWebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {\n\n\tconstructor: WebGLMultisampleRenderTarget,\n\n\tisWebGLMultisampleRenderTarget: true,\n\n\tcopy: function ( source ) {\n\n\t\tWebGLRenderTarget.prototype.copy.call( this, source );\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nfunction WebGLRenderTargetCube( width, height, options ) {\n\n\tWebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\tthis.activeMipMapLevel = 0;\n\n}\n\nWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\nWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\nWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { data: data, width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\tthis.generateMipmaps = false;\n\tthis.flipY = false;\n\tthis.unpackAlignment = 1;\n\n}\n\nDataTexture.prototype = Object.create( Texture.prototype );\nDataTexture.prototype.constructor = DataTexture;\n\nDataTexture.prototype.isDataTexture = true;\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Box3( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\n}\n\nObject.assign( Box3.prototype, {\n\n\tisBox3: true,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromArray: function ( array ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tvar x = array[ i ];\n\t\t\tvar y = array[ i + 1 ];\n\t\t\tvar z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromBufferAttribute: function ( attribute ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\tvar x = attribute.getX( i );\n\t\t\tvar y = attribute.getY( i );\n\t\t\tvar z = attribute.getZ( i );\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function ( object ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tgetCenter: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .getCenter() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tgetSize: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .getSize() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\texpandByObject: function () {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tvar scope, i, l;\n\n\t\tvar v1 = new Vector3();\n\n\t\tfunction traverse( node ) {\n\n\t\t\tvar geometry = node.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function expandByObject( object ) {\n\n\t\t\tscope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tobject.traverse( traverse );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t},\n\n\tgetParameter: function ( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .getParameter() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t},\n\n\tintersectsSphere: ( function () {\n\n\t\tvar closestPoint = new Vector3();\n\n\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t};\n\n\t} )(),\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tvar min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t},\n\n\tintersectsTriangle: ( function () {\n\n\t\t// triangle centered vertices\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\t// triangle edge vectors\n\t\tvar f0 = new Vector3();\n\t\tvar f1 = new Vector3();\n\t\tvar f2 = new Vector3();\n\n\t\tvar testAxis = new Vector3();\n\n\t\tvar center = new Vector3();\n\t\tvar extents = new Vector3();\n\n\t\tvar triangleNormal = new Vector3();\n\n\t\tfunction satForAxes( axes ) {\n\n\t\t\tvar i, j;\n\n\t\t\tfor ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t\t\ttestAxis.fromArray( axes, i );\n\t\t\t\t// project the aabb onto the seperating axis\n\t\t\t\tvar r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );\n\t\t\t\t// project all 3 vertices of the triangle onto the seperating axis\n\t\t\t\tvar p0 = v0.dot( testAxis );\n\t\t\t\tvar p1 = v1.dot( testAxis );\n\t\t\t\tvar p2 = v2.dot( testAxis );\n\t\t\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\t\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t\t\t// the axis is seperating and we can exit\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn function intersectsTriangle( triangle ) {\n\n\t\t\tif ( this.isEmpty() ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// compute box center and extents\n\t\t\tthis.getCenter( center );\n\t\t\textents.subVectors( this.max, center );\n\n\t\t\t// translate triangle to aabb origin\n\t\t\tv0.subVectors( triangle.a, center );\n\t\t\tv1.subVectors( triangle.b, center );\n\t\t\tv2.subVectors( triangle.c, center );\n\n\t\t\t// compute edge vectors for triangle\n\t\t\tf0.subVectors( v1, v0 );\n\t\t\tf1.subVectors( v2, v1 );\n\t\t\tf2.subVectors( v0, v2 );\n\n\t\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\t\tvar axes = [\n\t\t\t\t0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,\n\t\t\t\tf0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,\n\t\t\t\t- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0\n\t\t\t];\n\t\t\tif ( ! satForAxes( axes ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// test 3 face normals from the aabb\n\t\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\t\tif ( ! satForAxes( axes ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// finally testing the face normal of the triangle\n\t\t\t// use already existing triangle edge vectors here\n\t\t\ttriangleNormal.crossVectors( f0, f1 );\n\t\t\taxes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];\n\t\t\treturn satForAxes( axes );\n\n\t\t};\n\n\t} )(),\n\n\tclampPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box3: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function getBoundingSphere( target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Box3: .getBoundingSphere() target is now required' );\n\t\t\t\ttarget = new Sphere();\n\n\t\t\t}\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( v1 ).length() * 0.5;\n\n\t\t\treturn target;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar points = [\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3(),\n\t\t\tnew Vector3()\n\t\t];\n\n\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif ( this.isEmpty() ) return this;\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Sphere( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n}\n\nObject.assign( Sphere.prototype, {\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).getCenter( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t},\n\n\tclampPoint: function ( point, target ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t},\n\n\tgetBoundingBox: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );\n\t\t\ttarget = new Box3();\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n */\n\nfunction Plane( normal, constant ) {\n\n\t// normal is assumed to be normalized\n\n\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n}\n\nObject.assign( Plane.prototype, {\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t},\n\n\tintersectLine: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function intersectLine( line, target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\treturn target.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar m1 = new Matrix3();\n\n\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://clara.io\n */\n\nfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new Plane(),\n\t\t( p1 !== undefined ) ? p1 : new Plane(),\n\t\t( p2 !== undefined ) ? p2 : new Plane(),\n\t\t( p3 !== undefined ) ? p3 : new Plane(),\n\t\t( p4 !== undefined ) ? p4 : new Plane(),\n\t\t( p5 !== undefined ) ? p5 : new Plane()\n\n\t];\n\n}\n\nObject.assign( Frustum.prototype, {\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new Sphere();\n\n\t\treturn function intersectsObject( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSprite: function () {\n\n\t\tvar sphere = new Sphere();\n\n\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = - sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox: function () {\n\n\t\tvar p = new Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\t// corner at max distance\n\n\t\t\t\tp.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tif ( plane.distanceToPoint( p ) < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t}(),\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n} );\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\n\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\n\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\";\n\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar begin_vertex = \"vec3 transformed = vec3( position );\";\n\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\";\n\nvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotNV );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\";\n\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\n\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\";\n\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\";\n\nvar color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\nvar common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\";\n\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\";\n\nvar defaultnormal_vertex = \"vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\";\n\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\";\n\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\nvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\nvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\n\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\treflectVec = normalize( reflectVec );\\n\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = -mvPosition.z;\\n#endif\";\n\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\";\n\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\nvar gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\";\n\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar lights_pars_begin = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t\\tfloat shadowCameraNear;\\n\\t\\tfloat shadowCameraFar;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\nvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\";\n\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\";\n\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#endif\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearCoatInv = 1.0 - clearCoatDHR;\\n\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec3 singleScattering = vec3( 0.0 );\\n\\t\\tvec3 multiScattering = vec3( 0.0 );\\n\\t\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\t\\tvec3 diffuse = material.diffuseColor;\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\\n\\t\\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\\n\\t\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n\\t#else\\n\\t\\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\nvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n#endif\";\n\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#ifndef STANDARD\\n\\t\\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\\n\\t#endif\\n#endif\";\n\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\";\n\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n#endif\";\n\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\n\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\tgl_Position.z *= gl_Position.w;\\n\\t#endif\\n#endif\";\n\nvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\";\n\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\";\n\nvar map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform mat3 uvTransform;\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\";\n\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\";\n\nvar normal_fragment_begin = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t#endif\\n#endif\";\n\nvar normal_fragment_maps = \"#ifdef USE_NORMALMAP\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tnormal = - normal;\\n\\t\\t#endif\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t#endif\\n\\t\\tnormal = normalize( normalMatrix * normal );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\";\n\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\t#ifdef OBJECTSPACE_NORMALMAP\\n\\t\\tuniform mat3 normalMatrix;\\n\\t#else\\n\\t\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\t\\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\\n\\t\\t\\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\\n\\t\\t\\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\\n\\t\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\t\\tmapN.xy *= normalScale;\\n\\t\\t\\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\\t\\t\\treturn normalize( tsn * mapN );\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\n\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\nvar project_vertex = \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\";\n\nvar dithering_fragment = \"#if defined( DITHERING )\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\nvar dithering_pars_fragment = \"#if defined( DITHERING )\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\";\n\nvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\";\n\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\t#pragma unroll_loop\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\";\n\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\\n}\";\n\nvar uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\nvar uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\";\n\nvar uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\nvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\";\n\nvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\nvar cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\";\n\nvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\";\n\nvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\nvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\nvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\nvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\nvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\nvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nvar meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\n\nvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\nvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <fog_fragment>\\n}\";\n\nvar shadow_vert = \"#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nvar ShaderChunk = {\n\talphamap_fragment: alphamap_fragment,\n\talphamap_pars_fragment: alphamap_pars_fragment,\n\talphatest_fragment: alphatest_fragment,\n\taomap_fragment: aomap_fragment,\n\taomap_pars_fragment: aomap_pars_fragment,\n\tbegin_vertex: begin_vertex,\n\tbeginnormal_vertex: beginnormal_vertex,\n\tbsdfs: bsdfs,\n\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\tclipping_planes_fragment: clipping_planes_fragment,\n\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\tclipping_planes_vertex: clipping_planes_vertex,\n\tcolor_fragment: color_fragment,\n\tcolor_pars_fragment: color_pars_fragment,\n\tcolor_pars_vertex: color_pars_vertex,\n\tcolor_vertex: color_vertex,\n\tcommon: common,\n\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\tdefaultnormal_vertex: defaultnormal_vertex,\n\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\tdisplacementmap_vertex: displacementmap_vertex,\n\temissivemap_fragment: emissivemap_fragment,\n\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\tencodings_fragment: encodings_fragment,\n\tencodings_pars_fragment: encodings_pars_fragment,\n\tenvmap_fragment: envmap_fragment,\n\tenvmap_pars_fragment: envmap_pars_fragment,\n\tenvmap_pars_vertex: envmap_pars_vertex,\n\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\tenvmap_vertex: envmap_vertex,\n\tfog_vertex: fog_vertex,\n\tfog_pars_vertex: fog_pars_vertex,\n\tfog_fragment: fog_fragment,\n\tfog_pars_fragment: fog_pars_fragment,\n\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\tlightmap_fragment: lightmap_fragment,\n\tlightmap_pars_fragment: lightmap_pars_fragment,\n\tlights_lambert_vertex: lights_lambert_vertex,\n\tlights_pars_begin: lights_pars_begin,\n\tlights_phong_fragment: lights_phong_fragment,\n\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\tlights_physical_fragment: lights_physical_fragment,\n\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\tlights_fragment_begin: lights_fragment_begin,\n\tlights_fragment_maps: lights_fragment_maps,\n\tlights_fragment_end: lights_fragment_end,\n\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\tmap_fragment: map_fragment,\n\tmap_pars_fragment: map_pars_fragment,\n\tmap_particle_fragment: map_particle_fragment,\n\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\tmetalnessmap_fragment: metalnessmap_fragment,\n\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\tmorphnormal_vertex: morphnormal_vertex,\n\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\tmorphtarget_vertex: morphtarget_vertex,\n\tnormal_fragment_begin: normal_fragment_begin,\n\tnormal_fragment_maps: normal_fragment_maps,\n\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\tpacking: packing,\n\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\tproject_vertex: project_vertex,\n\tdithering_fragment: dithering_fragment,\n\tdithering_pars_fragment: dithering_pars_fragment,\n\troughnessmap_fragment: roughnessmap_fragment,\n\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\tshadowmap_vertex: shadowmap_vertex,\n\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\tskinbase_vertex: skinbase_vertex,\n\tskinning_pars_vertex: skinning_pars_vertex,\n\tskinning_vertex: skinning_vertex,\n\tskinnormal_vertex: skinnormal_vertex,\n\tspecularmap_fragment: specularmap_fragment,\n\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\ttonemapping_fragment: tonemapping_fragment,\n\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\tuv_pars_fragment: uv_pars_fragment,\n\tuv_pars_vertex: uv_pars_vertex,\n\tuv_vertex: uv_vertex,\n\tuv2_pars_fragment: uv2_pars_fragment,\n\tuv2_pars_vertex: uv2_pars_vertex,\n\tuv2_vertex: uv2_vertex,\n\tworldpos_vertex: worldpos_vertex,\n\n\tbackground_frag: background_frag,\n\tbackground_vert: background_vert,\n\tcube_frag: cube_frag,\n\tcube_vert: cube_vert,\n\tdepth_frag: depth_frag,\n\tdepth_vert: depth_vert,\n\tdistanceRGBA_frag: distanceRGBA_frag,\n\tdistanceRGBA_vert: distanceRGBA_vert,\n\tequirect_frag: equirect_frag,\n\tequirect_vert: equirect_vert,\n\tlinedashed_frag: linedashed_frag,\n\tlinedashed_vert: linedashed_vert,\n\tmeshbasic_frag: meshbasic_frag,\n\tmeshbasic_vert: meshbasic_vert,\n\tmeshlambert_frag: meshlambert_frag,\n\tmeshlambert_vert: meshlambert_vert,\n\tmeshmatcap_frag: meshmatcap_frag,\n\tmeshmatcap_vert: meshmatcap_vert,\n\tmeshphong_frag: meshphong_frag,\n\tmeshphong_vert: meshphong_vert,\n\tmeshphysical_frag: meshphysical_frag,\n\tmeshphysical_vert: meshphysical_vert,\n\tnormal_frag: normal_frag,\n\tnormal_vert: normal_vert,\n\tpoints_frag: points_frag,\n\tpoints_vert: points_vert,\n\tshadow_frag: shadow_frag,\n\tshadow_vert: shadow_vert,\n\tsprite_frag: sprite_frag,\n\tsprite_vert: sprite_vert\n};\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tvar dst = {};\n\n\tfor ( var u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( var p in src[ u ] ) {\n\n\t\t\tvar property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tvar merged = {};\n\n\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\tvar tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( var p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\n// Legacy\n\nvar UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nfunction Color( r, g, b ) {\n\n\tif ( g === undefined && b === undefined ) {\n\n\t\t// r is THREE.Color, hex or string\n\t\treturn this.set( r );\n\n\t}\n\n\treturn this.setRGB( r, g, b );\n\n}\n\nObject.assign( Color.prototype, {\n\n\tisColor: true,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value && value.isColor ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function () {\n\n\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\tif ( t < 0 ) t += 1;\n\t\t\tif ( t > 1 ) t -= 1;\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\treturn p;\n\n\t\t}\n\n\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = _Math.euclideanModulo( h, 1 );\n\t\t\ts = _Math.clamp( s, 0, 1 );\n\t\t\tl = _Math.clamp( l, 0, 1 );\n\n\t\t\tif ( s === 0 ) {\n\n\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t} else {\n\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetStyle: function ( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tvar color;\n\t\t\tvar name = m[ 1 ];\n\t\t\tvar components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tvar hex = m[ 1 ];\n\t\t\tvar size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\t// color keywords\n\t\t\tvar hex = ColorKeywords[ style ];\n\n\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t// red\n\t\t\t\tthis.setHex( hex );\n\n\t\t\t} else {\n\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function ( gammaFactor ) {\n\n\t\tthis.copyGammaToLinear( this, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function ( gammaFactor ) {\n\n\t\tthis.copyLinearToGamma( this, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopySRGBToLinear: function () {\n\n\t\tfunction SRGBToLinear( c ) {\n\n\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t}\n\n\t\treturn function copySRGBToLinear( color ) {\n\n\t\t\tthis.r = SRGBToLinear( color.r );\n\t\t\tthis.g = SRGBToLinear( color.g );\n\t\t\tthis.b = SRGBToLinear( color.b );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tcopyLinearToSRGB: function () {\n\n\t\tfunction LinearToSRGB( c ) {\n\n\t\t\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n\t\t}\n\n\t\treturn function copyLinearToSRGB( color ) {\n\n\t\t\tthis.r = LinearToSRGB( color.r );\n\t\t\tthis.g = LinearToSRGB( color.g );\n\t\t\tthis.b = LinearToSRGB( color.b );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tconvertSRGBToLinear: function () {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToSRGB: function () {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( target ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Color: .getHSL() target is now required' );\n\t\t\ttarget = { h: 0, s: 0, l: 0 };\n\n\t\t}\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function () {\n\n\t\tvar hsl = {};\n\n\t\treturn function ( h, s, l ) {\n\n\t\t\tthis.getHSL( hsl );\n\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpHSL: function () {\n\n\t\tvar hslA = { h: 0, s: 0, l: 0 };\n\t\tvar hslB = { h: 0, s: 0, l: 0 };\n\n\t\treturn function lerpHSL( color, alpha ) {\n\n\t\t\tthis.getHSL( hslA );\n\t\t\tcolor.getHSL( hslB );\n\n\t\t\tvar h = _Math.lerp( hslA.h, hslB.h, alpha );\n\t\t\tvar s = _Math.lerp( hslA.s, hslB.s, alpha );\n\t\t\tvar l = _Math.lerp( hslA.l, hslB.l, alpha );\n\n\t\t\tthis.setHSL( h, s, l );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\treturn this.getHex();\n\n\t}\n\n} );\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nvar UniformsLib = {\n\n\tcommon: {\n\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\topacity: { value: 1.0 },\n\n\t\tmap: { value: null },\n\t\tuvTransform: { value: new Matrix3() },\n\n\t\talphaMap: { value: null },\n\n\t},\n\n\tspecularmap: {\n\n\t\tspecularMap: { value: null },\n\n\t},\n\n\tenvmap: {\n\n\t\tenvMap: { value: null },\n\t\tflipEnvMap: { value: - 1 },\n\t\treflectivity: { value: 1.0 },\n\t\trefractionRatio: { value: 0.98 },\n\t\tmaxMipLevel: { value: 0 }\n\n\t},\n\n\taomap: {\n\n\t\taoMap: { value: null },\n\t\taoMapIntensity: { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\tlightMap: { value: null },\n\t\tlightMapIntensity: { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\temissiveMap: { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\tbumpMap: { value: null },\n\t\tbumpScale: { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\tnormalMap: { value: null },\n\t\tnormalScale: { value: new Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\tdisplacementMap: { value: null },\n\t\tdisplacementScale: { value: 1 },\n\t\tdisplacementBias: { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\troughnessMap: { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\tmetalnessMap: { value: null }\n\n\t},\n\n\tgradientmap: {\n\n\t\tgradientMap: { value: null }\n\n\t},\n\n\tfog: {\n\n\t\tfogDensity: { value: 0.00025 },\n\t\tfogNear: { value: 1 },\n\t\tfogFar: { value: 2000 },\n\t\tfogColor: { value: new Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\tambientLightColor: { value: [] },\n\n\t\tdirectionalLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tcolor: {},\n\n\t\t\tshadow: {},\n\t\t\tshadowBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tdirectionalShadowMap: { value: [] },\n\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\tspotLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdirection: {},\n\t\t\tdistance: {},\n\t\t\tconeCos: {},\n\t\t\tpenumbraCos: {},\n\t\t\tdecay: {},\n\n\t\t\tshadow: {},\n\t\t\tshadowBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tspotShadowMap: { value: [] },\n\t\tspotShadowMatrix: { value: [] },\n\n\t\tpointLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdecay: {},\n\t\t\tdistance: {},\n\n\t\t\tshadow: {},\n\t\t\tshadowBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {},\n\t\t\tshadowCameraNear: {},\n\t\t\tshadowCameraFar: {}\n\t\t} },\n\n\t\tpointShadowMap: { value: [] },\n\t\tpointShadowMatrix: { value: [] },\n\n\t\themisphereLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tskyColor: {},\n\t\t\tgroundColor: {}\n\t\t} },\n\n\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\trectAreaLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\twidth: {},\n\t\t\theight: {}\n\t\t} }\n\n\t},\n\n\tpoints: {\n\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\topacity: { value: 1.0 },\n\t\tsize: { value: 1.0 },\n\t\tscale: { value: 1.0 },\n\t\tmap: { value: null },\n\t\tuvTransform: { value: new Matrix3() }\n\n\t},\n\n\tsprite: {\n\n\t\tdiffuse: { value: new Color( 0xeeeeee ) },\n\t\topacity: { value: 1.0 },\n\t\tcenter: { value: new Vector2( 0.5, 0.5 ) },\n\t\trotation: { value: 0.0 },\n\t\tmap: { value: null },\n\t\tuvTransform: { value: new Matrix3() }\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\nvar ShaderLib = {\n\n\tbasic: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t},\n\n\tlambert: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t},\n\n\tphong: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.gradientmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\tspecular: { value: new Color( 0x111111 ) },\n\t\t\t\tshininess: { value: 30 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t},\n\n\tstandard: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.roughnessmap,\n\t\t\tUniformsLib.metalnessmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: new Color( 0x000000 ) },\n\t\t\t\troughness: { value: 0.5 },\n\t\t\t\tmetalness: { value: 0.5 },\n\t\t\t\tenvMapIntensity: { value: 1 } // temporary\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t},\n\n\tmatcap: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tmatcap: { value: null }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\n\t},\n\n\tpoints: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.points,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.points_vert,\n\t\tfragmentShader: ShaderChunk.points_frag\n\n\t},\n\n\tdashed: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tscale: { value: 1 },\n\t\t\t\tdashSize: { value: 1 },\n\t\t\t\ttotalSize: { value: 2 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t},\n\n\tdepth: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.depth_vert,\n\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t},\n\n\tnormal: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.normal_vert,\n\t\tfragmentShader: ShaderChunk.normal_frag\n\n\t},\n\n\tsprite: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.sprite,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\tfragmentShader: ShaderChunk.sprite_frag\n\n\t},\n\n\tbackground: {\n\n\t\tuniforms: {\n\t\t\tuvTransform: { value: new Matrix3() },\n\t\t\tt2D: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.background_vert,\n\t\tfragmentShader: ShaderChunk.background_frag\n\n\t},\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\tcube: {\n\n\t\tuniforms: {\n\t\t\ttCube: { value: null },\n\t\t\ttFlip: { value: - 1 },\n\t\t\topacity: { value: 1.0 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.cube_vert,\n\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t},\n\n\tequirect: {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t},\n\n\tdistanceRGBA: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\treferencePosition: { value: new Vector3() },\n\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t},\n\n\tshadow: {\n\n\t\tuniforms: mergeUniforms( [\n\t\t\tUniformsLib.lights,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tcolor: { value: new Color( 0x00000 ) },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\tfragmentShader: ShaderChunk.shadow_frag\n\n\t}\n\n};\n\nShaderLib.physical = {\n\n\tuniforms: mergeUniforms( [\n\t\tShaderLib.standard.uniforms,\n\t\t{\n\t\t\tclearCoat: { value: 0 },\n\t\t\tclearCoatRoughness: { value: 0 }\n\t\t}\n\t] ),\n\n\tvertexShader: ShaderChunk.meshphysical_vert,\n\tfragmentShader: ShaderChunk.meshphysical_frag\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLAnimation() {\n\n\tvar context = null;\n\tvar isAnimating = false;\n\tvar animationLoop = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tif ( isAnimating === false ) return;\n\n\t\tanimationLoop( time, frame );\n\n\t\tcontext.requestAnimationFrame( onAnimationFrame );\n\n\t}\n\n\treturn {\n\n\t\tstart: function () {\n\n\t\t\tif ( isAnimating === true ) return;\n\t\t\tif ( animationLoop === null ) return;\n\n\t\t\tcontext.requestAnimationFrame( onAnimationFrame );\n\n\t\t\tisAnimating = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tisAnimating = false;\n\n\t\t},\n\n\t\tsetAnimationLoop: function ( callback ) {\n\n\t\t\tanimationLoop = callback;\n\n\t\t},\n\n\t\tsetContext: function ( value ) {\n\n\t\t\tcontext = value;\n\n\t\t}\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLAttributes( gl ) {\n\n\tvar buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tvar array = attribute.array;\n\t\tvar usage = attribute.dynamic ? 35048 : 35044;\n\n\t\tvar buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tvar type = 5126;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = 5126;\n\n\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\ttype = 5123;\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = 5122;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = 5125;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = 5124;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = 5120;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = 5121;\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tvar array = attribute.array;\n\t\tvar updateRange = attribute.updateRange;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( attribute.dynamic === false ) {\n\n\t\t\tgl.bufferData( bufferType, array, 35044 );\n\n\t\t} else if ( updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else if ( updateRange.count === 0 ) {\n\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t} else {\n\n\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\n\n\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tvar data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tvar data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Face3( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\tthis.color = ( color && color.isColor ) ? color : new Color();\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n}\n\nObject.assign( Face3.prototype, {\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nfunction Euler( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || Euler.DefaultOrder;\n\n}\n\nEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nEuler.DefaultOrder = 'XYZ';\n\nObject.defineProperties( Euler.prototype, {\n\n\tx: {\n\n\t\tget: function () {\n\n\t\t\treturn this._x;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t}\n\n\t},\n\n\ty: {\n\n\t\tget: function () {\n\n\t\t\treturn this._y;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t}\n\n\t},\n\n\tz: {\n\n\t\tget: function () {\n\n\t\t\treturn this._z;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t}\n\n\t},\n\n\torder: {\n\n\t\tget: function () {\n\n\t\t\treturn this._order;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._order = value;\n\t\t\tthis.onChangeCallback();\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( Euler.prototype, {\n\n\tisEuler: true,\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\tvar clamp = _Math.clamp;\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function () {\n\n\t\tvar matrix = new Matrix4();\n\n\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t};\n\n\t}(),\n\n\tsetFromVector3: function ( v, order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new Quaternion();\n\n\t\treturn function reorder( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\n\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t},\n\n\ttoVector3: function ( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Layers() {\n\n\tthis.mask = 1 | 0;\n\n}\n\nObject.assign( Layers.prototype, {\n\n\tset: function ( channel ) {\n\n\t\tthis.mask = 1 << channel | 0;\n\n\t},\n\n\tenable: function ( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t},\n\n\ttoggle: function ( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t},\n\n\tdisable: function ( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t},\n\n\ttest: function ( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author elephantatwork / www.elephantatwork.ch\n */\n\nvar object3DId = 0;\n\nfunction Object3D() {\n\n\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Object3D';\n\n\tthis.parent = null;\n\tthis.children = [];\n\n\tthis.up = Object3D.DefaultUp.clone();\n\n\tvar position = new Vector3();\n\tvar rotation = new Euler();\n\tvar quaternion = new Quaternion();\n\tvar scale = new Vector3( 1, 1, 1 );\n\n\tfunction onRotationChange() {\n\n\t\tquaternion.setFromEuler( rotation, false );\n\n\t}\n\n\tfunction onQuaternionChange() {\n\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t}\n\n\trotation.onChange( onRotationChange );\n\tquaternion.onChange( onQuaternionChange );\n\n\tObject.defineProperties( this, {\n\t\tposition: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: position\n\t\t},\n\t\trotation: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: rotation\n\t\t},\n\t\tquaternion: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: quaternion\n\t\t},\n\t\tscale: {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tvalue: scale\n\t\t},\n\t\tmodelViewMatrix: {\n\t\t\tvalue: new Matrix4()\n\t\t},\n\t\tnormalMatrix: {\n\t\t\tvalue: new Matrix3()\n\t\t}\n\t} );\n\n\tthis.matrix = new Matrix4();\n\tthis.matrixWorld = new Matrix4();\n\n\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\tthis.matrixWorldNeedsUpdate = false;\n\n\tthis.layers = new Layers();\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\tthis.renderOrder = 0;\n\n\tthis.userData = {};\n\n}\n\nObject3D.DefaultUp = new Vector3( 0, 1, 0 );\nObject3D.DefaultMatrixAutoUpdate = true;\n\nObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Object3D,\n\n\tisObject3D: true,\n\n\tonBeforeRender: function () {},\n\tonAfterRender: function () {},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function () {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new Quaternion();\n\n\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateOnWorldAxis: function () {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\tvar q1 = new Quaternion();\n\n\t\treturn function rotateOnWorldAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.premultiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new Vector3( 1, 0, 0 );\n\n\t\treturn function translateX( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new Vector3( 0, 1, 0 );\n\n\t\treturn function translateY( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new Vector3( 0, 0, 1 );\n\n\t\treturn function translateZ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function worldToLocal( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tvar q1 = new Quaternion();\n\t\tvar m1 = new Matrix4();\n\t\tvar target = new Vector3();\n\t\tvar position = new Vector3();\n\n\t\treturn function lookAt( x, y, z ) {\n\n\t\t\tif ( x.isVector3 ) {\n\n\t\t\t\ttarget.copy( x );\n\n\t\t\t} else {\n\n\t\t\t\ttarget.set( x, y, z );\n\n\t\t\t}\n\n\t\t\tvar parent = this.parent;\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t\tm1.lookAt( position, target, this.up );\n\n\t\t\t} else {\n\n\t\t\t\tm1.lookAt( target, position, this.up );\n\n\t\t\t}\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tm1.extractRotation( parent.matrixWorld );\n\t\t\t\tq1.setFromRotationMatrix( m1 );\n\t\t\t\tthis.quaternion.premultiply( q1.inverse() );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( ( object && object.isObject3D ) ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\tthis.children.push( object );\n\n\t\t} else {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetObjectById: function ( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t},\n\n\tgetObjectByName: function ( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t},\n\n\tgetObjectByProperty: function ( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetWorldPosition: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t},\n\n\tgetWorldQuaternion: function () {\n\n\t\tvar position = new Vector3();\n\t\tvar scale = new Vector3();\n\n\t\treturn function getWorldQuaternion( target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );\n\t\t\t\ttarget = new Quaternion();\n\n\t\t\t}\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, target, scale );\n\n\t\t\treturn target;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldScale: function () {\n\n\t\tvar position = new Vector3();\n\t\tvar quaternion = new Quaternion();\n\n\t\treturn function getWorldScale( target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getWorldScale() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, target );\n\n\t\t\treturn target;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldDirection: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\tvar e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t},\n\n\traycast: function () {},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseVisible: function ( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseAncestors: function ( callback ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\tupdateWorldMatrix: function ( updateParents, updateChildren ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.parent === null ) {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t}\n\n\t\t// update children\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tvar children = this.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateWorldMatrix( false, true );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tvar output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tvar object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isMesh && this.drawMode !== TrianglesDrawMode ) object.drawMode = this.drawMode;\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tvar parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tvar shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tvar uuids = [];\n\n\t\t\t\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\t\t\tvar shapes = extractFromCache( meta.shapes );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tvar values = [];\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\t\t\treturn values;\n\n\t\t}\n\n\t},\n\n\tclone: function ( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t},\n\n\tcopy: function ( source, recursive ) {\n\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tvar child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nvar geometryId = 0; // Geometry uses even numbers as Id\n\nfunction Geometry() {\n\n\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.elementsNeedUpdate = false;\n\tthis.verticesNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n}\n\nGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Geometry,\n\n\tisGeometry: true,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj = new Object3D();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tvar scope = this;\n\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tscope.vertices.push( new Vector3().fromArray( positions, i ) );\n\n\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\tscope.colors.push( new Color().fromArray( colors, i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tvar vertexColors = ( colors === undefined ) ? [] : [\n\t\t\t\tscope.colors[ a ].clone(),\n\t\t\t\tscope.colors[ b ].clone(),\n\t\t\t\tscope.colors[ c ].clone() ];\n\n\t\t\tvar vertexNormals = ( normals === undefined ) ? [] : [\n\t\t\t\tnew Vector3().fromArray( normals, a * 3 ),\n\t\t\t\tnew Vector3().fromArray( normals, b * 3 ),\n\t\t\t\tnew Vector3().fromArray( normals, c * 3 )\n\t\t\t];\n\n\t\t\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\tnew Vector2().fromArray( uvs, a * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs, b * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs, c * 2 )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\n\t\t\t\t\tnew Vector2().fromArray( uvs2, a * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs2, b * 2 ),\n\t\t\t\t\tnew Vector2().fromArray( uvs2, c * 2 )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar groups = geometry.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( indices !== undefined ) {\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tvar offset = new Vector3();\n\n\t\treturn function center() {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tvar center = this.boundingSphere.center;\n\t\tvar radius = this.boundingSphere.radius;\n\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tvar matrix = new Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeFlatVertexNormals: function () {\n\n\t\tvar f, fl, face;\n\n\t\tthis.computeFaceNormals();\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ],\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// colors\n\n\t\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tif ( uv === undefined ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i, il, face;\n\t\tvar indices, j, jl;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.vertices = [];\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tvar faces = this.faces;\n\t\tvar length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tvar newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tvar faces = [];\n\t\tvar normals = [];\n\t\tvar normalsHash = {};\n\t\tvar colors = [];\n\t\tvar colorsHash = {};\n\t\tvar uvs = [];\n\t\tvar uvsHash = {};\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tvar hasMaterial = true;\n\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tvar faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t var parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t var values = [];\n\n\t\t for ( var key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar i, il, j, jl, k, kl;\n\n\t\t// reset\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\tthis.lineDistances = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// vertices\n\n\t\tvar vertices = source.vertices;\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\t// colors\n\n\t\tvar colors = source.colors;\n\n\t\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tvar faces = source.faces;\n\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\t// face vertex uvs\n\n\t\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphTargets = source.morphTargets;\n\n\t\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = {};\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\n\t\t\t// vertices\n\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\n\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\n\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.push( morphTarget );\n\n\t\t}\n\n\t\t// morph normals\n\n\t\tvar morphNormals = source.morphNormals;\n\n\t\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\tvar morphNormal = {};\n\n\t\t\t// vertex normals\n\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\tvar destVertexNormal = {};\n\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// face normals\n\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphNormals.push( morphNormal );\n\n\t\t}\n\n\t\t// skin weights\n\n\t\tvar skinWeights = source.skinWeights;\n\n\t\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\n\t\t}\n\n\t\t// skin indices\n\n\t\tvar skinIndices = source.skinIndices;\n\n\t\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\n\t\t}\n\n\t\t// line distances\n\n\t\tvar lineDistances = source.lineDistances;\n\n\t\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tvar boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tvar boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction BufferAttribute( array, itemSize, normalized ) {\n\n\tif ( Array.isArray( array ) ) {\n\n\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t}\n\n\tthis.name = '';\n\n\tthis.array = array;\n\tthis.itemSize = itemSize;\n\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\tthis.normalized = normalized === true;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n}\n\nObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\nObject.assign( BufferAttribute.prototype, {\n\n\tisBufferAttribute: true,\n\n\tonUploadCallback: function () {},\n\n\tsetArray: function ( array ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\tthis.array = array;\n\n\t\treturn this;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyArray: function ( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t},\n\n\tcopyColorsArray: function ( colors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tvar color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector2sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector3sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector4sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tonUpload: function ( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n} );\n\n//\n\nfunction Int8BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\n\n}\n\nInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\n\n\nfunction Uint8BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\n\n}\n\nUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\n\n\nfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\n\n}\n\nUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\n\n\nfunction Int16BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\n\n}\n\nInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\n\n\nfunction Uint16BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\n\n}\n\nUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\n\n\nfunction Int32BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\n\n}\n\nInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\n\n\nfunction Uint32BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\n\n}\n\nUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\n\n\nfunction Float32BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\n\n}\n\nFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\n\n\nfunction Float64BufferAttribute( array, itemSize, normalized ) {\n\n\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\n\n}\n\nFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\nFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction DirectGeometry() {\n\n\tthis.vertices = [];\n\tthis.normals = [];\n\tthis.colors = [];\n\tthis.uvs = [];\n\tthis.uvs2 = [];\n\n\tthis.groups = [];\n\n\tthis.morphTargets = {};\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\t// this.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n}\n\nObject.assign( DirectGeometry.prototype, {\n\n\tcomputeGroups: function ( geometry ) {\n\n\t\tvar group;\n\t\tvar groups = [];\n\t\tvar materialIndex = undefined;\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tvar faces = geometry.faces;\n\t\tvar vertices = geometry.vertices;\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tvar morphTargets = geometry.morphTargets;\n\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\tvar morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = {\n\t\t\t\t\tname: morphTargets[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tvar morphNormals = geometry.morphNormals;\n\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\tvar morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = {\n\t\t\t\t\tname: morphNormals[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tvar skinIndices = geometry.skinIndices;\n\t\tvar skinWeights = geometry.skinWeights;\n\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tif ( vertices.length > 0 && faces.length === 0 ) {\n\n\t\t\tconsole.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction arrayMax( array ) {\n\n\tif ( array.length === 0 ) return - Infinity;\n\n\tvar max = array[ 0 ];\n\n\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] > max ) max = array[ i ];\n\n\t}\n\n\treturn max;\n\n}\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\nfunction BufferGeometry() {\n\n\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n\tthis.userData = {};\n\n}\n\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: BufferGeometry,\n\n\tisBufferGeometry: true,\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t},\n\n\taddAttribute: function ( name, attribute ) {\n\n\t\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\treturn this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t}\n\n\t\tif ( name === 'index' ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\tthis.setIndex( attribute );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tremoveAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tmatrix.applyToBufferAttribute( position );\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.applyToBufferAttribute( normal );\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1 = new Matrix4();\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj = new Object3D();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tcenter: function () {\n\n\t\tvar offset = new Vector3();\n\n\t\treturn function center() {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t\tthis.boundingBox.getCenter( offset ).negate();\n\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object.isPoints || object.isLine ) {\n\n\t\t\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object.isMesh ) {\n\n\t\t\tif ( geometry && geometry.isGeometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tvar position = [];\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\tdirect = undefined;\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tvar attribute;\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n\t\t\t\tattribute.name = morphTarget.name;\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new Box3();\n\t\tvar vector = new Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tvar position = this.attributes.position;\n\n\t\t\tif ( position ) {\n\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tbox.setFromBufferAttribute( position );\n\t\t\t\tbox.getCenter( center );\n\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t\tvector.x = position.getX( i );\n\t\t\t\t\tvector.y = position.getY( i );\n\t\t\t\t\tvector.z = position.getZ( i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tvar cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) {\n\n\t\t\toffset = 0;\n\n\t\t\tconsole.warn(\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\n\t\t\t);\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar vector = new Vector3();\n\n\t\treturn function normalizeNormals() {\n\n\t\t\tvar normals = this.attributes.normal;\n\n\t\t\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t\tvector.x = normals.getX( i );\n\t\t\t\tvector.y = normals.getY( i );\n\t\t\t\tvector.z = normals.getZ( i );\n\n\t\t\t\tvector.normalize();\n\n\t\t\t\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoNonIndexed: function () {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.addAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tvar morphAttributes = this.morphAttributes;\n\n\t\tfor ( name in morphAttributes ) {\n\n\t\t\tvar morphArray = [];\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tvar attribute = morphAttribute[ i ];\n\n\t\t\t\tvar newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\t// groups\n\n\t\tvar groups = this.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: array\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: attribute.normalized\n\t\t\t};\n\n\t\t}\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t var parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t var values = [];\n\n\t\t for ( var key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t var geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar name, i, l;\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tvar morphAttributes = source.morphAttributes;\n\n\t\tfor ( name in morphAttributes ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone() );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// groups\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tvar boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tvar boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// BoxGeometry\n\nfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'BoxGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\tthis.mergeVertices();\n\n}\n\nBoxGeometry.prototype = Object.create( Geometry.prototype );\nBoxGeometry.prototype.constructor = BoxGeometry;\n\n// BoxBufferGeometry\n\nfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'BoxBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tvar scope = this;\n\n\twidth = width || 1;\n\theight = height || 1;\n\tdepth = depth || 1;\n\n\t// segments\n\n\twidthSegments = Math.floor( widthSegments ) || 1;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar numberOfVertices = 0;\n\tvar groupStart = 0;\n\n\t// build each side of the box geometry\n\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\tvar segmentWidth = width / gridX;\n\t\tvar segmentHeight = height / gridY;\n\n\t\tvar widthHalf = width / 2;\n\t\tvar heightHalf = height / 2;\n\t\tvar depthHalf = depth / 2;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar vertexCounter = 0;\n\t\tvar groupCount = 0;\n\n\t\tvar ix, iy;\n\n\t\tvar vector = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t// set values to correct vector component\n\n\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t// set values to correct vector component\n\n\t\t\t\tvector[ u ] = 0;\n\t\t\t\tvector[ v ] = 0;\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t// uvs\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t// counters\n\n\t\t\t\tvertexCounter += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\t// 1. you need three indices to draw a single face\n\t\t// 2. a single segment consists of two faces\n\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t// increase counter\n\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t// calculate new start value for groups\n\n\t\tgroupStart += groupCount;\n\n\t\t// update total number of vertices\n\n\t\tnumberOfVertices += vertexCounter;\n\n\t}\n\n}\n\nBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// PlaneGeometry\n\nfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'PlaneGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\tthis.mergeVertices();\n\n}\n\nPlaneGeometry.prototype = Object.create( Geometry.prototype );\nPlaneGeometry.prototype.constructor = PlaneGeometry;\n\n// PlaneBufferGeometry\n\nfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'PlaneBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\twidth = width || 1;\n\theight = height || 1;\n\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = Math.floor( widthSegments ) || 1;\n\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridY1 = gridY + 1;\n\n\tvar segment_width = width / gridX;\n\tvar segment_height = height / gridY;\n\n\tvar ix, iy;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// generate vertices, normals and uvs\n\n\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\tvar y = iy * segment_height - height_half;\n\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\tuvs.push( ix / gridX );\n\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iy;\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar materialId = 0;\n\nfunction Material() {\n\n\tObject.defineProperty( this, 'id', { value: materialId ++ } );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Material';\n\n\tthis.fog = true;\n\tthis.lights = true;\n\n\tthis.blending = NormalBlending;\n\tthis.side = FrontSide;\n\tthis.flatShading = false;\n\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blendSrc = SrcAlphaFactor;\n\tthis.blendDst = OneMinusSrcAlphaFactor;\n\tthis.blendEquation = AddEquation;\n\tthis.blendSrcAlpha = null;\n\tthis.blendDstAlpha = null;\n\tthis.blendEquationAlpha = null;\n\n\tthis.depthFunc = LessEqualDepth;\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.clippingPlanes = null;\n\tthis.clipIntersection = false;\n\tthis.clipShadows = false;\n\n\tthis.shadowSide = null;\n\n\tthis.colorWrite = true;\n\n\tthis.precision = null; // override the renderer's default precision for this material\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.dithering = false;\n\n\tthis.alphaTest = 0;\n\tthis.premultipliedAlpha = false;\n\n\tthis.visible = true;\n\n\tthis.userData = {};\n\n\tthis.needsUpdate = true;\n\n}\n\nMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Material,\n\n\tisMaterial: true,\n\n\tonBeforeCompile: function () {},\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// for backward compatability if shading is set in the constructor\n\t\t\tif ( key === 'shading' ) {\n\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\t\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;\n\t\tif ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\tif ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\t\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\n\t\t}\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\tdata.depthFunc = this.depthFunc;\n\t\tdata.depthTest = this.depthTest;\n\t\tdata.depthWrite = this.depthWrite;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.morphTargets === true ) data.morphTargets = true;\n\t\tif ( this.skinning === true ) data.skinning = true;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.flatShading = source.flatShading;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.visible = source.visible;\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.clipShadows = source.clipShadows;\n\t\tthis.clipIntersection = source.clipIntersection;\n\n\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\tdstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tvar n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction ShaderMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\tthis.uniformsNeedUpdate = false;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nShaderMaterial.prototype = Object.create( Material.prototype );\nShaderMaterial.prototype.constructor = ShaderMaterial;\n\nShaderMaterial.prototype.isShaderMaterial = true;\n\nShaderMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = cloneUniforms( source.uniforms );\n\n\tthis.defines = Object.assign( {}, source.defines );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = source.extensions;\n\n\treturn this;\n\n};\n\nShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tvar data = Material.prototype.toJSON.call( this, meta );\n\n\tdata.uniforms = {};\n\n\tfor ( var name in this.uniforms ) {\n\n\t\tvar uniform = this.uniforms[ name ];\n\t\tvar value = uniform.value;\n\n\t\tif ( value && value.isTexture ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t};\n\n\t\t} else if ( value && value.isColor ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'c',\n\t\t\t\tvalue: value.getHex()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v2',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'v4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm3',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\ttype: 'm4',\n\t\t\t\tvalue: value.toArray()\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tdata.uniforms[ name ] = {\n\t\t\t\tvalue: value\n\t\t\t};\n\n\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t}\n\n\t}\n\n\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\tvar extensions = {};\n\n\tfor ( var key in this.extensions ) {\n\n\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t}\n\n\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\treturn data;\n\n};\n\n/**\n * @author bhouston / http://clara.io\n */\n\nfunction Ray( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\n\n}\n\nObject.assign( Ray.prototype, {\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .at() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function recast( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tvar directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceToSquared( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function () {\n\n\t\tvar segCenter = new Vector3();\n\t\tvar segDir = new Vector3();\n\t\tvar diff = new Vector3();\n\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\tvar c = diff.lengthSq();\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\tif ( det > 0 ) {\n\n\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\n\t\t};\n\n\t}(),\n\n\tintersectSphere: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function intersectSphere( sphere, target ) {\n\n\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\tvar tca = v1.dot( this.direction );\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\tvar t0 = tca - thc;\n\n\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\tvar t1 = tca + thc;\n\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t// test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\treturn this.at( t0, target );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t},\n\n\tintersectPlane: function ( plane, target ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, target ) {\n\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tvar invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t},\n\n\tintersectsBox: ( function () {\n\n\t\tvar v = new Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t};\n\n\t} )(),\n\n\tintersectTriangle: function () {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new Vector3();\n\t\tvar edge1 = new Vector3();\n\t\tvar edge2 = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, target );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Triangle( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new Vector3();\n\tthis.b = ( b !== undefined ) ? b : new Vector3();\n\tthis.c = ( c !== undefined ) ? c : new Vector3();\n\n}\n\nObject.assign( Triangle, {\n\n\tgetNormal: function () {\n\n\t\tvar v0 = new Vector3();\n\n\t\treturn function getNormal( a, b, c, target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Triangle: .getNormal() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\ttarget.subVectors( c, b );\n\t\t\tv0.subVectors( a, b );\n\t\t\ttarget.cross( v0 );\n\n\t\t\tvar targetLengthSq = target.lengthSq();\n\t\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t\t}\n\n\t\t\treturn target.set( 0, 0, 0 );\n\n\t\t};\n\n\t}(),\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tgetBarycoord: function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function getBarycoord( point, a, b, c, target ) {\n\n\t\t\tv0.subVectors( c, a );\n\t\t\tv1.subVectors( b, a );\n\t\t\tv2.subVectors( point, a );\n\n\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\tvar dot12 = v1.dot( v2 );\n\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Triangle: .getBarycoord() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\t// collinear or singular triangle\n\t\t\tif ( denom === 0 ) {\n\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn target.set( - 2, - 1, - 1 );\n\n\t\t\t}\n\n\t\t\tvar invDenom = 1 / denom;\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t\t// barycentric coordinates must always sum to 1\n\t\t\treturn target.set( 1 - u - v, v, u );\n\n\t\t};\n\n\t}(),\n\n\tcontainsPoint: function () {\n\n\t\tvar v1 = new Vector3();\n\n\t\treturn function containsPoint( point, a, b, c ) {\n\n\t\t\tTriangle.getBarycoord( point, a, b, c, v1 );\n\n\t\t\treturn ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );\n\n\t\t};\n\n\t}(),\n\n\tgetUV: function () {\n\n\t\tvar barycoord = new Vector3();\n\n\t\treturn function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {\n\n\t\t\tthis.getBarycoord( point, p1, p2, p3, barycoord );\n\n\t\t\ttarget.set( 0, 0 );\n\t\t\ttarget.addScaledVector( uv1, barycoord.x );\n\t\t\ttarget.addScaledVector( uv2, barycoord.y );\n\t\t\ttarget.addScaledVector( uv3, barycoord.z );\n\n\t\t\treturn target;\n\n\t\t};\n\n\t}()\n\n} );\n\nObject.assign( Triangle.prototype, {\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tgetArea: function () {\n\n\t\tvar v0 = new Vector3();\n\t\tvar v1 = new Vector3();\n\n\t\treturn function getArea() {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tgetMidpoint: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getMidpoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tgetNormal: function ( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t},\n\n\tgetPlane: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle: .getPlane() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tgetBarycoord: function ( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tgetUV: function ( point, uv1, uv2, uv3, result ) {\n\n\t\treturn Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t},\n\n\tclosestPointToPoint: function () {\n\n\t\tvar vab = new Vector3();\n\t\tvar vac = new Vector3();\n\t\tvar vbc = new Vector3();\n\t\tvar vap = new Vector3();\n\t\tvar vbp = new Vector3();\n\t\tvar vcp = new Vector3();\n\n\t\treturn function closestPointToPoint( p, target ) {\n\n\t\t\tif ( target === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );\n\t\t\t\ttarget = new Vector3();\n\n\t\t\t}\n\n\t\t\tvar a = this.a, b = this.b, c = this.c;\n\t\t\tvar v, w;\n\n\t\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t\tvab.subVectors( b, a );\n\t\t\tvac.subVectors( c, a );\n\t\t\tvap.subVectors( p, a );\n\t\t\tvar d1 = vab.dot( vap );\n\t\t\tvar d2 = vac.dot( vap );\n\t\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\t\treturn target.copy( a );\n\n\t\t\t}\n\n\t\t\tvbp.subVectors( p, b );\n\t\t\tvar d3 = vab.dot( vbp );\n\t\t\tvar d4 = vac.dot( vbp );\n\t\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\t\treturn target.copy( b );\n\n\t\t\t}\n\n\t\t\tvar vc = d1 * d4 - d3 * d2;\n\t\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\t\treturn target.copy( a ).addScaledVector( vab, v );\n\n\t\t\t}\n\n\t\t\tvcp.subVectors( p, c );\n\t\t\tvar d5 = vab.dot( vcp );\n\t\t\tvar d6 = vac.dot( vcp );\n\t\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\t\treturn target.copy( c );\n\n\t\t\t}\n\n\t\t\tvar vb = d5 * d2 - d1 * d6;\n\t\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\t\treturn target.copy( a ).addScaledVector( vac, w );\n\n\t\t\t}\n\n\t\t\tvar va = d3 * d6 - d5 * d4;\n\t\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t\tvbc.subVectors( c, b );\n\t\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\t\treturn target.copy( b ).addScaledVector( vbc, w ); // edge region of BC\n\n\t\t\t}\n\n\t\t\t// face region\n\t\t\tvar denom = 1 / ( va + vb + vc );\n\t\t\t// u = va * denom\n\t\t\tv = vb * denom;\n\t\t\tw = vc * denom;\n\t\t\treturn target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>\n * }\n */\n\nfunction MeshBasicMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshBasicMaterial';\n\n\tthis.color = new Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshBasicMaterial.prototype = Object.create( Material.prototype );\nMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\nMeshBasicMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nfunction Mesh( geometry, material ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.drawMode = TrianglesDrawMode;\n\n\tthis.updateMorphTargets();\n\n}\n\nMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Mesh,\n\n\tisMesh: true,\n\n\tsetDrawMode: function ( value ) {\n\n\t\tthis.drawMode = value;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.drawMode = source.drawMode;\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tvar geometry = this.geometry;\n\t\tvar m, ml, name;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\t\tvar keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tname = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new Matrix4();\n\t\tvar ray = new Ray();\n\t\tvar sphere = new Sphere();\n\n\t\tvar vA = new Vector3();\n\t\tvar vB = new Vector3();\n\t\tvar vC = new Vector3();\n\n\t\tvar tempA = new Vector3();\n\t\tvar tempB = new Vector3();\n\t\tvar tempC = new Vector3();\n\n\t\tvar uvA = new Vector2();\n\t\tvar uvB = new Vector2();\n\t\tvar uvC = new Vector2();\n\n\t\tvar intersectionPoint = new Vector3();\n\t\tvar intersectionPointWorld = new Vector3();\n\n\t\tfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\tvar intersect;\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t} else {\n\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n\t\t\t}\n\n\t\t\tif ( intersect === null ) return null;\n\n\t\t\tintersectionPointWorld.copy( point );\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\treturn {\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\tobject: object\n\t\t\t};\n\n\t\t}\n\n\t\tfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( position, a );\n\t\t\tvB.fromBufferAttribute( position, b );\n\t\t\tvC.fromBufferAttribute( position, c );\n\n\t\t\tvar intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\tif ( intersection ) {\n\n\t\t\t\tif ( uv ) {\n\n\t\t\t\t\tuvA.fromBufferAttribute( uv, a );\n\t\t\t\t\tuvB.fromBufferAttribute( uv, b );\n\t\t\t\t\tuvC.fromBufferAttribute( uv, c );\n\n\t\t\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t\tvar face = new Face3( a, b, c );\n\t\t\t\tTriangle.getNormal( vA, vB, vC, face.normal );\n\n\t\t\t\tintersection.face = face;\n\n\t\t\t}\n\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\tif ( material === undefined ) return;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t// Check boundingBox before continuing\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t}\n\n\t\t\tvar intersection;\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar position = geometry.attributes.position;\n\t\t\t\tvar uv = geometry.attributes.uv;\n\t\t\t\tvar groups = geometry.groups;\n\t\t\t\tvar drawRange = geometry.drawRange;\n\t\t\t\tvar i, j, il, jl;\n\t\t\t\tvar group, groupMaterial;\n\t\t\t\tvar start, end;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\t// indexed buffer geometry\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );\n\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\ta = index.getX( i );\n\t\t\t\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( position !== undefined ) {\n\n\t\t\t\t\t// non-indexed buffer geometry\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\t\t\ta = j;\n\t\t\t\t\t\t\t\tb = j + 1;\n\t\t\t\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );\n\n\t\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\t\t\tend = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\ta = i;\n\t\t\t\t\t\t\tb = i + 1;\n\t\t\t\t\t\t\tc = i + 2;\n\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );\n\n\t\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\tvar isMultiMaterial = Array.isArray( material );\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar uvs;\n\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\n\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tif ( uvs && uvs[ f ] ) {\n\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLBackground( renderer, state, objects, premultipliedAlpha ) {\n\n\tvar clearColor = new Color( 0x000000 );\n\tvar clearAlpha = 0;\n\n\tvar planeMesh;\n\tvar boxMesh;\n\t// Store the current background texture and its `version`\n\t// so we can recompile the material accordingly.\n\tvar currentBackground = null;\n\tvar currentBackgroundVersion = 0;\n\n\tfunction render( renderList, scene, camera, forceClear ) {\n\n\t\tvar background = scene.background;\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\t\t\tcurrentBackground = null;\n\t\t\tcurrentBackgroundVersion = 0;\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\t\t\tcurrentBackground = null;\n\t\t\tcurrentBackgroundVersion = 0;\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background && ( background.isCubeTexture || background.isWebGLRenderTargetCube ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\tnew BoxBufferGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\ttype: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.cube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.removeAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.removeAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// enable code injection for non-built-in material\n\t\t\t\tObject.defineProperty( boxMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.tCube.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\tvar texture = background.isWebGLRenderTargetCube ? background.texture : background;\n\t\t\tboxMesh.material.uniforms.tCube.value = texture;\n\t\t\tboxMesh.material.uniforms.tFlip.value = ( background.isWebGLRenderTargetCube ) ? 1 : - 1;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t     currentBackgroundVersion !== texture.version ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = texture.version;\n\n\t\t\t}\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\tnew PlaneBufferGeometry( 2, 2 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\ttype: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.removeAttribute( 'normal' );\n\n\t\t\t\t// enable code injection for non-built-in material\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\t   currentBackgroundVersion !== background.version ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\n\t\t\t}\n\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha !== undefined ? alpha : 1;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawArrays( mode, start, count );\n\n\t\tinfo.update( count, mode );\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension;\n\n\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\textension = gl;\n\n\t\t} else {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );\n\n\t\tinfo.update( count, mode, geometry.maxInstancedCount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\tvar maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tvar isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n\n\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tvar maxPrecision = getMaxPrecision( precision );\n\n\tif ( maxPrecision !== precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\tprecision = maxPrecision;\n\n\t}\n\n\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n\tvar maxTextures = gl.getParameter( 34930 );\n\tvar maxVertexTextures = gl.getParameter( 35660 );\n\tvar maxTextureSize = gl.getParameter( 3379 );\n\tvar maxCubemapSize = gl.getParameter( 34076 );\n\n\tvar maxAttributes = gl.getParameter( 34921 );\n\tvar maxVertexUniforms = gl.getParameter( 36347 );\n\tvar maxVaryings = gl.getParameter( 36348 );\n\tvar maxFragmentUniforms = gl.getParameter( 36349 );\n\n\tvar vertexTextures = maxVertexTextures > 0;\n\tvar floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );\n\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\tvar maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;\n\n\treturn {\n\n\t\tisWebGL2: isWebGL2,\n\n\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\tprecision: precision,\n\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\tmaxTextures: maxTextures,\n\t\tmaxVertexTextures: maxVertexTextures,\n\t\tmaxTextureSize: maxTextureSize,\n\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\tmaxAttributes: maxAttributes,\n\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\tmaxVaryings: maxVaryings,\n\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\tvertexTextures: vertexTextures,\n\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\tfloatVertexTextures: floatVertexTextures,\n\n\t\tmaxSamples: maxSamples\n\n\t};\n\n}\n\n/**\n * @author tschw\n */\n\nfunction WebGLClipping() {\n\n\tvar scope = this,\n\n\t\tglobalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false,\n\n\t\tplane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping, camera ) {\n\n\t\tvar enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tcache.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\tdstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLExtensions( gl ) {\n\n\tvar extensions = {};\n\n\treturn {\n\n\t\tget: function ( name ) {\n\n\t\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\t\treturn extensions[ name ];\n\n\t\t\t}\n\n\t\t\tvar extension;\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\textension = gl.getExtension( name );\n\n\t\t\t}\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t}\n\n\t\t\textensions[ name ] = extension;\n\n\t\t\treturn extension;\n\n\t\t}\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLGeometries( gl, attributes, info ) {\n\n\tvar geometries = {};\n\tvar wireframeAttributes = {};\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tvar geometry = event.target;\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\tattributes.remove( buffergeometry.index );\n\n\t\t}\n\n\t\tfor ( var name in buffergeometry.attributes ) {\n\n\t\t\tattributes.remove( buffergeometry.attributes[ name ] );\n\n\t\t}\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\tvar attribute = wireframeAttributes[ buffergeometry.id ];\n\n\t\tif ( attribute ) {\n\n\t\t\tattributes.remove( attribute );\n\t\t\tdelete wireframeAttributes[ buffergeometry.id ];\n\n\t\t}\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction get( object, geometry ) {\n\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry ) return buffergeometry;\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tbuffergeometry = geometry;\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n\t\t\t}\n\n\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t}\n\n\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction update( geometry ) {\n\n\t\tvar index = geometry.index;\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, 34963 );\n\n\t\t}\n\n\t\tfor ( var name in geometryAttributes ) {\n\n\t\t\tattributes.update( geometryAttributes[ name ], 34962 );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.update( array[ i ], 34962 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tvar attribute = wireframeAttributes[ geometry.id ];\n\n\t\tif ( attribute ) return attribute;\n\n\t\tvar indices = [];\n\n\t\tvar geometryIndex = geometry.index;\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\t// console.time( 'wireframe' );\n\n\t\tif ( geometryIndex !== null ) {\n\n\t\t\tvar array = geometryIndex.array;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar array = geometryAttributes.position.array;\n\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tvar a = i + 0;\n\t\t\t\tvar b = i + 1;\n\t\t\t\tvar c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// console.timeEnd( 'wireframe' );\n\n\t\tattribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\n\t\tattributes.update( attribute, 34963 );\n\n\t\twireframeAttributes[ geometry.id ] = attribute;\n\n\t\treturn attribute;\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tupdate: update,\n\n\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tvar type, bytesPerElement;\n\n\tfunction setIndex( value ) {\n\n\t\ttype = value.type;\n\t\tbytesPerElement = value.bytesPerElement;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\n\t\tinfo.update( count, mode );\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension;\n\n\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\textension = gl;\n\n\t\t} else {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );\n\n\t\tinfo.update( count, mode, geometry.maxInstancedCount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction WebGLInfo( gl ) {\n\n\tvar memory = {\n\t\tgeometries: 0,\n\t\ttextures: 0\n\t};\n\n\tvar render = {\n\t\tframe: 0,\n\t\tcalls: 0,\n\t\ttriangles: 0,\n\t\tpoints: 0,\n\t\tlines: 0\n\t};\n\n\tfunction update( count, mode, instanceCount ) {\n\n\t\tinstanceCount = instanceCount || 1;\n\n\t\trender.calls ++;\n\n\t\tswitch ( mode ) {\n\n\t\t\tcase 4:\n\t\t\t\trender.triangles += instanceCount * ( count / 3 );\n\t\t\t\tbreak;\n\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\t\trender.triangles += instanceCount * ( count - 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\trender.lines += instanceCount * ( count / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\trender.lines += instanceCount * ( count - 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tcase 0:\n\t\t\t\trender.points += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\trender.frame ++;\n\t\trender.calls = 0;\n\t\trender.triangles = 0;\n\t\trender.points = 0;\n\t\trender.lines = 0;\n\n\t}\n\n\treturn {\n\t\tmemory: memory,\n\t\trender: render,\n\t\tprograms: null,\n\t\tautoReset: true,\n\t\treset: reset,\n\t\tupdate: update\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction absNumericalSort( a, b ) {\n\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\n}\n\nfunction WebGLMorphtargets( gl ) {\n\n\tvar influencesList = {};\n\tvar morphInfluences = new Float32Array( 8 );\n\n\tfunction update( object, geometry, material, program ) {\n\n\t\tvar objectInfluences = object.morphTargetInfluences;\n\n\t\tvar length = objectInfluences.length;\n\n\t\tvar influences = influencesList[ geometry.id ];\n\n\t\tif ( influences === undefined ) {\n\n\t\t\t// initialise list\n\n\t\t\tinfluences = [];\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\n\t\t\t}\n\n\t\t\tinfluencesList[ geometry.id ] = influences;\n\n\t\t}\n\n\t\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\n\t\t// Remove current morphAttributes\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar influence = influences[ i ];\n\n\t\t\tif ( influence[ 1 ] !== 0 ) {\n\n\t\t\t\tif ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\tif ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Collect influences\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar influence = influences[ i ];\n\n\t\t\tinfluence[ 0 ] = i;\n\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\n\t\t}\n\n\t\tinfluences.sort( absNumericalSort );\n\n\t\t// Add morphAttributes\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tvar influence = influences[ i ];\n\n\t\t\tif ( influence ) {\n\n\t\t\t\tvar index = influence[ 0 ];\n\t\t\t\tvar value = influence[ 1 ];\n\n\t\t\t\tif ( value ) {\n\n\t\t\t\t\tif ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\t\t\t\t\tif ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\n\t\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmorphInfluences[ i ] = 0;\n\n\t\t}\n\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLObjects( geometries, info ) {\n\n\tvar updateList = {};\n\n\tfunction update( object ) {\n\n\t\tvar frame = info.render.frame;\n\n\t\tvar geometry = object.geometry;\n\t\tvar buffergeometry = geometries.get( object, geometry );\n\n\t\t// Update once per frame\n\n\t\tif ( updateList[ buffergeometry.id ] !== frame ) {\n\n\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\tbuffergeometry.updateFromObject( object );\n\n\t\t\t}\n\n\t\t\tgeometries.update( buffergeometry );\n\n\t\t\tupdateList[ buffergeometry.id ] = frame;\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tupdateList = {};\n\n\t}\n\n\treturn {\n\n\t\tupdate: update,\n\t\tdispose: dispose\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\timages = images !== undefined ? images : [];\n\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.flipY = false;\n\n}\n\nCubeTexture.prototype = Object.create( Texture.prototype );\nCubeTexture.prototype.constructor = CubeTexture;\n\nCubeTexture.prototype.isCubeTexture = true;\n\nObject.defineProperty( CubeTexture.prototype, 'images', {\n\n\tget: function () {\n\n\t\treturn this.image;\n\n\t},\n\n\tset: function ( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n} );\n\n/**\n * @author Artur Trzesiok\n */\n\nfunction DataTexture3D( data, width, height, depth ) {\n\n\t// We're going to add .setXXX() methods for setting properties later.\n\t// Users can still set in DataTexture3D directly.\n\t//\n\t//\tvar texture = new THREE.DataTexture3D( data, width, height, depth );\n\t// \ttexture.anisotropy = 16;\n\t//\n\t// See #14839\n\n\tTexture.call( this, null );\n\n\tthis.image = { data: data, width: width, height: height, depth: depth };\n\n\tthis.magFilter = NearestFilter;\n\tthis.minFilter = NearestFilter;\n\n\tthis.generateMipmaps = false;\n\tthis.flipY = false;\n\n}\n\nDataTexture3D.prototype = Object.create( Texture.prototype );\nDataTexture3D.prototype.constructor = DataTexture3D;\nDataTexture3D.prototype.isDataTexture3D = true;\n\n/**\n * @author tschw\n * @author Mugen87 / https://github.com/Mugen87\n * @author mrdoob / http://mrdoob.com/\n *\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [renderer] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'renderer' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (renderer factorizations):\n *\n * .upload( gl, seq, values, renderer )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (renderer factorizations):\n *\n * .setValue( gl, name, value )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .set( gl, obj, prop )\n *\n * \t\tsets uniform from object and property with same name than uniform\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\nvar emptyTexture = new Texture();\nvar emptyTexture3d = new DataTexture3D();\nvar emptyCubeTexture = new CubeTexture();\n\n// --- Base for inner nodes (including the root) ---\n\nfunction UniformContainer() {\n\n\tthis.seq = [];\n\tthis.map = {};\n\n}\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nvar arrayCacheF32 = [];\nvar arrayCacheI32 = [];\n\n// Float32Array caches used for uploading Matrix uniforms\n\nvar mat4array = new Float32Array( 16 );\nvar mat3array = new Float32Array( 9 );\nvar mat2array = new Float32Array( 4 );\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten( array, nBlocks, blockSize ) {\n\n\tvar firstElem = array[ 0 ];\n\n\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t// unoptimized: ! isNaN( firstElem )\n\t// see http://jacksondunstan.com/articles/983\n\n\tvar n = nBlocks * blockSize,\n\t\tr = arrayCacheF32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Float32Array( n );\n\t\tarrayCacheF32[ n ] = r;\n\n\t}\n\n\tif ( nBlocks !== 0 ) {\n\n\t\tfirstElem.toArray( r, 0 );\n\n\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\toffset += blockSize;\n\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t}\n\n\t}\n\n\treturn r;\n\n}\n\nfunction arraysEqual( a, b ) {\n\n\tif ( a.length !== b.length ) return false;\n\n\tfor ( var i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction copyArray( a, b ) {\n\n\tfor ( var i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ i ] = b[ i ];\n\n\t}\n\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits( renderer, n ) {\n\n\tvar r = arrayCacheI32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Int32Array( n );\n\t\tarrayCacheI32[ n ] = r;\n\n\t}\n\n\tfor ( var i = 0; i !== n; ++ i )\n\t\tr[ i ] = renderer.allocTextureUnit();\n\n\treturn r;\n\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValue1f( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1f( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\nfunction setValue1i( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1i( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValue2fv( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValue3fv( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else if ( v.r !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\n\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\n\t\t\tcache[ 0 ] = v.r;\n\t\t\tcache[ 1 ] = v.g;\n\t\t\tcache[ 2 ] = v.b;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValue4fv( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single matrix (from flat array or MatrixN)\n\nfunction setValue2fm( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat2array.set( elements );\n\n\t\tgl.uniformMatrix2fv( this.addr, false, mat2array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValue3fm( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat3array.set( elements );\n\n\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValue4fm( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat4array.set( elements );\n\n\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\n// Single texture (2D / Cube)\n\nfunction setValueT1( gl, v, renderer ) {\n\n\tvar cache = this.cache;\n\tvar unit = renderer.allocTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\trenderer.setTexture2D( v || emptyTexture, unit );\n\n}\n\nfunction setValueT3D1( gl, v, renderer ) {\n\n\tvar cache = this.cache;\n\tvar unit = renderer.allocTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\trenderer.setTexture3D( v || emptyTexture3d, unit );\n\n}\n\nfunction setValueT6( gl, v, renderer ) {\n\n\tvar cache = this.cache;\n\tvar unit = renderer.allocTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n}\n\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\nfunction setValue2iv( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform2iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValue3iv( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform3iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\nfunction setValue4iv( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform4iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\tcase 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\n\t\tcase 0x8B5F: return setValueT3D1; // SAMPLER_3D\n\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t}\n\n}\n\n// Array of scalars\n\nfunction setValue1fv( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform1fv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\nfunction setValue1iv( gl, v ) {\n\n\tvar cache = this.cache;\n\n\tif ( arraysEqual( cache, v ) ) return;\n\n\tgl.uniform1iv( this.addr, v );\n\n\tcopyArray( cache, v );\n\n}\n\n// Array of vectors (flat or from THREE classes)\n\nfunction setValueV2a( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar data = flatten( v, this.size, 2 );\n\n\tif ( arraysEqual( cache, data ) ) return;\n\n\tgl.uniform2fv( this.addr, data );\n\n\tthis.updateCache( data );\n\n}\n\nfunction setValueV3a( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar data = flatten( v, this.size, 3 );\n\n\tif ( arraysEqual( cache, data ) ) return;\n\n\tgl.uniform3fv( this.addr, data );\n\n\tthis.updateCache( data );\n\n}\n\nfunction setValueV4a( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar data = flatten( v, this.size, 4 );\n\n\tif ( arraysEqual( cache, data ) ) return;\n\n\tgl.uniform4fv( this.addr, data );\n\n\tthis.updateCache( data );\n\n}\n\n// Array of matrices (flat or from THREE clases)\n\nfunction setValueM2a( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar data = flatten( v, this.size, 4 );\n\n\tif ( arraysEqual( cache, data ) ) return;\n\n\tgl.uniformMatrix2fv( this.addr, false, data );\n\n\tthis.updateCache( data );\n\n}\n\nfunction setValueM3a( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar data = flatten( v, this.size, 9 );\n\n\tif ( arraysEqual( cache, data ) ) return;\n\n\tgl.uniformMatrix3fv( this.addr, false, data );\n\n\tthis.updateCache( data );\n\n}\n\nfunction setValueM4a( gl, v ) {\n\n\tvar cache = this.cache;\n\tvar data = flatten( v, this.size, 16 );\n\n\tif ( arraysEqual( cache, data ) ) return;\n\n\tgl.uniformMatrix4fv( this.addr, false, data );\n\n\tthis.updateCache( data );\n\n}\n\n// Array of textures (2D / Cube)\n\nfunction setValueT1a( gl, v, renderer ) {\n\n\tvar cache = this.cache;\n\tvar n = v.length;\n\n\tvar units = allocTexUnits( renderer, n );\n\n\tif ( arraysEqual( cache, units ) === false ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT6a( gl, v, renderer ) {\n\n\tvar cache = this.cache;\n\tvar n = v.length;\n\n\tvar units = allocTexUnits( renderer, n );\n\n\tif ( arraysEqual( cache, units ) === false ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t}\n\n}\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t}\n\n}\n\n// --- Uniform Classes ---\n\nfunction SingleUniform( id, activeInfo, addr ) {\n\n\tthis.id = id;\n\tthis.addr = addr;\n\tthis.cache = [];\n\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t// this.path = activeInfo.name; // DEBUG\n\n}\n\nfunction PureArrayUniform( id, activeInfo, addr ) {\n\n\tthis.id = id;\n\tthis.addr = addr;\n\tthis.cache = [];\n\tthis.size = activeInfo.size;\n\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t// this.path = activeInfo.name; // DEBUG\n\n}\n\nPureArrayUniform.prototype.updateCache = function ( data ) {\n\n\tvar cache = this.cache;\n\n\tif ( data instanceof Float32Array && cache.length !== data.length ) {\n\n\t\tthis.cache = new Float32Array( data.length );\n\n\t}\n\n\tcopyArray( cache, data );\n\n};\n\nfunction StructuredUniform( id ) {\n\n\tthis.id = id;\n\n\tUniformContainer.call( this ); // mix-in\n\n}\n\nStructuredUniform.prototype.setValue = function ( gl, value, renderer ) {\n\n\tvar seq = this.seq;\n\n\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tvar u = seq[ i ];\n\t\tu.setValue( gl, value[ u.id ], renderer );\n\n\t}\n\n};\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform( container, uniformObject ) {\n\n\tcontainer.seq.push( uniformObject );\n\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n}\n\nfunction parseUniform( activeInfo, addr, container ) {\n\n\tvar path = activeInfo.name,\n\t\tpathLength = path.length;\n\n\t// reset RegExp object, because of the early exit of a previous run\n\tRePathPart.lastIndex = 0;\n\n\twhile ( true ) {\n\n\t\tvar match = RePathPart.exec( path ),\n\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\tid = match[ 1 ],\n\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\tsubscript = match[ 3 ];\n\n\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\n\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\tvar map = container.map, next = map[ id ];\n\n\t\t\tif ( next === undefined ) {\n\n\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\taddUniform( container, next );\n\n\t\t\t}\n\n\t\t\tcontainer = next;\n\n\t\t}\n\n\t}\n\n}\n\n// Root Container\n\nfunction WebGLUniforms( gl, program, renderer ) {\n\n\tUniformContainer.call( this );\n\n\tthis.renderer = renderer;\n\n\tvar n = gl.getProgramParameter( program, 35718 );\n\n\tfor ( var i = 0; i < n; ++ i ) {\n\n\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\taddr = gl.getUniformLocation( program, info.name );\n\n\t\tparseUniform( info, addr, this );\n\n\t}\n\n}\n\nWebGLUniforms.prototype.setValue = function ( gl, name, value ) {\n\n\tvar u = this.map[ name ];\n\n\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n};\n\nWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\n\n\tvar v = object[ name ];\n\n\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n};\n\n\n// Static interface\n\nWebGLUniforms.upload = function ( gl, seq, values, renderer ) {\n\n\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tvar u = seq[ i ],\n\t\t\tv = values[ u.id ];\n\n\t\tif ( v.needsUpdate !== false ) {\n\n\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t}\n\n\t}\n\n};\n\nWebGLUniforms.seqWithValue = function ( seq, values ) {\n\n\tvar r = [];\n\n\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\tvar u = seq[ i ];\n\t\tif ( u.id in values ) r.push( u );\n\n\t}\n\n\treturn r;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction addLineNumbers( string ) {\n\n\tvar lines = string.split( '\\n' );\n\n\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t}\n\n\treturn lines.join( '\\n' );\n\n}\n\nfunction WebGLShader( gl, type, string ) {\n\n\tvar shader = gl.createShader( type );\n\n\tgl.shaderSource( shader, string );\n\tgl.compileShader( shader );\n\n\tif ( gl.getShaderParameter( shader, 35713 ) === false ) {\n\n\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t}\n\n\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === 35633 ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t}\n\n\t// --enable-privileged-webgl-extension\n\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\treturn shader;\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar programIdCount = 0;\n\nfunction getEncodingComponents( encoding ) {\n\n\tswitch ( encoding ) {\n\n\t\tcase LinearEncoding:\n\t\t\treturn [ 'Linear', '( value )' ];\n\t\tcase sRGBEncoding:\n\t\t\treturn [ 'sRGB', '( value )' ];\n\t\tcase RGBEEncoding:\n\t\t\treturn [ 'RGBE', '( value )' ];\n\t\tcase RGBM7Encoding:\n\t\t\treturn [ 'RGBM', '( value, 7.0 )' ];\n\t\tcase RGBM16Encoding:\n\t\t\treturn [ 'RGBM', '( value, 16.0 )' ];\n\t\tcase RGBDEncoding:\n\t\t\treturn [ 'RGBD', '( value, 256.0 )' ];\n\t\tcase GammaEncoding:\n\t\t\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\n\t\tdefault:\n\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t}\n\n}\n\nfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\tvar components = getEncodingComponents( encoding );\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\n\n}\n\nfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\tvar components = getEncodingComponents( encoding );\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\n\n}\n\nfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\tvar toneMappingName;\n\n\tswitch ( toneMapping ) {\n\n\t\tcase LinearToneMapping:\n\t\t\ttoneMappingName = 'Linear';\n\t\t\tbreak;\n\n\t\tcase ReinhardToneMapping:\n\t\t\ttoneMappingName = 'Reinhard';\n\t\t\tbreak;\n\n\t\tcase Uncharted2ToneMapping:\n\t\t\ttoneMappingName = 'Uncharted2';\n\t\t\tbreak;\n\n\t\tcase CineonToneMapping:\n\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\tbreak;\n\n\t\tcase ACESFilmicToneMapping:\n\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t}\n\n\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\n}\n\nfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\textensions = extensions || {};\n\n\tvar chunks = [\n\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\n\t];\n\n\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n}\n\nfunction generateDefines( defines ) {\n\n\tvar chunks = [];\n\n\tfor ( var name in defines ) {\n\n\t\tvar value = defines[ name ];\n\n\t\tif ( value === false ) continue;\n\n\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t}\n\n\treturn chunks.join( '\\n' );\n\n}\n\nfunction fetchAttributeLocations( gl, program ) {\n\n\tvar attributes = {};\n\n\tvar n = gl.getProgramParameter( program, 35721 );\n\n\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\tvar info = gl.getActiveAttrib( program, i );\n\t\tvar name = info.name;\n\n\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t}\n\n\treturn attributes;\n\n}\n\nfunction filterEmptyLine( string ) {\n\n\treturn string !== '';\n\n}\n\nfunction replaceLightNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n}\n\nfunction replaceClippingPlaneNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\n}\n\nfunction parseIncludes( string ) {\n\n\tvar pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n\tfunction replace( match, include ) {\n\n\t\tvar replace = ShaderChunk[ include ];\n\n\t\tif ( replace === undefined ) {\n\n\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t}\n\n\t\treturn parseIncludes( replace );\n\n\t}\n\n\treturn string.replace( pattern, replace );\n\n}\n\nfunction unrollLoops( string ) {\n\n\tvar pattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\tfunction replace( match, start, end, snippet ) {\n\n\t\tvar unroll = '';\n\n\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t}\n\n\t\treturn unroll;\n\n\t}\n\n\treturn string.replace( pattern, replace );\n\n}\n\nfunction WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities ) {\n\n\tvar gl = renderer.context;\n\n\tvar defines = material.defines;\n\n\tvar vertexShader = shader.vertexShader;\n\tvar fragmentShader = shader.fragmentShader;\n\n\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t}\n\n\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\tcase CubeReflectionMapping:\n\t\t\tcase CubeRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\tbreak;\n\n\t\t\tcase CubeUVReflectionMapping:\n\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\tbreak;\n\n\t\t\tcase EquirectangularReflectionMapping:\n\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\tbreak;\n\n\t\t\tcase SphericalReflectionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\tcase CubeRefractionMapping:\n\t\t\tcase EquirectangularRefractionMapping:\n\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tswitch ( material.combine ) {\n\n\t\t\tcase MultiplyOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\tbreak;\n\n\t\t\tcase MixOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\tbreak;\n\n\t\t\tcase AddOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t// console.log( 'building new program ' );\n\n\t//\n\n\tvar customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );\n\n\tvar customDefines = generateDefines( defines );\n\n\t//\n\n\tvar program = gl.createProgram();\n\n\tvar prefixVertex, prefixFragment;\n\n\tif ( material.isRawShaderMaterial ) {\n\n\t\tprefixVertex = [\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixVertex.length > 0 ) {\n\n\t\t\tprefixVertex += '\\n';\n\n\t\t}\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixFragment.length > 0 ) {\n\n\t\t\tprefixFragment += '\\n';\n\n\t\t}\n\n\t} else {\n\n\t\tprefixVertex = [\n\n\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t'#define SHADER_NAME ' + shader.name,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\n\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\tparameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec3 normal;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t'\tattribute vec3 color;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t'\t#else',\n\n\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t'\t#endif',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t'#endif',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\n\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t'#define SHADER_NAME ' + shader.name,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer\n\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.matcap ? '#define USE_MATCAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n\t\t\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\tparameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\tparameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\n\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\n\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?\n\t\t\t\tShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\tparameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',\n\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\n\n\t\t\tparameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tvertexShader = parseIncludes( vertexShader );\n\tvertexShader = replaceLightNums( vertexShader, parameters );\n\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\n\tfragmentShader = parseIncludes( fragmentShader );\n\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\n\tvertexShader = unrollLoops( vertexShader );\n\tfragmentShader = unrollLoops( fragmentShader );\n\n\tif ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {\n\n\t\tvar isGLSL3ShaderMaterial = false;\n\n\t\tvar versionRegex = /^\\s*#version\\s+300\\s+es\\s*\\n/;\n\n\t\tif ( material.isShaderMaterial &&\n\t\t\tvertexShader.match( versionRegex ) !== null &&\n\t\t\tfragmentShader.match( versionRegex ) !== null ) {\n\n\t\t\tisGLSL3ShaderMaterial = true;\n\n\t\t\tvertexShader = vertexShader.replace( versionRegex, '' );\n\t\t\tfragmentShader = fragmentShader.replace( versionRegex, '' );\n\n\t\t}\n\n\t\t// GLSL 3.0 conversion\n\t\tprefixVertex = [\n\t\t\t'#version 300 es\\n',\n\t\t\t'#define attribute in',\n\t\t\t'#define varying out',\n\t\t\t'#define texture2D texture'\n\t\t].join( '\\n' ) + '\\n' + prefixVertex;\n\n\t\tprefixFragment = [\n\t\t\t'#version 300 es\\n',\n\t\t\t'#define varying in',\n\t\t\tisGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',\n\t\t\tisGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',\n\t\t\t'#define gl_FragDepthEXT gl_FragDepth',\n\t\t\t'#define texture2D texture',\n\t\t\t'#define textureCube texture',\n\t\t\t'#define texture2DProj textureProj',\n\t\t\t'#define texture2DLodEXT textureLod',\n\t\t\t'#define texture2DProjLodEXT textureProjLod',\n\t\t\t'#define textureCubeLodEXT textureLod',\n\t\t\t'#define texture2DGradEXT textureGrad',\n\t\t\t'#define texture2DProjGradEXT textureProjGrad',\n\t\t\t'#define textureCubeGradEXT textureGrad'\n\t\t].join( '\\n' ) + '\\n' + prefixFragment;\n\n\t}\n\n\tvar vertexGlsl = prefixVertex + vertexShader;\n\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t// console.log( '*VERTEX*', vertexGlsl );\n\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\tvar glVertexShader = WebGLShader( gl, 35633, vertexGlsl );\n\tvar glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );\n\n\tgl.attachShader( program, glVertexShader );\n\tgl.attachShader( program, glFragmentShader );\n\n\t// Force a particular attribute to index 0.\n\n\tif ( material.index0AttributeName !== undefined ) {\n\n\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t} else if ( parameters.morphTargets === true ) {\n\n\t\t// programs with morphTargets displace position out of attribute 0\n\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t}\n\n\tgl.linkProgram( program );\n\n\tvar programLog = gl.getProgramInfoLog( program ).trim();\n\tvar vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\n\tvar runnable = true;\n\tvar haveDiagnostics = true;\n\n\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\tif ( gl.getProgramParameter( program, 35714 ) === false ) {\n\n\t\trunnable = false;\n\n\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t} else if ( programLog !== '' ) {\n\n\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\thaveDiagnostics = false;\n\n\t}\n\n\tif ( haveDiagnostics ) {\n\n\t\tthis.diagnostics = {\n\n\t\t\trunnable: runnable,\n\t\t\tmaterial: material,\n\n\t\t\tprogramLog: programLog,\n\n\t\t\tvertexShader: {\n\n\t\t\t\tlog: vertexLog,\n\t\t\t\tprefix: prefixVertex\n\n\t\t\t},\n\n\t\t\tfragmentShader: {\n\n\t\t\t\tlog: fragmentLog,\n\t\t\t\tprefix: prefixFragment\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// clean up\n\n\tgl.deleteShader( glVertexShader );\n\tgl.deleteShader( glFragmentShader );\n\n\t// set up caching for uniform locations\n\n\tvar cachedUniforms;\n\n\tthis.getUniforms = function () {\n\n\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\tcachedUniforms = new WebGLUniforms( gl, program, renderer );\n\n\t\t}\n\n\t\treturn cachedUniforms;\n\n\t};\n\n\t// set up caching for attribute locations\n\n\tvar cachedAttributes;\n\n\tthis.getAttributes = function () {\n\n\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t}\n\n\t\treturn cachedAttributes;\n\n\t};\n\n\t// free resource\n\n\tthis.destroy = function () {\n\n\t\tgl.deleteProgram( program );\n\t\tthis.program = undefined;\n\n\t};\n\n\t// DEPRECATED\n\n\tObject.defineProperties( this, {\n\n\t\tuniforms: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\treturn this.getUniforms();\n\n\t\t\t}\n\t\t},\n\n\t\tattributes: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\treturn this.getAttributes();\n\n\t\t\t}\n\t\t}\n\n\t} );\n\n\n\t//\n\n\tthis.name = shader.name;\n\tthis.id = programIdCount ++;\n\tthis.code = code;\n\tthis.usedTimes = 1;\n\tthis.program = program;\n\tthis.vertexShader = glVertexShader;\n\tthis.fragmentShader = glFragmentShader;\n\n\treturn this;\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLPrograms( renderer, extensions, capabilities ) {\n\n\tvar programs = [];\n\n\tvar shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tMeshMatcapMaterial: 'matcap',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points',\n\t\tShadowMaterial: 'shadow',\n\t\tSpriteMaterial: 'sprite'\n\t};\n\n\tvar parameterNames = [\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"matcap\", \"matcapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"objectSpaceNormalMap\", \"displacementMap\", \"specularMap\",\n\t\t\"roughnessMap\", \"metalnessMap\", \"gradientMap\",\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\", \"numRectAreaLights\",\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\", \"dithering\"\n\t];\n\n\n\tfunction allocateBones( object ) {\n\n\t\tvar skeleton = object.skeleton;\n\t\tvar bones = skeleton.bones;\n\n\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = Math.min( nVertexMatrices, bones.length );\n\n\t\t\tif ( maxBones < bones.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\tvar encoding;\n\n\t\tif ( ! map ) {\n\n\t\t\tencoding = LinearEncoding;\n\n\t\t} else if ( map.isTexture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map.isWebGLRenderTarget ) {\n\n\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t}\n\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\tencoding = GammaEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tthis.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {\n\n\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\n\t\tvar precision = capabilities.precision;\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar parameters = {\n\n\t\t\tshaderID: shaderID,\n\n\t\t\tprecision: precision,\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\tmatcap: !! material.matcap,\n\t\t\tmatcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),\n\t\t\tenvMap: !! material.envMap,\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tobjectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tgradientMap: !! material.gradientMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: !! fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: ( fog && fog.isFogExp2 ),\n\n\t\t\tflatShading: material.flatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\tskinning: material.skinning && maxBones > 0,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumClippingPlanes: nClipPlanes,\n\t\t\tnumClipIntersection: nClipIntersection,\n\n\t\t\tdithering: material.dithering,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\tflipSided: material.side === BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t};\n\n\t\treturn parameters;\n\n\t};\n\n\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\tvar array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( material.fragmentShader );\n\t\t\tarray.push( material.vertexShader );\n\n\t\t}\n\n\t\tif ( material.defines !== undefined ) {\n\n\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t}\n\n\t\tarray.push( material.onBeforeCompile.toString() );\n\n\t\tarray.push( renderer.gammaOutput );\n\n\t\tarray.push( renderer.gammaFactor );\n\n\t\treturn array.join();\n\n\t};\n\n\tthis.acquireProgram = function ( material, shader, parameters, code ) {\n\n\t\tvar program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\tprogram = programInfo;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\tthis.releaseProgram = function ( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tvar i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t};\n\n\t// Exposed for resource monitoring & error feedback via renderer.info:\n\tthis.programs = programs;\n\n}\n\n/**\n * @author fordacious / fordacious.github.io\n */\n\nfunction WebGLProperties() {\n\n\tvar properties = new WeakMap();\n\n\tfunction get( object ) {\n\n\t\tvar map = properties.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tfunction remove( object ) {\n\n\t\tproperties.delete( object );\n\n\t}\n\n\tfunction update( object, key, value ) {\n\n\t\tproperties.get( object )[ key ] = value;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tproperties = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update,\n\t\tdispose: dispose\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.program && b.program && a.program !== b.program ) {\n\n\t\treturn a.program.id - b.program.id;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n\nfunction WebGLRenderList() {\n\n\tvar renderItems = [];\n\tvar renderItemsIndex = 0;\n\n\tvar opaque = [];\n\tvar transparent = [];\n\n\tfunction init() {\n\n\t\trenderItemsIndex = 0;\n\n\t\topaque.length = 0;\n\t\ttransparent.length = 0;\n\n\t}\n\n\tfunction getNextRenderItem( object, geometry, material, groupOrder, z, group ) {\n\n\t\tvar renderItem = renderItems[ renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tprogram: material.program,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.program = material.program;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\n\t\t}\n\n\t\trenderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tfunction push( object, geometry, material, groupOrder, z, group ) {\n\n\t\tvar renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\t( material.transparent === true ? transparent : opaque ).push( renderItem );\n\n\t}\n\n\tfunction unshift( object, geometry, material, groupOrder, z, group ) {\n\n\t\tvar renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\t( material.transparent === true ? transparent : opaque ).unshift( renderItem );\n\n\t}\n\n\tfunction sort() {\n\n\t\tif ( opaque.length > 1 ) opaque.sort( painterSortStable );\n\t\tif ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );\n\n\t}\n\n\treturn {\n\t\topaque: opaque,\n\t\ttransparent: transparent,\n\n\t\tinit: init,\n\t\tpush: push,\n\t\tunshift: unshift,\n\n\t\tsort: sort\n\t};\n\n}\n\nfunction WebGLRenderLists() {\n\n\tvar lists = {};\n\n\tfunction onSceneDispose( event ) {\n\n\t\tvar scene = event.target;\n\n\t\tscene.removeEventListener( 'dispose', onSceneDispose );\n\n\t\tdelete lists[ scene.id ];\n\n\t}\n\n\tfunction get( scene, camera ) {\n\n\t\tvar cameras = lists[ scene.id ];\n\t\tvar list;\n\t\tif ( cameras === undefined ) {\n\n\t\t\tlist = new WebGLRenderList();\n\t\t\tlists[ scene.id ] = {};\n\t\t\tlists[ scene.id ][ camera.id ] = list;\n\n\t\t\tscene.addEventListener( 'dispose', onSceneDispose );\n\n\t\t} else {\n\n\t\t\tlist = cameras[ camera.id ];\n\t\t\tif ( list === undefined ) {\n\n\t\t\t\tlist = new WebGLRenderList();\n\t\t\t\tcameras[ camera.id ] = list;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tlists = {};\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction UniformsCache() {\n\n\tvar lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tvar uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\nvar count = 0;\n\nfunction WebGLLights() {\n\n\tvar cache = new UniformsCache();\n\n\tvar state = {\n\n\t\tid: count ++,\n\n\t\thash: {\n\t\t\tstateID: - 1,\n\t\t\tdirectionalLength: - 1,\n\t\t\tpointLength: - 1,\n\t\t\tspotLength: - 1,\n\t\t\trectAreaLength: - 1,\n\t\t\themiLength: - 1,\n\t\t\tshadowsLength: - 1\n\t\t},\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\trectArea: [],\n\t\tpoint: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: []\n\n\t};\n\n\tvar vector3 = new Vector3();\n\tvar matrix4 = new Matrix4();\n\tvar matrix42 = new Matrix4();\n\n\tfunction setup( lights, shadows, camera ) {\n\n\t\tvar r = 0, g = 0, b = 0;\n\n\t\tvar directionalLength = 0;\n\t\tvar pointLength = 0;\n\t\tvar spotLength = 0;\n\t\tvar rectAreaLength = 0;\n\t\tvar hemiLength = 0;\n\n\t\tvar viewMatrix = camera.matrixWorldInverse;\n\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\n\t\t\tvar color = light.color;\n\t\t\tvar intensity = light.intensity;\n\t\t\tvar distance = light.distance;\n\n\t\t\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\t// (a) intensity is the total visible light emitted\n\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\n\t\t\t\t// (b) intensity is the brightness of the light\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\tmatrix42.identity();\n\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\t// TODO (abelnation): RectAreaLight distance?\n\t\t\t\t// uniforms.distance = distance;\n\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tvar shadow = light.shadow;\n\n\t\t\t\t\tuniforms.shadowBias = shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\tuniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\tuniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t}\n\n\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tvar uniforms = cache.get( light );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.ambient[ 0 ] = r;\n\t\tstate.ambient[ 1 ] = g;\n\t\tstate.ambient[ 2 ] = b;\n\n\t\tstate.directional.length = directionalLength;\n\t\tstate.spot.length = spotLength;\n\t\tstate.rectArea.length = rectAreaLength;\n\t\tstate.point.length = pointLength;\n\t\tstate.hemi.length = hemiLength;\n\n\t\tstate.hash.stateID = state.id;\n\t\tstate.hash.directionalLength = directionalLength;\n\t\tstate.hash.pointLength = pointLength;\n\t\tstate.hash.spotLength = spotLength;\n\t\tstate.hash.rectAreaLength = rectAreaLength;\n\t\tstate.hash.hemiLength = hemiLength;\n\t\tstate.hash.shadowsLength = shadows.length;\n\n\t}\n\n\treturn {\n\t\tsetup: setup,\n\t\tstate: state\n\t};\n\n}\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction WebGLRenderState() {\n\n\tvar lights = new WebGLLights();\n\n\tvar lightsArray = [];\n\tvar shadowsArray = [];\n\n\tfunction init() {\n\n\t\tlightsArray.length = 0;\n\t\tshadowsArray.length = 0;\n\n\t}\n\n\tfunction pushLight( light ) {\n\n\t\tlightsArray.push( light );\n\n\t}\n\n\tfunction pushShadow( shadowLight ) {\n\n\t\tshadowsArray.push( shadowLight );\n\n\t}\n\n\tfunction setupLights( camera ) {\n\n\t\tlights.setup( lightsArray, shadowsArray, camera );\n\n\t}\n\n\tvar state = {\n\t\tlightsArray: lightsArray,\n\t\tshadowsArray: shadowsArray,\n\n\t\tlights: lights\n\t};\n\n\treturn {\n\t\tinit: init,\n\t\tstate: state,\n\t\tsetupLights: setupLights,\n\n\t\tpushLight: pushLight,\n\t\tpushShadow: pushShadow\n\t};\n\n}\n\nfunction WebGLRenderStates() {\n\n\tvar renderStates = {};\n\n\tfunction onSceneDispose( event ) {\n\n\t\tvar scene = event.target;\n\n\t\tscene.removeEventListener( 'dispose', onSceneDispose );\n\n\t\tdelete renderStates[ scene.id ];\n\n\t}\n\n\tfunction get( scene, camera ) {\n\n\t\tvar renderState;\n\n\t\tif ( renderStates[ scene.id ] === undefined ) {\n\n\t\t\trenderState = new WebGLRenderState();\n\t\t\trenderStates[ scene.id ] = {};\n\t\t\trenderStates[ scene.id ][ camera.id ] = renderState;\n\n\t\t\tscene.addEventListener( 'dispose', onSceneDispose );\n\n\t\t} else {\n\n\t\t\tif ( renderStates[ scene.id ][ camera.id ] === undefined ) {\n\n\t\t\t\trenderState = new WebGLRenderState();\n\t\t\t\trenderStates[ scene.id ][ camera.id ] = renderState;\n\n\t\t\t} else {\n\n\t\t\t\trenderState = renderStates[ scene.id ][ camera.id ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderState;\n\n\t}\n\n\tfunction dispose() {\n\n\t\trenderStates = {};\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / https://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nfunction MeshDepthMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshDepthMaterial';\n\n\tthis.depthPacking = BasicDepthPacking;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshDepthMaterial.prototype = Object.create( Material.prototype );\nMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\nMeshDepthMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.depthPacking = source.depthPacking;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  referencePosition: <float>,\n *  nearDistance: <float>,\n *  farDistance: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>\n *\n * }\n */\n\nfunction MeshDistanceMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshDistanceMaterial';\n\n\tthis.referencePosition = new Vector3();\n\tthis.nearDistance = 1;\n\tthis.farDistance = 1000;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshDistanceMaterial.prototype = Object.create( Material.prototype );\nMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\n\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\nMeshDistanceMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.referencePosition.copy( source.referencePosition );\n\tthis.nearDistance = source.nearDistance;\n\tthis.farDistance = source.farDistance;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\treturn this;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\n\n\tvar _frustum = new Frustum(),\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_shadowMapSize = new Vector2(),\n\t\t_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),\n\n\t\t_lookTarget = new Vector3(),\n\t\t_lightPositionWorld = new Vector3(),\n\n\t\t_MorphingFlag = 1,\n\t\t_SkinningFlag = 2,\n\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t\t_materialCache = {};\n\n\tvar shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\n\n\tvar cubeDirections = [\n\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t];\n\n\tvar cubeUps = [\n\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t];\n\n\tvar cube2DViewPorts = [\n\t\tnew Vector4(), new Vector4(), new Vector4(),\n\t\tnew Vector4(), new Vector4(), new Vector4()\n\t];\n\n\t// init\n\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\tvar depthMaterial = new MeshDepthMaterial( {\n\n\t\t\tdepthPacking: RGBADepthPacking,\n\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning\n\n\t\t} );\n\n\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\t//\n\n\t\tvar distanceMaterial = new MeshDistanceMaterial( {\n\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning\n\n\t\t} );\n\n\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t}\n\n\t//\n\n\tvar scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tvar _state = _renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tvar faceCount;\n\n\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\t\t\tvar shadow = light.shadow;\n\t\t\tvar isPointLight = light && light.isPointLight;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t// following orientation:\n\t\t\t\t//\n\t\t\t\t//  xzXZ\n\t\t\t\t//   y Y\n\t\t\t\t//\n\t\t\t\t// X - Positive x direction\n\t\t\t\t// x - Negative x direction\n\t\t\t\t// Y - Positive y direction\n\t\t\t\t// y - Negative y direction\n\t\t\t\t// Z - Positive z direction\n\t\t\t\t// z - Negative z direction\n\n\t\t\t\t// positive X\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative X\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Z\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative Z\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Y\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t// negative Y\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + \".shadowMap\";\n\n\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow.isSpotLightShadow ) {\n\n\t\t\t\tshadow.update( light );\n\n\t\t\t}\n\n\t\t\tvar shadowMap = shadow.map;\n\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\tif ( isPointLight ) {\n\n\t\t\t\tfaceCount = 6;\n\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t// equal to inverse of the light's position\n\n\t\t\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t\t} else {\n\n\t\t\t\tfaceCount = 1;\n\n\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\t\t// compute shadow matrix\n\n\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t// run a single pass if not\n\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t}\n\n\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\trenderObject( scene, camera, shadowCamera, isPointLight );\n\n\t\t\t}\n\n\t\t}\n\n\t\tscope.needsUpdate = false;\n\n\t};\n\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tvar result = null;\n\n\t\tvar materialVariants = _depthMaterials;\n\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\tif ( isPointLight ) {\n\n\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( ! customMaterial ) {\n\n\t\t\tvar useMorphing = false;\n\n\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\tif ( geometry && geometry.isBufferGeometry ) {\n\n\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t\t} else if ( geometry && geometry.isGeometry ) {\n\n\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( object.isSkinnedMesh && material.skinning === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\n\n\t\t\t}\n\n\t\t\tvar useSkinning = object.isSkinnedMesh && material.skinning;\n\n\t\t\tvar variantIndex = 0;\n\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\tmaterial.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tresult.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( isPointLight && result.isMeshDistanceMaterial ) {\n\n\t\t\tresult.referencePosition.copy( lightPositionWorld );\n\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\tresult.farDistance = shadowCameraFar;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, isPointLight ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tvar visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, isPointLight );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLState( gl, extensions, utils, capabilities ) {\n\n\tfunction ColorBuffer() {\n\n\t\tvar locked = false;\n\n\t\tvar color = new Vector4();\n\t\tvar currentColorMask = null;\n\t\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\n\n\t\treturn {\n\n\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n\t\t\t\tif ( premultipliedAlpha === true ) {\n\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t\t}\n\n\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentColorMask = null;\n\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction DepthBuffer() {\n\n\t\tvar locked = false;\n\n\t\tvar currentDepthMask = null;\n\t\tvar currentDepthFunc = null;\n\t\tvar currentDepthClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\tenable( 2929 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( 2929 );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\tif ( depthFunc ) {\n\n\t\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 512 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 519 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 513 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 515 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 514 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 518 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 516 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 517 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tgl.depthFunc( 515 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.depthFunc( 515 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentDepthMask = null;\n\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction StencilBuffer() {\n\n\t\tvar locked = false;\n\n\t\tvar currentStencilMask = null;\n\t\tvar currentStencilFunc = null;\n\t\tvar currentStencilRef = null;\n\t\tvar currentStencilFuncMask = null;\n\t\tvar currentStencilFail = null;\n\t\tvar currentStencilZFail = null;\n\t\tvar currentStencilZPass = null;\n\t\tvar currentStencilClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\tenable( 2960 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( 2960 );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentStencilMask = null;\n\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\tcurrentStencilRef = null;\n\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\tcurrentStencilFail = null;\n\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t//\n\n\tvar colorBuffer = new ColorBuffer();\n\tvar depthBuffer = new DepthBuffer();\n\tvar stencilBuffer = new StencilBuffer();\n\n\tvar maxVertexAttributes = gl.getParameter( 34921 );\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\tvar enabledCapabilities = {};\n\n\tvar compressedTextureFormats = null;\n\n\tvar currentProgram = null;\n\n\tvar currentBlendingEnabled = null;\n\tvar currentBlending = null;\n\tvar currentBlendEquation = null;\n\tvar currentBlendSrc = null;\n\tvar currentBlendDst = null;\n\tvar currentBlendEquationAlpha = null;\n\tvar currentBlendSrcAlpha = null;\n\tvar currentBlendDstAlpha = null;\n\tvar currentPremultipledAlpha = false;\n\n\tvar currentFlipSided = null;\n\tvar currentCullFace = null;\n\n\tvar currentLineWidth = null;\n\n\tvar currentPolygonOffsetFactor = null;\n\tvar currentPolygonOffsetUnits = null;\n\n\tvar maxTextures = gl.getParameter( 35661 );\n\n\tvar lineWidthAvailable = false;\n\tvar version = 0;\n\tvar glVersion = gl.getParameter( 7938 );\n\n\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^WebGL\\ ([0-9])/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 1.0 );\n\n\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^OpenGL\\ ES\\ ([0-9])/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 2.0 );\n\n\t}\n\n\tvar currentTextureSlot = null;\n\tvar currentBoundTextures = {};\n\n\tvar currentScissor = new Vector4();\n\tvar currentViewport = new Vector4();\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tvar texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, 10241, 9728 );\n\t\tgl.texParameteri( type, 10240, 9728 );\n\n\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tvar emptyTextures = {};\n\temptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );\n\temptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );\n\n\t// init\n\n\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\tdepthBuffer.setClear( 1 );\n\tstencilBuffer.setClear( 0 );\n\n\tenable( 2929 );\n\tdepthBuffer.setFunc( LessEqualDepth );\n\n\tsetFlipSided( false );\n\tsetCullFace( CullFaceBack );\n\tenable( 2884 );\n\n\tsetBlending( NoBlending );\n\n\t//\n\n\tfunction initAttributes() {\n\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tvar extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction enable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tenabledCapabilities[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tfunction disable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tenabledCapabilities[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tfunction getCompressedTextureFormats() {\n\n\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\tcompressedTextureFormats = [];\n\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {\n\n\t\t\t\tvar formats = gl.getParameter( 34467 );\n\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn compressedTextureFormats;\n\n\t}\n\n\tfunction useProgram( program ) {\n\n\t\tif ( currentProgram !== program ) {\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tcurrentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( currentBlendingEnabled ) {\n\n\t\t\t\tdisable( 3042 );\n\t\t\t\tcurrentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( ! currentBlendingEnabled ) {\n\n\t\t\tenable( 3042 );\n\t\t\tcurrentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( 32774 );\n\n\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 1, 771, 1, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 1, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 0, 0, 769, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 0, 768, 0, 770 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( 770, 771, 1, 771 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 770, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 0, 769 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( 0, 768 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );\n\n\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );\n\n\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\tcurrentBlendDst = blendDst;\n\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tcurrentBlending = blending;\n\t\tcurrentPremultipledAlpha = null;\n\n\t}\n\n\tfunction setMaterial( material, frontFaceCW ) {\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? disable( 2884 )\n\t\t\t: enable( 2884 );\n\n\t\tvar flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tsetFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? setBlending( NoBlending )\n\t\t\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\tdepthBuffer.setTest( material.depthTest );\n\t\tdepthBuffer.setMask( material.depthWrite );\n\t\tcolorBuffer.setMask( material.colorWrite );\n\n\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t}\n\n\t//\n\n\tfunction setFlipSided( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( 2304 );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( 2305 );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tfunction setCullFace( cullFace ) {\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tenable( 2884 );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( 1029 );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( 1028 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( 1032 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( 2884 );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t}\n\n\tfunction setLineWidth( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tenable( 32823 );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( 32823 );\n\n\t\t}\n\n\t}\n\n\tfunction setScissorTest( scissorTest ) {\n\n\t\tif ( scissorTest ) {\n\n\t\t\tenable( 3089 );\n\n\t\t} else {\n\n\t\t\tdisable( 3089 );\n\n\t\t}\n\n\t}\n\n\t// texture\n\n\tfunction activeTexture( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tfunction bindTexture( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\tactiveTexture();\n\n\t\t}\n\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction scissor( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\tfunction viewport( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction reset() {\n\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tenabledCapabilities = {};\n\n\t\tcompressedTextureFormats = null;\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentProgram = null;\n\n\t\tcurrentBlending = null;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tcolorBuffer.reset();\n\t\tdepthBuffer.reset();\n\t\tstencilBuffer.reset();\n\n\t}\n\n\treturn {\n\n\t\tbuffers: {\n\t\t\tcolor: colorBuffer,\n\t\t\tdepth: depthBuffer,\n\t\t\tstencil: stencilBuffer\n\t\t},\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tenableAttributeAndDivisor: enableAttributeAndDivisor,\n\t\tdisableUnusedAttributes: disableUnusedAttributes,\n\t\tenable: enable,\n\t\tdisable: disable,\n\t\tgetCompressedTextureFormats: getCompressedTextureFormats,\n\n\t\tuseProgram: useProgram,\n\n\t\tsetBlending: setBlending,\n\t\tsetMaterial: setMaterial,\n\n\t\tsetFlipSided: setFlipSided,\n\t\tsetCullFace: setCullFace,\n\n\t\tsetLineWidth: setLineWidth,\n\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\tsetScissorTest: setScissorTest,\n\n\t\tactiveTexture: activeTexture,\n\t\tbindTexture: bindTexture,\n\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\ttexImage2D: texImage2D,\n\t\ttexImage3D: texImage3D,\n\n\t\tscissor: scissor,\n\t\tviewport: viewport,\n\n\t\treset: reset\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\n\n\tvar _videoTextures = {};\n\tvar _canvas;\n\n\t//\n\n\tfunction resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {\n\n\t\tvar scale = 1;\n\n\t\t// handle case if texture exceeds max size\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\tscale = maxSize / Math.max( image.width, image.height );\n\n\t\t}\n\n\t\t// only perform resize if necessary\n\n\t\tif ( scale < 1 || needsPowerOfTwo === true ) {\n\n\t\t\t// only perform resize for certain image types\n\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\n\t\t\t\t// cube textures can't reuse the same canvas\n\n\t\t\t\tvar canvas = needsNewCanvas ? document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ) : _canvas;\n\n\t\t\t\tvar floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;\n\n\t\t\t\tcanvas.width = floor( scale * image.width );\n\t\t\t\tcanvas.height = floor( scale * image.height );\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + canvas.width + 'x' + canvas.height + ').' );\n\n\t\t\t\treturn canvas;\n\n\t\t\t} else {\n\n\t\t\t\tif ( 'data' in image ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );\n\n\t\t\t\t}\n\n\t\t\t\treturn image;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo( image ) {\n\n\t\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( capabilities.isWebGL2 ) return false;\n\n\t\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\n\t\t\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\n\n\t}\n\n\tfunction textureNeedsGenerateMipmaps( texture, supportsMips ) {\n\n\t\treturn texture.generateMipmaps && supportsMips &&\n\t\t\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t}\n\n\tfunction generateMipmap( target, texture, width, height ) {\n\n\t\t_gl.generateMipmap( target );\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\t// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11\n\t\ttextureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;\n\n\t}\n\n\tfunction getInternalFormat( glFormat, glType ) {\n\n\t\tif ( ! capabilities.isWebGL2 ) return glFormat;\n\n\t\tvar internalFormat = glFormat;\n\n\t\tif ( glFormat === 6403 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 33326;\n\t\t\tif ( glType === 5131 ) internalFormat = 33325;\n\t\t\tif ( glType === 5121 ) internalFormat = 33321;\n\n\t\t}\n\n\t\tif ( glFormat === 6407 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 34837;\n\t\t\tif ( glType === 5131 ) internalFormat = 34843;\n\t\t\tif ( glType === 5121 ) internalFormat = 32849;\n\n\t\t}\n\n\t\tif ( glFormat === 6408 ) {\n\n\t\t\tif ( glType === 5126 ) internalFormat = 34836;\n\t\t\tif ( glType === 5131 ) internalFormat = 34842;\n\t\t\tif ( glType === 5121 ) internalFormat = 32856;\n\n\t\t}\n\n\t\tif ( internalFormat === 33325 || internalFormat === 33326 ||\n\t\t\tinternalFormat === 34842 || internalFormat === 34836 ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t} else if ( internalFormat === 34843 || internalFormat === 34837 ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback( f ) {\n\n\t\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\n\t\t\treturn 9728;\n\n\t\t}\n\n\t\treturn 9729;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\tdelete _videoTextures[ texture.id ];\n\n\t\t}\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\t// remove all webgl properties\n\t\tproperties.remove( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t}\n\n\t\tproperties.remove( renderTarget.texture );\n\t\tproperties.remove( renderTarget );\n\n\t}\n\n\t//\n\n\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tvar image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 3553, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTexture3D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 32879, textureProperties.__webglTexture );\n\n\t}\n\n\n\tfunction setTextureCube( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.activeTexture( 33984 + slot );\n\t\t\t\tstate.bindTexture( 34067, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( 37440, texture.flipY );\n\n\t\t\t\tvar isCompressed = ( texture && texture.isCompressedTexture );\n\t\t\t\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\tsupportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,\n\t\t\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\t\t\tglType = utils.convert( texture.type ),\n\t\t\t\t\tglInternalFormat = getInternalFormat( glFormat, glType );\n\n\t\t\t\tsetTextureParameters( 34067, texture, supportsMips );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\t\t// We assume images for cube map have the same size.\n\t\t\t\t\tgenerateMipmap( 34067, texture, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t} else {\n\n\t\t\t\tstate.activeTexture( 33984 + slot );\n\t\t\t\tstate.bindTexture( 34067, textureProperties.__image__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setTextureCubeDynamic( texture, slot ) {\n\n\t\tstate.activeTexture( 33984 + slot );\n\t\tstate.bindTexture( 34067, properties.get( texture ).__webglTexture );\n\n\t}\n\n\tfunction setTextureParameters( textureType, texture, supportsMips ) {\n\n\t\tvar extension;\n\n\t\tif ( supportsMips ) {\n\n\t\t\t_gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, 10242, 33071 );\n\t\t\t_gl.texParameteri( textureType, 10243, 33071 );\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension ) {\n\n\t\t\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\tif ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tvar textureType;\n\n\t\tif ( texture.isDataTexture3D ) {\n\n\t\t\ttextureType = 32879;\n\n\t\t} else {\n\n\t\t\ttextureType = 3553;\n\n\t\t}\n\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\tinfo.memory.textures ++;\n\n\t\t}\n\t\tstate.activeTexture( 33984 + slot );\n\n\n\t\tstate.bindTexture( textureType, textureProperties.__webglTexture );\n\n\n\n\t\t_gl.pixelStorei( 37440, texture.flipY );\n\t\t_gl.pixelStorei( 37441, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( 3317, texture.unpackAlignment );\n\n\t\tvar needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;\n\t\tvar image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize );\n\n\t\tvar supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,\n\t\t\tglFormat = utils.convert( texture.format ),\n\t\t\tglType = utils.convert( texture.type ),\n\t\t\tglInternalFormat = getInternalFormat( glFormat, glType );\n\n\t\tsetTextureParameters( textureType, texture, supportsMips );\n\n\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tglInternalFormat = 6402;\n\n\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\tif ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );\n\t\t\t\tglInternalFormat = 36012;\n\n\t\t\t} else if ( capabilities.isWebGL2 ) {\n\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\tglInternalFormat = 33189;\n\n\t\t\t}\n\n\t\t\tif ( texture.format === DepthFormat && glInternalFormat === 6402 ) {\n\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\n\n\t\t\t\t\ttexture.type = UnsignedShortType;\n\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\tif ( texture.format === DepthStencilFormat ) {\n\n\t\t\t\tglInternalFormat = 34041;\n\n\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\tif ( texture.type !== UnsignedInt248Type ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\n\n\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture.isDataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t} else if ( texture.isDataTexture3D ) {\n\n\t\t\tstate.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\tgenerateMipmap( 3553, texture, image.width, image.height );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\tvar glFormat = utils.convert( renderTarget.texture.format );\n\t\tvar glType = utils.convert( renderTarget.texture.type );\n\t\tvar glInternalFormat = getInternalFormat( glFormat, glType );\n\t\tstate.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t_gl.bindFramebuffer( 36160, framebuffer );\n\t\t_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t_gl.bindFramebuffer( 36160, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {\n\n\t\t_gl.bindRenderbuffer( 36161, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tvar samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tvar samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, 34041, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\n\t\t\t_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );\n\n\t\t} else {\n\n\t\t\tvar glFormat = utils.convert( renderTarget.texture.format );\n\t\t\tvar glType = utils.convert( renderTarget.texture.type );\n\t\t\tvar glInternalFormat = getInternalFormat( glFormat, glType );\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tvar samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( 36161, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\n\t\t_gl.bindFramebuffer( 36160, framebuffer );\n\n\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\t_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );\n\n\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\t_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\n\t\t}\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindFramebuffer( 36160, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\tinfo.memory.textures ++;\n\n\t\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n\t\tvar isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );\n\t\tvar supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\tif ( isMultisample ) {\n\n\t\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );\n\t\t\t\t\tvar glFormat = utils.convert( renderTarget.texture.format );\n\t\t\t\t\tvar glType = utils.convert( renderTarget.texture.type );\n\t\t\t\t\tvar glInternalFormat = getInternalFormat( glFormat, glType );\n\t\t\t\t\tvar samples = getRenderTargetSamples( renderTarget );\n\t\t\t\t\t_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t\t_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );\n\t\t\t\t\t_gl.bindRenderbuffer( 36161, null );\n\n\t\t\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.bindFramebuffer( 36160, null );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( 34067, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( 34067, renderTarget.texture, supportsMips );\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( 34067, null );\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( 3553, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( 3553, renderTarget.texture, supportsMips );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );\n\n\t\t\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( 3553, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tvar texture = renderTarget.texture;\n\t\tvar supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\tvar target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;\n\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\tgenerateMipmap( target, texture, renderTarget.width, renderTarget.height );\n\t\t\tstate.bindTexture( target, null );\n\n\t\t}\n\n\t}\n\n\tfunction updateMultisampleRenderTarget( renderTarget ) {\n\n\t\tif ( renderTarget.isWebGLMultisampleRenderTarget ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\t_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );\n\n\t\t\t\tvar width = renderTarget.width;\n\t\t\t\tvar height = renderTarget.height;\n\t\t\t\tvar mask = 16384;\n\n\t\t\t\tif ( renderTarget.depthBuffer ) mask |= 256;\n\t\t\t\tif ( renderTarget.stencilBuffer ) mask |= 1024;\n\n\t\t\t\t_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction getRenderTargetSamples( renderTarget ) {\n\n\t\treturn ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?\n\t\t\tMath.min( capabilities.maxSamples, renderTarget.samples ) : 0;\n\n\t}\n\n\tfunction updateVideoTexture( texture ) {\n\n\t\tvar id = texture.id;\n\t\tvar frame = info.render.frame;\n\n\t\t// Check the last frame we updated the VideoTexture\n\n\t\tif ( _videoTextures[ id ] !== frame ) {\n\n\t\t\t_videoTextures[ id ] = frame;\n\t\t\ttexture.update();\n\n\t\t}\n\n\t}\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTexture3D = setTexture3D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\n}\n\n/**\n * @author thespite / http://www.twitter.com/thespite\n */\n\nfunction WebGLUtils( gl, extensions, capabilities ) {\n\n\tfunction convert( p ) {\n\n\t\tvar extension;\n\n\t\tif ( p === RepeatWrapping ) return 10497;\n\t\tif ( p === ClampToEdgeWrapping ) return 33071;\n\t\tif ( p === MirroredRepeatWrapping ) return 33648;\n\n\t\tif ( p === NearestFilter ) return 9728;\n\t\tif ( p === NearestMipMapNearestFilter ) return 9984;\n\t\tif ( p === NearestMipMapLinearFilter ) return 9986;\n\n\t\tif ( p === LinearFilter ) return 9729;\n\t\tif ( p === LinearMipMapNearestFilter ) return 9985;\n\t\tif ( p === LinearMipMapLinearFilter ) return 9987;\n\n\t\tif ( p === UnsignedByteType ) return 5121;\n\t\tif ( p === UnsignedShort4444Type ) return 32819;\n\t\tif ( p === UnsignedShort5551Type ) return 32820;\n\t\tif ( p === UnsignedShort565Type ) return 33635;\n\n\t\tif ( p === ByteType ) return 5120;\n\t\tif ( p === ShortType ) return 5122;\n\t\tif ( p === UnsignedShortType ) return 5123;\n\t\tif ( p === IntType ) return 5124;\n\t\tif ( p === UnsignedIntType ) return 5125;\n\t\tif ( p === FloatType ) return 5126;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) return 5131;\n\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return 6406;\n\t\tif ( p === RGBFormat ) return 6407;\n\t\tif ( p === RGBAFormat ) return 6408;\n\t\tif ( p === LuminanceFormat ) return 6409;\n\t\tif ( p === LuminanceAlphaFormat ) return 6410;\n\t\tif ( p === DepthFormat ) return 6402;\n\t\tif ( p === DepthStencilFormat ) return 34041;\n\t\tif ( p === RedFormat ) return 6403;\n\n\t\tif ( p === AddEquation ) return 32774;\n\t\tif ( p === SubtractEquation ) return 32778;\n\t\tif ( p === ReverseSubtractEquation ) return 32779;\n\n\t\tif ( p === ZeroFactor ) return 0;\n\t\tif ( p === OneFactor ) return 1;\n\t\tif ( p === SrcColorFactor ) return 768;\n\t\tif ( p === OneMinusSrcColorFactor ) return 769;\n\t\tif ( p === SrcAlphaFactor ) return 770;\n\t\tif ( p === OneMinusSrcAlphaFactor ) return 771;\n\t\tif ( p === DstAlphaFactor ) return 772;\n\t\tif ( p === OneMinusDstAlphaFactor ) return 773;\n\n\t\tif ( p === DstColorFactor ) return 774;\n\t\tif ( p === OneMinusDstColorFactor ) return 775;\n\t\tif ( p === SrcAlphaSaturateFactor ) return 776;\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n\t\t\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n\t\t\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t}\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === MinEquation || p === MaxEquation ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\tif ( p === MinEquation ) return 32775;\n\t\t\t\tif ( p === MaxEquation ) return 32776;\n\n\t\t\t}\n\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === MinEquation ) return extension.MIN_EXT;\n\t\t\t\tif ( p === MaxEquation ) return extension.MAX_EXT;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) return 34042;\n\n\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n\treturn { convert: convert };\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Group() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Group';\n\n}\n\nGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Group,\n\n\tisGroup: true\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nfunction Camera() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Camera';\n\n\tthis.matrixWorldInverse = new Matrix4();\n\n\tthis.projectionMatrix = new Matrix4();\n\tthis.projectionMatrixInverse = new Matrix4();\n\n}\n\nCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Camera,\n\n\tisCamera: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\treturn this;\n\n\t},\n\n\tgetWorldDirection: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Camera: .getWorldDirection() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\tvar e = this.matrixWorld.elements;\n\n\t\treturn target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author tschw\n */\n\nfunction PerspectiveCamera( fov, aspect, near, far ) {\n\n\tCamera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.zoom = 1;\n\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n}\n\nPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\tconstructor: PerspectiveCamera,\n\n\tisPerspectiveCamera: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tCamera.prototype.copy.call( this, source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn _Math.RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   var w = 1920;\n\t *   var h = 1080;\n\t *   var fullWidth = w * 3;\n\t *   var fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function () {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar near = this.near,\n\t\t\ttop = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\theight = 2 * top,\n\t\t\twidth = this.aspect * height,\n\t\t\tleft = - 0.5 * width,\n\t\t\tview = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tvar skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n\t\tthis.projectionMatrixInverse.getInverse( this.projectionMatrix );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction ArrayCamera( array ) {\n\n\tPerspectiveCamera.call( this );\n\n\tthis.cameras = array || [];\n\n}\n\nArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\n\n\tconstructor: ArrayCamera,\n\n\tisArrayCamera: true\n\n} );\n\n/**\n * @author jsantell / https://www.jsantell.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar cameraLPos = new Vector3();\nvar cameraRPos = new Vector3();\n\n/**\n * Assumes 2 cameras that are parallel and share an X-axis, and that\n * the cameras' projection and world matrices have already been set.\n * And that near and far planes are identical for both cameras.\n * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n */\nfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\tvar ipd = cameraLPos.distanceTo( cameraRPos );\n\n\tvar projL = cameraL.projectionMatrix.elements;\n\tvar projR = cameraR.projectionMatrix.elements;\n\n\t// VR systems will have identical far and near planes, and\n\t// most likely identical top and bottom frustum extents.\n\t// Use the left camera for these values.\n\tvar near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\tvar far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\tvar topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\tvar bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\tvar leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\tvar rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\tvar left = near * leftFov;\n\tvar right = near * rightFov;\n\n\t// Calculate the new camera's position offset from the\n\t// left camera. xOffset should be roughly half `ipd`.\n\tvar zOffset = ipd / ( - leftFov + rightFov );\n\tvar xOffset = zOffset * - leftFov;\n\n\t// TODO: Better way to apply this offset?\n\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\tcamera.translateX( xOffset );\n\tcamera.translateZ( zOffset );\n\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t// Find the union of the frustum values of the cameras and scale\n\t// the values so that the near plane's position does not change in world space,\n\t// although must now be relative to the new union camera.\n\tvar near2 = near + zOffset;\n\tvar far2 = far + zOffset;\n\tvar left2 = left - xOffset;\n\tvar right2 = right + ( ipd - xOffset );\n\tvar top2 = topFov * far / far2 * near2;\n\tvar bottom2 = bottomFov * far / far2 * near2;\n\n\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebVRManager( renderer ) {\n\n\tvar scope = this;\n\n\tvar device = null;\n\tvar frameData = null;\n\n\tvar poseTarget = null;\n\n\tvar controllers = [];\n\tvar standingMatrix = new Matrix4();\n\tvar standingMatrixInverse = new Matrix4();\n\n\tvar framebufferScaleFactor = 1.0;\n\n\tvar frameOfReferenceType = 'stage';\n\n\tif ( typeof window !== 'undefined' && 'VRFrameData' in window ) {\n\n\t\tframeData = new window.VRFrameData();\n\t\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\n\n\t}\n\n\tvar matrixWorldInverse = new Matrix4();\n\tvar tempQuaternion = new Quaternion();\n\tvar tempPosition = new Vector3();\n\n\tvar cameraL = new PerspectiveCamera();\n\tcameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );\n\tcameraL.layers.enable( 1 );\n\n\tvar cameraR = new PerspectiveCamera();\n\tcameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );\n\tcameraR.layers.enable( 2 );\n\n\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\n\tcameraVR.layers.enable( 1 );\n\tcameraVR.layers.enable( 2 );\n\n\t//\n\n\tfunction isPresenting() {\n\n\t\treturn device !== null && device.isPresenting === true;\n\n\t}\n\n\tvar currentSize, currentPixelRatio;\n\n\tfunction onVRDisplayPresentChange() {\n\n\t\tif ( isPresenting() ) {\n\n\t\t\tvar eyeParameters = device.getEyeParameters( 'left' );\n\t\t\tvar renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;\n\t\t\tvar renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;\n\n\t\t\tcurrentPixelRatio = renderer.getPixelRatio();\n\t\t\tcurrentSize = renderer.getSize();\n\n\t\t\trenderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );\n\n\t\t\tanimation.start();\n\n\t\t} else {\n\n\t\t\tif ( scope.enabled ) {\n\n\t\t\t\trenderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );\n\n\t\t\t}\n\n\t\t\tanimation.stop();\n\n\t\t}\n\n\t}\n\n\t//\n\n\tvar triggers = [];\n\n\tfunction findGamepad( id ) {\n\n\t\tvar gamepads = navigator.getGamepads && navigator.getGamepads();\n\n\t\tfor ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {\n\n\t\t\tvar gamepad = gamepads[ i ];\n\n\t\t\tif ( gamepad && ( gamepad.id === 'Daydream Controller' ||\n\t\t\t\tgamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||\n\t\t\t\tgamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||\n\t\t\t\tgamepad.id.startsWith( 'Spatial Controller' ) ) ) {\n\n\t\t\t\tif ( j === id ) return gamepad;\n\n\t\t\t\tj ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateControllers() {\n\n\t\tfor ( var i = 0; i < controllers.length; i ++ ) {\n\n\t\t\tvar controller = controllers[ i ];\n\n\t\t\tvar gamepad = findGamepad( i );\n\n\t\t\tif ( gamepad !== undefined && gamepad.pose !== undefined ) {\n\n\t\t\t\tif ( gamepad.pose === null ) return;\n\n\t\t\t\t//  Pose\n\n\t\t\t\tvar pose = gamepad.pose;\n\n\t\t\t\tif ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );\n\n\t\t\t\tif ( pose.position !== null ) controller.position.fromArray( pose.position );\n\t\t\t\tif ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );\n\t\t\t\tcontroller.matrix.compose( controller.position, controller.quaternion, controller.scale );\n\t\t\t\tcontroller.matrix.premultiply( standingMatrix );\n\t\t\t\tcontroller.matrix.decompose( controller.position, controller.quaternion, controller.scale );\n\t\t\t\tcontroller.matrixWorldNeedsUpdate = true;\n\t\t\t\tcontroller.visible = true;\n\n\t\t\t\t//  Trigger\n\n\t\t\t\tvar buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;\n\n\t\t\t\tif ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {\n\n\t\t\t\t\ttriggers[ i ] = gamepad.buttons[ buttonId ].pressed;\n\n\t\t\t\t\tif ( triggers[ i ] === true ) {\n\n\t\t\t\t\t\tcontroller.dispatchEvent( { type: 'selectstart' } );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontroller.dispatchEvent( { type: 'selectend' } );\n\t\t\t\t\t\tcontroller.dispatchEvent( { type: 'select' } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcontroller.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.enabled = false;\n\n\tthis.getController = function ( id ) {\n\n\t\tvar controller = controllers[ id ];\n\n\t\tif ( controller === undefined ) {\n\n\t\t\tcontroller = new Group();\n\t\t\tcontroller.matrixAutoUpdate = false;\n\t\t\tcontroller.visible = false;\n\n\t\t\tcontrollers[ id ] = controller;\n\n\t\t}\n\n\t\treturn controller;\n\n\t};\n\n\tthis.getDevice = function () {\n\n\t\treturn device;\n\n\t};\n\n\tthis.setDevice = function ( value ) {\n\n\t\tif ( value !== undefined ) device = value;\n\n\t\tanimation.setContext( value );\n\n\t};\n\n\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\tframebufferScaleFactor = value;\n\n\t};\n\n\tthis.setFrameOfReferenceType = function ( value ) {\n\n\t\tframeOfReferenceType = value;\n\n\t};\n\n\tthis.setPoseTarget = function ( object ) {\n\n\t\tif ( object !== undefined ) poseTarget = object;\n\n\t};\n\n\tthis.getCamera = function ( camera ) {\n\n\t\tvar userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;\n\n\t\tif ( device === null ) {\n\n\t\t\tcamera.position.set( 0, userHeight, 0 );\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tdevice.depthNear = camera.near;\n\t\tdevice.depthFar = camera.far;\n\n\t\tdevice.getFrameData( frameData );\n\n\t\t//\n\n\t\tif ( frameOfReferenceType === 'stage' ) {\n\n\t\t\tvar stageParameters = device.stageParameters;\n\n\t\t\tif ( stageParameters ) {\n\n\t\t\t\tstandingMatrix.fromArray( stageParameters.sittingToStandingTransform );\n\n\t\t\t} else {\n\n\t\t\t\tstandingMatrix.makeTranslation( 0, userHeight, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar pose = frameData.pose;\n\t\tvar poseObject = poseTarget !== null ? poseTarget : camera;\n\n\t\t// We want to manipulate poseObject by its position and quaternion components since users may rely on them.\n\t\tposeObject.matrix.copy( standingMatrix );\n\t\tposeObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );\n\n\t\tif ( pose.orientation !== null ) {\n\n\t\t\ttempQuaternion.fromArray( pose.orientation );\n\t\t\tposeObject.quaternion.multiply( tempQuaternion );\n\n\t\t}\n\n\t\tif ( pose.position !== null ) {\n\n\t\t\ttempQuaternion.setFromRotationMatrix( standingMatrix );\n\t\t\ttempPosition.fromArray( pose.position );\n\t\t\ttempPosition.applyQuaternion( tempQuaternion );\n\t\t\tposeObject.position.add( tempPosition );\n\n\t\t}\n\n\t\tposeObject.updateMatrixWorld();\n\n\t\tif ( device.isPresenting === false ) return camera;\n\n\t\t//\n\n\t\tcameraL.near = camera.near;\n\t\tcameraR.near = camera.near;\n\n\t\tcameraL.far = camera.far;\n\t\tcameraR.far = camera.far;\n\n\t\tcameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );\n\t\tcameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );\n\n\t\t// TODO (mrdoob) Double check this code\n\n\t\tstandingMatrixInverse.getInverse( standingMatrix );\n\n\t\tif ( frameOfReferenceType === 'stage' ) {\n\n\t\t\tcameraL.matrixWorldInverse.multiply( standingMatrixInverse );\n\t\t\tcameraR.matrixWorldInverse.multiply( standingMatrixInverse );\n\n\t\t}\n\n\t\tvar parent = poseObject.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\n\t\t\tcameraL.matrixWorldInverse.multiply( matrixWorldInverse );\n\t\t\tcameraR.matrixWorldInverse.multiply( matrixWorldInverse );\n\n\t\t}\n\n\t\t// envMap and Mirror needs camera.matrixWorld\n\n\t\tcameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );\n\t\tcameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );\n\n\t\tcameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );\n\t\tcameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );\n\n\t\tsetProjectionFromUnion( cameraVR, cameraL, cameraR );\n\n\t\t//\n\n\t\tvar layers = device.getLayers();\n\n\t\tif ( layers.length ) {\n\n\t\t\tvar layer = layers[ 0 ];\n\n\t\t\tif ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {\n\n\t\t\t\tcameraL.bounds.fromArray( layer.leftBounds );\n\n\t\t\t}\n\n\t\t\tif ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {\n\n\t\t\t\tcameraR.bounds.fromArray( layer.rightBounds );\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdateControllers();\n\n\t\treturn cameraVR;\n\n\t};\n\n\tthis.getStandingMatrix = function () {\n\n\t\treturn standingMatrix;\n\n\t};\n\n\tthis.isPresenting = isPresenting;\n\n\t// Animation Loop\n\n\tvar animation = new WebGLAnimation();\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tanimation.setAnimationLoop( callback );\n\n\t};\n\n\tthis.submitFrame = function () {\n\n\t\tif ( isPresenting() ) device.submitFrame();\n\n\t};\n\n\tthis.dispose = function () {\n\n\t\tif ( typeof window !== 'undefined' ) {\n\n\t\t\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );\n\n\t\t}\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction WebXRManager( renderer ) {\n\n\tvar gl = renderer.context;\n\n\tvar device = null;\n\tvar session = null;\n\n\tvar framebufferScaleFactor = 1.0;\n\n\tvar frameOfReference = null;\n\tvar frameOfReferenceType = 'stage';\n\n\tvar pose = null;\n\n\tvar controllers = [];\n\tvar inputSources = [];\n\n\tfunction isPresenting() {\n\n\t\treturn session !== null && frameOfReference !== null;\n\n\t}\n\n\t//\n\n\tvar cameraL = new PerspectiveCamera();\n\tcameraL.layers.enable( 1 );\n\tcameraL.viewport = new Vector4();\n\n\tvar cameraR = new PerspectiveCamera();\n\tcameraR.layers.enable( 2 );\n\tcameraR.viewport = new Vector4();\n\n\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\n\tcameraVR.layers.enable( 1 );\n\tcameraVR.layers.enable( 2 );\n\n\t//\n\n\tthis.enabled = false;\n\n\tthis.getController = function ( id ) {\n\n\t\tvar controller = controllers[ id ];\n\n\t\tif ( controller === undefined ) {\n\n\t\t\tcontroller = new Group();\n\t\t\tcontroller.matrixAutoUpdate = false;\n\t\t\tcontroller.visible = false;\n\n\t\t\tcontrollers[ id ] = controller;\n\n\t\t}\n\n\t\treturn controller;\n\n\t};\n\n\tthis.getDevice = function () {\n\n\t\treturn device;\n\n\t};\n\n\tthis.setDevice = function ( value ) {\n\n\t\tif ( value !== undefined ) device = value;\n\t\tif ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value );\n\n\t};\n\n\t//\n\n\tfunction onSessionEvent( event ) {\n\n\t\tvar controller = controllers[ inputSources.indexOf( event.inputSource ) ];\n\t\tif ( controller ) controller.dispatchEvent( { type: event.type } );\n\n\t}\n\n\tfunction onSessionEnd() {\n\n\t\trenderer.setFramebuffer( null );\n\t\tanimation.stop();\n\n\t}\n\n\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\tframebufferScaleFactor = value;\n\n\t};\n\n\tthis.setFrameOfReferenceType = function ( value ) {\n\n\t\tframeOfReferenceType = value;\n\n\t};\n\n\tthis.setSession = function ( value ) {\n\n\t\tsession = value;\n\n\t\tif ( session !== null ) {\n\n\t\t\tsession.addEventListener( 'select', onSessionEvent );\n\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\n\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\n\t\t\tsession.addEventListener( 'end', onSessionEnd );\n\n\t\t\tsession.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } );\n\t\t\tsession.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) {\n\n\t\t\t\tframeOfReference = value;\n\n\t\t\t\trenderer.setFramebuffer( session.baseLayer.framebuffer );\n\n\t\t\t\tanimation.setContext( session );\n\t\t\t\tanimation.start();\n\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\tinputSources = session.getInputSources();\n\n\t\t\tsession.addEventListener( 'inputsourceschange', function () {\n\n\t\t\t\tinputSources = session.getInputSources();\n\t\t\t\tconsole.log( inputSources );\n\n\t\t\t\tfor ( var i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\t\tvar controller = controllers[ i ];\n\t\t\t\t\tcontroller.userData.inputSource = inputSources[ i ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n\tfunction updateCamera( camera, parent ) {\n\n\t\tif ( parent === null ) {\n\n\t\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t\t} else {\n\n\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t\t}\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t}\n\n\tthis.getCamera = function ( camera ) {\n\n\t\tif ( isPresenting() ) {\n\n\t\t\tvar parent = camera.parent;\n\t\t\tvar cameras = cameraVR.cameras;\n\n\t\t\tupdateCamera( cameraVR, parent );\n\n\t\t\tfor ( var i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t\t}\n\n\t\t\t// update camera and its children\n\n\t\t\tcamera.matrixWorld.copy( cameraVR.matrixWorld );\n\n\t\t\tvar children = camera.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t\tsetProjectionFromUnion( cameraVR, cameraL, cameraR );\n\n\t\t\treturn cameraVR;\n\n\t\t}\n\n\t\treturn camera;\n\n\t};\n\n\tthis.isPresenting = isPresenting;\n\n\t// Animation Loop\n\n\tvar onAnimationFrameCallback = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tpose = frame.getDevicePose( frameOfReference );\n\n\t\tif ( pose !== null ) {\n\n\t\t\tvar layer = session.baseLayer;\n\t\t\tvar views = frame.views;\n\n\t\t\tfor ( var i = 0; i < views.length; i ++ ) {\n\n\t\t\t\tvar view = views[ i ];\n\t\t\t\tvar viewport = layer.getViewport( view );\n\t\t\t\tvar viewMatrix = pose.getViewMatrix( view );\n\n\t\t\t\tvar camera = cameraVR.cameras[ i ];\n\t\t\t\tcamera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );\n\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tcameraVR.matrix.copy( camera.matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( var i = 0; i < controllers.length; i ++ ) {\n\n\t\t\tvar controller = controllers[ i ];\n\n\t\t\tvar inputSource = inputSources[ i ];\n\n\t\t\tif ( inputSource ) {\n\n\t\t\t\tvar inputPose = frame.getInputPose( inputSource, frameOfReference );\n\n\t\t\t\tif ( inputPose !== null ) {\n\n\t\t\t\t\tif ( 'targetRay' in inputPose ) {\n\n\t\t\t\t\t\tcontroller.matrix.elements = inputPose.targetRay.transformMatrix;\n\n\t\t\t\t\t} else if ( 'pointerMatrix' in inputPose ) {\n\n\t\t\t\t\t\t// DEPRECATED\n\n\t\t\t\t\t\tcontroller.matrix.elements = inputPose.pointerMatrix;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontroller.matrix.decompose( controller.position, controller.rotation, controller.scale );\n\t\t\t\t\tcontroller.visible = true;\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcontroller.visible = false;\n\n\t\t}\n\n\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t}\n\n\tvar animation = new WebGLAnimation();\n\tanimation.setAnimationLoop( onAnimationFrame );\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tonAnimationFrameCallback = callback;\n\n\t};\n\n\tthis.dispose = function () {};\n\n\t// DEPRECATED\n\n\tthis.getStandingMatrix = function () {\n\n\t\tconsole.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );\n\t\treturn new THREE.Matrix4();\n\n\t};\n\n\tthis.submitFrame = function () {};\n\n}\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n * @author tschw\n */\n\nfunction WebGLRenderer( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';\n\n\tvar currentRenderList = null;\n\tvar currentRenderState = null;\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = LinearToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\tthis.toneMappingWhitePoint = 1.0;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t\t_isContextLost = false,\n\n\t\t// internal state cache\n\n\t\t_framebuffer = null,\n\n\t\t_currentRenderTarget = null,\n\t\t_currentFramebuffer = null,\n\t\t_currentMaterialId = - 1,\n\n\t\t// geometry and program caching\n\n\t\t_currentGeometryProgram = {\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false\n\t\t},\n\n\t\t_currentCamera = null,\n\t\t_currentArrayCamera = null,\n\n\t\t_currentViewport = new Vector4(),\n\t\t_currentScissor = new Vector4(),\n\t\t_currentScissorTest = null,\n\n\t\t//\n\n\t\t_usedTextureUnits = 0,\n\n\t\t//\n\n\t\t_width = _canvas.width,\n\t\t_height = _canvas.height,\n\n\t\t_pixelRatio = 1,\n\n\t\t_viewport = new Vector4( 0, 0, _width, _height ),\n\t\t_scissor = new Vector4( 0, 0, _width, _height ),\n\t\t_scissorTest = false,\n\n\t\t// frustum\n\n\t\t_frustum = new Frustum(),\n\n\t\t// clipping\n\n\t\t_clipping = new WebGLClipping(),\n\t\t_clippingEnabled = false,\n\t\t_localClippingEnabled = false,\n\n\t\t// camera matrices cache\n\n\t\t_projScreenMatrix = new Matrix4(),\n\n\t\t_vector3 = new Vector3();\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\t// initialize\n\n\tvar _gl;\n\n\ttry {\n\n\t\tvar contextAttributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\tpowerPreference: _powerPreference\n\t\t};\n\n\t\t// event listeners must be registered before WebGL context is created, see #12753\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\n\t}\n\n\tvar extensions, capabilities, state, info;\n\tvar properties, textures, attributes, geometries, objects;\n\tvar programCache, renderLists, renderStates;\n\n\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\tvar utils;\n\n\tfunction initGLContext() {\n\n\t\textensions = new WebGLExtensions( _gl );\n\n\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\tif ( ! capabilities.isWebGL2 ) {\n\n\t\t\textensions.get( 'WEBGL_depth_texture' );\n\t\t\textensions.get( 'OES_texture_float' );\n\t\t\textensions.get( 'OES_texture_half_float' );\n\t\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\t\textensions.get( 'OES_standard_derivatives' );\n\t\t\textensions.get( 'OES_element_index_uint' );\n\t\t\textensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t}\n\n\t\textensions.get( 'OES_texture_float_linear' );\n\n\t\tutils = new WebGLUtils( _gl, extensions, capabilities );\n\n\t\tstate = new WebGLState( _gl, extensions, utils, capabilities );\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\tinfo = new WebGLInfo( _gl );\n\t\tproperties = new WebGLProperties();\n\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\tattributes = new WebGLAttributes( _gl );\n\t\tgeometries = new WebGLGeometries( _gl, attributes, info );\n\t\tobjects = new WebGLObjects( geometries, info );\n\t\tmorphtargets = new WebGLMorphtargets( _gl );\n\t\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\n\t\trenderLists = new WebGLRenderLists();\n\t\trenderStates = new WebGLRenderStates();\n\n\t\tbackground = new WebGLBackground( _this, state, objects, _premultipliedAlpha );\n\n\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );\n\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );\n\n\t\tinfo.programs = programCache.programs;\n\n\t\t_this.context = _gl;\n\t\t_this.capabilities = capabilities;\n\t\t_this.extensions = extensions;\n\t\t_this.properties = properties;\n\t\t_this.renderLists = renderLists;\n\t\t_this.state = state;\n\t\t_this.info = info;\n\n\t}\n\n\tinitGLContext();\n\n\t// vr\n\n\tvar vr = null;\n\n\tif ( typeof navigator !== 'undefined' ) {\n\n\t\tvr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );\n\n\t}\n\n\tthis.vr = vr;\n\n\t// shadow map\n\n\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\n\n\tthis.shadowMap = shadowMap;\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.loseContext();\n\n\t};\n\n\tthis.forceContextRestore = function () {\n\n\t\tvar extension = extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.restoreContext();\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _width, _height, false );\n\n\t};\n\n\tthis.getSize = function () {\n\n\t\treturn {\n\t\t\twidth: _width,\n\t\t\theight: _height\n\t\t};\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\tif ( vr.isPresenting() ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = width * _pixelRatio;\n\t\t_canvas.height = height * _pixelRatio;\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getDrawingBufferSize = function () {\n\n\t\treturn {\n\t\t\twidth: _width * _pixelRatio,\n\t\t\theight: _height * _pixelRatio\n\t\t};\n\n\t};\n\n\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_pixelRatio = pixelRatio;\n\n\t\t_canvas.width = width * pixelRatio;\n\t\t_canvas.height = height * pixelRatio;\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.getCurrentViewport = function () {\n\n\t\treturn _currentViewport;\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t_viewport.set( x, _height - y - height, width, height );\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t_scissor.set( x, _height - y - height, width, height );\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function () {\n\n\t\treturn background.getClearColor();\n\n\t};\n\n\tthis.setClearColor = function () {\n\n\t\tbackground.setClearColor.apply( background, arguments );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn background.getClearAlpha();\n\n\t};\n\n\tthis.setClearAlpha = function () {\n\n\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= 16384;\n\t\tif ( depth === undefined || depth ) bits |= 256;\n\t\tif ( stencil === undefined || stencil ) bits |= 1024;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\t//\n\n\tthis.dispose = function () {\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\n\t\trenderLists.dispose();\n\t\trenderStates.dispose();\n\t\tproperties.dispose();\n\t\tobjects.dispose();\n\n\t\tvr.dispose();\n\n\t\tanimation.stop();\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t_isContextLost = true;\n\n\t}\n\n\tfunction onContextRestore( /* event */ ) {\n\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t_isContextLost = false;\n\n\t\tinitGLContext();\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReference( material );\n\n\t\tproperties.remove( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReference( material ) {\n\n\t\tvar programInfo = properties.get( material ).program;\n\n\t\tmaterial.program = undefined;\n\n\t\tif ( programInfo !== undefined ) {\n\n\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tfunction renderObjectImmediate( object, program ) {\n\n\t\tobject.render( function ( object ) {\n\n\t\t\t_this.renderBufferImmediate( object, program );\n\n\t\t} );\n\n\t}\n\n\tthis.renderBufferImmediate = function ( object, program ) {\n\n\t\tstate.initAttributes();\n\n\t\tvar buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.position );\n\t\t\t_gl.bufferData( 34962, object.positionArray, 35048 );\n\n\t\t\tstate.enableAttribute( programAttributes.position );\n\t\t\t_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.normal );\n\t\t\t_gl.bufferData( 34962, object.normalArray, 35048 );\n\n\t\t\tstate.enableAttribute( programAttributes.normal );\n\t\t\t_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.uv );\n\t\t\t_gl.bufferData( 34962, object.uvArray, 35048 );\n\n\t\t\tstate.enableAttribute( programAttributes.uv );\n\t\t\t_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors ) {\n\n\t\t\t_gl.bindBuffer( 34962, buffers.color );\n\t\t\t_gl.bufferData( 34962, object.colorArray, 35048 );\n\n\t\t\tstate.enableAttribute( programAttributes.color );\n\t\t\t_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( 4, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\tvar frontFaceCW = ( object.isMesh && object.normalMatrix.determinant() < 0 );\n\n\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\tvar updateBuffers = false;\n\n\t\tif ( _currentGeometryProgram.geometry !== geometry.id ||\n\t\t\t_currentGeometryProgram.program !== program.id ||\n\t\t\t_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {\n\n\t\t\t_currentGeometryProgram.geometry = geometry.id;\n\t\t\t_currentGeometryProgram.program = program.id;\n\t\t\t_currentGeometryProgram.wireframe = material.wireframe === true;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\tmorphtargets.update( object, geometry, material, program );\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t//\n\n\t\tvar index = geometry.index;\n\t\tvar position = geometry.attributes.position;\n\t\tvar rangeFactor = 1;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tvar attribute;\n\t\tvar renderer = bufferRenderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\tattribute = attributes.get( index );\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( attribute );\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t_gl.bindBuffer( 34963, attribute.buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar dataCount = Infinity;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdataCount = index.count;\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\tdataCount = position.count;\n\n\t\t}\n\n\t\tvar rangeStart = geometry.drawRange.start * rangeFactor;\n\t\tvar rangeCount = geometry.drawRange.count * rangeFactor;\n\n\t\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n\t\tvar drawStart = Math.max( rangeStart, groupStart );\n\t\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\t//\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( 1 );\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\tcase TrianglesDrawMode:\n\t\t\t\t\t\trenderer.setMode( 4 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TriangleStripDrawMode:\n\t\t\t\t\t\trenderer.setMode( 5 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TriangleFanDrawMode:\n\t\t\t\t\t\trenderer.setMode( 6 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\trenderer.setMode( 1 );\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\trenderer.setMode( 2 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( 3 );\n\n\t\t\t}\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\trenderer.setMode( 0 );\n\n\t\t} else if ( object.isSprite ) {\n\n\t\t\trenderer.setMode( 4 );\n\n\t\t}\n\n\t\tif ( geometry && geometry.isInstancedBufferGeometry ) {\n\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\tfunction setupVertexAttributes( material, program, geometry ) {\n\n\t\tif ( geometry && geometry.isInstancedBufferGeometry & ! capabilities.isWebGL2 ) {\n\n\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.initAttributes();\n\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( var name in programAttributes ) {\n\n\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\n\t\t\t\t\tvar attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tvar buffer = attribute.buffer;\n\t\t\t\t\tvar type = attribute.type;\n\t\t\t\t\tvar bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( 34962, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( 34962, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t}\n\n\t// Compile\n\n\tthis.compile = function ( scene, camera ) {\n\n\t\tcurrentRenderState = renderStates.get( scene, camera );\n\t\tcurrentRenderState.init();\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tif ( object.isLight ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tcurrentRenderState.setupLights( camera );\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tif ( object.material ) {\n\n\t\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\t\tfor ( var i = 0; i < object.material.length; i ++ ) {\n\n\t\t\t\t\t\tinitMaterial( object.material[ i ], scene.fog, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinitMaterial( object.material, scene.fog, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t};\n\n\t// Animation Loop\n\n\tvar onAnimationFrameCallback = null;\n\n\tfunction onAnimationFrame( time ) {\n\n\t\tif ( vr.isPresenting() ) return;\n\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t}\n\n\tvar animation = new WebGLAnimation();\n\tanimation.setAnimationLoop( onAnimationFrame );\n\n\tif ( typeof window !== 'undefined' ) animation.setContext( window );\n\n\tthis.setAnimationLoop = function ( callback ) {\n\n\t\tonAnimationFrameCallback = callback;\n\t\tvr.setAnimationLoop( callback );\n\n\t\tanimation.start();\n\n\t};\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( ! ( camera && camera.isCamera ) ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( _isContextLost ) return;\n\n\t\t// reset caching for this frame\n\n\t\t_currentGeometryProgram.geometry = null;\n\t\t_currentGeometryProgram.program = null;\n\t\t_currentGeometryProgram.wireframe = false;\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tif ( vr.enabled ) {\n\n\t\t\tcamera = vr.getCamera( camera );\n\n\t\t}\n\n\t\t//\n\n\t\tcurrentRenderState = renderStates.get( scene, camera );\n\t\tcurrentRenderState.init();\n\n\t\tscene.onBeforeRender( _this, scene, camera, renderTarget );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tcurrentRenderList = renderLists.get( scene, camera );\n\t\tcurrentRenderList.init();\n\n\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\tcurrentRenderList.sort();\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\tcurrentRenderState.setupLights( camera );\n\n\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t//\n\n\t\tif ( this.info.autoReset ) this.info.reset();\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = null;\n\n\t\t}\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\t//\n\n\t\tbackground.render( currentRenderList, scene, camera, forceClear );\n\n\t\t// render scene\n\n\t\tvar opaqueObjects = currentRenderList.opaque;\n\t\tvar transparentObjects = currentRenderList.transparent;\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );\n\t\t\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );\n\n\t\t} else {\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderTarget ) {\n\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\ttextures.updateMultisampleRenderTarget( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.buffers.depth.setTest( true );\n\t\tstate.buffers.depth.setMask( true );\n\t\tstate.buffers.color.setMask( true );\n\n\t\tstate.setPolygonOffset( false );\n\n\t\tscene.onAfterRender( _this, scene, camera );\n\n\t\tif ( vr.enabled ) {\n\n\t\t\tvr.submitFrame();\n\n\t\t}\n\n\t\t// _gl.finish();\n\n\t\tcurrentRenderList = null;\n\t\tcurrentRenderState = null;\n\n\t};\n\n\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tvar visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isImmediateRenderObject ) {\n\n\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\tvar groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t}\n\n\t}\n\n\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\n\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\tvar object = renderItem.object;\n\t\t\tvar geometry = renderItem.geometry;\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\tvar group = renderItem.group;\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\t_currentArrayCamera = camera;\n\n\t\t\t\tvar cameras = camera.cameras;\n\n\t\t\t\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar camera2 = cameras[ j ];\n\n\t\t\t\t\tif ( object.layers.test( camera2.layers ) ) {\n\n\t\t\t\t\t\tif ( 'viewport' in camera2 ) { // XR\n\n\t\t\t\t\t\t\tstate.viewport( _currentViewport.copy( camera2.viewport ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar bounds = camera2.bounds;\n\n\t\t\t\t\t\t\tvar x = bounds.x * _width;\n\t\t\t\t\t\t\tvar y = bounds.y * _height;\n\t\t\t\t\t\t\tvar width = bounds.z * _width;\n\t\t\t\t\t\t\tvar height = bounds.w * _height;\n\n\t\t\t\t\t\t\tstate.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentRenderState.setupLights( camera2 );\n\n\t\t\t\t\t\trenderObject( object, scene, camera2, geometry, material, group );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_currentArrayCamera = null;\n\n\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\n\n\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\tif ( object.isImmediateRenderObject ) {\n\n\t\t\tstate.setMaterial( material );\n\n\t\t\tvar program = setProgram( camera, scene.fog, material, object );\n\n\t\t\t_currentGeometryProgram.geometry = null;\n\t\t\t_currentGeometryProgram.program = null;\n\t\t\t_currentGeometryProgram.wireframe = false;\n\n\t\t\trenderObjectImmediate( object, program );\n\n\t\t} else {\n\n\t\t\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\n\t\t}\n\n\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\t\tcurrentRenderState = renderStates.get( scene, _currentArrayCamera || camera );\n\n\t}\n\n\tfunction initMaterial( material, fog, object ) {\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tvar lights = currentRenderState.state.lights;\n\t\tvar shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\tvar lightsHash = materialProperties.lightsHash;\n\t\tvar lightsStateHash = lights.state.hash;\n\n\t\tvar parameters = programCache.getParameters(\n\t\t\tmaterial, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\n\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\tvar program = materialProperties.program;\n\t\tvar programChange = true;\n\n\t\tif ( program === undefined ) {\n\n\t\t\t// new material\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t} else if ( program.code !== code ) {\n\n\t\t\t// changed glsl or parameters\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t} else if ( lightsHash.stateID !== lightsStateHash.stateID ||\n\t\t\tlightsHash.directionalLength !== lightsStateHash.directionalLength ||\n\t\t\tlightsHash.pointLength !== lightsStateHash.pointLength ||\n\t\t\tlightsHash.spotLength !== lightsStateHash.spotLength ||\n\t\t\tlightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||\n\t\t\tlightsHash.hemiLength !== lightsStateHash.hemiLength ||\n\t\t\tlightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {\n\n\t\t\tlightsHash.stateID = lightsStateHash.stateID;\n\t\t\tlightsHash.directionalLength = lightsStateHash.directionalLength;\n\t\t\tlightsHash.pointLength = lightsStateHash.pointLength;\n\t\t\tlightsHash.spotLength = lightsStateHash.spotLength;\n\t\t\tlightsHash.rectAreaLength = lightsStateHash.rectAreaLength;\n\t\t\tlightsHash.hemiLength = lightsStateHash.hemiLength;\n\t\t\tlightsHash.shadowsLength = lightsStateHash.shadowsLength;\n\n\t\t\tprogramChange = false;\n\n\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t// same glsl and uniform list\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// only rebuild uniform list\n\t\t\tprogramChange = false;\n\n\t\t}\n\n\t\tif ( programChange ) {\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tvar shader = ShaderLib[ parameters.shaderID ];\n\n\t\t\t\tmaterialProperties.shader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tmaterialProperties.shader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tmaterial.onBeforeCompile( materialProperties.shader, _this );\n\n\t\t\t// Computing code again as onBeforeCompile may have changed the shaders\n\t\t\tcode = programCache.getProgramCode( material, parameters );\n\n\t\t\tprogram = programCache.acquireProgram( material, materialProperties.shader, parameters, code );\n\n\t\t\tmaterialProperties.program = program;\n\t\t\tmaterial.program = program;\n\n\t\t}\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar uniforms = materialProperties.shader.uniforms;\n\n\t\tif ( ! material.isShaderMaterial &&\n\t\t\t! material.isRawShaderMaterial ||\n\t\t\tmaterial.clipping === true ) {\n\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\tmaterialProperties.numIntersection = _clipping.numIntersection;\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t}\n\n\t\tmaterialProperties.fog = fog;\n\n\t\t// store the light setup it was created for\n\t\tif ( lightsHash === undefined ) {\n\n\t\t\tmaterialProperties.lightsHash = lightsHash = {};\n\n\t\t}\n\n\t\tlightsHash.stateID = lightsStateHash.stateID;\n\t\tlightsHash.directionalLength = lightsStateHash.directionalLength;\n\t\tlightsHash.pointLength = lightsStateHash.pointLength;\n\t\tlightsHash.spotLength = lightsStateHash.spotLength;\n\t\tlightsHash.rectAreaLength = lightsStateHash.rectAreaLength;\n\t\tlightsHash.hemiLength = lightsStateHash.hemiLength;\n\t\tlightsHash.shadowsLength = lightsStateHash.shadowsLength;\n\n\t\tif ( material.lights ) {\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t}\n\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\tuniformsList =\n\t\t\t\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t}\n\n\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tvar materialProperties = properties.get( material );\n\t\tvar lights = currentRenderState.state.lights;\n\n\t\tvar lightsHash = materialProperties.lightsHash;\n\t\tvar lightsStateHash = lights.state.hash;\n\n\t\tif ( _clippingEnabled ) {\n\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\tvar useCache =\n\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\t_clipping.setState(\n\t\t\t\t\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\n\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.needsUpdate === false ) {\n\n\t\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID ||\n\t\t\t\tlightsHash.directionalLength !== lightsStateHash.directionalLength ||\n\t\t\t\tlightsHash.pointLength !== lightsStateHash.pointLength ||\n\t\t\t\tlightsHash.spotLength !== lightsStateHash.spotLength ||\n\t\t\t\tlightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||\n\t\t\t\tlightsHash.hemiLength !== lightsStateHash.hemiLength ||\n\t\t\t\tlightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\n\t\t\t\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tinitMaterial( material, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tvar refreshProgram = false;\n\t\tvar refreshMaterial = false;\n\t\tvar refreshLights = false;\n\n\t\tvar program = materialProperties.program,\n\t\t\tp_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.shader.uniforms;\n\n\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\tmaterial.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.envMap ) {\n\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\tmaterial.isShaderMaterial ||\n\t\t\t\tmaterial.skinning ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tvar skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tvar bones = skeleton.bones;\n\n\t\t\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\t\t\tif ( skeleton.boneTexture === undefined ) {\n\n\t\t\t\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\t\t\t\t\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\t\t\t\tsize = _Math.ceilPowerOfTwo( size );\n\t\t\t\t\t\tsize = Math.max( size, 4 );\n\n\t\t\t\t\t\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\t\t\t\t\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\n\n\t\t\t\t\t\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\t\t\t\t\tboneTexture.needsUpdate = true;\n\n\t\t\t\t\t\tskeleton.boneMatrices = boneMatrices;\n\t\t\t\t\t\tskeleton.boneTexture = boneTexture;\n\t\t\t\t\t\tskeleton.boneTextureSize = size;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\tif ( material.isMeshToonMaterial ) {\n\n\t\t\t\t\trefreshUniformsToon( m_uniforms, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material.isMeshMatcapMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t\trefreshUniformsMatcap( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\trefreshUniformsDepth( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshDistanceMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\trefreshUniformsDistance( m_uniforms, material );\n\n\t\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\t\t\trefreshUniformsNormal( m_uniforms, material );\n\n\t\t\t} else if ( material.isLineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t\tif ( material.isLineDashedMaterial ) {\n\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t} else if ( material.isSpriteMaterial ) {\n\n\t\t\t\trefreshUniformsSprites( m_uniforms, material );\n\n\t\t\t} else if ( material.isShadowMaterial ) {\n\n\t\t\t\tm_uniforms.color.value = material.color;\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\t// RectAreaLight Texture\n\t\t\t// TODO (mrdoob): Find a nicer implementation\n\n\t\t\tif ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;\n\t\t\tif ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t}\n\n\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );\n\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t}\n\n\t\t// common matrices\n\n\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\treturn program;\n\n\t}\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.color ) {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\tuniforms.envMap.value = material.envMap;\n\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\tuniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\tuniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. normal map\n\t\t// 4. bump map\n\t\t// 5. alpha map\n\t\t// 6. emissive map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\tuniforms.scale.value = _height * 0.5;\n\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tif ( material.map.matrixAutoUpdate === true ) {\n\n\t\t\t\tmaterial.map.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( material.map.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsSprites( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.rotation.value = material.rotation;\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tif ( material.map.matrixAutoUpdate === true ) {\n\n\t\t\t\tmaterial.map.updateMatrix();\n\n\t\t\t}\n\n\t\t\tuniforms.uvTransform.value.copy( material.map.matrix );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsFog( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog.isFog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert( uniforms, material ) {\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\tuniforms.specular.value = material.specular;\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsToon( uniforms, material ) {\n\n\t\trefreshUniformsPhong( uniforms, material );\n\n\t\tif ( material.gradientMap ) {\n\n\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical( uniforms, material ) {\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t\tuniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\n\n\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t}\n\n\tfunction refreshUniformsMatcap( uniforms, material ) {\n\n\t\tif ( material.matcap ) {\n\n\t\t\tuniforms.matcap.value = material.matcap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDepth( uniforms, material ) {\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDistance( uniforms, material ) {\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tuniforms.referencePosition.value.copy( material.referencePosition );\n\t\tuniforms.nearDistance.value = material.nearDistance;\n\t\tuniforms.farDistance.value = material.farDistance;\n\n\t}\n\n\tfunction refreshUniformsNormal( uniforms, material ) {\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\tif ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\t\tif ( material.side === BackSide ) uniforms.normalScale.value.negate();\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\t// Textures\n\n\tfunction allocTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tthis.allocTextureUnit = allocTextureUnit;\n\n\t// this.setTexture2D = setTexture2D;\n\tthis.setTexture2D = ( function () {\n\n\t\tvar warned = false;\n\n\t\t// backwards compatibility: peel texture.texture\n\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\tif ( texture && texture.isWebGLRenderTarget ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTexture3D = ( function () {\n\n\t\t// backwards compatibility: peel texture.texture\n\t\treturn function setTexture3D( texture, slot ) {\n\n\t\t\ttextures.setTexture3D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTexture = ( function () {\n\n\t\tvar warned = false;\n\n\t\treturn function setTexture( texture, slot ) {\n\n\t\t\tif ( ! warned ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\twarned = true;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTextureCube = ( function () {\n\n\t\tvar warned = false;\n\n\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\tif ( texture && texture.isWebGLRenderTargetCube ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t// TODO: unify these code paths\n\t\t\tif ( ( texture && texture.isCubeTexture ) ||\n\t\t\t\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t} else {\n\n\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\t//\n\n\tthis.setFramebuffer = function ( value ) {\n\n\t\t_framebuffer = value;\n\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tvar framebuffer = _framebuffer;\n\t\tvar isCube = false;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLRenderTargetCube ) {\n\n\t\t\t\tframebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];\n\t\t\t\tisCube = true;\n\n\t\t\t} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {\n\n\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t} else {\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t}\n\n\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( 36160, framebuffer );\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\tstate.viewport( _currentViewport );\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tif ( isCube ) {\n\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( 36160, 36064, 34069 + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( framebuffer ) {\n\n\t\t\tvar restore = false;\n\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( 36160, framebuffer );\n\n\t\t\t\trestore = true;\n\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\tvar texture = renderTarget.texture;\n\t\t\t\tvar textureFormat = texture.format;\n\t\t\t\tvar textureType = texture.type;\n\n\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( 36160, _currentFramebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.copyFramebufferToTexture = function ( position, texture, level ) {\n\n\t\tvar width = texture.image.width;\n\t\tvar height = texture.image.height;\n\t\tvar glFormat = utils.convert( texture.format );\n\n\t\tthis.setTexture2D( texture, 0 );\n\n\t\t_gl.copyTexImage2D( 3553, level || 0, glFormat, position.x, position.y, width, height, 0 );\n\n\t};\n\n\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {\n\n\t\tvar width = srcTexture.image.width;\n\t\tvar height = srcTexture.image.height;\n\t\tvar glFormat = utils.convert( dstTexture.format );\n\t\tvar glType = utils.convert( dstTexture.type );\n\n\t\tthis.setTexture2D( dstTexture, 0 );\n\n\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t_gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\n\n\t\t} else {\n\n\t\t\t_gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );\n\n\t\t}\n\n\t};\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction FogExp2( color, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new Color( color );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n}\n\nFogExp2.prototype.isFogExp2 = true;\n\nFogExp2.prototype.clone = function () {\n\n\treturn new FogExp2( this.color, this.density );\n\n};\n\nFogExp2.prototype.toJSON = function ( /* meta */ ) {\n\n\treturn {\n\t\ttype: 'FogExp2',\n\t\tcolor: this.color.getHex(),\n\t\tdensity: this.density\n\t};\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Fog( color, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new Color( color );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n}\n\nFog.prototype.isFog = true;\n\nFog.prototype.clone = function () {\n\n\treturn new Fog( this.color, this.near, this.far );\n\n};\n\nFog.prototype.toJSON = function ( /* meta */ ) {\n\n\treturn {\n\t\ttype: 'Fog',\n\t\tcolor: this.color.getHex(),\n\t\tnear: this.near,\n\t\tfar: this.far\n\t};\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Scene() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Scene';\n\n\tthis.background = null;\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\n}\n\nScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Scene,\n\n\tisScene: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tObject3D.prototype.copy.call( this, source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\treturn data;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InterleavedBuffer( array, stride ) {\n\n\tthis.array = array;\n\tthis.stride = stride;\n\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n}\n\nObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\n\n\tset: function ( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n} );\n\nObject.assign( InterleavedBuffer.prototype, {\n\n\tisInterleavedBuffer: true,\n\n\tonUploadCallback: function () {},\n\n\tsetArray: function ( array ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.count = array !== undefined ? array.length / this.stride : 0;\n\t\tthis.array = array;\n\n\t\treturn this;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tonUpload: function ( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n\tthis.data = interleavedBuffer;\n\tthis.itemSize = itemSize;\n\tthis.offset = offset;\n\n\tthis.normalized = normalized === true;\n\n}\n\nObject.defineProperties( InterleavedBufferAttribute.prototype, {\n\n\tcount: {\n\n\t\tget: function () {\n\n\t\t\treturn this.data.count;\n\n\t\t}\n\n\t},\n\n\tarray: {\n\n\t\tget: function () {\n\n\t\t\treturn this.data.array;\n\n\t\t}\n\n\t}\n\n} );\n\nObject.assign( InterleavedBufferAttribute.prototype, {\n\n\tisInterleavedBufferAttribute: true,\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  map: new THREE.Texture( <Image> ),\n *  rotation: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nfunction SpriteMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'SpriteMaterial';\n\n\tthis.color = new Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.sizeAttenuation = true;\n\n\tthis.lights = false;\n\tthis.transparent = true;\n\n\tthis.setValues( parameters );\n\n}\n\nSpriteMaterial.prototype = Object.create( Material.prototype );\nSpriteMaterial.prototype.constructor = SpriteMaterial;\nSpriteMaterial.prototype.isSpriteMaterial = true;\n\nSpriteMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.map = source.map;\n\n\tthis.rotation = source.rotation;\n\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\treturn this;\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar geometry;\n\nfunction Sprite( material ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Sprite';\n\n\tif ( geometry === undefined ) {\n\n\t\tgeometry = new BufferGeometry();\n\n\t\tvar float32Array = new Float32Array( [\n\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t] );\n\n\t\tvar interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\tgeometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\tgeometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t}\n\n\tthis.geometry = geometry;\n\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\tthis.center = new Vector2( 0.5, 0.5 );\n\n}\n\nSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Sprite,\n\n\tisSprite: true,\n\n\traycast: ( function () {\n\n\t\tvar intersectPoint = new Vector3();\n\t\tvar worldScale = new Vector3();\n\t\tvar mvPosition = new Vector3();\n\n\t\tvar alignedPosition = new Vector2();\n\t\tvar rotatedPosition = new Vector2();\n\t\tvar viewWorldMatrix = new Matrix4();\n\n\t\tvar vA = new Vector3();\n\t\tvar vB = new Vector3();\n\t\tvar vC = new Vector3();\n\n\t\tvar uvA = new Vector2();\n\t\tvar uvB = new Vector2();\n\t\tvar uvC = new Vector2();\n\n\t\tfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t\t\t// compute position in camera space\n\t\t\talignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t\t\t// to check if rotation is not zero\n\t\t\tif ( sin !== undefined ) {\n\n\t\t\t\trotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );\n\t\t\t\trotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );\n\n\t\t\t} else {\n\n\t\t\t\trotatedPosition.copy( alignedPosition );\n\n\t\t\t}\n\n\n\t\t\tvertexPosition.copy( mvPosition );\n\t\t\tvertexPosition.x += rotatedPosition.x;\n\t\t\tvertexPosition.y += rotatedPosition.y;\n\n\t\t\t// transform to world space\n\t\t\tvertexPosition.applyMatrix4( viewWorldMatrix );\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tworldScale.setFromMatrixScale( this.matrixWorld );\n\t\t\tviewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );\n\t\t\tmvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\t\tvar rotation = this.material.rotation;\n\t\t\tvar sin, cos;\n\t\t\tif ( rotation !== 0 ) {\n\n\t\t\t\tcos = Math.cos( rotation );\n\t\t\t\tsin = Math.sin( rotation );\n\n\t\t\t}\n\n\t\t\tvar center = this.center;\n\n\t\t\ttransformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\n\t\t\ttransformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\n\t\t\ttransformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\n\n\t\t\tuvA.set( 0, 0 );\n\t\t\tuvB.set( 1, 0 );\n\t\t\tuvC.set( 1, 1 );\n\n\t\t\t// check first triangle\n\t\t\tvar intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );\n\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\t// check second triangle\n\t\t\t\ttransformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );\n\t\t\t\tuvB.set( 0, 1 );\n\n\t\t\t\tintersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );\n\t\t\t\tif ( intersect === null ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\tuv: Triangle.getUV( intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() ),\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\n\t\t\t} );\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.material ).copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\treturn this;\n\n\t}\n\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LOD() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'LOD';\n\n\tObject.defineProperties( this, {\n\t\tlevels: {\n\t\t\tenumerable: true,\n\t\t\tvalue: []\n\t\t}\n\t} );\n\n}\n\nLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: LOD,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source, false );\n\n\t\tvar levels = source.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\taddLevel: function ( object, distance ) {\n\n\t\tif ( distance === undefined ) distance = 0;\n\n\t\tdistance = Math.abs( distance );\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t},\n\n\tgetObjectForDistance: function ( distance ) {\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn levels[ i - 1 ].object;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t};\n\n\t}() ),\n\n\tupdate: function () {\n\n\t\tvar v1 = new Vector3();\n\t\tvar v2 = new Vector3();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.levels = [];\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nfunction SkinnedMesh( geometry, material ) {\n\n\tif ( geometry && geometry.isGeometry ) {\n\n\t\tconsole.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t}\n\n\tMesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = 'attached';\n\tthis.bindMatrix = new Matrix4();\n\tthis.bindMatrixInverse = new Matrix4();\n\n}\n\nSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: SkinnedMesh,\n\n\tisSkinnedMesh: true,\n\n\tbind: function ( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tvar vector = new Vector4();\n\n\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( var i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.x = skinWeight.getX( i );\n\t\t\tvector.y = skinWeight.getY( i );\n\t\t\tvector.z = skinWeight.getZ( i );\n\t\t\tvector.w = skinWeight.getW( i );\n\n\t\t\tvar scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tMesh.prototype.updateMatrixWorld.call( this, force );\n\n\t\tif ( this.bindMode === 'attached' ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === 'detached' ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author michael guerrero / http://realitymeltdown.com\n * @author ikerr / http://verold.com\n */\n\nfunction Skeleton( bones, boneInverses ) {\n\n\t// copy the bone array\n\n\tbones = bones || [];\n\n\tthis.bones = bones.slice( 0 );\n\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\n\n\t// use the supplied bone inverses or calculate the inverses\n\n\tif ( boneInverses === undefined ) {\n\n\t\tthis.calculateInverses();\n\n\t} else {\n\n\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nObject.assign( Skeleton.prototype, {\n\n\tcalculateInverses: function () {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tvar inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.getInverse( this.bones[ i ].matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t},\n\n\tpose: function () {\n\n\t\tvar bone, i, il;\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tbone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tbone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: ( function () {\n\n\t\tvar offsetMatrix = new Matrix4();\n\t\tvar identityMatrix = new Matrix4();\n\n\t\treturn function update() {\n\n\t\t\tvar bones = this.bones;\n\t\t\tvar boneInverses = this.boneInverses;\n\t\t\tvar boneMatrices = this.boneMatrices;\n\t\t\tvar boneTexture = this.boneTexture;\n\n\t\t\t// flatten bone matrices to array\n\n\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;\n\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t\toffsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t\t}\n\n\t\t\tif ( boneTexture !== undefined ) {\n\n\t\t\t\tboneTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )(),\n\n\tclone: function () {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t},\n\n\tgetBoneByName: function ( name ) {\n\n\t\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tvar bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n} );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nfunction Bone() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Bone';\n\n}\n\nBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Bone,\n\n\tisBone: true\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nfunction LineBasicMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'LineBasicMaterial';\n\n\tthis.color = new Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nLineBasicMaterial.prototype = Object.create( Material.prototype );\nLineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\nLineBasicMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\tthis.linecap = source.linecap;\n\tthis.linejoin = source.linejoin;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Line( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );\n\n\t}\n\n\tObject3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n}\n\nLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Line,\n\n\tisLine: true,\n\n\tcomputeLineDistances: ( function () {\n\n\t\tvar start = new Vector3();\n\t\tvar end = new Vector3();\n\n\t\treturn function computeLineDistances() {\n\n\t\t\tvar geometry = this.geometry;\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t// we assume non-indexed geometry\n\n\t\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\t\tvar lineDistances = [ 0 ];\n\n\t\t\t\t\tfor ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\t\tlineDistances[ i ] += start.distanceTo( end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar lineDistances = geometry.lineDistances;\n\n\t\t\t\tlineDistances[ 0 ] = 0;\n\n\t\t\t\tfor ( var i = 1, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() ),\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new Matrix4();\n\t\tvar ray = new Ray();\n\t\tvar sphere = new Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\t\tsphere.radius += precision;\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localPrecisionSq = localPrecision * localPrecision;\n\n\t\t\tvar vStart = new Vector3();\n\t\t\tvar vEnd = new Vector3();\n\t\t\tvar interSegment = new Vector3();\n\t\t\tvar interRay = new Vector3();\n\t\t\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > localPrecisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > localPrecisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localPrecisionSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.geometry.copy( source.geometry );\n\t\tthis.material.copy( source.material );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LineSegments( geometry, material ) {\n\n\tLine.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n}\n\nLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\tconstructor: LineSegments,\n\n\tisLineSegments: true,\n\n\tcomputeLineDistances: ( function () {\n\n\t\tvar start = new Vector3();\n\t\tvar end = new Vector3();\n\n\t\treturn function computeLineDistances() {\n\n\t\t\tvar geometry = this.geometry;\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t// we assume non-indexed geometry\n\n\t\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\t\tvar lineDistances = [];\n\n\t\t\t\t\tfor ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t\t\tstart.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t\tend.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar lineDistances = geometry.lineDistances;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i += 2 ) {\n\n\t\t\t\t\tstart.copy( vertices[ i ] );\n\t\t\t\t\tend.copy( vertices[ i + 1 ] );\n\n\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() )\n\n} );\n\n/**\n * @author mgreter / http://github.com/mgreter\n */\n\nfunction LineLoop( geometry, material ) {\n\n\tLine.call( this, geometry, material );\n\n\tthis.type = 'LineLoop';\n\n}\n\nLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\tconstructor: LineLoop,\n\n\tisLineLoop: true,\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n *\n *  morphTargets: <bool>\n * }\n */\n\nfunction PointsMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'PointsMaterial';\n\n\tthis.color = new Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nPointsMaterial.prototype = Object.create( Material.prototype );\nPointsMaterial.prototype.constructor = PointsMaterial;\n\nPointsMaterial.prototype.isPointsMaterial = true;\n\nPointsMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.size = source.size;\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Points( geometry, material ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n}\n\nPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Points,\n\n\tisPoints: true,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new Matrix4();\n\t\tvar ray = new Ray();\n\t\tvar sphere = new Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar object = this;\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\t\tsphere.radius += threshold;\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\tvar position = new Vector3();\n\t\t\tvar intersectPoint = new Vector3();\n\n\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\tray.closestPointToPoint( point, intersectPoint );\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.format = format !== undefined ? format : RGBFormat;\n\n\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\tthis.generateMipmaps = false;\n\n}\n\nVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\n\n\tconstructor: VideoTexture,\n\n\tisVideoTexture: true,\n\n\tupdate: function () {\n\n\t\tvar video = this.image;\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\t// no flipping for cube textures\n\t// (also flipping doesn't work for compressed textures )\n\n\tthis.flipY = false;\n\n\t// can't generate mipmaps for compressed textures\n\t// mips must be embedded in DDS files\n\n\tthis.generateMipmaps = false;\n\n}\n\nCompressedTexture.prototype = Object.create( Texture.prototype );\nCompressedTexture.prototype.constructor = CompressedTexture;\n\nCompressedTexture.prototype.isCompressedTexture = true;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.needsUpdate = true;\n\n}\n\nCanvasTexture.prototype = Object.create( Texture.prototype );\nCanvasTexture.prototype.constructor = CanvasTexture;\nCanvasTexture.prototype.isCanvasTexture = true;\n\n/**\n * @author Matt DesLauriers / @mattdesl\n * @author atix / arthursilber.de\n */\n\nfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\tformat = format !== undefined ? format : DepthFormat;\n\n\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t}\n\n\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\n\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.image = { width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\tthis.flipY = false;\n\tthis.generateMipmaps\t= false;\n\n}\n\nDepthTexture.prototype = Object.create( Texture.prototype );\nDepthTexture.prototype.constructor = DepthTexture;\nDepthTexture.prototype.isDepthTexture = true;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction WireframeGeometry( geometry ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'WireframeGeometry';\n\n\t// buffer\n\n\tvar vertices = [];\n\n\t// helper variables\n\n\tvar i, j, l, o, ol;\n\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\n\tvar key, keys = [ 'a', 'b', 'c' ];\n\tvar vertex;\n\n\t// different logic for Geometry and BufferGeometry\n\n\tif ( geometry && geometry.isGeometry ) {\n\n\t\t// create a data structure that contains all edges without duplicates\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices\n\n\t\tfor ( key in edges ) {\n\n\t\t\te = edges[ key ];\n\n\t\t\tvertex = geometry.vertices[ e.index1 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\tvertex = geometry.vertices[ e.index2 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t} else if ( geometry && geometry.isBufferGeometry ) {\n\n\t\tvar position, indices, groups;\n\t\tvar group, start, count;\n\t\tvar index1, index2;\n\n\t\tvertex = new Vector3();\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// indexed BufferGeometry\n\n\t\t\tposition = geometry.attributes.position;\n\t\t\tindices = geometry.index;\n\t\t\tgroups = geometry.groups;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t}\n\n\t\t\t// create a data structure that contains all eges without duplicates\n\n\t\t\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tgroup = groups[ o ];\n\n\t\t\t\tstart = group.start;\n\t\t\t\tcount = group.count;\n\n\t\t\t\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tedge1 = indices.getX( i + j );\n\t\t\t\t\t\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\n\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate vertices\n\n\t\t\tfor ( key in edges ) {\n\n\t\t\t\te = edges[ key ];\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index1 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\tvertex.fromBufferAttribute( position, e.index2 );\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tposition = geometry.attributes.position;\n\n\t\t\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\tindex1 = 3 * i + j;\n\t\t\t\t\tvertex.fromBufferAttribute( position, index1 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\n\t\t\t\t\tvertex.fromBufferAttribute( position, index2 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n}\n\nWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\nWireframeGeometry.prototype.constructor = WireframeGeometry;\n\n/**\n * @author zz85 / https://github.com/zz85\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n */\n\n// ParametricGeometry\n\nfunction ParametricGeometry( func, slices, stacks ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n\tthis.mergeVertices();\n\n}\n\nParametricGeometry.prototype = Object.create( Geometry.prototype );\nParametricGeometry.prototype.constructor = ParametricGeometry;\n\n// ParametricBufferGeometry\n\nfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ParametricBufferGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tvar EPS = 0.00001;\n\n\tvar normal = new Vector3();\n\n\tvar p0 = new Vector3(), p1 = new Vector3();\n\tvar pu = new Vector3(), pv = new Vector3();\n\n\tvar i, j;\n\n\tif ( func.length < 3 ) {\n\n\t\tconsole.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );\n\n\t}\n\n\t// generate vertices, normals and uvs\n\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tvar v = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tvar u = j / slices;\n\n\t\t\t// vertex\n\n\t\t\tfunc( u, v, p0 );\n\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t// normal\n\n\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\tfunc( u - EPS, v, p1 );\n\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u + EPS, v, p1 );\n\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\tfunc( u, v - EPS, p1 );\n\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u, v + EPS, p1 );\n\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( u, v );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\tvar a = i * sliceCount + j;\n\t\t\tvar b = i * sliceCount + j + 1;\n\t\t\tvar c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\tvar d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t// faces one and two\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// PolyhedronGeometry\n\nfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'PolyhedronGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\nPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n// PolyhedronBufferGeometry\n\nfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'PolyhedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\t// default buffer data\n\n\tvar vertexBuffer = [];\n\tvar uvBuffer = [];\n\n\t// the subdivision creates the vertex buffer data\n\n\tsubdivide( detail );\n\n\t// all vertices should lie on a conceptual sphere with a given radius\n\n\tappplyRadius( radius );\n\n\t// finally, create the uv data\n\n\tgenerateUVs();\n\n\t// build non-indexed geometry\n\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\tif ( detail === 0 ) {\n\n\t\tthis.computeVertexNormals(); // flat normals\n\n\t} else {\n\n\t\tthis.normalizeNormals(); // smooth normals\n\n\t}\n\n\t// helper functions\n\n\tfunction subdivide( detail ) {\n\n\t\tvar a = new Vector3();\n\t\tvar b = new Vector3();\n\t\tvar c = new Vector3();\n\n\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t// get the vertices of the face\n\n\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t// perform subdivision\n\n\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t}\n\n\t}\n\n\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\tvar cols = Math.pow( 2, detail );\n\n\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\tvar v = [];\n\n\t\tvar i, j;\n\n\t\t// construct all of the vertices for this subdivision\n\n\t\tfor ( i = 0; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = a.clone().lerp( c, i / cols );\n\t\t\tvar bj = b.clone().lerp( c, i / cols );\n\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( j = 0; j <= rows; j ++ ) {\n\n\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// construct all of the faces\n\n\t\tfor ( i = 0; i < cols; i ++ ) {\n\n\t\t\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction appplyRadius( radius ) {\n\n\t\tvar vertex = new Vector3();\n\n\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t}\n\n\t}\n\n\tfunction generateUVs() {\n\n\t\tvar vertex = new Vector3();\n\n\t\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\tvar v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t}\n\n\t\tcorrectUVs();\n\n\t\tcorrectSeam();\n\n\t}\n\n\tfunction correctSeam() {\n\n\t\t// handle case when face straddles the seam, see #3269\n\n\t\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t// uv data of a single face\n\n\t\t\tvar x0 = uvBuffer[ i + 0 ];\n\t\t\tvar x1 = uvBuffer[ i + 2 ];\n\t\t\tvar x2 = uvBuffer[ i + 4 ];\n\n\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction pushVertex( vertex ) {\n\n\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t}\n\n\tfunction getVertexByIndex( index, vertex ) {\n\n\t\tvar stride = index * 3;\n\n\t\tvertex.x = vertices[ stride + 0 ];\n\t\tvertex.y = vertices[ stride + 1 ];\n\t\tvertex.z = vertices[ stride + 2 ];\n\n\t}\n\n\tfunction correctUVs() {\n\n\t\tvar a = new Vector3();\n\t\tvar b = new Vector3();\n\t\tvar c = new Vector3();\n\n\t\tvar centroid = new Vector3();\n\n\t\tvar uvA = new Vector2();\n\t\tvar uvB = new Vector2();\n\t\tvar uvC = new Vector2();\n\n\t\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\tvar azi = azimuth( centroid );\n\n\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t}\n\n\t}\n\n\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t}\n\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t}\n\n\t}\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n}\n\nPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// TetrahedronGeometry\n\nfunction TetrahedronGeometry( radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TetrahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\nTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\n// TetrahedronBufferGeometry\n\nfunction TetrahedronBufferGeometry( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t];\n\n\tvar indices = [\n\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t];\n\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'TetrahedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n}\n\nTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\nTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// OctahedronGeometry\n\nfunction OctahedronGeometry( radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'OctahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nOctahedronGeometry.prototype = Object.create( Geometry.prototype );\nOctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\n// OctahedronBufferGeometry\n\nfunction OctahedronBufferGeometry( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t];\n\n\tvar indices = [\n\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t1, 3, 4,\t1, 4, 2\n\t];\n\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'OctahedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n}\n\nOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\nOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// IcosahedronGeometry\n\nfunction IcosahedronGeometry( radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'IcosahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\nIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\n// IcosahedronBufferGeometry\n\nfunction IcosahedronBufferGeometry( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t 0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t t, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t];\n\n\tvar indices = [\n\t\t 0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t 1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t 3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t 4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t];\n\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'IcosahedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n}\n\nIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\nIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n/**\n * @author Abe Pazos / https://hamoid.com\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// DodecahedronGeometry\n\nfunction DodecahedronGeometry( radius, detail ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'DodecahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n\tthis.mergeVertices();\n\n}\n\nDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\nDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\n// DodecahedronBufferGeometry\n\nfunction DodecahedronBufferGeometry( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\tvar r = 1 / t;\n\n\tvar vertices = [\n\n\t\t// (1, 1, 1)\n\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t// (0, 1/, )\n\t\t 0, - r, - t, 0, - r, t,\n\t\t 0, r, - t, 0, r, t,\n\n\t\t// (1/, , 0)\n\t\t- r, - t, 0, - r, t, 0,\n\t\t r, - t, 0, r, t, 0,\n\n\t\t// (, 0, 1/)\n\t\t- t, 0, - r, t, 0, - r,\n\t\t- t, 0, r, t, 0, r\n\t];\n\n\tvar indices = [\n\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t];\n\n\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'DodecahedronBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n}\n\nDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\nDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n/**\n * @author oosmoxiecode / https://github.com/oosmoxiecode\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n * @author jonobr1 / https://github.com/jonobr1\n * @author Mugen87 / https://github.com/Mugen87\n *\n */\n\n// TubeGeometry\n\nfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TubeGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\ttubularSegments: tubularSegments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed\n\t};\n\n\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\n\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\n\t// expose internals\n\n\tthis.tangents = bufferGeometry.tangents;\n\tthis.normals = bufferGeometry.normals;\n\tthis.binormals = bufferGeometry.binormals;\n\n\t// create geometry\n\n\tthis.fromBufferGeometry( bufferGeometry );\n\tthis.mergeVertices();\n\n}\n\nTubeGeometry.prototype = Object.create( Geometry.prototype );\nTubeGeometry.prototype.constructor = TubeGeometry;\n\n// TubeBufferGeometry\n\nfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'TubeBufferGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\ttubularSegments: tubularSegments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed\n\t};\n\n\ttubularSegments = tubularSegments || 64;\n\tradius = radius || 1;\n\tradialSegments = radialSegments || 8;\n\tclosed = closed || false;\n\n\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t// expose internals\n\n\tthis.tangents = frames.tangents;\n\tthis.normals = frames.normals;\n\tthis.binormals = frames.binormals;\n\n\t// helper variables\n\n\tvar vertex = new Vector3();\n\tvar normal = new Vector3();\n\tvar uv = new Vector2();\n\tvar P = new Vector3();\n\n\tvar i, j;\n\n\t// buffer\n\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\tvar indices = [];\n\n\t// create buffer data\n\n\tgenerateBufferData();\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t// functions\n\n\tfunction generateBufferData() {\n\n\t\tfor ( i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\tgenerateSegment( i );\n\n\t\t}\n\n\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t// at the regular position on the given path\n\t\t//\n\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t// uvs are generated in a separate function.\n\t\t// this makes it easy compute correct values for closed geometries\n\n\t\tgenerateUVs();\n\n\t\t// finally create faces\n\n\t\tgenerateIndices();\n\n\t}\n\n\tfunction generateSegment( i ) {\n\n\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t// retrieve corresponding normal and binormal\n\n\t\tvar N = frames.normals[ i ];\n\t\tvar B = frames.binormals[ i ];\n\n\t\t// generate normals and vertices for the current segment\n\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\tvar sin = Math.sin( v );\n\t\t\tvar cos = - Math.cos( v );\n\n\t\t\t// normal\n\n\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\tnormal.normalize();\n\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t}\n\n\tfunction generateIndices() {\n\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction generateUVs() {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\n/**\n * @author oosmoxiecode\n * @author Mugen87 / https://github.com/Mugen87\n *\n * based on http://www.blackpawn.com/texts/pqtorus/\n */\n\n// TorusKnotGeometry\n\nfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TorusKnotGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\tthis.mergeVertices();\n\n}\n\nTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\nTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n// TorusKnotBufferGeometry\n\nfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'TorusKnotBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tradius = radius || 1;\n\ttube = tube || 0.4;\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\tp = p || 2;\n\tq = q || 3;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar i, j;\n\n\tvar vertex = new Vector3();\n\tvar normal = new Vector3();\n\n\tvar P1 = new Vector3();\n\tvar P2 = new Vector3();\n\n\tvar B = new Vector3();\n\tvar T = new Vector3();\n\tvar N = new Vector3();\n\n\t// generate vertices, normals and uvs\n\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t// calculate orthonormal basis\n\n\t\tT.subVectors( P2, P1 );\n\t\tN.addVectors( P2, P1 );\n\t\tB.crossVectors( T, N );\n\t\tN.crossVectors( B, T );\n\n\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\tB.normalize();\n\t\tN.normalize();\n\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t// now calculate the final vertex position.\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( i / tubularSegments );\n\t\t\tuvs.push( j / radialSegments );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t// indices\n\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t// this function calculates the current position on the torus curve\n\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = q / p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t}\n\n}\n\nTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// TorusGeometry\n\nfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TorusGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\tthis.mergeVertices();\n\n}\n\nTorusGeometry.prototype = Object.create( Geometry.prototype );\nTorusGeometry.prototype.constructor = TorusGeometry;\n\n// TorusBufferGeometry\n\nfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'TorusBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tradius = radius || 1;\n\ttube = tube || 0.4;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\tarc = arc || Math.PI * 2;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar center = new Vector3();\n\tvar vertex = new Vector3();\n\tvar normal = new Vector3();\n\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / tubularSegments * arc;\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( i / tubularSegments );\n\t\t\tuvs.push( j / radialSegments );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t// indices\n\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n * Port from https://github.com/mapbox/earcut (v2.1.2)\n */\n\nvar Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim ) {\n\n\t\tdim = dim || 2;\n\n\t\tvar hasHoles = holeIndices && holeIndices.length,\n\t\t\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\n\t\t\touterNode = linkedList( data, 0, outerLen, dim, true ),\n\t\t\ttriangles = [];\n\n\t\tif ( ! outerNode ) return triangles;\n\n\t\tvar minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( var i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\n\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tvar i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\n\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tvar p = start, again;\n\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\n\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tvar stop = ear, prev, next;\n\n\t// iterate through ears, slicing them one by one\n\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim );\n\t\t\ttriangles.push( ear.i / dim );\n\t\t\ttriangles.push( next.i / dim );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertice leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( ear, triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\n\nfunction isEar( ear ) {\n\n\tvar a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tvar p = ear.next.next;\n\n\twhile ( p !== ear.prev ) {\n\n\t\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tvar a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// triangle bbox; min & max are calculated like this for speed\n\n\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\n\t\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\n\t\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\n\t\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\n\n\t// z-order range for the current triangle bbox;\n\n\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\n\t\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\n\n\t// first look for points inside the triangle in increasing z-order\n\n\tvar p = ear.nextZ;\n\n\twhile ( p && p.z <= maxZ ) {\n\n\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.nextZ;\n\n\t}\n\n\t// then look for points in decreasing z-order\n\n\tp = ear.prevZ;\n\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p !== ear.prev && p !== ear.next &&\n\t\t\t\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\n\t\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\n\t\tp = p.prevZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\n\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tvar p = start;\n\n\tdo {\n\n\t\tvar a = p.prev, b = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim );\n\t\t\ttriangles.push( p.i / dim );\n\t\t\ttriangles.push( b.i / dim );\n\n\t\t\t// remove two nodes involved\n\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn p;\n\n}\n\n// try splitting polygon into two and triangulate them independently\n\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\n\tvar a = start;\n\n\tdo {\n\n\t\tvar b = a.next.next;\n\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\n\t\t\t\tvar c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\n\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tvar queue = [], i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\teliminateHole( queue[ i ], outerNode );\n\t\touterNode = filterPoints( outerNode, outerNode.next );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\n\nfunction eliminateHole( hole, outerNode ) {\n\n\touterNode = findHoleBridge( hole, outerNode );\n\n\tif ( outerNode ) {\n\n\t\tvar b = splitPolygon( outerNode, hole );\n\n\t\tfilterPoints( b, b.next );\n\n\t}\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\n\nfunction findHoleBridge( hole, outerNode ) {\n\n\tvar p = outerNode,\n\t\thx = hole.x,\n\t\thy = hole.y,\n\t\tqx = - Infinity,\n\t\tm;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\n\t\t\t\tif ( x === hx ) {\n\n\t\t\t\t\tif ( hy === p.y ) return p;\n\t\t\t\t\tif ( hy === p.next.y ) return p.next;\n\n\t\t\t\t}\n\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tvar stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y,\n\t\ttanMin = Infinity,\n\t\ttan;\n\n\tp = m.next;\n\n\twhile ( p !== stop ) {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t}\n\n\treturn m;\n\n}\n\n// interlink polygon nodes in z-order\n\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tvar p = start;\n\n\tdo {\n\n\t\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\nfunction sortLinked( list ) {\n\n\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\n\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\n\tx = 32767 * ( x - minX ) * invSize;\n\ty = 32767 * ( y - minY ) * invSize;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\n\nfunction getLeftmost( start ) {\n\n\tvar p = start, leftmost = start;\n\n\tdo {\n\n\t\tif ( p.x < leftmost.x ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\n\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\n\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\n\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\n\t\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\n\n}\n\n// signed area of a triangle\n\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\n\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\n\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\n\t\t\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\n\n\treturn area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&\n\t\t\t\t area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\n\nfunction intersectsPolygon( a, b ) {\n\n\tvar p = a;\n\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\t\t\t\tintersects( p, p.next, a, b ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\n\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\n\nfunction middleInside( a, b ) {\n\n\tvar p = a,\n\t\tinside = false,\n\t\tpx = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\n\n\t\t\tinside = ! inside;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\nfunction splitPolygon( a, b ) {\n\n\tvar a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\n\nfunction insertNode( i, x, y, last ) {\n\n\tvar p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertice index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertice nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = null;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tvar sum = 0;\n\n\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nvar ShapeUtils = {\n\n\t// calculate area of the contour polygon\n\n\tarea: function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t},\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t},\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tvar holeIndices = []; // array of hole indices\n\t\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tvar holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( var i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tvar triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( var i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n};\n\nfunction removeDupEndPts( points ) {\n\n\tvar l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( var i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n// ExtrudeGeometry\n\nfunction ExtrudeGeometry( shapes, options ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'ExtrudeGeometry';\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\toptions: options\n\t};\n\n\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\n\tthis.mergeVertices();\n\n}\n\nExtrudeGeometry.prototype = Object.create( Geometry.prototype );\nExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\nExtrudeGeometry.prototype.toJSON = function () {\n\n\tvar data = Geometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\tvar options = this.parameters.options;\n\n\treturn toJSON( shapes, options, data );\n\n};\n\n// ExtrudeBufferGeometry\n\nfunction ExtrudeBufferGeometry( shapes, options ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ExtrudeBufferGeometry';\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\toptions: options\n\t};\n\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\tvar scope = this;\n\n\tvar verticesArray = [];\n\tvar uvArray = [];\n\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\tvar shape = shapes[ i ];\n\t\taddShape( shape );\n\n\t}\n\n\t// build geometry\n\n\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\tthis.computeVertexNormals();\n\n\t// functions\n\n\tfunction addShape( shape ) {\n\n\t\tvar placeholder = [];\n\n\t\t// options\n\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\tvar depth = options.depth !== undefined ? options.depth : 100;\n\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\tvar extrudePath = options.extrudePath;\n\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t// deprecated options\n\n\t\tif ( options.amount !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );\n\t\t\tdepth = options.amount;\n\n\t\t}\n\n\t\t//\n\n\t\tvar extrudePts, extrudeByPath = false;\n\t\tvar splineTube, binormal, normal, position2;\n\n\t\tif ( extrudePath ) {\n\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t// SETUP TNB variables\n\n\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\tbinormal = new Vector3();\n\t\t\tnormal = new Vector3();\n\t\t\tposition2 = new Vector3();\n\n\t\t}\n\n\t\t// Safeguards if bevels are not enabled\n\n\t\tif ( ! bevelEnabled ) {\n\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\n\t\t}\n\n\t\t// Variables initialization\n\n\t\tvar ahole, h, hl; // looping of holes\n\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\n\t\tvar reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\tif ( reverse ) {\n\n\t\t\tvertices = vertices.reverse();\n\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t/* Vertices */\n\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tvertices = vertices.concat( ahole );\n\n\t\t}\n\n\n\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t}\n\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\n\n\t\t// Find directions for point movement\n\n\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\tvar v_prev_x = inPt.x - inPrev.x,\n\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x,\n\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t// not collinear\n\n\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\tvar direction_eq = false; // assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t}\n\n\n\t\tvar contourMovements = [];\n\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t}\n\n\t\tvar holesMovements = [],\n\t\t\toneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\toneHoleMovements = [];\n\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t}\n\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t}\n\n\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbs = bevelSize;\n\n\t\t// Back facing vertices\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\n\t\tvar s;\n\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// Add bevel segments planes\n\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n\t\t\t// contract shape\n\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t}\n\n\t\t\t// expand holes\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Faces */\n\n\t\t// Top and bottom faces\n\n\t\tbuildLidFaces();\n\n\t\t// Sides faces\n\n\t\tbuildSideFaces();\n\n\n\t\t/////  Internal functions\n\n\t\tfunction buildLidFaces() {\n\n\t\t\tvar start = verticesArray.length / 3;\n\n\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bottom faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// Top faces\n\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t}\n\n\t\t// Create faces for the z-sides of the shape\n\n\t\tfunction buildSideFaces() {\n\n\t\t\tvar start = verticesArray.length / 3;\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t}\n\n\n\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t}\n\n\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\n\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\tvar s = 0,\n\t\t\t\t\tsl = steps + bevelSegments * 2;\n\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction v( x, y, z ) {\n\n\t\t\tplaceholder.push( x );\n\t\t\tplaceholder.push( y );\n\t\t\tplaceholder.push( z );\n\n\t\t}\n\n\n\t\tfunction f3( a, b, c ) {\n\n\t\t\taddVertex( a );\n\t\t\taddVertex( b );\n\t\t\taddVertex( c );\n\n\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\taddUV( uvs[ 0 ] );\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 2 ] );\n\n\t\t}\n\n\t\tfunction f4( a, b, c, d ) {\n\n\t\t\taddVertex( a );\n\t\t\taddVertex( b );\n\t\t\taddVertex( d );\n\n\t\t\taddVertex( b );\n\t\t\taddVertex( c );\n\t\t\taddVertex( d );\n\n\n\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\taddUV( uvs[ 0 ] );\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\taddUV( uvs[ 1 ] );\n\t\t\taddUV( uvs[ 2 ] );\n\t\t\taddUV( uvs[ 3 ] );\n\n\t\t}\n\n\t\tfunction addVertex( index ) {\n\n\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t}\n\n\n\t\tfunction addUV( vector2 ) {\n\n\t\t\tuvArray.push( vector2.x );\n\t\t\tuvArray.push( vector2.y );\n\n\t\t}\n\n\t}\n\n}\n\nExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\n\nExtrudeBufferGeometry.prototype.toJSON = function () {\n\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\tvar options = this.parameters.options;\n\n\treturn toJSON( shapes, options, data );\n\n};\n\n//\n\nvar WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tvar a_x = vertices[ indexA * 3 ];\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\tvar b_x = vertices[ indexB * 3 ];\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\tvar c_x = vertices[ indexC * 3 ];\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tvar a_x = vertices[ indexA * 3 ];\n\t\tvar a_y = vertices[ indexA * 3 + 1 ];\n\t\tvar a_z = vertices[ indexA * 3 + 2 ];\n\t\tvar b_x = vertices[ indexB * 3 ];\n\t\tvar b_y = vertices[ indexB * 3 + 1 ];\n\t\tvar b_z = vertices[ indexB * 3 + 2 ];\n\t\tvar c_x = vertices[ indexC * 3 ];\n\t\tvar c_y = vertices[ indexC * 3 + 1 ];\n\t\tvar c_z = vertices[ indexC * 3 + 2 ];\n\t\tvar d_x = vertices[ indexD * 3 ];\n\t\tvar d_y = vertices[ indexD * 3 + 1 ];\n\t\tvar d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n};\n\nfunction toJSON( shapes, options, data ) {\n\n\t//\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tvar shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\t//\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float> // how far from text outline is bevel\n * }\n */\n\n// TextGeometry\n\nfunction TextGeometry( text, parameters ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'TextGeometry';\n\n\tthis.parameters = {\n\t\ttext: text,\n\t\tparameters: parameters\n\t};\n\n\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\n\tthis.mergeVertices();\n\n}\n\nTextGeometry.prototype = Object.create( Geometry.prototype );\nTextGeometry.prototype.constructor = TextGeometry;\n\n// TextBufferGeometry\n\nfunction TextBufferGeometry( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar font = parameters.font;\n\n\tif ( ! ( font && font.isFont ) ) {\n\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\treturn new Geometry();\n\n\t}\n\n\tvar shapes = font.generateShapes( text, parameters.size );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.depth = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tExtrudeBufferGeometry.call( this, shapes, parameters );\n\n\tthis.type = 'TextBufferGeometry';\n\n}\n\nTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\nTextBufferGeometry.prototype.constructor = TextBufferGeometry;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author benaadams / https://twitter.com/ben_a_adams\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// SphereGeometry\n\nfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'SphereGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n}\n\nSphereGeometry.prototype = Object.create( Geometry.prototype );\nSphereGeometry.prototype.constructor = SphereGeometry;\n\n// SphereBufferGeometry\n\nfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'SphereBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 1;\n\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar thetaEnd = thetaStart + thetaLength;\n\n\tvar ix, iy;\n\n\tvar index = 0;\n\tvar grid = [];\n\n\tvar vertex = new Vector3();\n\tvar normal = new Vector3();\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// generate vertices, normals and uvs\n\n\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\tvar verticesRow = [];\n\n\t\tvar v = iy / heightSegments;\n\n\t\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\tvar u = ix / widthSegments;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormal.set( vertex.x, vertex.y, vertex.z ).normalize();\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( u, 1 - v );\n\n\t\t\tverticesRow.push( index ++ );\n\n\t\t}\n\n\t\tgrid.push( verticesRow );\n\n\t}\n\n\t// indices\n\n\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\tvar a = grid[ iy ][ ix + 1 ];\n\t\t\tvar b = grid[ iy ][ ix ];\n\t\t\tvar c = grid[ iy + 1 ][ ix ];\n\t\t\tvar d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n/**\n * @author Kaleb Murphy\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// RingGeometry\n\nfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'RingGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n}\n\nRingGeometry.prototype = Object.create( Geometry.prototype );\nRingGeometry.prototype.constructor = RingGeometry;\n\n// RingBufferGeometry\n\nfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'RingBufferGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tinnerRadius = innerRadius || 0.5;\n\touterRadius = outerRadius || 1;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// some helper variables\n\n\tvar segment;\n\tvar radius = innerRadius;\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\tvar vertex = new Vector3();\n\tvar uv = new Vector2();\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uv\n\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// increase the radius for next row of vertices\n\n\t\tradius += radiusStep;\n\n\t}\n\n\t// indices\n\n\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\tvar a = segment;\n\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\tvar d = segment + 1;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nRingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n/**\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// LatheGeometry\n\nfunction LatheGeometry( points, segments, phiStart, phiLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n}\n\nLatheGeometry.prototype = Object.create( Geometry.prototype );\nLatheGeometry.prototype.constructor = LatheGeometry;\n\n// LatheBufferGeometry\n\nfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar base;\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new Vector3();\n\tvar uv = new Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// faces\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif ( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new Vector3();\n\t\tvar n2 = new Vector3();\n\t\tvar n = new Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\n\t\tbase = segments * points.length * 3;\n\n\t\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t}\n\n\t}\n\n}\n\nLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n/**\n * @author jonobr1 / http://jonobr1.com\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// ShapeGeometry\n\nfunction ShapeGeometry( shapes, curveSegments ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'ShapeGeometry';\n\n\tif ( typeof curveSegments === 'object' ) {\n\n\t\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\n\n\t\tcurveSegments = curveSegments.curveSegments;\n\n\t}\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\tcurveSegments: curveSegments\n\t};\n\n\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\n\tthis.mergeVertices();\n\n}\n\nShapeGeometry.prototype = Object.create( Geometry.prototype );\nShapeGeometry.prototype.constructor = ShapeGeometry;\n\nShapeGeometry.prototype.toJSON = function () {\n\n\tvar data = Geometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\n\treturn toJSON$1( shapes, data );\n\n};\n\n// ShapeBufferGeometry\n\nfunction ShapeBufferGeometry( shapes, curveSegments ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ShapeBufferGeometry';\n\n\tthis.parameters = {\n\t\tshapes: shapes,\n\t\tcurveSegments: curveSegments\n\t};\n\n\tcurveSegments = curveSegments || 12;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar groupStart = 0;\n\tvar groupCount = 0;\n\n\t// allow single and array values for \"shapes\" parameter\n\n\tif ( Array.isArray( shapes ) === false ) {\n\n\t\taddShape( shapes );\n\n\t} else {\n\n\t\tfor ( var i = 0; i < shapes.length; i ++ ) {\n\n\t\t\taddShape( shapes[ i ] );\n\n\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\tgroupStart += groupCount;\n\t\t\tgroupCount = 0;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t// helper functions\n\n\tfunction addShape( shape ) {\n\n\t\tvar i, l, shapeHole;\n\n\t\tvar indexOffset = vertices.length / 3;\n\t\tvar points = shape.extractPoints( curveSegments );\n\n\t\tvar shapeVertices = points.shape;\n\t\tvar shapeHoles = points.holes;\n\n\t\t// check direction of vertices\n\n\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t}\n\n\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\tshapeHole = shapeHoles[ i ];\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t// join vertices of inner and outer paths to a single array\n\n\t\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\tshapeHole = shapeHoles[ i ];\n\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t}\n\n\t\t// vertices, normals, uvs\n\n\t\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\tvar vertex = shapeVertices[ i ];\n\n\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\tnormals.push( 0, 0, 1 );\n\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t}\n\n\t\t// incides\n\n\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar a = face[ 0 ] + indexOffset;\n\t\t\tvar b = face[ 1 ] + indexOffset;\n\t\t\tvar c = face[ 2 ] + indexOffset;\n\n\t\t\tindices.push( a, b, c );\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t}\n\n}\n\nShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\n\nShapeBufferGeometry.prototype.toJSON = function () {\n\n\tvar data = BufferGeometry.prototype.toJSON.call( this );\n\n\tvar shapes = this.parameters.shapes;\n\n\treturn toJSON$1( shapes, data );\n\n};\n\n//\n\nfunction toJSON$1( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tvar shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction EdgesGeometry( geometry, thresholdAngle ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'EdgesGeometry';\n\n\tthis.parameters = {\n\t\tthresholdAngle: thresholdAngle\n\t};\n\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t// buffer\n\n\tvar vertices = [];\n\n\t// helper variables\n\n\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\n\tvar key, keys = [ 'a', 'b', 'c' ];\n\n\t// prepare source geometry\n\n\tvar geometry2;\n\n\tif ( geometry.isBufferGeometry ) {\n\n\t\tgeometry2 = new Geometry();\n\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry2 = geometry.clone();\n\n\t}\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar sourceVertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\n\t// now create a data structure where each entry represents an edge with its adjoining faces\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge1 = face[ keys[ j ] ];\n\t\t\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge[ 0 ] = Math.min( edge1, edge2 );\n\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\tkey = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t} else {\n\n\t\t\t\tedges[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// generate vertices\n\n\tfor ( key in edges ) {\n\n\t\tvar e = edges[ key ];\n\n\t\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n\n\t\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\tvar vertex = sourceVertices[ e.index1 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\tvertex = sourceVertices[ e.index2 ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n}\n\nEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\nEdgesGeometry.prototype.constructor = EdgesGeometry;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n// CylinderGeometry\n\nfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'CylinderGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n}\n\nCylinderGeometry.prototype = Object.create( Geometry.prototype );\nCylinderGeometry.prototype.constructor = CylinderGeometry;\n\n// CylinderBufferGeometry\n\nfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'CylinderBufferGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tvar scope = this;\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\n\theight = height || 1;\n\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\n\topenEnded = openEnded !== undefined ? openEnded : false;\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar index = 0;\n\tvar indexArray = [];\n\tvar halfHeight = height / 2;\n\tvar groupStart = 0;\n\n\t// generate geometry\n\n\tgenerateTorso();\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\tfunction generateTorso() {\n\n\t\tvar x, y;\n\t\tvar normal = new Vector3();\n\t\tvar vertex = new Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\t// this will be used to calculate the normal\n\t\tvar slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar indexRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\t// calculate the radius of the current row\n\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\t// now save vertices of the row in our index array\n\n\t\t\tindexArray.push( indexRow );\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\tvar a = indexArray[ y ][ x ];\n\t\t\t\tvar b = indexArray[ y + 1 ][ x ];\n\t\t\t\tvar c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\tvar d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t// update group counter\n\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t// calculate new start value for groups\n\n\t\tgroupStart += groupCount;\n\n\t}\n\n\tfunction generateCap( top ) {\n\n\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\tvar uv = new Vector2();\n\t\tvar vertex = new Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t// save the index of the first center vertex\n\t\tcenterIndexStart = index;\n\n\t\t// first we generate the center vertex data of the cap.\n\t\t// because the geometry needs one set of uvs per face,\n\t\t// we must generate a center vertex per face/segment\n\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t// vertex\n\n\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t// increase index\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// save the index of the last center vertex\n\n\t\tcenterIndexEnd = index;\n\n\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * sinTheta;\n\t\t\tvertex.y = halfHeight * sign;\n\t\t\tvertex.z = radius * cosTheta;\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t// uv\n\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t// increase index\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar c = centerIndexStart + x;\n\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\tif ( top === true ) {\n\n\t\t\t\t// face top\n\n\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t} else {\n\n\t\t\t\t// face bottom\n\n\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t}\n\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t// calculate new start value for groups\n\n\t\tgroupStart += groupCount;\n\n\t}\n\n}\n\nCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\n// ConeGeometry\n\nfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n}\n\nConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\nConeGeometry.prototype.constructor = ConeGeometry;\n\n// ConeBufferGeometry\n\nfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n}\n\nConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\nConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n * @author Mugen87 / https://github.com/Mugen87\n * @author hughes\n */\n\n// CircleGeometry\n\nfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\tGeometry.call( this );\n\n\tthis.type = 'CircleGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n}\n\nCircleGeometry.prototype = Object.create( Geometry.prototype );\nCircleGeometry.prototype.constructor = CircleGeometry;\n\n// CircleBufferGeometry\n\nfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'CircleBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 1;\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t// buffers\n\n\tvar indices = [];\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\t// helper variables\n\n\tvar i, s;\n\tvar vertex = new Vector3();\n\tvar uv = new Vector2();\n\n\t// center point\n\n\tvertices.push( 0, 0, 0 );\n\tnormals.push( 0, 0, 1 );\n\tuvs.push( 0.5, 0.5 );\n\n\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\t// vertex\n\n\t\tvertex.x = radius * Math.cos( segment );\n\t\tvertex.y = radius * Math.sin( segment );\n\n\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t// normal\n\n\t\tnormals.push( 0, 0, 1 );\n\n\t\t// uvs\n\n\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\tuvs.push( uv.x, uv.y );\n\n\t}\n\n\t// indices\n\n\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\tindices.push( i, i + 1, 0 );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\tWireframeGeometry: WireframeGeometry,\n\tParametricGeometry: ParametricGeometry,\n\tParametricBufferGeometry: ParametricBufferGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tOctahedronBufferGeometry: OctahedronBufferGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\n\tTubeGeometry: TubeGeometry,\n\tTubeBufferGeometry: TubeBufferGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusBufferGeometry: TorusBufferGeometry,\n\tTextGeometry: TextGeometry,\n\tTextBufferGeometry: TextBufferGeometry,\n\tSphereGeometry: SphereGeometry,\n\tSphereBufferGeometry: SphereBufferGeometry,\n\tRingGeometry: RingGeometry,\n\tRingBufferGeometry: RingBufferGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPlaneBufferGeometry: PlaneBufferGeometry,\n\tLatheGeometry: LatheGeometry,\n\tLatheBufferGeometry: LatheBufferGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tShapeBufferGeometry: ShapeBufferGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tExtrudeBufferGeometry: ExtrudeBufferGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tConeGeometry: ConeGeometry,\n\tConeBufferGeometry: ConeBufferGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tCylinderBufferGeometry: CylinderBufferGeometry,\n\tCircleGeometry: CircleGeometry,\n\tCircleBufferGeometry: CircleBufferGeometry,\n\tBoxGeometry: BoxGeometry,\n\tBoxBufferGeometry: BoxBufferGeometry\n});\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  color: <THREE.Color>\n * }\n */\n\nfunction ShadowMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'ShadowMaterial';\n\n\tthis.color = new Color( 0x000000 );\n\tthis.transparent = true;\n\n\tthis.setValues( parameters );\n\n}\n\nShadowMaterial.prototype = Object.create( Material.prototype );\nShadowMaterial.prototype.constructor = ShadowMaterial;\n\nShadowMaterial.prototype.isShadowMaterial = true;\n\nShadowMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction RawShaderMaterial( parameters ) {\n\n\tShaderMaterial.call( this, parameters );\n\n\tthis.type = 'RawShaderMaterial';\n\n}\n\nRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\nRawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshStandardMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\tthis.roughness = 0.5;\n\tthis.metalness = 0.5;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshStandardMaterial.prototype = Object.create( Material.prototype );\nMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\nMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  reflectivity: <float>\n *  clearCoat: <float>\n *  clearCoatRoughness: <float>\n * }\n */\n\nfunction MeshPhysicalMaterial( parameters ) {\n\n\tMeshStandardMaterial.call( this );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.type = 'MeshPhysicalMaterial';\n\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\tthis.clearCoat = 0.0;\n\tthis.clearCoatRoughness = 0.0;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\nMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\nMeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\tMeshStandardMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.reflectivity = source.reflectivity;\n\n\tthis.clearCoat = source.clearCoat;\n\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshPhongMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshPhongMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\tthis.specular = new Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshPhongMaterial.prototype = Object.create( Material.prototype );\nMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\nMeshPhongMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.specular.copy( source.specular );\n\tthis.shininess = source.shininess;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author takahirox / http://github.com/takahirox\n *\n * parameters = {\n *  gradientMap: new THREE.Texture( <Image> )\n * }\n */\n\nfunction MeshToonMaterial( parameters ) {\n\n\tMeshPhongMaterial.call( this );\n\n\tthis.defines = { 'TOON': '' };\n\n\tthis.type = 'MeshToonMaterial';\n\n\tthis.gradientMap = null;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\nMeshToonMaterial.prototype.constructor = MeshToonMaterial;\n\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\nMeshToonMaterial.prototype.copy = function ( source ) {\n\n\tMeshPhongMaterial.prototype.copy.call( this, source );\n\n\tthis.gradientMap = source.gradientMap;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshNormalMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshNormalMaterial';\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshNormalMaterial.prototype = Object.create( Material.prototype );\nMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\nMeshNormalMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshLambertMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshLambertMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshLambertMaterial.prototype = Object.create( Material.prototype );\nMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\nMeshLambertMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  matcap: new THREE.Texture( <Image> ),\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshMatcapMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.defines = { 'MATCAP': '' };\n\n\tthis.type = 'MeshMatcapMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\n\tthis.matcap = null;\n\n\tthis.map = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.alphaMap = null;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshMatcapMaterial.prototype = Object.create( Material.prototype );\nMeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;\n\nMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\n\nMeshMatcapMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'MATCAP': '' };\n\n\tthis.color.copy( source.color );\n\n\tthis.matcap = source.matcap;\n\n\tthis.map = source.map;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nfunction LineDashedMaterial( parameters ) {\n\n\tLineBasicMaterial.call( this );\n\n\tthis.type = 'LineDashedMaterial';\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.setValues( parameters );\n\n}\n\nLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\nLineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\nLineDashedMaterial.prototype.copy = function ( source ) {\n\n\tLineBasicMaterial.prototype.copy.call( this, source );\n\n\tthis.scale = source.scale;\n\tthis.dashSize = source.dashSize;\n\tthis.gapSize = source.gapSize;\n\n\treturn this;\n\n};\n\n\n\nvar Materials = /*#__PURE__*/Object.freeze({\n\tShadowMaterial: ShadowMaterial,\n\tSpriteMaterial: SpriteMaterial,\n\tRawShaderMaterial: RawShaderMaterial,\n\tShaderMaterial: ShaderMaterial,\n\tPointsMaterial: PointsMaterial,\n\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\tMeshStandardMaterial: MeshStandardMaterial,\n\tMeshPhongMaterial: MeshPhongMaterial,\n\tMeshToonMaterial: MeshToonMaterial,\n\tMeshNormalMaterial: MeshNormalMaterial,\n\tMeshLambertMaterial: MeshLambertMaterial,\n\tMeshDepthMaterial: MeshDepthMaterial,\n\tMeshDistanceMaterial: MeshDistanceMaterial,\n\tMeshBasicMaterial: MeshBasicMaterial,\n\tMeshMatcapMaterial: MeshMatcapMaterial,\n\tLineDashedMaterial: LineDashedMaterial,\n\tLineBasicMaterial: LineBasicMaterial,\n\tMaterial: Material\n});\n\n/**\n * @author tschw\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nvar AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function ( array, from, to ) {\n\n\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function ( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function ( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function ( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tvar n = times.length;\n\t\tvar result = new Array( n );\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function ( values, stride, order ) {\n\n\t\tvar nValues = values.length;\n\t\tvar result = new values.constructor( nValues );\n\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tvar value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t}\n\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\n\nfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n}\n\nObject.assign( Interpolant.prototype, {\n\n\tevaluate: function ( t ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tvar right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function () {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function ( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n} );\n\n//!\\ DECLARE ALIAS AFTER assign prototype !\nObject.assign( Interpolant.prototype, {\n\n\t//( 0, t, t0 ), returns this.resultBuffer\n\tbeforeStart_: Interpolant.prototype.copySampleValue_,\n\n\t//( N-1, tN-1, t ), returns this.resultBuffer\n\tafterEnd_: Interpolant.prototype.copySampleValue_,\n\n} );\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n *\n * @author tschw\n */\n\nfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = - 0;\n\tthis._offsetPrev = - 0;\n\tthis._weightNext = - 0;\n\tthis._offsetNext = - 0;\n\n}\n\nCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: ZeroCurvatureEnding,\n\t\tendingEnd: ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function ( i1, t0, t1 ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\tiPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tvar sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n/**\n * @author tschw\n */\n\nfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: LinearInterpolant,\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n *\n * @author tschw\n */\n\nfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: DiscreteInterpolant,\n\n\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\n/**\n *\n * A timed sequence of keyframes for a specific property.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\tthis.name = name;\n\n\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n}\n\n// Static methods\n\nObject.assign( KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\ttoJSON: function ( track ) {\n\n\t\tvar trackType = track.constructor;\n\n\t\tvar json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n} );\n\nObject.assign( KeyframeTrack.prototype, {\n\n\tconstructor: KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function ( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function ( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function ( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function ( interpolation ) {\n\n\t\tvar factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t},\n\n\tgetInterpolation: function () {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function () {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function ( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function ( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function ( startTime, endTime ) {\n\n\t\tvar times = this.times,\n\t\t\tnKeys = times.length,\n\t\t\tfrom = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) to = Math.max( to, 1 ), from = to - 1;\n\n\t\t\tvar stride = this.getValueSize();\n\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function () {\n\n\t\tvar valid = true;\n\n\t\tvar valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar prevTime = null;\n\n\t\tfor ( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tvar currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function () {\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\twriteIndex = 1,\n\t\t\tlastIndex = times.length - 1;\n\n\t\tfor ( var i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tvar keep = false;\n\n\t\t\tvar time = times[ i ];\n\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar times = AnimationUtils.arraySlice( this.times, 0 );\n\t\tvar values = AnimationUtils.arraySlice( this.values, 0 );\n\n\t\tvar TypedKeyframeTrack = this.constructor;\n\t\tvar track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n} );\n\n/**\n *\n * A Track of Boolean keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction BooleanKeyframeTrack( name, times, values ) {\n\n\tKeyframeTrack.call( this, name, times, values );\n\n}\n\nBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: BooleanKeyframeTrack,\n\n\tValueTypeName: 'bool',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\tInterpolantFactoryMethodSmooth: undefined\n\n\t// Note: Actually this track could have a optimized / compressed\n\t// representation of a single value and a custom interpolant that\n\t// computes \"firstValue ^ isOdd( index )\".\n\n} );\n\n/**\n *\n * A Track of keyframe values that represent color.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction ColorKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: ColorKeyframeTrack,\n\n\tValueTypeName: 'color'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n\t// Note: Very basic implementation and nothing special yet.\n\t// However, this is the place for color space parameterization.\n\n} );\n\n/**\n *\n * A Track of numeric keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction NumberKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: NumberKeyframeTrack,\n\n\tValueTypeName: 'number'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n/**\n * Spherical linear unit quaternion interpolant.\n *\n * @author tschw\n */\n\nfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n}\n\nQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n\tconstructor: QuaternionLinearInterpolant,\n\n\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset = i1 * stride,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n/**\n *\n * A Track of quaternion keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: QuaternionKeyframeTrack,\n\n\tValueTypeName: 'quaternion',\n\n\t// ValueBufferType is inherited\n\n\tDefaultInterpolation: InterpolateLinear,\n\n\tInterpolantFactoryMethodLinear: function ( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n} );\n\n/**\n *\n * A Track that interpolates Strings\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction StringKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: StringKeyframeTrack,\n\n\tValueTypeName: 'string',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\n\tInterpolantFactoryMethodSmooth: undefined\n\n} );\n\n/**\n *\n * A Track of vectored keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction VectorKeyframeTrack( name, times, values, interpolation ) {\n\n\tKeyframeTrack.call( this, name, times, values, interpolation );\n\n}\n\nVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\n\n\tconstructor: VectorKeyframeTrack,\n\n\tValueTypeName: 'vector'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nfunction AnimationClip( name, duration, tracks ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : - 1;\n\n\tthis.uuid = _Math.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tvar trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tvar times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nObject.assign( AnimationClip, {\n\n\tparse: function ( json ) {\n\n\t\tvar tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( json.name, json.duration, tracks );\n\n\t},\n\n\ttoJSON: function ( clip ) {\n\n\t\tvar tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tvar json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid\n\n\t\t};\n\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tvar order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( name, - 1, tracks );\n\n\t},\n\n\tfindByName: function ( objectOrClipArray, name ) {\n\n\t\tvar clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tvar o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\n\n\t\tvar animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar clips = [];\n\n\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function ( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar tracks = [];\n\n\t\tvar clipName = animation.name || 'default';\n\t\t// automatic length determination in AnimationClip.\n\t\tvar duration = animation.length || - 1;\n\t\tvar fps = animation.fps || 30;\n\n\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tvar morphTargetNames = {};\n\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tvar animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar clip = new AnimationClip( clipName, duration, tracks );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\nObject.assign( AnimationClip.prototype, {\n\n\tresetDuration: function () {\n\n\t\tvar tracks = this.tracks, duration = 0;\n\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tvar track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t},\n\n\ttrim: function () {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tvalidate: function () {\n\n\t\tvar valid = true;\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\toptimize: function () {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\n\tclone: function () {\n\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new AnimationClip( this.name, this.duration, tracks );\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false;\n\tvar itemsLoaded = 0;\n\tvar itemsTotal = 0;\n\tvar urlModifier = undefined;\n\n\t// Refer to #5689 for the reason why we don't set .onStart\n\t// in the constructor\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n\tthis.resolveURL = function ( url ) {\n\n\t\tif ( urlModifier ) {\n\n\t\t\treturn urlModifier( url );\n\n\t\t}\n\n\t\treturn url;\n\n\t};\n\n\tthis.setURLModifier = function ( transform ) {\n\n\t\turlModifier = transform;\n\t\treturn this;\n\n\t};\n\n}\n\nvar DefaultLoadingManager = new LoadingManager();\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar loading = {};\n\nfunction FileLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( FileLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tvar scope = this;\n\n\t\tvar cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Check for data: URI\n\t\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\tvar dataUriRegexResult = url.match( dataUriRegex );\n\n\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\tif ( dataUriRegexResult ) {\n\n\t\t\tvar mimeType = dataUriRegexResult[ 1 ];\n\t\t\tvar isBase64 = !! dataUriRegexResult[ 2 ];\n\t\t\tvar data = dataUriRegexResult[ 3 ];\n\n\t\t\tdata = decodeURIComponent( data );\n\n\t\t\tif ( isBase64 ) data = atob( data );\n\n\t\t\ttry {\n\n\t\t\t\tvar response;\n\t\t\t\tvar responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\tvar view = new Uint8Array( data.length );\n\n\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tresponse = view.buffer;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\tvar parser = new DOMParser();\n\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Initialise array for duplicate requests\n\n\t\t\tloading[ url ] = [];\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\trequest.open( 'GET', url, true );\n\n\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\tvar response = this.response;\n\n\t\t\t\tCache.add( url, response );\n\n\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tif ( this.status === 200 || this.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( response );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'abort', function ( event ) {\n\n\t\t\t\tvar callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\n\n\t\t\tfor ( var header in this.requestHeader ) {\n\n\t\t\t\trequest.setRequestHeader( header, this.requestHeader[ header ] );\n\n\t\t\t}\n\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetWithCredentials: function ( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t},\n\n\tsetMimeType: function ( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t},\n\n\tsetRequestHeader: function ( value ) {\n\n\t\tthis.requestHeader = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io/\n */\n\nfunction AnimationLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( AnimationLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json, onLoad ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\tonLoad( animations );\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n */\n\nfunction CompressedTextureLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n}\n\nObject.assign( CompressedTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar images = [];\n\n\t\tvar texture = new CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n */\n\nfunction DataTextureLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n}\n\nObject.assign( DataTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new DataTexture();\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction ImageLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( ImageLoader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tvar scope = this;\n\n\t\tvar cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.substr( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction CubeTextureLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( CubeTextureLoader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new CubeTexture();\n\n\t\tvar loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tvar loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction TextureLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( TextureLoader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new Texture();\n\n\t\tvar loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\tvar isJPEG = url.search( /\\.jpe?g($|\\?)/i ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nfunction Curve() {\n\n\tthis.type = 'Curve';\n\n\tthis.arcLengthDivisions = 200;\n\n}\n\nObject.assign( Curve.prototype, {\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u, optionalTarget ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\tvar points = [];\n\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\tvar points = [];\n\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tvar lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tvar cache = [];\n\t\tvar current, last = this.getPoint( 0 );\n\t\tvar p, sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tvar arcLengths = this.getLengths();\n\n\t\tvar i = 0, il = arcLengths.length;\n\n\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tvar low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tvar lengthBefore = arcLengths[ i ];\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function ( t ) {\n\n\t\tvar delta = 0.0001;\n\t\tvar t1 = t - delta;\n\t\tvar t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tvar pt1 = this.getPoint( t1 );\n\t\tvar pt2 = this.getPoint( t2 );\n\n\t\tvar vec = pt2.clone().sub( pt1 );\n\t\treturn vec.normalize();\n\n\t},\n\n\tgetTangentAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t );\n\n\t},\n\n\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tvar normal = new Vector3();\n\n\t\tvar tangents = [];\n\t\tvar normals = [];\n\t\tvar binormals = [];\n\n\t\tvar vec = new Vector3();\n\t\tvar mat = new Matrix4();\n\n\t\tvar i, u, theta;\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\t\tu = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u );\n\t\t\ttangents[ i ].normalize();\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tvar min = Number.MAX_VALUE;\n\t\tvar tx = Math.abs( tangents[ 0 ].x );\n\t\tvar ty = Math.abs( tangents[ 0 ].y );\n\t\tvar tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n} );\n\nfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'EllipseCurve';\n\n\tthis.aX = aX || 0;\n\tthis.aY = aY || 0;\n\n\tthis.xRadius = xRadius || 1;\n\tthis.yRadius = yRadius || 1;\n\n\tthis.aStartAngle = aStartAngle || 0;\n\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\n\n\tthis.aClockwise = aClockwise || false;\n\n\tthis.aRotation = aRotation || 0;\n\n}\n\nEllipseCurve.prototype = Object.create( Curve.prototype );\nEllipseCurve.prototype.constructor = EllipseCurve;\n\nEllipseCurve.prototype.isEllipseCurve = true;\n\nEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tvar twoPi = Math.PI * 2;\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t// ensures that deltaAngle is 0 .. 2 PI\n\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\tif ( samePoints ) {\n\n\t\t\tdeltaAngle = 0;\n\n\t\t} else {\n\n\t\t\tdeltaAngle = twoPi;\n\n\t\t}\n\n\t}\n\n\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\tdeltaAngle = - twoPi;\n\n\t\t} else {\n\n\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t}\n\n\t}\n\n\tvar angle = this.aStartAngle + t * deltaAngle;\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\tif ( this.aRotation !== 0 ) {\n\n\t\tvar cos = Math.cos( this.aRotation );\n\t\tvar sin = Math.sin( this.aRotation );\n\n\t\tvar tx = x - this.aX;\n\t\tvar ty = y - this.aY;\n\n\t\t// Rotate the point about the center of the ellipse.\n\t\tx = tx * cos - ty * sin + this.aX;\n\t\ty = tx * sin + ty * cos + this.aY;\n\n\t}\n\n\treturn point.set( x, y );\n\n};\n\nEllipseCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.aX = source.aX;\n\tthis.aY = source.aY;\n\n\tthis.xRadius = source.xRadius;\n\tthis.yRadius = source.yRadius;\n\n\tthis.aStartAngle = source.aStartAngle;\n\tthis.aEndAngle = source.aEndAngle;\n\n\tthis.aClockwise = source.aClockwise;\n\n\tthis.aRotation = source.aRotation;\n\n\treturn this;\n\n};\n\n\nEllipseCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.aX = this.aX;\n\tdata.aY = this.aY;\n\n\tdata.xRadius = this.xRadius;\n\tdata.yRadius = this.yRadius;\n\n\tdata.aStartAngle = this.aStartAngle;\n\tdata.aEndAngle = this.aEndAngle;\n\n\tdata.aClockwise = this.aClockwise;\n\n\tdata.aRotation = this.aRotation;\n\n\treturn data;\n\n};\n\nEllipseCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.aX = json.aX;\n\tthis.aY = json.aY;\n\n\tthis.xRadius = json.xRadius;\n\tthis.yRadius = json.yRadius;\n\n\tthis.aStartAngle = json.aStartAngle;\n\tthis.aEndAngle = json.aEndAngle;\n\n\tthis.aClockwise = json.aClockwise;\n\n\tthis.aRotation = json.aRotation;\n\n\treturn this;\n\n};\n\nfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\tthis.type = 'ArcCurve';\n\n}\n\nArcCurve.prototype = Object.create( EllipseCurve.prototype );\nArcCurve.prototype.constructor = ArcCurve;\n\nArcCurve.prototype.isArcCurve = true;\n\n/**\n * @author zz85 https://github.com/zz85\n *\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nvar tmp = new Vector3();\nvar px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\n\nfunction CatmullRomCurve3( points, closed, curveType, tension ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'CatmullRomCurve3';\n\n\tthis.points = points || [];\n\tthis.closed = closed || false;\n\tthis.curveType = curveType || 'centripetal';\n\tthis.tension = tension || 0.5;\n\n}\n\nCatmullRomCurve3.prototype = Object.create( Curve.prototype );\nCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\n\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\nCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector3();\n\n\tvar points = this.points;\n\tvar l = points.length;\n\n\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\tvar intPoint = Math.floor( p );\n\tvar weight = p - intPoint;\n\n\tif ( this.closed ) {\n\n\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\tintPoint = l - 2;\n\t\tweight = 1;\n\n\t}\n\n\tvar p0, p1, p2, p3; // 4 points\n\n\tif ( this.closed || intPoint > 0 ) {\n\n\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t} else {\n\n\t\t// extrapolate first point\n\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\tp0 = tmp;\n\n\t}\n\n\tp1 = points[ intPoint % l ];\n\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t} else {\n\n\t\t// extrapolate last point\n\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\tp3 = tmp;\n\n\t}\n\n\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t// init Centripetal / Chordal Catmull-Rom\n\t\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t// safety check for repeated points\n\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t}\n\n\tpoint.set(\n\t\tpx.calc( weight ),\n\t\tpy.calc( weight ),\n\t\tpz.calc( weight )\n\t);\n\n\treturn point;\n\n};\n\nCatmullRomCurve3.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.points = [];\n\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\tvar point = source.points[ i ];\n\n\t\tthis.points.push( point.clone() );\n\n\t}\n\n\tthis.closed = source.closed;\n\tthis.curveType = source.curveType;\n\tthis.tension = source.tension;\n\n\treturn this;\n\n};\n\nCatmullRomCurve3.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.points = [];\n\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\tvar point = this.points[ i ];\n\t\tdata.points.push( point.toArray() );\n\n\t}\n\n\tdata.closed = this.closed;\n\tdata.curveType = this.curveType;\n\tdata.tension = this.tension;\n\n\treturn data;\n\n};\n\nCatmullRomCurve3.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.points = [];\n\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\tvar point = json.points[ i ];\n\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t}\n\n\tthis.closed = json.closed;\n\tthis.curveType = json.curveType;\n\tthis.tension = json.tension;\n\n\treturn this;\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Bezier Curves formulas obtained from\n * http://en.wikipedia.org/wiki/Bzier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tvar v0 = ( p2 - p0 ) * 0.5;\n\tvar v1 = ( p3 - p1 ) * 0.5;\n\tvar t2 = t * t;\n\tvar t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tvar k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tvar k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tvar k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nfunction CubicBezierCurve( v0, v1, v2, v3 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'CubicBezierCurve';\n\n\tthis.v0 = v0 || new Vector2();\n\tthis.v1 = v1 || new Vector2();\n\tthis.v2 = v2 || new Vector2();\n\tthis.v3 = v3 || new Vector2();\n\n}\n\nCubicBezierCurve.prototype = Object.create( Curve.prototype );\nCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\nCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\tpoint.set(\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t);\n\n\treturn point;\n\n};\n\nCubicBezierCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v0.copy( source.v0 );\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\tthis.v3.copy( source.v3 );\n\n\treturn this;\n\n};\n\nCubicBezierCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v0 = this.v0.toArray();\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\tdata.v3 = this.v3.toArray();\n\n\treturn data;\n\n};\n\nCubicBezierCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v0.fromArray( json.v0 );\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\tthis.v3.fromArray( json.v3 );\n\n\treturn this;\n\n};\n\nfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'CubicBezierCurve3';\n\n\tthis.v0 = v0 || new Vector3();\n\tthis.v1 = v1 || new Vector3();\n\tthis.v2 = v2 || new Vector3();\n\tthis.v3 = v3 || new Vector3();\n\n}\n\nCubicBezierCurve3.prototype = Object.create( Curve.prototype );\nCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\n\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\nCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector3();\n\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\tpoint.set(\n\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t);\n\n\treturn point;\n\n};\n\nCubicBezierCurve3.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v0.copy( source.v0 );\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\tthis.v3.copy( source.v3 );\n\n\treturn this;\n\n};\n\nCubicBezierCurve3.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v0 = this.v0.toArray();\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\tdata.v3 = this.v3.toArray();\n\n\treturn data;\n\n};\n\nCubicBezierCurve3.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v0.fromArray( json.v0 );\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\tthis.v3.fromArray( json.v3 );\n\n\treturn this;\n\n};\n\nfunction LineCurve( v1, v2 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'LineCurve';\n\n\tthis.v1 = v1 || new Vector2();\n\tthis.v2 = v2 || new Vector2();\n\n}\n\nLineCurve.prototype = Object.create( Curve.prototype );\nLineCurve.prototype.constructor = LineCurve;\n\nLineCurve.prototype.isLineCurve = true;\n\nLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tif ( t === 1 ) {\n\n\t\tpoint.copy( this.v2 );\n\n\t} else {\n\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t}\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\n\n\treturn this.getPoint( u, optionalTarget );\n\n};\n\nLineCurve.prototype.getTangent = function ( /* t */ ) {\n\n\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\treturn tangent.normalize();\n\n};\n\nLineCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\n\treturn this;\n\n};\n\nLineCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\n\treturn data;\n\n};\n\nLineCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\n\treturn this;\n\n};\n\nfunction LineCurve3( v1, v2 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'LineCurve3';\n\n\tthis.v1 = v1 || new Vector3();\n\tthis.v2 = v2 || new Vector3();\n\n}\n\nLineCurve3.prototype = Object.create( Curve.prototype );\nLineCurve3.prototype.constructor = LineCurve3;\n\nLineCurve3.prototype.isLineCurve3 = true;\n\nLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector3();\n\n\tif ( t === 1 ) {\n\n\t\tpoint.copy( this.v2 );\n\n\t} else {\n\n\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t}\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\n\n\treturn this.getPoint( u, optionalTarget );\n\n};\n\nLineCurve3.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\n\treturn this;\n\n};\n\nLineCurve3.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\n\treturn data;\n\n};\n\nLineCurve3.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\n\treturn this;\n\n};\n\nfunction QuadraticBezierCurve( v0, v1, v2 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'QuadraticBezierCurve';\n\n\tthis.v0 = v0 || new Vector2();\n\tthis.v1 = v1 || new Vector2();\n\tthis.v2 = v2 || new Vector2();\n\n}\n\nQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\nQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\nQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\tpoint.set(\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t);\n\n\treturn point;\n\n};\n\nQuadraticBezierCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v0.copy( source.v0 );\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\n\treturn this;\n\n};\n\nQuadraticBezierCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v0 = this.v0.toArray();\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\n\treturn data;\n\n};\n\nQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v0.fromArray( json.v0 );\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\n\treturn this;\n\n};\n\nfunction QuadraticBezierCurve3( v0, v1, v2 ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'QuadraticBezierCurve3';\n\n\tthis.v0 = v0 || new Vector3();\n\tthis.v1 = v1 || new Vector3();\n\tthis.v2 = v2 || new Vector3();\n\n}\n\nQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\nQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\n\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\nQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector3();\n\n\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\tpoint.set(\n\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t);\n\n\treturn point;\n\n};\n\nQuadraticBezierCurve3.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.v0.copy( source.v0 );\n\tthis.v1.copy( source.v1 );\n\tthis.v2.copy( source.v2 );\n\n\treturn this;\n\n};\n\nQuadraticBezierCurve3.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.v0 = this.v0.toArray();\n\tdata.v1 = this.v1.toArray();\n\tdata.v2 = this.v2.toArray();\n\n\treturn data;\n\n};\n\nQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.v0.fromArray( json.v0 );\n\tthis.v1.fromArray( json.v1 );\n\tthis.v2.fromArray( json.v2 );\n\n\treturn this;\n\n};\n\nfunction SplineCurve( points /* array of Vector2 */ ) {\n\n\tCurve.call( this );\n\n\tthis.type = 'SplineCurve';\n\n\tthis.points = points || [];\n\n}\n\nSplineCurve.prototype = Object.create( Curve.prototype );\nSplineCurve.prototype.constructor = SplineCurve;\n\nSplineCurve.prototype.isSplineCurve = true;\n\nSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new Vector2();\n\n\tvar points = this.points;\n\tvar p = ( points.length - 1 ) * t;\n\n\tvar intPoint = Math.floor( p );\n\tvar weight = p - intPoint;\n\n\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\tvar p1 = points[ intPoint ];\n\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\tpoint.set(\n\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t);\n\n\treturn point;\n\n};\n\nSplineCurve.prototype.copy = function ( source ) {\n\n\tCurve.prototype.copy.call( this, source );\n\n\tthis.points = [];\n\n\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\tvar point = source.points[ i ];\n\n\t\tthis.points.push( point.clone() );\n\n\t}\n\n\treturn this;\n\n};\n\nSplineCurve.prototype.toJSON = function () {\n\n\tvar data = Curve.prototype.toJSON.call( this );\n\n\tdata.points = [];\n\n\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\tvar point = this.points[ i ];\n\t\tdata.points.push( point.toArray() );\n\n\t}\n\n\treturn data;\n\n};\n\nSplineCurve.prototype.fromJSON = function ( json ) {\n\n\tCurve.prototype.fromJSON.call( this, json );\n\n\tthis.points = [];\n\n\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\tvar point = json.points[ i ];\n\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t}\n\n\treturn this;\n\n};\n\n\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nfunction CurvePath() {\n\n\tCurve.call( this );\n\n\tthis.type = 'CurvePath';\n\n\tthis.curves = [];\n\tthis.autoClose = false; // Automatically closes the path\n\n}\n\nCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\tconstructor: CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tvar d = t * this.getLength();\n\t\tvar curveLengths = this.getCurveLengths();\n\t\tvar i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tvar lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tvar lengths = [], sums = 0;\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 40;\n\n\t\tvar points = [];\n\n\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tvar points = [], last;\n\n\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tvar curve = curves[ i ];\n\t\t\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\n\t\t\t\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\n\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\tfor ( var j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tvar curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tvar curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tvar curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n **/\n\nfunction Path( points ) {\n\n\tCurvePath.call( this );\n\n\tthis.type = 'Path';\n\n\tthis.currentPoint = new Vector2();\n\n\tif ( points ) {\n\n\t\tthis.setFromPoints( points );\n\n\t}\n\n}\n\nPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n\tconstructor: Path,\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t},\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tvar curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tvar curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t},\n\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tvar curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t},\n\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tvar x0 = this.currentPoint.x;\n\t\tvar y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar x0 = this.currentPoint.x;\n\t\tvar y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t},\n\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tCurvePath.prototype.copy.call( this, source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = CurvePath.prototype.toJSON.call( this );\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tCurvePath.prototype.fromJSON.call( this, json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nfunction Shape( points ) {\n\n\tPath.call( this, points );\n\n\tthis.uuid = _Math.generateUUID();\n\n\tthis.type = 'Shape';\n\n\tthis.holes = [];\n\n}\n\nShape.prototype = Object.assign( Object.create( Path.prototype ), {\n\n\tconstructor: Shape,\n\n\tgetPointsHoles: function ( divisions ) {\n\n\t\tvar holesPts = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t},\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints: function ( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tPath.prototype.copy.call( this, source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tvar hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = Path.prototype.toJSON.call( this );\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tvar hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tPath.prototype.fromJSON.call( this, json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tvar hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Light( color, intensity ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Light';\n\n\tthis.color = new Color( color );\n\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\tthis.receiveShadow = undefined;\n\n}\n\nLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Light,\n\n\tisLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction HemisphereLight( skyColor, groundColor, intensity ) {\n\n\tLight.call( this, skyColor, intensity );\n\n\tthis.type = 'HemisphereLight';\n\n\tthis.castShadow = undefined;\n\n\tthis.position.copy( Object3D.DefaultUp );\n\tthis.updateMatrix();\n\n\tthis.groundColor = new Color( groundColor );\n\n}\n\nHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: HemisphereLight,\n\n\tisHemisphereLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LightShadow( camera ) {\n\n\tthis.camera = camera;\n\n\tthis.bias = 0;\n\tthis.radius = 1;\n\n\tthis.mapSize = new Vector2( 512, 512 );\n\n\tthis.map = null;\n\tthis.matrix = new Matrix4();\n\n}\n\nObject.assign( LightShadow.prototype, {\n\n\tcopy: function ( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar object = {};\n\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction SpotLightShadow() {\n\n\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n}\n\nSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\tconstructor: SpotLightShadow,\n\n\tisSpotLightShadow: true,\n\n\tupdate: function ( light ) {\n\n\t\tvar camera = this.camera;\n\n\t\tvar fov = _Math.RAD2DEG * 2 * light.angle;\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\tvar far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'SpotLight';\n\n\tthis.position.copy( Object3D.DefaultUp );\n\tthis.updateMatrix();\n\n\tthis.target = new Object3D();\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new SpotLightShadow();\n\n}\n\nSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: SpotLight,\n\n\tisSpotLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction PointLight( color, intensity, distance, decay ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'PointLight';\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n}\n\nPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: PointLight,\n\n\tisPointLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author arose / http://github.com/arose\n */\n\nfunction OrthographicCamera( left, right, top, bottom, near, far ) {\n\n\tCamera.call( this );\n\n\tthis.type = 'OrthographicCamera';\n\n\tthis.zoom = 1;\n\tthis.view = null;\n\n\tthis.left = ( left !== undefined ) ? left : - 1;\n\tthis.right = ( right !== undefined ) ? right : 1;\n\tthis.top = ( top !== undefined ) ? top : 1;\n\tthis.bottom = ( bottom !== undefined ) ? bottom : - 1;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n}\n\nOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n\tconstructor: OrthographicCamera,\n\n\tisOrthographicCamera: true,\n\n\tcopy: function ( source, recursive ) {\n\n\t\tCamera.prototype.copy.call( this, source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t},\n\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function () {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tvar cx = ( this.right + this.left ) / 2;\n\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\tvar left = cx - dx;\n\t\tvar right = cx + dx;\n\t\tvar top = cy + dy;\n\t\tvar bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t\tthis.projectionMatrixInverse.getInverse( this.projectionMatrix );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction DirectionalLightShadow( ) {\n\n\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n}\n\nDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n\tconstructor: DirectionalLightShadow\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction DirectionalLight( color, intensity ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'DirectionalLight';\n\n\tthis.position.copy( Object3D.DefaultUp );\n\tthis.updateMatrix();\n\n\tthis.target = new Object3D();\n\n\tthis.shadow = new DirectionalLightShadow();\n\n}\n\nDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: DirectionalLight,\n\n\tisDirectionalLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction AmbientLight( color, intensity ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'AmbientLight';\n\n\tthis.castShadow = undefined;\n\n}\n\nAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: AmbientLight,\n\n\tisAmbientLight: true\n\n} );\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\nfunction RectAreaLight( color, intensity, width, height ) {\n\n\tLight.call( this, color, intensity );\n\n\tthis.type = 'RectAreaLight';\n\n\tthis.width = ( width !== undefined ) ? width : 10;\n\tthis.height = ( height !== undefined ) ? height : 10;\n\n}\n\nRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n\tconstructor: RectAreaLight,\n\n\tisRectAreaLight: true,\n\n\tcopy: function ( source ) {\n\n\t\tLight.prototype.copy.call( this, source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = Light.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction MaterialLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\tthis.textures = {};\n\n}\n\nObject.assign( MaterialLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tvar material = new Materials[ json.type ]();\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\n\t\tif ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\n\t\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( var name in json.uniforms ) {\n\n\t\t\t\tvar uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( var key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Deprecated\n\n\t\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\n\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\tmaterial.alphaMap = getTexture( json.alphaMap );\n\t\t\tmaterial.transparent = true;\n\n\t\t}\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tvar normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\treturn material;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetTextures: function ( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nvar LoaderUtils = {\n\n\tdecodeText: function ( array ) {\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tvar s = '';\n\n\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\t// Merges multi-byte utf-8 characters.\n\t\treturn decodeURIComponent( escape( s ) );\n\n\t},\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.substr( 0, index + 1 );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction BufferGeometryLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( BufferGeometryLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tvar index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tvar attributes = json.data.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t}\n\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tvar center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\nvar TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\t// Workaround for IE11 pre KB2929437. See #11440\n\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction ObjectLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\tthis.resourcePath = '';\n\n}\n\nObject.assign( ObjectLoader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResourcePath: function ( value ) {\n\n\t\tthis.resourcePath = value;\n\t\treturn this;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tparse: function ( json, onLoad ) {\n\n\t\tvar shapes = this.parseShape( json.shapes );\n\t\tvar geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tvar textures = this.parseTextures( json.textures, images );\n\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\tif ( json.animations ) {\n\n\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t}\n\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t},\n\n\tparseShape: function ( json ) {\n\n\t\tvar shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t},\n\n\tparseGeometries: function ( json, shapes ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\tcase 'DodecahedronBufferGeometry':\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\tcase 'IcosahedronBufferGeometry':\n\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\tcase 'OctahedronBufferGeometry':\n\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\t\t\t\tcase 'TetrahedronBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PolyhedronGeometry':\n\t\t\t\t\tcase 'PolyhedronBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tdata.vertices,\n\t\t\t\t\t\t\tdata.indices,\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.details\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ShapeGeometry':\n\t\t\t\t\tcase 'ShapeBufferGeometry':\n\n\t\t\t\t\t\tvar geometryShapes = [];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar shape = shapes[ data.shapes[ j ] ];\n\n\t\t\t\t\t\t\tgeometryShapes.push( shape );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tgeometryShapes,\n\t\t\t\t\t\t\tdata.curveSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase 'ExtrudeGeometry':\n\t\t\t\t\tcase 'ExtrudeBufferGeometry':\n\n\t\t\t\t\t\tvar geometryShapes = [];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar shape = shapes[ data.shapes[ j ] ];\n\n\t\t\t\t\t\t\tgeometryShapes.push( shape );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar extrudePath = data.options.extrudePath;\n\n\t\t\t\t\t\tif ( extrudePath !== undefined ) {\n\n\t\t\t\t\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry = new Geometries[ data.type ](\n\t\t\t\t\t\t\tgeometryShapes,\n\t\t\t\t\t\t\tdata.options\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tif ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) {\n\n\t\t\t\t\t\t\tvar geometryLoader = new THREE.LegacyJSONLoader();\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data, this.resourcePath ).geometry;\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type \"Geometry\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json, textures ) {\n\n\t\tvar cache = {}; // MultiMaterial\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.type === 'MultiMaterial' ) {\n\n\t\t\t\t\t// Deprecated\n\n\t\t\t\t\tvar array = [];\n\n\t\t\t\t\tfor ( var j = 0; j < data.materials.length; j ++ ) {\n\n\t\t\t\t\t\tvar material = data.materials[ j ];\n\n\t\t\t\t\t\tif ( cache[ material.uuid ] === undefined ) {\n\n\t\t\t\t\t\t\tcache[ material.uuid ] = loader.parse( material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarray.push( cache[ material.uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterials[ data.uuid ] = array;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseAnimations: function ( json ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar data = json[ i ];\n\n\t\t\tvar clip = AnimationClip.parse( data );\n\n\t\t\tif ( data.uuid !== undefined ) clip.uuid = data.uuid;\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t},\n\n\tparseImages: function ( json, onLoad ) {\n\n\t\tvar scope = this;\n\t\tvar images = {};\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tvar manager = new LoadingManager( onLoad );\n\n\t\t\tvar loader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( var i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tvar image = json[ i ];\n\t\t\t\tvar url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\timages[ image.uuid ] = [];\n\n\t\t\t\t\tfor ( var j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar currentUrl = url[ j ];\n\n\t\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;\n\n\t\t\t\t\t\timages[ image.uuid ].push( loadImage( path ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;\n\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t},\n\n\tparseTextures: function ( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tvar textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( Array.isArray( images[ data.image ] ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture( images[ data.image ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = new Texture( images[ data.image ] );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.encoding !== undefined ) texture.encoding = data.encoding;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t},\n\n\tparseObject: function ( data, geometries, materials ) {\n\n\t\tvar object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tvar children = data.children;\n\n\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tvar levels = data.levels;\n\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tvar level = levels[ l ];\n\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n} );\n\nvar TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tSphericalReflectionMapping: SphericalReflectionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\tCubeUVRefractionMapping: CubeUVRefractionMapping\n};\n\nvar TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nvar TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\n\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\n\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\n};\n\n/**\n * @author thespite / http://clicktorelease.com/\n */\n\n\nfunction ImageBitmapLoader( manager ) {\n\n\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t}\n\n\tif ( typeof fetch === 'undefined' ) {\n\n\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t}\n\n\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\n\tthis.options = undefined;\n\n}\n\nImageBitmapLoader.prototype = {\n\n\tconstructor: ImageBitmapLoader,\n\n\tsetOptions: function setOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t},\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tvar scope = this;\n\n\t\tvar cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tfetch( url ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\treturn createImageBitmap( blob, scope.options );\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t},\n\n\tsetCrossOrigin: function ( /* value */ ) {\n\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n **/\n\nfunction ShapePath() {\n\n\tthis.type = 'ShapePath';\n\n\tthis.color = new Color();\n\n\tthis.subPaths = [];\n\tthis.currentPath = null;\n\n}\n\nObject.assign( ShapePath.prototype, {\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t},\n\n\tsplineThru: function ( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t},\n\n\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\tvar tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tvar inside = false;\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tvar edgeLowPt = inPolygon[ p ];\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tvar isClockWise = ShapeUtils.isClockWise;\n\n\t\tvar subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tvar betterShapeHoles = [];\n\t\tvar newShapes = [];\n\t\tvar newShapeHoles = [];\n\t\tvar mainIdx = 0;\n\t\tvar tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tvar ambiguous = false;\n\t\t\tvar toChange = [];\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmpHoles;\n\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nfunction Font( data ) {\n\n\tthis.type = 'Font';\n\n\tthis.data = data;\n\n}\n\nObject.assign( Font.prototype, {\n\n\tisFont: true,\n\n\tgenerateShapes: function ( text, size ) {\n\n\t\tif ( size === undefined ) size = 100;\n\n\t\tvar shapes = [];\n\t\tvar paths = createPaths( text, size, this.data );\n\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\nfunction createPaths( text, size, data ) {\n\n\tvar chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988\n\tvar scale = size / data.resolution;\n\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\n\tvar paths = [];\n\n\tvar offsetX = 0, offsetY = 0;\n\n\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\tvar char = chars[ i ];\n\n\t\tif ( char === '\\n' ) {\n\n\t\t\toffsetX = 0;\n\t\t\toffsetY -= line_height;\n\n\t\t} else {\n\n\t\t\tvar ret = createPath( char, scale, offsetX, offsetY, data );\n\t\t\toffsetX += ret.offsetX;\n\t\t\tpaths.push( ret.path );\n\n\t\t}\n\n\t}\n\n\treturn paths;\n\n}\n\nfunction createPath( char, scale, offsetX, offsetY, data ) {\n\n\tvar glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\n\n\tif ( ! glyph ) return;\n\n\tvar path = new ShapePath();\n\n\tvar x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\tif ( glyph.o ) {\n\n\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\tvar action = outline[ i ++ ];\n\n\t\t\tswitch ( action ) {\n\n\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { offsetX: glyph.ha * scale, path: path };\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction FontLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( FontLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tvar font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\treturn new Font( json );\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Loader() {}\n\nLoader.Handlers = {\n\n\thandlers: [],\n\n\tadd: function ( regex, loader ) {\n\n\t\tthis.handlers.push( regex, loader );\n\n\t},\n\n\tget: function ( file ) {\n\n\t\tvar handlers = this.handlers;\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader = handlers[ i + 1 ];\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n};\n\nObject.assign( Loader.prototype, {\n\n\tcrossOrigin: 'anonymous',\n\n\tonLoadStart: function () {},\n\n\tonLoadProgress: function () {},\n\n\tonLoadComplete: function () {},\n\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tcreateMaterial: ( function () {\n\n\t\tvar BlendingMode = {\n\t\t\tNoBlending: NoBlending,\n\t\t\tNormalBlending: NormalBlending,\n\t\t\tAdditiveBlending: AdditiveBlending,\n\t\t\tSubtractiveBlending: SubtractiveBlending,\n\t\t\tMultiplyBlending: MultiplyBlending,\n\t\t\tCustomBlending: CustomBlending\n\t\t};\n\n\t\tvar color = new Color();\n\t\tvar textureLoader = new TextureLoader();\n\t\tvar materialLoader = new MaterialLoader();\n\n\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\t// convert from old material format\n\n\t\t\tvar textures = {};\n\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\tvar loader = Loader.Handlers.get( fullPath );\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t}\n\n\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t}\n\n\t\t\t\tvar uuid = _Math.generateUUID();\n\n\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\treturn uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar json = {\n\t\t\t\tuuid: _Math.generateUUID(),\n\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t};\n\n\t\t\tfor ( var name in m ) {\n\n\t\t\t\tvar value = m[ name ];\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\tjson.blending = BlendingMode[ value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\tjson.normalScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\tjson.side = BackSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\tjson.side = DoubleSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\tcase 'opacity':\n\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\tcase 'visible':\n\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = VertexColors;\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = FaceColors;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\treturn materialLoader.parse( json );\n\n\t\t};\n\n\t} )()\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar context;\n\nvar AudioContext = {\n\n\tgetContext: function () {\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn context;\n\n\t},\n\n\tsetContext: function ( value ) {\n\n\t\tcontext = value;\n\n\t}\n\n};\n\n/**\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nfunction AudioLoader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n}\n\nObject.assign( AudioLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\tvar bufferCopy = buffer.slice( 0 );\n\n\t\t\tvar context = AudioContext.getContext();\n\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t} );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction StereoCamera() {\n\n\tthis.type = 'StereoCamera';\n\n\tthis.aspect = 1;\n\n\tthis.eyeSep = 0.064;\n\n\tthis.cameraL = new PerspectiveCamera();\n\tthis.cameraL.layers.enable( 1 );\n\tthis.cameraL.matrixAutoUpdate = false;\n\n\tthis.cameraR = new PerspectiveCamera();\n\tthis.cameraR.layers.enable( 2 );\n\tthis.cameraR.matrixAutoUpdate = false;\n\n}\n\nObject.assign( StereoCamera.prototype, {\n\n\tupdate: ( function () {\n\n\t\tvar instance, focus, fov, aspect, near, far, zoom, eyeSep;\n\n\t\tvar eyeRight = new Matrix4();\n\t\tvar eyeLeft = new Matrix4();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\tinstance = this;\n\t\t\t\tfocus = camera.focus;\n\t\t\t\tfov = camera.fov;\n\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\tnear = camera.near;\n\t\t\t\tfar = camera.far;\n\t\t\t\tzoom = camera.zoom;\n\n\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\teyeSep = this.eyeSep / 2;\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t// translate xOffset\n\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t// for left eye\n\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t// for right eye\n\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t};\n\n\t} )()\n\n} );\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction CubeCamera( near, far, cubeResolution, options ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'CubeCamera';\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, - 1, 0 );\n\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, - 1, 0 );\n\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, - 1 );\n\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, - 1, 0 );\n\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, - 1, 0 );\n\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n\tthis.add( cameraNZ );\n\n\toptions = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\n\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\tthis.renderTarget.texture.name = \"CubeCamera\";\n\n\tthis.update = function ( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n\tthis.clear = function ( renderer, color, depth, stencil ) {\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar renderTarget = this.renderTarget;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\trenderTarget.activeCubeFace = i;\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n}\n\nCubeCamera.prototype = Object.create( Object3D.prototype );\nCubeCamera.prototype.constructor = CubeCamera;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Clock( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n}\n\nObject.assign( Clock.prototype, {\n\n\tstart: function () {\n\n\t\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction AudioListener() {\n\n\tObject3D.call( this );\n\n\tthis.type = 'AudioListener';\n\n\tthis.context = AudioContext.getContext();\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( this.context.destination );\n\n\tthis.filter = null;\n\n\tthis.timeDelta = 0;\n\n}\n\nAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: AudioListener,\n\n\tgetInput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tremoveFilter: function ( ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.filter;\n\n\t},\n\n\tsetFilter: function ( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t},\n\n\tgetMasterVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetMasterVolume: function ( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new Vector3();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3();\n\n\t\tvar orientation = new Vector3();\n\t\tvar clock = new Clock();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tvar listener = this.context.listener;\n\t\t\tvar up = this.up;\n\n\t\t\tthis.timeDelta = clock.getDelta();\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\tif ( listener.positionX ) {\n\n\t\t\t\t// code path for Chrome (see #14393)\n\n\t\t\t\tvar endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\t\tlistener.positionX.linearRampToValueAtTime( position.x, endTime );\n\t\t\t\tlistener.positionY.linearRampToValueAtTime( position.y, endTime );\n\t\t\t\tlistener.positionZ.linearRampToValueAtTime( position.z, endTime );\n\t\t\t\tlistener.forwardX.linearRampToValueAtTime( orientation.x, endTime );\n\t\t\t\tlistener.forwardY.linearRampToValueAtTime( orientation.y, endTime );\n\t\t\t\tlistener.forwardZ.linearRampToValueAtTime( orientation.z, endTime );\n\t\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t\t} else {\n\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t\t}\n\n\t\t};\n\n\t} )()\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nfunction Audio( listener ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Audio';\n\n\tthis.listener = listener;\n\tthis.context = listener.context;\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( listener.getInput() );\n\n\tthis.autoplay = false;\n\n\tthis.buffer = null;\n\tthis.detune = 0;\n\tthis.loop = false;\n\tthis.startTime = 0;\n\tthis.offset = 0;\n\tthis.playbackRate = 1;\n\tthis.isPlaying = false;\n\tthis.hasPlaybackControl = true;\n\tthis.sourceType = 'empty';\n\n\tthis.filters = [];\n\n}\n\nAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Audio,\n\n\tgetOutput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tsetNodeSource: function ( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetMediaElementSource: function ( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetBuffer: function ( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t},\n\n\tplay: function () {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar source = this.context.createBufferSource();\n\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tthis.startTime = this.context.currentTime;\n\t\tsource.start( this.startTime, this.offset );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t},\n\n\tpause: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\t\t\tthis.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.source.onended = null;\n\t\tthis.offset = 0;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdisconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilters: function () {\n\n\t\treturn this.filters;\n\n\t},\n\n\tsetFilters: function ( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value;\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetDetune: function ( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.source.detune === undefined ) return; // only set detune when available\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetDetune: function () {\n\n\t\treturn this.detune;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t},\n\n\tsetFilter: function ( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t},\n\n\tsetPlaybackRate: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetPlaybackRate: function () {\n\n\t\treturn this.playbackRate;\n\n\t},\n\n\tonEnded: function () {\n\n\t\tthis.isPlaying = false;\n\n\t},\n\n\tgetLoop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t},\n\n\tsetLoop: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetVolume: function ( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction PositionalAudio( listener ) {\n\n\tAudio.call( this, listener );\n\n\tthis.panner = this.context.createPanner();\n\tthis.panner.connect( this.gain );\n\n}\n\nPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\n\tconstructor: PositionalAudio,\n\n\tgetOutput: function () {\n\n\t\treturn this.panner;\n\n\t},\n\n\tgetRefDistance: function () {\n\n\t\treturn this.panner.refDistance;\n\n\t},\n\n\tsetRefDistance: function ( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t},\n\n\tgetRolloffFactor: function () {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t},\n\n\tsetRolloffFactor: function ( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t},\n\n\tgetDistanceModel: function () {\n\n\t\treturn this.panner.distanceModel;\n\n\t},\n\n\tsetDistanceModel: function ( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxDistance: function () {\n\n\t\treturn this.panner.maxDistance;\n\n\t},\n\n\tsetMaxDistance: function ( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t},\n\n\tsetDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new Vector3();\n\t\tvar quaternion = new Quaternion();\n\t\tvar scale = new Vector3();\n\n\t\tvar orientation = new Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tif ( this.isPlaying === false ) return;\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t\tvar panner = this.panner;\n\n\t\t\tif ( panner.positionX ) {\n\n\t\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\t\tvar endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\t\tpanner.positionX.linearRampToValueAtTime( position.x, endTime );\n\t\t\t\tpanner.positionY.linearRampToValueAtTime( position.y, endTime );\n\t\t\t\tpanner.positionZ.linearRampToValueAtTime( position.z, endTime );\n\t\t\t\tpanner.orientationX.linearRampToValueAtTime( orientation.x, endTime );\n\t\t\t\tpanner.orientationY.linearRampToValueAtTime( orientation.y, endTime );\n\t\t\t\tpanner.orientationZ.linearRampToValueAtTime( orientation.z, endTime );\n\n\t\t\t} else {\n\n\t\t\t\tpanner.setPosition( position.x, position.y, position.z );\n\t\t\t\tpanner.setOrientation( orientation.x, orientation.y, orientation.z );\n\n\t\t\t}\n\n\t\t};\n\n\t} )()\n\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction AudioAnalyser( audio, fftSize ) {\n\n\tthis.analyser = audio.context.createAnalyser();\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\taudio.getOutput().connect( this.analyser );\n\n}\n\nObject.assign( AudioAnalyser.prototype, {\n\n\tgetFrequencyData: function () {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t},\n\n\tgetAverageFrequency: function () {\n\n\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n} );\n\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tvar bufferType = Float64Array,\n\t\tmixFunction;\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\n\t\t\tmixFunction = this._slerp;\n\t\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\t\t\tbufferType = Array;\n\t\t\tmixFunction = this._select;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmixFunction = this._lerp;\n\n\t}\n\n\tthis.buffer = new bufferType( valueSize * 4 );\n\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\n\tthis._mixBufferRegion = mixFunction;\n\n\tthis.cumulativeWeight = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n}\n\nObject.assign( PropertyMixer.prototype, {\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function ( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tvar mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function ( accuIndex ) {\n\n\t\tvar stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function () {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function () {\n\n\t\tvar originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tvar s = 1 - t;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tvar j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n *\n * A reference to a real property in the scene graph.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\n// Characters [].:/ are reserved for track binding syntax.\nvar RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\nfunction Composite( targetGroup, path, optionalParsedPath ) {\n\n\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n}\n\nObject.assign( Composite.prototype, {\n\n\tgetValue: function ( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function ( array, offset ) {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function () {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function () {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n} );\n\n\nfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n}\n\nObject.assign( PropertyBinding, {\n\n\tComposite: Composite,\n\n\tcreate: function ( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param  {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tsanitizeNodeName: ( function () {\n\n\t\tvar reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );\n\n\t\treturn function sanitizeNodeName( name ) {\n\n\t\t\treturn name.replace( /\\s/g, '_' ).replace( reservedRe, '' );\n\n\t\t};\n\n\t}() ),\n\n\tparseTrackName: function () {\n\n\t\t// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n\t\t// only latin characters, and the unicode \\p{L} is not yet supported. So\n\t\t// instead, we exclude reserved characters and match everything else.\n\t\tvar wordChar = '[^' + RESERVED_CHARS_RE + ']';\n\t\tvar wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n\t\t// Parent directories, delimited by '/' or ':'. Currently unused, but must\n\t\t// be matched to parse the rest of the track name.\n\t\tvar directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', wordChar );\n\n\t\t// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\t\tvar nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );\n\n\t\t// Object on target node, and accessor. May not contain reserved\n\t\t// characters. Accessor may contain any character except closing bracket.\n\t\tvar objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', wordChar );\n\n\t\t// Property and accessor. May not contain reserved characters. Accessor may\n\t\t// contain any non-bracket characters.\n\t\tvar propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', wordChar );\n\n\t\tvar trackRe = new RegExp( ''\n\t\t\t+ '^'\n\t\t\t+ directoryRe\n\t\t\t+ nodeRe\n\t\t\t+ objectRe\n\t\t\t+ propertyRe\n\t\t\t+ '$'\n\t\t);\n\n\t\tvar supportedObjectNames = [ 'material', 'materials', 'bones' ];\n\n\t\treturn function parseTrackName( trackName ) {\n\n\t\t\tvar matches = trackRe.exec( trackName );\n\n\t\t\tif ( ! matches ) {\n\n\t\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t\t}\n\n\t\t\tvar results = {\n\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\tnodeName: matches[ 2 ],\n\t\t\t\tobjectName: matches[ 3 ],\n\t\t\t\tobjectIndex: matches[ 4 ],\n\t\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\t\tpropertyIndex: matches[ 6 ]\n\t\t\t};\n\n\t\t\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\t\tvar objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t\t// Object names must be checked against a whitelist. Otherwise, there\n\t\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t\t// include '.' characters).\n\t\t\t\tif ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\t\tresults.objectName = objectName;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t\t}\n\n\t\t\treturn results;\n\n\t\t};\n\n\t}(),\n\n\tfindNode: function ( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tvar bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tvar searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n} );\n\nObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function () {},\n\t_setValue_unavailable: function () {},\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tvar source = this.resolvedProperty;\n\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t],\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function () {\n\n\t\tvar targetObject = this.node,\n\t\t\tparsedPath = this.parsedPath,\n\n\t\t\tobjectName = parsedPath.objectName,\n\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tvar versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tvar bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function () {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n} );\n\n//!\\ DECLARE ALIAS AFTER assign prototype !\nObject.assign( PropertyBinding.prototype, {\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n} );\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n *\n * @author tschw\n */\n\nfunction AnimationObjectGroup() {\n\n\tthis.uuid = _Math.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0; // threshold\n\t// note: read by PropertyBinding.Composite\n\n\tvar indices = {};\n\tthis._indicesByUUID = indices; // for bookkeeping\n\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = []; // inside: string\n\tthis._parsedPaths = []; // inside: { we don't care, here }\n\tthis._bindings = []; // inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\tvar scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() {\n\n\t\t\t\treturn scope._objects.length;\n\n\t\t\t},\n\t\t\tget inUse() {\n\n\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t}\n\t\t},\n\t\tget bindingsPerObject() {\n\n\t\t\treturn scope._bindings.length;\n\n\t\t}\n\n\t};\n\n}\n\nObject.assign( AnimationObjectGroup.prototype, {\n\n\tisAnimationObjectGroup: true,\n\n\tadd: function () {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length,\n\t\t\tknownObject = undefined;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function () {\n\n\t\tvar objects = this._objects,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function () {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function ( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ],\n\t\t\tbindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tvar paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tvar object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function ( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nfunction AnimationAction( mixer, clip, localRoot ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\n\tvar tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tvar interpolantSettings = {\n\t\tendingStart: ZeroCurvatureEnding,\n\t\tendingEnd: ZeroCurvatureEnding\n\t};\n\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants; // bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null; // for the memory manager\n\tthis._byClipCacheIndex = null; // for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = LoopRepeat;\n\tthis._loopCount = - 1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\tthis.paused = false; // true -> zero effective time scale\n\tthis.enabled = true; // false -> zero effective weight\n\n\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n}\n\nObject.assign( AnimationAction.prototype, {\n\n\t// State & Scheduling\n\n\tplay: function () {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function () {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function () {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function () {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function ( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function ( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function ( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function () {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function ( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function ( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function () {\n\n\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function ( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function () {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function ( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function ( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function ( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function ( startTimeScale, endTimeScale, duration ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function () {\n\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function () {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function () {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function () {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tvar weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tvar interpolants = this._interpolants;\n\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function ( time ) {\n\n\t\tvar weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function ( time ) {\n\n\t\tvar timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function ( deltaTime ) {\n\n\t\tvar time = this.time + deltaTime;\n\t\tvar duration = this._clip.duration;\n\t\tvar loop = this.loop;\n\t\tvar loopCount = this._loopCount;\n\n\t\tvar pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else break handle_stop;\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\tthis.time = time;\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.time = time;\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function ( atStart, atEnd, pingPong ) {\n\n\t\tvar settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function ( duration, weightNow, weightThen ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nfunction AnimationMixer( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n}\n\nAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: AnimationMixer,\n\n\t_bindAction: function ( action, prototypeAction ) {\n\n\t\tvar root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar track = tracks[ i ],\n\t\t\t\ttrackName = track.name,\n\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function ( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function ( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function () {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction: function ( action ) {\n\n\t\tvar index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\n\n\t\tvar actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function ( action ) {\n\n\t\tvar actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tvar clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function ( action ) {\n\n\t\tvar bindings = action._propertyBindings;\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tvar binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function ( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function ( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tbindings = this._bindings;\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function ( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tremove_empty_map: {\n\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function ( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function ( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function () {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function ( interpolant ) {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function ( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tvar existingAction =\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function ( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function () {\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tthis._nActiveActions = 0;\n\t\tthis._nActiveBindings = 0;\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tactions[ i ].reset();\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].useCount = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function ( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tvar action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tvar bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function () {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function ( clip ) {\n\n\t\tvar actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function ( root ) {\n\n\t\tvar rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function ( clip, optionalRoot ) {\n\n\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Uniform( value ) {\n\n\tif ( typeof value === 'string' ) {\n\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\tvalue = arguments[ 1 ];\n\n\t}\n\n\tthis.value = value;\n\n}\n\nUniform.prototype.clone = function () {\n\n\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n};\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InstancedBufferGeometry() {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'InstancedBufferGeometry';\n\tthis.maxInstancedCount = undefined;\n\n}\n\nInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\n\n\tconstructor: InstancedBufferGeometry,\n\n\tisInstancedBufferGeometry: true,\n\n\tcopy: function ( source ) {\n\n\t\tBufferGeometry.prototype.copy.call( this, source );\n\n\t\tthis.maxInstancedCount = source.maxInstancedCount;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n\tInterleavedBuffer.call( this, array, stride );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n}\n\nInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\n\n\tconstructor: InstancedInterleavedBuffer,\n\n\tisInstancedInterleavedBuffer: true,\n\n\tcopy: function ( source ) {\n\n\t\tInterleavedBuffer.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nfunction InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {\n\n\tif ( typeof ( normalized ) === 'number' ) {\n\n\t\tmeshPerAttribute = normalized;\n\n\t\tnormalized = false;\n\n\t\tconsole.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );\n\n\t}\n\n\tBufferAttribute.call( this, array, itemSize, normalized );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n}\n\nInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\n\n\tconstructor: InstancedBufferAttribute,\n\n\tisInstancedBufferAttribute: true,\n\n\tcopy: function ( source ) {\n\n\t\tBufferAttribute.prototype.copy.call( this, source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\nfunction Raycaster( origin, direction, near, far ) {\n\n\tthis.ray = new Ray( origin, direction );\n\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\tthis.near = near || 0;\n\tthis.far = far || Infinity;\n\n\tthis.params = {\n\t\tMesh: {},\n\t\tLine: {},\n\t\tLOD: {},\n\t\tPoints: { threshold: 1 },\n\t\tSprite: {}\n\t};\n\n\tObject.defineProperties( this.params, {\n\t\tPointCloud: {\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\treturn this.Points;\n\n\t\t\t}\n\t\t}\n\t} );\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\tif ( object.visible === false ) return;\n\n\tobject.raycast( raycaster, intersects );\n\n\tif ( recursive === true ) {\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\nObject.assign( Raycaster.prototype, {\n\n\tlinePrecision: 1,\n\n\tset: function ( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t},\n\n\tsetFromCamera: function ( coords, camera ) {\n\n\t\tif ( ( camera && camera.isPerspectiveCamera ) ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t}\n\n\t},\n\n\tintersectObject: function ( object, recursive, optionalTarget ) {\n\n\t\tvar intersects = optionalTarget || [];\n\n\t\tintersectObject( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t},\n\n\tintersectObjects: function ( objects, recursive, optionalTarget ) {\n\n\t\tvar intersects = optionalTarget || [];\n\n\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\treturn intersects;\n\n\t\t}\n\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axiz.\n */\n\nfunction Spherical( radius, phi, theta ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // polar angle\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle\n\n\treturn this;\n\n}\n\nObject.assign( Spherical.prototype, {\n\n\tset: function ( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t},\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe: function () {\n\n\t\tvar EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function ( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t},\n\n\tsetFromCartesianCoords: function ( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n *\n */\n\nfunction Cylindrical( radius, theta, y ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\n\n\treturn this;\n\n}\n\nObject.assign( Cylindrical.prototype, {\n\n\tset: function ( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function ( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t},\n\n\tsetFromCartesianCoords: function ( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n */\n\nfunction Box2( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\n}\n\nObject.assign( Box2.prototype, {\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new Vector2();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tgetCenter: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .getCenter() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tgetSize: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .getSize() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t},\n\n\tgetParameter: function ( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .getParameter() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\n\t},\n\n\tclampPoint: function ( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Box2: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector2();\n\n\t\t}\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new Vector2();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n} );\n\n/**\n * @author bhouston / http://clara.io\n */\n\nfunction Line3( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new Vector3();\n\tthis.end = ( end !== undefined ) ? end : new Vector3();\n\n}\n\nObject.assign( Line3.prototype, {\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tgetCenter: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .getCenter() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .delta() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .at() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function () {\n\n\t\tvar startP = new Vector3();\n\t\tvar startEnd = new Vector3();\n\n\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = _Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, target ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n} );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction ImmediateRenderObject( material ) {\n\n\tObject3D.call( this );\n\n\tthis.material = material;\n\tthis.render = function ( /* renderCallback */ ) {};\n\n}\n\nImmediateRenderObject.prototype = Object.create( Object3D.prototype );\nImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction VertexNormalsHelper( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry && objGeometry.isGeometry ) {\n\n\t\tnNormals = objGeometry.faces.length * 3;\n\n\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\n\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t}\n\n\t//\n\n\tvar geometry = new BufferGeometry();\n\n\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n}\n\nVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\nVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\nVertexNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new Vector3();\n\tvar v2 = new Vector3();\n\tvar normalMatrix = new Matrix3();\n\n\treturn function update() {\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry && objGeometry.isGeometry ) {\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\n\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\tvar idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t};\n\n}() );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction SpotLightHelper( light, color ) {\n\n\tObject3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.color = color;\n\n\tvar geometry = new BufferGeometry();\n\n\tvar positions = [\n\t\t0, 0, 0, \t0, 0, 1,\n\t\t0, 0, 0, \t1, 0, 1,\n\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t0, 0, 0, \t0, 1, 1,\n\t\t0, 0, 0, \t0, - 1, 1\n\t];\n\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\tpositions.push(\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t);\n\n\t}\n\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\tvar material = new LineBasicMaterial( { fog: false } );\n\n\tthis.cone = new LineSegments( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n}\n\nSpotLightHelper.prototype = Object.create( Object3D.prototype );\nSpotLightHelper.prototype.constructor = SpotLightHelper;\n\nSpotLightHelper.prototype.dispose = function () {\n\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n\n};\n\nSpotLightHelper.prototype.update = function () {\n\n\tvar vector = new Vector3();\n\n\treturn function update() {\n\n\t\tthis.light.updateMatrixWorld();\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t};\n\n}();\n\n/**\n * @author Sean Griffin / http://twitter.com/sgrif\n * @author Michael Guerrero / http://realitymeltdown.com\n * @author mrdoob / http://mrdoob.com/\n * @author ikerr / http://verold.com\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction getBoneList( object ) {\n\n\tvar boneList = [];\n\n\tif ( object && object.isBone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nfunction SkeletonHelper( object ) {\n\n\tvar bones = getBoneList( object );\n\n\tvar geometry = new BufferGeometry();\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tvar color1 = new Color( 0, 0, 1 );\n\tvar color2 = new Color( 0, 1, 0 );\n\n\tfor ( var i = 0; i < bones.length; i ++ ) {\n\n\t\tvar bone = bones[ i ];\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t}\n\n\t}\n\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\tLineSegments.call( this, geometry, material );\n\n\tthis.root = object;\n\tthis.bones = bones;\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n}\n\nSkeletonHelper.prototype = Object.create( LineSegments.prototype );\nSkeletonHelper.prototype.constructor = SkeletonHelper;\n\nSkeletonHelper.prototype.updateMatrixWorld = function () {\n\n\tvar vector = new Vector3();\n\n\tvar boneMatrix = new Matrix4();\n\tvar matrixWorldInv = new Matrix4();\n\n\treturn function updateMatrixWorld( force ) {\n\n\t\tvar bones = this.bones;\n\n\t\tvar geometry = this.geometry;\n\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\tmatrixWorldInv.getInverse( this.root.matrixWorld );\n\n\t\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tvar bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\n\t\t\t\tposition.setXYZ( j, vector.x, vector.y, vector.z );\n\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\tvector.setFromMatrixPosition( boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, vector.x, vector.y, vector.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n\t};\n\n}();\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction PointLightHelper( light, sphereSize, color ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.color = color;\n\n\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\n\tMesh.call( this, geometry, material );\n\n\tthis.matrix = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n}\n\nPointLightHelper.prototype = Object.create( Mesh.prototype );\nPointLightHelper.prototype.constructor = PointLightHelper;\n\nPointLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\n};\n\nPointLightHelper.prototype.update = function () {\n\n\tif ( this.color !== undefined ) {\n\n\t\tthis.material.color.set( this.color );\n\n\t} else {\n\n\t\tthis.material.color.copy( this.light.color );\n\n\t}\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n/**\n * @author abelnation / http://github.com/abelnation\n * @author Mugen87 / http://github.com/Mugen87\n * @author WestLangley / http://github.com/WestLangley\n *\n *  This helper must be added as a child of the light\n */\n\nfunction RectAreaLightHelper( light, color ) {\n\n\tthis.type = 'RectAreaLightHelper';\n\n\tthis.light = light;\n\n\tthis.color = color; // optional hardwired color for the helper\n\n\tvar positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\tgeometry.computeBoundingSphere();\n\n\tvar material = new LineBasicMaterial( { fog: false } );\n\n\tLine.call( this, geometry, material );\n\n\t//\n\n\tvar positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\n\tvar geometry2 = new BufferGeometry();\n\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\tgeometry2.computeBoundingSphere();\n\n\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );\n\n\tthis.update();\n\n}\n\nRectAreaLightHelper.prototype = Object.create( Line.prototype );\nRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\n\nRectAreaLightHelper.prototype.update = function () {\n\n\tthis.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );\n\n\tif ( this.color !== undefined ) {\n\n\t\tthis.material.color.set( this.color );\n\t\tthis.children[ 0 ].material.color.set( this.color );\n\n\t} else {\n\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\t// prevent hue shift\n\t\tvar c = this.material.color;\n\t\tvar max = Math.max( c.r, c.g, c.b );\n\t\tif ( max > 1 ) c.multiplyScalar( 1 / max );\n\n\t\tthis.children[ 0 ].material.color.copy( this.material.color );\n\n\t}\n\n};\n\nRectAreaLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\tthis.children[ 0 ].geometry.dispose();\n\tthis.children[ 0 ].material.dispose();\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nfunction HemisphereLightHelper( light, size, color ) {\n\n\tObject3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.color = color;\n\n\tvar geometry = new OctahedronBufferGeometry( size );\n\tgeometry.rotateY( Math.PI * 0.5 );\n\n\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n\tif ( this.color === undefined ) this.material.vertexColors = VertexColors;\n\n\tvar position = geometry.getAttribute( 'position' );\n\tvar colors = new Float32Array( position.count * 3 );\n\n\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\tthis.add( new Mesh( geometry, this.material ) );\n\n\tthis.update();\n\n}\n\nHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\nHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\nHemisphereLightHelper.prototype.dispose = function () {\n\n\tthis.children[ 0 ].geometry.dispose();\n\tthis.children[ 0 ].material.dispose();\n\n};\n\nHemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new Vector3();\n\n\tvar color1 = new Color();\n\tvar color2 = new Color();\n\n\treturn function update() {\n\n\t\tvar mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tvar colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\tcolor1.copy( this.light.color );\n\t\t\tcolor2.copy( this.light.groundColor );\n\n\t\t\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tvar color = ( i < ( l / 2 ) ) ? color1 : color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tmesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t};\n\n}();\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction GridHelper( size, divisions, color1, color2 ) {\n\n\tsize = size || 10;\n\tdivisions = divisions || 10;\n\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar center = divisions / 2;\n\tvar step = size / divisions;\n\tvar halfSize = size / 2;\n\n\tvar vertices = [], colors = [];\n\n\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\tvar color = i === center ? color1 : color2;\n\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\n\t}\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\tLineSegments.call( this, geometry, material );\n\n}\n\nGridHelper.prototype = Object.create( LineSegments.prototype );\nGridHelper.prototype.constructor = GridHelper;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / http://github.com/Mugen87\n * @author Hectate / http://www.github.com/Hectate\n */\n\nfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\n\n\tradius = radius || 10;\n\tradials = radials || 16;\n\tcircles = circles || 8;\n\tdivisions = divisions || 64;\n\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tvar x, z;\n\tvar v, i, j, r, color;\n\n\t// create the radials\n\n\tfor ( i = 0; i <= radials; i ++ ) {\n\n\t\tv = ( i / radials ) * ( Math.PI * 2 );\n\n\t\tx = Math.sin( v ) * radius;\n\t\tz = Math.cos( v ) * radius;\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tvertices.push( x, 0, z );\n\n\t\tcolor = ( i & 1 ) ? color1 : color2;\n\n\t\tcolors.push( color.r, color.g, color.b );\n\t\tcolors.push( color.r, color.g, color.b );\n\n\t}\n\n\t// create the circles\n\n\tfor ( i = 0; i <= circles; i ++ ) {\n\n\t\tcolor = ( i & 1 ) ? color1 : color2;\n\n\t\tr = radius - ( radius / circles * i );\n\n\t\tfor ( j = 0; j < divisions; j ++ ) {\n\n\t\t\t// first vertex\n\n\t\t\tv = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\tx = Math.sin( v ) * r;\n\t\t\tz = Math.cos( v ) * r;\n\n\t\t\tvertices.push( x, 0, z );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t// second vertex\n\n\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\tx = Math.sin( v ) * r;\n\t\t\tz = Math.cos( v ) * r;\n\n\t\t\tvertices.push( x, 0, z );\n\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t}\n\n\t}\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\tLineSegments.call( this, geometry, material );\n\n}\n\nPolarGridHelper.prototype = Object.create( LineSegments.prototype );\nPolarGridHelper.prototype.constructor = PolarGridHelper;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction FaceNormalsHelper( object, size, hex, linewidth ) {\n\n\t// FaceNormalsHelper only supports THREE.Geometry\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry && objGeometry.isGeometry ) {\n\n\t\tnNormals = objGeometry.faces.length;\n\n\t} else {\n\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t}\n\n\t//\n\n\tvar geometry = new BufferGeometry();\n\n\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\tthis.update();\n\n}\n\nFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\nFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\nFaceNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new Vector3();\n\tvar v2 = new Vector3();\n\tvar normalMatrix = new Matrix3();\n\n\treturn function update() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tvar vertices = objGeometry.vertices;\n\n\t\tvar faces = objGeometry.faces;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar normal = face.normal;\n\n\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t.divideScalar( 3 )\n\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t};\n\n}() );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction DirectionalLightHelper( light, size, color ) {\n\n\tObject3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.color = color;\n\n\tif ( size === undefined ) size = 1;\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [\n\t\t- size, size, 0,\n\t\tsize, size, 0,\n\t\tsize, - size, 0,\n\t\t- size, - size, 0,\n\t\t- size, size, 0\n\t], 3 ) );\n\n\tvar material = new LineBasicMaterial( { fog: false } );\n\n\tthis.lightPlane = new Line( geometry, material );\n\tthis.add( this.lightPlane );\n\n\tgeometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\tthis.targetLine = new Line( geometry, material );\n\tthis.add( this.targetLine );\n\n\tthis.update();\n\n}\n\nDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\nDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\nDirectionalLightHelper.prototype.dispose = function () {\n\n\tthis.lightPlane.geometry.dispose();\n\tthis.lightPlane.material.dispose();\n\tthis.targetLine.geometry.dispose();\n\tthis.targetLine.material.dispose();\n\n};\n\nDirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new Vector3();\n\tvar v2 = new Vector3();\n\tvar v3 = new Vector3();\n\n\treturn function update() {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tthis.lightPlane.lookAt( v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( v2 );\n\t\tthis.targetLine.scale.z = v3.length();\n\n\t};\n\n}();\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author Mugen87 / https://github.com/Mugen87\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nfunction CameraHelper( camera ) {\n\n\tvar geometry = new BufferGeometry();\n\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\n\tvar vertices = [];\n\tvar colors = [];\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar colorFrustum = new Color( 0xffaa00 );\n\tvar colorCone = new Color( 0xff0000 );\n\tvar colorUp = new Color( 0x00aaff );\n\tvar colorTarget = new Color( 0xffffff );\n\tvar colorCross = new Color( 0x333333 );\n\n\t// near\n\n\taddLine( 'n1', 'n2', colorFrustum );\n\taddLine( 'n2', 'n4', colorFrustum );\n\taddLine( 'n4', 'n3', colorFrustum );\n\taddLine( 'n3', 'n1', colorFrustum );\n\n\t// far\n\n\taddLine( 'f1', 'f2', colorFrustum );\n\taddLine( 'f2', 'f4', colorFrustum );\n\taddLine( 'f4', 'f3', colorFrustum );\n\taddLine( 'f3', 'f1', colorFrustum );\n\n\t// sides\n\n\taddLine( 'n1', 'f1', colorFrustum );\n\taddLine( 'n2', 'f2', colorFrustum );\n\taddLine( 'n3', 'f3', colorFrustum );\n\taddLine( 'n4', 'f4', colorFrustum );\n\n\t// cone\n\n\taddLine( 'p', 'n1', colorCone );\n\taddLine( 'p', 'n2', colorCone );\n\taddLine( 'p', 'n3', colorCone );\n\taddLine( 'p', 'n4', colorCone );\n\n\t// up\n\n\taddLine( 'u1', 'u2', colorUp );\n\taddLine( 'u2', 'u3', colorUp );\n\taddLine( 'u3', 'u1', colorUp );\n\n\t// target\n\n\taddLine( 'c', 't', colorTarget );\n\taddLine( 'p', 'c', colorCross );\n\n\t// cross\n\n\taddLine( 'cn1', 'cn2', colorCross );\n\taddLine( 'cn3', 'cn4', colorCross );\n\n\taddLine( 'cf1', 'cf2', colorCross );\n\taddLine( 'cf3', 'cf4', colorCross );\n\n\tfunction addLine( a, b, color ) {\n\n\t\taddPoint( a, color );\n\t\taddPoint( b, color );\n\n\t}\n\n\tfunction addPoint( id, color ) {\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tcolors.push( color.r, color.g, color.b );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t}\n\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tLineSegments.call( this, geometry, material );\n\n\tthis.camera = camera;\n\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\tthis.matrix = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n}\n\nCameraHelper.prototype = Object.create( LineSegments.prototype );\nCameraHelper.prototype.constructor = CameraHelper;\n\nCameraHelper.prototype.update = function () {\n\n\tvar geometry, pointMap;\n\n\tvar vector = new Vector3();\n\tvar camera = new Camera();\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\tvar points = pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tposition.setXYZ( points[ i ], vector.x, vector.y, vector.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn function update() {\n\n\t\tgeometry = this.geometry;\n\t\tpointMap = this.pointMap;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t// center / target\n\n\t\tsetPoint( 'c', 0, 0, - 1 );\n\t\tsetPoint( 't', 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', - w, - h, - 1 );\n\t\tsetPoint( 'n2', w, - h, - 1 );\n\t\tsetPoint( 'n3', - w, h, - 1 );\n\t\tsetPoint( 'n4', w, h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', - w, - h, 1 );\n\t\tsetPoint( 'f2', w, - h, 1 );\n\t\tsetPoint( 'f3', - w, h, 1 );\n\t\tsetPoint( 'f4', w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u2', - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u3', 0, h * 2, - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', - w, 0, 1 );\n\t\tsetPoint( 'cf2', w, 0, 1 );\n\t\tsetPoint( 'cf3', 0, - h, 1 );\n\t\tsetPoint( 'cf4', 0, h, 1 );\n\n\t\tsetPoint( 'cn1', - w, 0, - 1 );\n\t\tsetPoint( 'cn2', w, 0, - 1 );\n\t\tsetPoint( 'cn3', 0, - h, - 1 );\n\t\tsetPoint( 'cn4', 0, h, - 1 );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t};\n\n}();\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / http://github.com/Mugen87\n */\n\nfunction BoxHelper( object, color ) {\n\n\tthis.object = object;\n\n\tif ( color === undefined ) color = 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\tvar positions = new Float32Array( 8 * 3 );\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n}\n\nBoxHelper.prototype = Object.create( LineSegments.prototype );\nBoxHelper.prototype.constructor = BoxHelper;\n\nBoxHelper.prototype.update = ( function () {\n\n\tvar box = new Box3();\n\n\treturn function update( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\tbox.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tvar min = box.min;\n\t\tvar max = box.max;\n\n\t\t/*\n\t\t  5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tvar position = this.geometry.attributes.position;\n\t\tvar array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t};\n\n} )();\n\nBoxHelper.prototype.setFromObject = function ( object ) {\n\n\tthis.object = object;\n\tthis.update();\n\n\treturn this;\n\n};\n\nBoxHelper.prototype.copy = function ( source ) {\n\n\tLineSegments.prototype.copy.call( this, source );\n\n\tthis.object = source.object;\n\n\treturn this;\n\n};\n\nBoxHelper.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction Box3Helper( box, hex ) {\n\n\tthis.type = 'Box3Helper';\n\n\tthis.box = box;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\tvar geometry = new BufferGeometry();\n\n\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\tthis.geometry.computeBoundingSphere();\n\n}\n\nBox3Helper.prototype = Object.create( LineSegments.prototype );\nBox3Helper.prototype.constructor = Box3Helper;\n\nBox3Helper.prototype.updateMatrixWorld = function ( force ) {\n\n\tvar box = this.box;\n\n\tif ( box.isEmpty() ) return;\n\n\tbox.getCenter( this.position );\n\n\tbox.getSize( this.scale );\n\n\tthis.scale.multiplyScalar( 0.5 );\n\n\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nfunction PlaneHelper( plane, size, hex ) {\n\n\tthis.type = 'PlaneHelper';\n\n\tthis.plane = plane;\n\n\tthis.size = ( size === undefined ) ? 1 : size;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\tgeometry.computeBoundingSphere();\n\n\tLine.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n\t//\n\n\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\n\n\tvar geometry2 = new BufferGeometry();\n\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\tgeometry2.computeBoundingSphere();\n\n\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );\n\n}\n\nPlaneHelper.prototype = Object.create( Line.prototype );\nPlaneHelper.prototype.constructor = PlaneHelper;\n\nPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\n\n\tvar scale = - this.plane.constant;\n\n\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\n\n\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\n\n\tthis.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\n\n\tthis.lookAt( this.plane.normal );\n\n\tObject3D.prototype.updateMatrixWorld.call( this, force );\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://clara.io\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  color - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nvar lineGeometry, coneGeometry;\n\nfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t// dir is assumed to be normalized\n\n\tObject3D.call( this );\n\n\tif ( dir === undefined ) dir = new Vector3( 0, 0, 1 );\n\tif ( origin === undefined ) origin = new Vector3( 0, 0, 0 );\n\tif ( length === undefined ) length = 1;\n\tif ( color === undefined ) color = 0xffff00;\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tif ( lineGeometry === undefined ) {\n\n\t\tlineGeometry = new BufferGeometry();\n\t\tlineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\tconeGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\t}\n\n\tthis.position.copy( origin );\n\n\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n\tthis.line.matrixAutoUpdate = false;\n\tthis.add( this.line );\n\n\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n\tthis.cone.matrixAutoUpdate = false;\n\tthis.add( this.cone );\n\n\tthis.setDirection( dir );\n\tthis.setLength( length, headLength, headWidth );\n\n}\n\nArrowHelper.prototype = Object.create( Object3D.prototype );\nArrowHelper.prototype.constructor = ArrowHelper;\n\nArrowHelper.prototype.setDirection = ( function () {\n\n\tvar axis = new Vector3();\n\tvar radians;\n\n\treturn function setDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}() );\n\nArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nArrowHelper.prototype.setColor = function ( color ) {\n\n\tthis.line.material.color.copy( color );\n\tthis.cone.material.color.copy( color );\n\n};\n\nArrowHelper.prototype.copy = function ( source ) {\n\n\tObject3D.prototype.copy.call( this, source, false );\n\n\tthis.line.copy( source.line );\n\tthis.cone.copy( source.cone );\n\n\treturn this;\n\n};\n\nArrowHelper.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction AxesHelper( size ) {\n\n\tsize = size || 1;\n\n\tvar vertices = [\n\t\t0, 0, 0,\tsize, 0, 0,\n\t\t0, 0, 0,\t0, size, 0,\n\t\t0, 0, 0,\t0, 0, size\n\t];\n\n\tvar colors = [\n\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t0, 0, 1,\t0, 0.6, 1\n\t];\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n\tLineSegments.call( this, geometry, material );\n\n}\n\nAxesHelper.prototype = Object.create( LineSegments.prototype );\nAxesHelper.prototype.constructor = AxesHelper;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction Face4( a, b, c, d, normal, color, materialIndex ) {\n\n\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\treturn new Face3( a, b, c, normal, color, materialIndex );\n\n}\n\nvar LineStrip = 0;\n\nvar LinePieces = 1;\n\nfunction MeshFaceMaterial( materials ) {\n\n\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\n\treturn materials;\n\n}\n\nfunction MultiMaterial( materials ) {\n\n\tif ( materials === undefined ) materials = [];\n\n\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\n\tmaterials.isMultiMaterial = true;\n\tmaterials.materials = materials;\n\tmaterials.clone = function () {\n\n\t\treturn materials.slice();\n\n\t};\n\treturn materials;\n\n}\n\nfunction PointCloud( geometry, material ) {\n\n\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\treturn new Points( geometry, material );\n\n}\n\nfunction Particle( material ) {\n\n\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\n\treturn new Sprite( material );\n\n}\n\nfunction ParticleSystem( geometry, material ) {\n\n\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\treturn new Points( geometry, material );\n\n}\n\nfunction PointCloudMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction ParticleBasicMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction ParticleSystemMaterial( parameters ) {\n\n\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\treturn new PointsMaterial( parameters );\n\n}\n\nfunction Vertex( x, y, z ) {\n\n\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\treturn new Vector3( x, y, z );\n\n}\n\n//\n\nfunction DynamicBufferAttribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\n\n}\n\nfunction Int8Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\n\treturn new Int8BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint8Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\n\treturn new Uint8BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint8ClampedAttribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\n\treturn new Uint8ClampedBufferAttribute( array, itemSize );\n\n}\n\nfunction Int16Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\n\treturn new Int16BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint16Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\n\treturn new Uint16BufferAttribute( array, itemSize );\n\n}\n\nfunction Int32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\n\treturn new Int32BufferAttribute( array, itemSize );\n\n}\n\nfunction Uint32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\n\treturn new Uint32BufferAttribute( array, itemSize );\n\n}\n\nfunction Float32Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\n\treturn new Float32BufferAttribute( array, itemSize );\n\n}\n\nfunction Float64Attribute( array, itemSize ) {\n\n\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\n\treturn new Float64BufferAttribute( array, itemSize );\n\n}\n\n//\n\nCurve.create = function ( construct, getPoint ) {\n\n\tconsole.log( 'THREE.Curve.create() has been deprecated' );\n\n\tconstruct.prototype = Object.create( Curve.prototype );\n\tconstruct.prototype.constructor = construct;\n\tconstruct.prototype.getPoint = getPoint;\n\n\treturn construct;\n\n};\n\n//\n\nObject.assign( CurvePath.prototype, {\n\n\tcreatePointsGeometry: function ( divisions ) {\n\n\t\tconsole.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\n\t\t// generate geometry from path points (for Line or Points objects)\n\n\t\tvar pts = this.getPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\tconsole.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\n\t\t// generate geometry from equidistant sampling along the path\n\n\t\tvar pts = this.getSpacedPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateGeometry: function ( points ) {\n\n\t\tconsole.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\n\n\t\tvar geometry = new Geometry();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n//\n\nObject.assign( Path.prototype, {\n\n\tfromPoints: function ( points ) {\n\n\t\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\n\t\tthis.setFromPoints( points );\n\n\t}\n\n} );\n\n//\n\nfunction ClosedSplineCurve3( points ) {\n\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\n\tCatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\tthis.closed = true;\n\n}\n\nClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n//\n\nfunction SplineCurve3( points ) {\n\n\tconsole.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\n\tCatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\n}\n\nSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n//\n\nfunction Spline( points ) {\n\n\tconsole.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\n\n\tCatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\n}\n\nSpline.prototype = Object.create( CatmullRomCurve3.prototype );\n\nObject.assign( Spline.prototype, {\n\n\tinitFromArray: function ( /* a */ ) {\n\n\t\tconsole.error( 'THREE.Spline: .initFromArray() has been removed.' );\n\n\t},\n\tgetControlPointsArray: function ( /* optionalTarget */ ) {\n\n\t\tconsole.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\n\n\t},\n\treparametrizeByArcLength: function ( /* samplingCoef */ ) {\n\n\t\tconsole.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\n\n\t}\n\n} );\n\n//\n\nfunction AxisHelper( size ) {\n\n\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\n\treturn new AxesHelper( size );\n\n}\n\nfunction BoundingBoxHelper( object, color ) {\n\n\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\n\treturn new BoxHelper( object, color );\n\n}\n\nfunction EdgesHelper( object, hex ) {\n\n\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n}\n\nGridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\nSkeletonHelper.prototype.update = function () {\n\n\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\n\n};\n\nfunction WireframeHelper( object, hex ) {\n\n\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n}\n\n//\n\nObject.assign( Loader.prototype, {\n\n\textractUrlBase: function ( url ) {\n\n\t\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\n\t\treturn LoaderUtils.extractUrlBase( url );\n\n\t}\n\n} );\n\nfunction XHRLoader( manager ) {\n\n\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\n\treturn new FileLoader( manager );\n\n}\n\nfunction BinaryTextureLoader( manager ) {\n\n\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\n\treturn new DataTextureLoader( manager );\n\n}\n\nObject.assign( ObjectLoader.prototype, {\n\n\tsetTexturePath: function ( value ) {\n\n\t\tconsole.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );\n\t\treturn this.setResourcePath( value );\n\n\t}\n\n} );\n\n//\n\nObject.assign( Box2.prototype, {\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n\t\treturn this.getCenter( optionalTarget );\n\n\t},\n\tempty: function () {\n\n\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\n\t},\n\tisIntersectionBox: function ( box ) {\n\n\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\n\t},\n\tsize: function ( optionalTarget ) {\n\n\t\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n\t\treturn this.getSize( optionalTarget );\n\n\t}\n} );\n\nObject.assign( Box3.prototype, {\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n\t\treturn this.getCenter( optionalTarget );\n\n\t},\n\tempty: function () {\n\n\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\n\t},\n\tisIntersectionBox: function ( box ) {\n\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\n\t},\n\tsize: function ( optionalTarget ) {\n\n\t\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n\t\treturn this.getSize( optionalTarget );\n\n\t}\n} );\n\nLine3.prototype.center = function ( optionalTarget ) {\n\n\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n\treturn this.getCenter( optionalTarget );\n\n};\n\nObject.assign( _Math, {\n\n\trandom16: function () {\n\n\t\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\n\t\treturn Math.random();\n\n\t},\n\n\tnearestPowerOfTwo: function ( value ) {\n\n\t\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\n\t\treturn _Math.floorPowerOfTwo( value );\n\n\t},\n\n\tnextPowerOfTwo: function ( value ) {\n\n\t\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\n\t\treturn _Math.ceilPowerOfTwo( value );\n\n\t}\n\n} );\n\nObject.assign( Matrix3.prototype, {\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n\t\treturn this.toArray( array, offset );\n\n\t},\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\n\t},\n\tmultiplyVector3Array: function ( /* a */ ) {\n\n\t\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\n\n\t},\n\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\n\n\t\tconsole.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n\t\treturn this.applyToBufferAttribute( buffer );\n\n\t},\n\tapplyToVector3Array: function ( /* array, offset, length */ ) {\n\n\t\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\n\n\t}\n\n} );\n\nObject.assign( Matrix4.prototype, {\n\n\textractPosition: function ( m ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\n\t},\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n\t\treturn this.toArray( array, offset );\n\n\t},\n\tgetPosition: function () {\n\n\t\tvar v1;\n\n\t\treturn function getPosition() {\n\n\t\t\tif ( v1 === undefined ) v1 = new Vector3();\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t};\n\n\t}(),\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\treturn this.makeRotationFromQuaternion( q );\n\n\t},\n\tmultiplyToArray: function () {\n\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\n\n\t},\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\tmultiplyVector4: function ( vector ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\tmultiplyVector3Array: function ( /* a */ ) {\n\n\t\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\n\n\t},\n\trotateAxis: function ( v ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\tv.transformDirection( this );\n\n\t},\n\tcrossVector: function ( vector ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\ttranslate: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\n\t},\n\trotateX: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\n\t},\n\trotateY: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\n\t},\n\trotateZ: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\n\t},\n\trotateByAxis: function () {\n\n\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\n\t},\n\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n\t\treturn this.applyToBufferAttribute( buffer );\n\n\t},\n\tapplyToVector3Array: function ( /* array, offset, length */ ) {\n\n\t\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\n\n\t},\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\n\t\treturn this.makePerspective( left, right, top, bottom, near, far );\n\n\t}\n\n} );\n\nPlane.prototype.isIntersectionLine = function ( line ) {\n\n\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\treturn this.intersectsLine( line );\n\n};\n\nQuaternion.prototype.multiplyVector3 = function ( vector ) {\n\n\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\treturn vector.applyQuaternion( this );\n\n};\n\nObject.assign( Ray.prototype, {\n\n\tisIntersectionBox: function ( box ) {\n\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\n\t},\n\tisIntersectionPlane: function ( plane ) {\n\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\treturn this.intersectsPlane( plane );\n\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\n\t}\n\n} );\n\nObject.assign( Triangle.prototype, {\n\n\tarea: function () {\n\n\t\tconsole.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );\n\t\treturn this.getArea();\n\n\t},\n\tbarycoordFromPoint: function ( point, target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\n\t\treturn this.getBarycoord( point, target );\n\n\t},\n\tmidpoint: function ( target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );\n\t\treturn this.getMidpoint( target );\n\n\t},\n\tnormal: function ( target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\n\t\treturn this.getNormal( target );\n\n\t},\n\tplane: function ( target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );\n\t\treturn this.getPlane( target );\n\n\t}\n\n} );\n\nObject.assign( Triangle, {\n\n\tbarycoordFromPoint: function ( point, a, b, c, target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );\n\t\treturn Triangle.getBarycoord( point, a, b, c, target );\n\n\t},\n\tnormal: function ( a, b, c, target ) {\n\n\t\tconsole.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );\n\t\treturn Triangle.getNormal( a, b, c, target );\n\n\t}\n\n} );\n\nObject.assign( Shape.prototype, {\n\n\textractAllPoints: function ( divisions ) {\n\n\t\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\n\t\treturn this.extractPoints( divisions );\n\n\t},\n\textrude: function ( options ) {\n\n\t\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n\t\treturn new ExtrudeGeometry( this, options );\n\n\t},\n\tmakeGeometry: function ( options ) {\n\n\t\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n\t\treturn new ShapeGeometry( this, options );\n\n\t}\n\n} );\n\nObject.assign( Vector2.prototype, {\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\n\t},\n\tdistanceToManhattan: function ( v ) {\n\n\t\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\t\treturn this.manhattanDistanceTo( v );\n\n\t},\n\tlengthManhattan: function () {\n\n\t\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\treturn this.manhattanLength();\n\n\t}\n\n} );\n\nObject.assign( Vector3.prototype, {\n\n\tsetEulerFromRotationMatrix: function () {\n\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\n\t},\n\tsetEulerFromQuaternion: function () {\n\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\n\t},\n\tgetPositionFromMatrix: function ( m ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\treturn this.setFromMatrixPosition( m );\n\n\t},\n\tgetScaleFromMatrix: function ( m ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\treturn this.setFromMatrixScale( m );\n\n\t},\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\treturn this.setFromMatrixColumn( matrix, index );\n\n\t},\n\tapplyProjection: function ( m ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\n\t\treturn this.applyMatrix4( m );\n\n\t},\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\n\t},\n\tdistanceToManhattan: function ( v ) {\n\n\t\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\n\t\treturn this.manhattanDistanceTo( v );\n\n\t},\n\tlengthManhattan: function () {\n\n\t\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\treturn this.manhattanLength();\n\n\t}\n\n} );\n\nObject.assign( Vector4.prototype, {\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n\t\treturn this.fromBufferAttribute( attribute, index, offset );\n\n\t},\n\tlengthManhattan: function () {\n\n\t\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\n\t\treturn this.manhattanLength();\n\n\t}\n\n} );\n\n//\n\nObject.assign( Geometry.prototype, {\n\n\tcomputeTangents: function () {\n\n\t\tconsole.error( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\tcomputeLineDistances: function () {\n\n\t\tconsole.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );\n\n\t}\n\n} );\n\nObject.assign( Object3D.prototype, {\n\n\tgetChildByName: function ( name ) {\n\n\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name );\n\n\t},\n\trenderDepth: function () {\n\n\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\n\t},\n\ttranslate: function ( distance, axis ) {\n\n\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\n\t},\n\tgetWorldRotation: function () {\n\n\t\tconsole.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );\n\n\t}\n\n} );\n\nObject.defineProperties( Object3D.prototype, {\n\n\teulerOrder: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( LOD.prototype, {\n\n\tobjects: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\treturn this.levels;\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperty( Skeleton.prototype, 'useVertexTexture', {\n\n\tget: function () {\n\n\t\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\n\n\t},\n\tset: function () {\n\n\t\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\n\n\t}\n\n} );\n\nSkinnedMesh.prototype.initBones = function () {\n\n\tconsole.error( 'THREE.SkinnedMesh: initBones() has been removed.' );\n\n};\n\nObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\n\n\tget: function () {\n\n\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\treturn this.arcLengthDivisions;\n\n\t},\n\tset: function ( value ) {\n\n\t\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\n\t\tthis.arcLengthDivisions = value;\n\n\t}\n\n} );\n\n//\n\nPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( Light.prototype, {\n\tonlyShadow: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( BufferAttribute.prototype, {\n\n\tlength: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\n\t\t\treturn this.array.length;\n\n\t\t}\n\t},\n\tcopyIndicesArray: function ( /* indices */ ) {\n\n\t\tconsole.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );\n\n\t}\n\n} );\n\nObject.assign( BufferGeometry.prototype, {\n\n\taddIndex: function ( index ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\tthis.setIndex( index );\n\n\t},\n\taddDrawCall: function ( start, count, indexOffset ) {\n\n\t\tif ( indexOffset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\n\t\t}\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\tthis.addGroup( start, count );\n\n\t},\n\tclearDrawCalls: function () {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\tthis.clearGroups();\n\n\t},\n\tcomputeTangents: function () {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\n\t},\n\tcomputeOffsets: function () {\n\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\n\t}\n\n} );\n\nObject.defineProperties( BufferGeometry.prototype, {\n\n\tdrawcalls: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.assign( ExtrudeBufferGeometry.prototype, {\n\n\tgetArrays: function () {\n\n\t\tconsole.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );\n\n\t},\n\n\taddShapeList: function () {\n\n\t\tconsole.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );\n\n\t},\n\n\taddShape: function () {\n\n\t\tconsole.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );\n\n\t}\n\n} );\n\n//\n\nObject.defineProperties( Uniform.prototype, {\n\n\tdynamic: {\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\n\t\t}\n\t},\n\tonUpdate: {\n\t\tvalue: function () {\n\n\t\t\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n\t\t\treturn this;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.defineProperties( Material.prototype, {\n\n\twrapAround: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\n\n\t\t}\n\t},\n\n\toverdraw: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .overdraw has been removed.' );\n\n\t\t}\n\t},\n\n\twrapRGB: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\n\t\t\treturn new Color();\n\n\t\t}\n\t},\n\n\tshading: {\n\t\tget: function () {\n\n\t\t\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\n\t\t\tthis.flatShading = ( value === FlatShading );\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( MeshPhongMaterial.prototype, {\n\n\tmetal: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\treturn false;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\n\t\t}\n\t}\n\n} );\n\nObject.defineProperties( ShaderMaterial.prototype, {\n\n\tderivatives: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.assign( WebGLRenderer.prototype, {\n\n\tclearTarget: function ( renderTarget, color, depth, stencil ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t},\n\n\tanimate: function ( callback ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );\n\t\tthis.setAnimationLoop( callback );\n\n\t},\n\n\tgetCurrentRenderTarget: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\n\t\treturn this.getRenderTarget();\n\n\t},\n\n\tgetMaxAnisotropy: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\n\t\treturn this.capabilities.getMaxAnisotropy();\n\n\t},\n\n\tgetPrecision: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\n\t\treturn this.capabilities.precision;\n\n\t},\n\n\tresetGLState: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\n\t\treturn this.state.reset();\n\n\t},\n\n\tsupportsFloatTextures: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_float' );\n\n\t},\n\tsupportsHalfFloatTextures: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\n\t},\n\tsupportsStandardDerivatives: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\n\t},\n\tsupportsCompressedTextureS3TC: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t},\n\tsupportsCompressedTexturePVRTC: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t},\n\tsupportsBlendMinMax: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\n\t},\n\tsupportsVertexTextures: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\n\t\treturn this.capabilities.vertexTextures;\n\n\t},\n\tsupportsInstancedArrays: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\n\t},\n\tenableScissorTest: function ( boolean ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\tthis.setScissorTest( boolean );\n\n\t},\n\tinitMaterial: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\n\t},\n\taddPrePlugin: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\n\t},\n\taddPostPlugin: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\n\t},\n\tupdateShadowMap: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\n\t},\n\tsetFaceCulling: function () {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );\n\n\t}\n\n} );\n\nObject.defineProperties( WebGLRenderer.prototype, {\n\n\tshadowMapEnabled: {\n\t\tget: function () {\n\n\t\t\treturn this.shadowMap.enabled;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\n\t\t\treturn this.shadowMap.type;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t}\n} );\n\nObject.defineProperties( WebGLShadowMap.prototype, {\n\n\tcullFace: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function ( /* cullFace */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\trenderReverseSided: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t},\n\trenderSingleSided: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\t\t\treturn undefined;\n\n\t\t},\n\t\tset: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.defineProperties( WebGLRenderTarget.prototype, {\n\n\twrapS: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\n\t\t},\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\n\t\t}\n\t}\n\n} );\n\n//\n\nObject.defineProperties( WebVRManager.prototype, {\n\n\tstanding: {\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebVRManager: .standing has been removed.' );\n\n\t\t}\n\t},\n\tuserHeight: {\n\t\tset: function ( /* value */ ) {\n\n\t\t\tconsole.warn( 'THREE.WebVRManager: .userHeight has been removed.' );\n\n\t\t}\n\t}\n\n} );\n\n//\n\nAudio.prototype.load = function ( file ) {\n\n\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\n\tvar scope = this;\n\tvar audioLoader = new AudioLoader();\n\taudioLoader.load( file, function ( buffer ) {\n\n\t\tscope.setBuffer( buffer );\n\n\t} );\n\treturn this;\n\n};\n\nAudioAnalyser.prototype.getData = function () {\n\n\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\treturn this.getFrequencyData();\n\n};\n\n//\n\nCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\n\n\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\n\treturn this.update( renderer, scene );\n\n};\n\n//\n\nvar GeometryUtils = {\n\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\t\tvar matrix;\n\n\t\tif ( geometry2.isMesh ) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t}\n\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t},\n\n\tcenter: function ( geometry ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\treturn geometry.center();\n\n\t}\n\n};\n\nImageUtils.crossOrigin = undefined;\n\nImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {\n\n\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\tvar loader = new TextureLoader();\n\tloader.setCrossOrigin( this.crossOrigin );\n\n\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\tif ( mapping ) texture.mapping = mapping;\n\n\treturn texture;\n\n};\n\nImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {\n\n\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\tvar loader = new CubeTextureLoader();\n\tloader.setCrossOrigin( this.crossOrigin );\n\n\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\tif ( mapping ) texture.mapping = mapping;\n\n\treturn texture;\n\n};\n\nImageUtils.loadCompressedTexture = function () {\n\n\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n};\n\nImageUtils.loadCompressedTextureCube = function () {\n\n\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n};\n\n//\n\nfunction Projector() {\n\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function () {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n}\n\n//\n\nfunction CanvasRenderer() {\n\n\tconsole.error( 'THREE.CanvasRenderer has been removed' );\n\n}\n\n//\n\nfunction JSONLoader() {\n\n\tconsole.error( 'THREE.JSONLoader has been removed.' );\n\n}\n\n//\n\nvar SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( /* geometry, materials */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\n\t},\n\n\tdetach: function ( /* child, parent, scene */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\n\t},\n\n\tattach: function ( /* child, scene, parent */ ) {\n\n\t\tconsole.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );\n\n\t}\n\n};\n\n//\n\nfunction LensFlare() {\n\n\tconsole.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );\n\n}\n\n\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/three/build/three.module.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://THREEAR/./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./node_modules/vm-browserify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/vm-browserify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var indexOf = __webpack_require__(/*! indexof */ \"./node_modules/indexof/index.js\");\n\nvar Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar defineProp = (function() {\n    try {\n        Object.defineProperty({}, '_', {});\n        return function(obj, name, value) {\n            Object.defineProperty(obj, name, {\n                writable: true,\n                enumerable: false,\n                configurable: true,\n                value: value\n            })\n        };\n    } catch(e) {\n        return function(obj, name, value) {\n            obj[name] = value;\n        };\n    }\n}());\n\nvar globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',\n'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',\n'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',\n'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',\n'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];\n\nfunction Context() {}\nContext.prototype = {};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInContext = function (context) {\n    if (!(context instanceof Context)) {\n        throw new TypeError(\"needs a 'context' argument.\");\n    }\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    var wEval = win.eval, wExecScript = win.execScript;\n\n    if (!wEval && wExecScript) {\n        // win.eval() magically appears when this is called in IE:\n        wExecScript.call(win, 'null');\n        wEval = win.eval;\n    }\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n    forEach(globals, function (key) {\n        if (context[key]) {\n            win[key] = context[key];\n        }\n    });\n    \n    var winKeys = Object_keys(win);\n\n    var res = wEval.call(win, this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        // Avoid copying circular objects like `top` and `window` by only\n        // updating existing context properties or new properties in the `win`\n        // that was only introduced after the eval.\n        if (key in context || indexOf(winKeys, key) === -1) {\n            context[key] = win[key];\n        }\n    });\n\n    forEach(globals, function (key) {\n        if (!(key in context)) {\n            defineProp(context, key, win[key]);\n        }\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInNewContext = function (context) {\n    var ctx = Script.createContext(context);\n    var res = this.runInContext(ctx);\n\n    forEach(Object_keys(ctx), function (key) {\n        context[key] = ctx[key];\n    });\n\n    return res;\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    var copy = new Context();\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n\n\n//# sourceURL=webpack://THREEAR/./node_modules/vm-browserify/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://THREEAR/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack://THREEAR/(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/ARBaseControls.ts":
/*!*******************************!*\
  !*** ./src/ARBaseControls.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar three_1 = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nvar ARBaseControls = /** @class */ (function (_super) {\n    __extends(ARBaseControls, _super);\n    function ARBaseControls(object3d) {\n        var _this = _super.call(this) || this;\n        _this.id = ARBaseControls.id++;\n        _this.object3d = object3d;\n        _this.object3d.matrixAutoUpdate = false;\n        _this.object3d.visible = false;\n        return _this;\n    }\n    ARBaseControls.prototype.update = function () {\n        throw Error(\"update(): you need to implement your own update \");\n    };\n    ARBaseControls.prototype.name = function () {\n        throw Error(\"name(): Not yet implemented \");\n    };\n    ARBaseControls.id = 0;\n    return ARBaseControls;\n}(three_1.EventDispatcher));\nexports.ARBaseControls = ARBaseControls;\nexports.default = ARBaseControls;\n\n\n//# sourceURL=webpack://THREEAR/./src/ARBaseControls.ts?");

/***/ }),

/***/ "./src/ARCameraParam.ts":
/*!******************************!*\
  !*** ./src/ARCameraParam.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ARToolkitAPI_1 = __webpack_require__(/*! ./ARToolkitAPI */ \"./src/ARToolkitAPI.ts\");\n/**\n * ARCameraParam is used for loading AR camera parameters for use with ARController.\n * Use by passing in an URL and a callback function.\n * var camera = new ARCameraParam('Data/camera_para.dat', function() {\n * \t console.log('loaded camera', this.id);\n * },\n * function(err) {\n *   console.log('failed to load camera', err);\n * });\n * @exports ARCameraParam\n * @constructor\n * @param {string} src URL to load camera parameters from.\n * @param {string} onload Onload callback to be called on successful parameter loading.\n * @param {string} onerror Error callback to called when things don't work out.\n */\nvar ARCameraParam = /** @class */ (function () {\n    function ARCameraParam(src, onload, onerror) {\n        this.id = -1;\n        this._src = \"\";\n        this.complete = false;\n        this.onload = onload;\n        this.onerror = onerror;\n        if (src) {\n            this.load(src);\n        }\n    }\n    /**\n     * Loads the given URL as camera parameters definition file into this ARCameraParam.\n     * Can only be called on an unloaded ARCameraParam instance.\n     * @param {string} src URL to load.\n     */\n    ARCameraParam.prototype.load = function (src) {\n        var _this = this;\n        if (this._src !== \"\") {\n            throw new Error((\"ARCameraParam: Trying to load camera parameters twice.\"));\n        }\n        this._src = src;\n        if (src) {\n            ARToolkitAPI_1.default.loadCamera(src, function (id) {\n                _this.id = id;\n                _this.complete = true;\n                _this.onload();\n            }, function (err) {\n                _this.onerror(err);\n            });\n        }\n    };\n    Object.defineProperty(ARCameraParam.prototype, \"src\", {\n        get: function () {\n            return this._src;\n        },\n        set: function (src) {\n            this.load(src);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Destroys the camera parameter and frees associated Emscripten resources.\n     */\n    ARCameraParam.prototype.dispose = function () {\n        if (this.id !== -1) {\n            ARToolkitAPI_1.default.deleteCamera(this.id);\n        }\n        this.id = -1;\n        this._src = \"\";\n        this.complete = false;\n    };\n    return ARCameraParam;\n}());\nexports.ARCameraParam = ARCameraParam;\nexports.default = ARCameraParam;\n\n\n//# sourceURL=webpack://THREEAR/./src/ARCameraParam.ts?");

/***/ }),

/***/ "./src/ARContext.ts":
/*!**************************!*\
  !*** ./src/ARContext.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ARToolkitAPI_1 = __webpack_require__(/*! ./ARToolkitAPI */ \"./src/ARToolkitAPI.ts\");\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nvar ARMarkerControls_1 = __webpack_require__(/*! ./ARMarkerControls */ \"./src/ARMarkerControls.ts\");\nvar ARCameraParam_1 = __webpack_require__(/*! ./ARCameraParam */ \"./src/ARCameraParam.ts\");\nvar ARController_1 = __webpack_require__(/*! ./ARController */ \"./src/ARController.ts\");\nvar ARContext = /** @class */ (function (_super) {\n    __extends(ARContext, _super);\n    function ARContext(parameters) {\n        var _this = _super.call(this) || this;\n        // handle default parameters\n        _this.parameters = {\n            // AR backend - ['artoolkit', 'aruco', 'tango']\n            trackingBackend: \"artoolkit\",\n            // debug - true if one should display artoolkit debug canvas, false otherwise\n            debug: false,\n            // the mode of detection - ['color', 'color_and_matrix', 'mono', 'mono_and_matrix']\n            detectionMode: \"mono\",\n            // type of matrix code - valid iif detectionMode end with 'matrix' -\n            // [3x3, 3x3_HAMMING63, 3x3_PARITY65, 4x4, 4x4_BCH_13_9_3, 4x4_BCH_13_5_5]\n            matrixCodeType: \"3x3\",\n            // url of the camera parameters\n            cameraParametersUrl: \"../data/camera_para.dat\",\n            // tune the maximum rate of pose detection in the source image\n            maxDetectionRate: 60,\n            // resolution of at which we detect pose in the source image\n            canvasWidth: 640,\n            canvasHeight: 480,\n            // the patternRatio inside the artoolkit marker - artoolkit only\n            patternRatio: 0.5,\n            // enable image smoothing or not for canvas copy - default to true\n            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled\n            imageSmoothingEnabled: false,\n        };\n        _this.initialized = false;\n        _this.arController = null;\n        _this._updatedAt = null;\n        _this._arMarkerControls = [];\n        return _this;\n    }\n    ARContext.prototype.init = function (onCompleted) {\n        var _this = this;\n        var done = function () {\n            // dispatch event\n            _this.dispatchEvent({\n                type: \"initialized\",\n            });\n            _this.initialized = true;\n            if (onCompleted) {\n                onCompleted();\n            }\n        };\n        if (this.parameters.trackingBackend === \"artoolkit\") {\n            this._initArtoolkit(done);\n        }\n        else {\n            console.assert(false);\n        }\n    };\n    ARContext.prototype.update = function (srcElement) {\n        // be sure arController is fully initialized\n        if (this.parameters.trackingBackend === \"artoolkit\" && this.arController === null) {\n            return false;\n        }\n        // honor this.parameters.maxDetectionRate\n        var present = performance.now();\n        if (this._updatedAt !== null &&\n            present - this._updatedAt < 1000 / this.parameters.maxDetectionRate) {\n            return false;\n        }\n        this._updatedAt = present;\n        // mark all markers to invisible before processing this frame\n        this._arMarkerControls.forEach(function (markerControls) {\n            markerControls.object3d.visible = false;\n        });\n        // process this frame\n        if (this.parameters.trackingBackend === \"artoolkit\") {\n            this._updateArtoolkit(srcElement);\n        }\n        else {\n            console.assert(false);\n        }\n        // dispatch event\n        this.dispatchEvent({\n            type: \"sourceProcessed\",\n        });\n        // return true as we processed the frame\n        return true;\n    };\n    ARContext.prototype.addMarker = function (arMarkerControls) {\n        console.assert(arMarkerControls instanceof ARMarkerControls_1.ARMarkerControls);\n        this._arMarkerControls.push(arMarkerControls);\n    };\n    ARContext.prototype.removeMarker = function (arMarkerControls) {\n        console.assert(arMarkerControls instanceof ARMarkerControls_1.ARMarkerControls);\n        var index = this._arMarkerControls.indexOf(arMarkerControls);\n        this._arMarkerControls.splice(index, 1);\n    };\n    ARContext.prototype._initArtoolkit = function (onCompleted) {\n        var _this = this;\n        // set this._artoolkitProjectionAxisTransformMatrix to change artoolkit\n        // projection matrix axis to match usual` webgl one\n        this._artoolkitProjectionAxisTransformMatrix = new THREE.Matrix4();\n        this._artoolkitProjectionAxisTransformMatrix.multiply(new THREE.Matrix4().makeRotationY(Math.PI));\n        this._artoolkitProjectionAxisTransformMatrix.multiply(new THREE.Matrix4().makeRotationZ(Math.PI));\n        // get cameraParameters\n        var cameraParameters = new ARCameraParam_1.default(this.parameters.cameraParametersUrl, function () {\n            // init controller\n            var arController = new ARController_1.ARController(_this.parameters.canvasWidth, _this.parameters.canvasHeight, cameraParameters);\n            _this.arController = arController;\n            // honor this.parameters.imageSmoothingEnabled\n            arController.ctx.mozImageSmoothingEnabled = _this.parameters.imageSmoothingEnabled;\n            arController.ctx.webkitImageSmoothingEnabled = _this.parameters.imageSmoothingEnabled;\n            arController.ctx.msImageSmoothingEnabled = _this.parameters.imageSmoothingEnabled;\n            arController.ctx.imageSmoothingEnabled = _this.parameters.imageSmoothingEnabled;\n            // honor this.parameters.debug\n            if (_this.parameters.debug === true) {\n                arController.debugSetup();\n                arController.canvas.style.position = \"absolute\";\n                arController.canvas.style.top = \"0px\";\n                arController.canvas.style.opacity = \"0.6\";\n                arController.canvas.style.pointerEvents = \"none\";\n                arController.canvas.style.zIndex = \"-1\";\n            }\n            // setPatternDetectionMode\n            var detectionModes = {\n                color: ARToolkitAPI_1.default.AR_TEMPLATE_MATCHING_COLOR,\n                color_and_matrix: ARToolkitAPI_1.default.AR_TEMPLATE_MATCHING_COLOR_AND_MATRIX,\n                mono: ARToolkitAPI_1.default.AR_TEMPLATE_MATCHING_MONO,\n                mono_and_matrix: ARToolkitAPI_1.default.AR_TEMPLATE_MATCHING_MONO_AND_MATRIX,\n            };\n            var detectionMode = detectionModes[_this.parameters.detectionMode];\n            arController.setPatternDetectionMode(detectionMode);\n            // setMatrixCodeType\n            var matrixCodeTypes = {\n                \"3x3\": ARToolkitAPI_1.default.AR_MATRIX_CODE_3x3,\n                \"3x3_HAMMING63\": ARToolkitAPI_1.default.AR_MATRIX_CODE_3x3_HAMMING63,\n                \"3x3_PARITY65\": ARToolkitAPI_1.default.AR_MATRIX_CODE_3x3_PARITY65,\n                \"4x4\": ARToolkitAPI_1.default.AR_MATRIX_CODE_4x4,\n                \"4x4_BCH_13_9_3\": ARToolkitAPI_1.default.AR_MATRIX_CODE_4x4_BCH_13_9_3,\n                \"4x4_BCH_13_5_5\": ARToolkitAPI_1.default.AR_MATRIX_CODE_4x4_BCH_13_5_5,\n            };\n            var matrixCodeType = matrixCodeTypes[_this.parameters.matrixCodeType];\n            arController.setMatrixCodeType(matrixCodeType);\n            // set the patternRatio for artoolkit\n            arController.setPattRatio(_this.parameters.patternRatio);\n            // set thresholding in artoolkit\n            // this seems to be the default\n            // arController.setThresholdMode(artoolkit.AR_LABELING_THRESH_MODE_MANUAL)\n            // adatative consume a LOT of cpu...\n            // arController.setThresholdMode(artoolkit.AR_LABELING_THRESH_MODE_AUTO_ADAPTIVE)\n            // arController.setThresholdMode(artoolkit.AR_LABELING_THRESH_MODE_AUTO_OTSU)\n            // notify\n            onCompleted();\n        }, function (err) {\n            throw err;\n            // onerror\n        });\n        return this;\n    };\n    ARContext.prototype.getProjectionMatrix = function (srcElement) {\n        // FIXME rename this function to say it is artoolkit specific - getArtoolkitProjectMatrix\n        // keep a backward compatibility with a console.warn\n        console.assert(this.parameters.trackingBackend === \"artoolkit\");\n        console.assert(this.arController, \"arController MUST be initialized to call this function\");\n        // get projectionMatrixArr from artoolkit\n        var projectionMatrixArr = this.arController.getCameraMatrix();\n        var projectionMatrix = new THREE.Matrix4().fromArray(projectionMatrixArr);\n        // apply context._axisTransformMatrix - change artoolkit axis to match usual webgl one\n        projectionMatrix.multiply(this._artoolkitProjectionAxisTransformMatrix);\n        // return the result\n        return projectionMatrix;\n    };\n    ARContext.prototype._updateArtoolkit = function (srcElement) {\n        this.arController.process(srcElement);\n    };\n    return ARContext;\n}(THREE.EventDispatcher));\nexports.ARContext = ARContext;\nexports.default = ARContext;\n\n\n//# sourceURL=webpack://THREEAR/./src/ARContext.ts?");

/***/ }),

/***/ "./src/ARController.ts":
/*!*****************************!*\
  !*** ./src/ARController.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ARToolkitAPI_1 = __webpack_require__(/*! ./ARToolkitAPI */ \"./src/ARToolkitAPI.ts\");\nvar ARCameraParam_1 = __webpack_require__(/*! ./ARCameraParam */ \"./src/ARCameraParam.ts\");\n/**\n * The ARController is the main object for doing AR marker detection with JSARToolKit.\n *\n * \tTo use an ARController, you need to tell it the dimensions to use for the AR processing canvas and\n * \tpass it an ARCameraParam to define the camera parameters to use when processing images.\n * \tThe ARCameraParam defines the lens distortion and aspect ratio of the camera used.\n * \tSee https://www.artoolworks.com/support/library/Calibrating_your_camera for\n *  more information about AR camera parameteters and how to make and use them.\n *\n * \tIf you pass an image as the first argument, the ARController uses that as the image to process,\n * \tusing the dimensions of the image as AR processing canvas width and height. If the first argument\n * \tto ARController is an image, the second argument is used as the camera param.\n *\n * The camera parameters argument can be either an ARCameraParam or an URL to a camera definition file.\n * If the camera argument is an URL, it is loaded into a new ARCameraParam, and the ARController dispatches\n * a 'load' event and calls the onload method if it is defined.\n *\n * @exports ARController\n * @constructor\n * @param {number} width The width of the images to process.\n * @param {number} height The height of the images to process.\n * @param {ARCameraParam | string} camera The ARCameraParam to use for image processing.\n * If this is a string, the ARController treats it as an URL and tries to load it as a\n * ARCameraParam definition file, calling ARController#onload on success.\n */\nvar ARController = /** @class */ (function () {\n    function ARController(width, height, camera) {\n        var _this = this;\n        var w = width;\n        var h = height;\n        this.orientation = \"landscape\";\n        this.listeners = {};\n        if (typeof width !== \"number\") {\n            var image = width;\n            camera = height;\n            w = image.videoWidth || image.width;\n            h = image.videoHeight || image.height;\n            this.image = image;\n        }\n        this.defaultMarkerWidth = 1;\n        this.patternMarkers = {};\n        this.barcodeMarkers = {};\n        this.transformMat = new Float32Array(16);\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.width = w;\n        this.canvas.height = h;\n        this.ctx = this.canvas.getContext(\"2d\");\n        this.videoWidth = w;\n        this.videoHeight = h;\n        if (typeof camera === \"string\") {\n            this.cameraParam = new ARCameraParam_1.default(camera, function () {\n                _this._initialize();\n            }, function (err) {\n                throw Error(\"ARController: Failed to load ARCameraParam \" + err);\n            });\n        }\n        else {\n            this.cameraParam = camera;\n            this._initialize();\n        }\n    }\n    /**\n     * Destroys the ARController instance and frees all associated resources.\n     * After calling dispose, the ARController can't be used any longer. Make a new one if you need one.\n     * Calling this avoids leaking Emscripten memory, which may be important if you're\n     * using multiple ARControllers.\n     */\n    ARController.prototype.dispose = function () {\n        ARToolkitAPI_1.default.teardown(this.id);\n        for (var t in this) {\n            if (t) {\n                this[t] = null;\n            }\n        }\n    };\n    /**\n     * Detects markers in the given image. The process method dispatches marker detection events during its run.\n     *\n     * The marker detection process proceeds by first dispatching a markerNum event that tells you how many\n     * markers were found in the image. Next, a getMarker event is dispatched for each found marker square.\n     * finally, getMultiMarker is dispatched for every found multimarker\n     * followed by getMultiMarkerSub events\n     * dispatched for each of the markers in the multimarker.\n     * arController.addEventListener('markerNum', function(ev) {\n     * console.log(\"Detected \" + ev.data + \" markers.\")\n     * });\n     * arController.addEventListener('getMarker', function(ev) {\n     * console.log(\"Detected marker with ids:\", ev.data.marker.id, ev.data.marker.idPatt, ev.data.marker.idMatrix);\n     * console.log(\"Marker data\", ev.data.marker);\n     * console.log(\"Marker transform matrix:\", [].join.call(ev.data.matrix, ', '));\n     * });\n     * arController.addEventListener('getMultiMarker', function(ev) {\n     * console.log(\"Detected multimarker with id:\", ev.data.multiMarkerId);\n     * });\n     * arController.addEventListener('getMultiMarkerSub', function(ev) {\n     * console.log(\"Submarker for \" + ev.data.multiMarkerId, ev.data.markerIndex, ev.data.marker);\n     * });\n     * arController.process(image);\n     * If no image is given, defaults to this.image.\n     * If the debugSetup has been called, draws debug markers on the debug canvas.\n     * @param {HTMLImageElement|HTMLVideoElement} [image] The image to process [optional].\n     */\n    ARController.prototype.process = function (image) {\n        this.detectMarker(image);\n        // TODO: Figure out why this always returns 0?\n        var markerNum = this.getMarkerNum();\n        var k;\n        var o;\n        for (k in this.patternMarkers) {\n            if (k) {\n                o = this.patternMarkers[k];\n                o.inPrevious = o.inCurrent;\n                o.inCurrent = false;\n            }\n        }\n        for (k in this.barcodeMarkers) {\n            if (k) {\n                o = this.barcodeMarkers[k];\n                o.inPrevious = o.inCurrent;\n                o.inCurrent = false;\n            }\n        }\n        var visible;\n        var multiEachMarkerInfo;\n        for (var i = 0; i < markerNum; i++) {\n            var markerInfo = this.getMarker(i);\n            var markerType = ARToolkitAPI_1.default.UNKNOWN_MARKER;\n            visible = this.trackPatternMarkerId(-1);\n            if (markerInfo.idPatt > -1 && (markerInfo.id === markerInfo.idPatt ||\n                markerInfo.idMatrix === -1)) {\n                visible = this.trackPatternMarkerId(markerInfo.idPatt);\n                markerType = ARToolkitAPI_1.default.PATTERN_MARKER;\n                if (markerInfo.dir !== markerInfo.dirPatt) {\n                    this.setMarkerInfoDir(i, markerInfo.dirPatt);\n                }\n            }\n            else if (markerInfo.idMatrix > -1) {\n                visible = this.trackBarcodeMarkerId(markerInfo.idMatrix);\n                markerType = ARToolkitAPI_1.default.BARCODE_MARKER;\n                if (markerInfo.dir !== markerInfo.dirMatrix) {\n                    this.setMarkerInfoDir(i, markerInfo.dirMatrix);\n                }\n            }\n            if (markerType !== ARToolkitAPI_1.default.UNKNOWN_MARKER && visible.inPrevious) {\n                this.getTransMatSquareCont(i, visible.markerWidth, visible.matrix, visible.matrix);\n            }\n            else {\n                this.getTransMatSquare(i, visible.markerWidth, visible.matrix);\n            }\n            visible.inCurrent = true;\n            this.transMatToGLMat(visible.matrix, this.transformMat);\n            this.dispatchEvent({\n                name: \"getMarker\",\n                target: this,\n                data: {\n                    index: i,\n                    type: markerType,\n                    marker: markerInfo,\n                    matrix: this.transformMat\n                }\n            });\n        }\n        var multiMarkerCount = this.getMultiMarkerCount();\n        for (var i = 0; i < multiMarkerCount; i++) {\n            var subMarkerCount = this.getMultiMarkerPatternCount(i);\n            visible = false;\n            ARToolkitAPI_1.default.getTransMatMultiSquareRobust(this.id, i);\n            this.transMatToGLMat(this.markerTransformMat, this.transformMat);\n            for (var j = 0; j < subMarkerCount; j++) {\n                multiEachMarkerInfo = this.getMultiEachMarker(i, j);\n                if (multiEachMarkerInfo.visible >= 0) {\n                    visible = true;\n                    this.dispatchEvent({\n                        name: \"getMultiMarker\",\n                        target: this,\n                        data: {\n                            multiMarkerId: i,\n                            matrix: this.transformMat\n                        }\n                    });\n                    break;\n                }\n            }\n            if (visible) {\n                for (var j = 0; j < subMarkerCount; j++) {\n                    multiEachMarkerInfo = this.getMultiEachMarker(i, j);\n                    this.transMatToGLMat(this.markerTransformMat, this.transformMat);\n                    this.dispatchEvent({\n                        name: \"getMultiMarkerSub\",\n                        target: this,\n                        data: {\n                            multiMarkerId: i,\n                            markerIndex: j,\n                            marker: multiEachMarkerInfo,\n                            matrix: this.transformMat\n                        }\n                    });\n                }\n            }\n        }\n        if (this._bwpointer) {\n            this.debugDraw();\n        }\n    };\n    /**\n     * Adds the given pattern marker ID to the index of tracked IDs.\n     * Sets the markerWidth for the pattern marker to markerWidth.\n     * Used by process() to implement continuous tracking,\n     * keeping track of the marker's transformation matrix\n     * and customizable marker widths.\n     * @param {number} id ID of the pattern marker to track.\n     * @param {number} [markerWidth] The width of the marker to track.\n     * @return {Object} The marker tracking object.\n     */\n    ARController.prototype.trackPatternMarkerId = function (id, markerWidth) {\n        var obj = this.patternMarkers[id];\n        if (!obj) {\n            this.patternMarkers[id] = obj = {\n                inPrevious: false,\n                inCurrent: false,\n                matrix: new Float32Array(12),\n                markerWidth: markerWidth || this.defaultMarkerWidth\n            };\n        }\n        if (markerWidth) {\n            obj.markerWidth = markerWidth;\n        }\n        return obj;\n    };\n    /**\n     * Adds the given barcode marker ID to the index of tracked IDs.\n     * Sets the markerWidth for the pattern marker to markerWidth.\n     * Used by process() to implement continuous tracking,\n     * keeping track of the marker's transformation matrix\n     * and customizable marker widths.\n     * @param {number} id ID of the barcode marker to track.\n     * @param {number} [markerWidth] The width of the marker to track.\n     * @return {Object} The marker tracking object.\n     */\n    ARController.prototype.trackBarcodeMarkerId = function (id, markerWidth) {\n        var obj = this.barcodeMarkers[id];\n        if (!obj) {\n            this.barcodeMarkers[id] = obj = {\n                inPrevious: false,\n                inCurrent: false,\n                matrix: new Float32Array(12),\n                markerWidth: markerWidth || this.defaultMarkerWidth\n            };\n        }\n        if (markerWidth) {\n            obj.markerWidth = markerWidth;\n        }\n        return obj;\n    };\n    /**\n     * Returns the number of multimarkers registered on this ARController.\n     * @return {number} Number of multimarkers registered.\n     */\n    ARController.prototype.getMultiMarkerCount = function () {\n        return ARToolkitAPI_1.default.getMultiMarkerCount(this.id);\n    };\n    /**\n     * Returns the number of markers in the multimarker registered for the given multiMarkerId.\n     * @param {number} multiMarkerId The id number of the multimarker to access. Given by loadMultiMarker.\n     * @return {number} Number of markers in the multimarker. Negative value indicates failure to find the multimarker.\n     */\n    ARController.prototype.getMultiMarkerPatternCount = function (multiMarkerId) {\n        return ARToolkitAPI_1.default.getMultiMarkerNum(this.id, multiMarkerId);\n    };\n    /**\n     * Add an event listener on this ARController for the named event, calling the callback function\n     * whenever that event is dispatched.\n     *\n     * Possible events are:\n     *  - getMarker - dispatched whenever process() finds a square marker\n     *  - getMultiMarker - dispatched whenever process() finds a visible registered multimarker\n     *  - getMultiMarkerSub - dispatched by process() for each marker in a visible multimarker\n     *  - load - dispatched when the ARController is ready to use (useful if passing in a camera URL in the constructor)\n     *  @param {string} name Name of the event to listen to.\n     * @param {function} callback Callback function to call when an event with the given name is dispatched.\n     */\n    ARController.prototype.addEventListener = function (name, callback) {\n        if (!this.listeners[name]) {\n            this.listeners[name] = [];\n        }\n        this.listeners[name].push(callback);\n    };\n    /**\n     * Remove an event listener from the named event.\n     * @param {string} name Name of the event to stop listening to.\n     * @param {function} callback Callback function to remove from the listeners of the named event.\n     */\n    ARController.prototype.removeEventListener = function (name, callback) {\n        if (this.listeners[name]) {\n            var index = this.listeners[name].indexOf(callback);\n            if (index > -1) {\n                this.listeners[name].splice(index, 1);\n            }\n        }\n    };\n    /**\n     * Dispatches the given event to all registered listeners on event.name.\n     * @param {Object} event Event to dispatch.\n     */\n    ARController.prototype.dispatchEvent = function (event) {\n        var listeners = this.listeners[event.name];\n        if (listeners) {\n            for (var i = 0; i < listeners.length; i++) {\n                listeners[i].call(this, event);\n            }\n        }\n    };\n    ;\n    /**\n     * Sets up a debug canvas for the AR detection. Draws a red marker on top of each detected square in the image.\n     * The debug canvas is added to document.body.\n     */\n    ARController.prototype.debugSetup = function () {\n        document.body.appendChild(this.canvas);\n        this.setDebugMode(1);\n        this._bwpointer = this.getProcessingImage();\n    };\n    /**\n     * Loads a pattern marker from the given URL and calls the onSuccess callback with the UID of the marker.\n     * arController.loadMarker(markerURL, onSuccess, onError);\n     * @param {string} markerURL - The URL of the marker pattern file to load.\n     * @param {function} onSuccess - The success callback. Called with the id of the loaded marker on a successful load.\n     * @param {function} onError - The error callback. Called with the encountered error if the load fails.\n     */\n    ARController.prototype.loadMarker = function (markerURL, onSuccess, onError) {\n        return ARToolkitAPI_1.default.addMarker(this.id, markerURL, onSuccess, onError);\n    };\n    /**\n     * Loads a multimarker from the given URL and calls the onSuccess callback with the UID of the marker.\n     * arController.loadMultiMarker(markerURL, onSuccess, onError);\n     * @param {string} markerURL - The URL of the multimarker pattern file to load.\n     * @param {function} onSuccess - The success callback. Called with the id and the\n     * number of sub-markers of the loaded marker on a successful load.\n     * @param {function} onError - The error callback. Called with the encountered error if the load fails.\n     */\n    ARController.prototype.loadMultiMarker = function (markerURL, onSuccess, onError) {\n        return ARToolkitAPI_1.default.addMultiMarker(this.id, markerURL, onSuccess, onError);\n    };\n    /**\n     * Populates the provided float array with the current transformation for the specified marker. After\n     * a call to detectMarker, all marker information will be current. Marker transformations can then be\n     * checked.\n     * @param {number} markerUID\tThe unique identifier (UID) of the marker to query\n     * @param {number} markerWidth\tThe width of the marker\n     * @param {Float64Array} dst\tThe float array to populate with the 3x4 marker transformation matrix\n     * @return\t{Float64Array} The dst array.\n     */\n    ARController.prototype.getTransMatSquare = function (markerUID, markerWidth, dst) {\n        ARToolkitAPI_1.default.getTransMatSquare(this.id, markerUID, markerWidth);\n        dst.set(this.markerTransformMat);\n        return dst;\n    };\n    /**\n     * Populates the provided float array with the current transformation for the specified marker, using\n     * previousMarkerTransform as the previously detected transformation. After\n     * a call to detectMarker, all marker information will be current. Marker transformations can then be\n     * checked.\n     * @param {number} markerUID\tThe unique identifier (UID) of the marker to query\n     * @param {number} markerWidth\tThe width of the marker\n     * @param {Float64Array} previousMarkerTransform\tThe float array to use as the previous\n     * 3x4 marker transformation matrix\n     * @param {Float64Array} dst\tThe float array to populate with the 3x4 marker transformation matrix\n     * @return\t{Float64Array} The dst array.\n     */\n    ARController.prototype.getTransMatSquareCont = function (markerUID, markerWidth, previousMarkerTransform, dst) {\n        this.markerTransformMat.set(previousMarkerTransform);\n        ARToolkitAPI_1.default.getTransMatSquareCont(this.id, markerUID, markerWidth);\n        dst.set(this.markerTransformMat);\n        return dst;\n    };\n    /**\n     * Populates the provided float array with the current transformation for the specified multimarker. After\n     * a call to detectMarker, all marker information will be current. Marker transformations can then be\n     * checked.\n     *\n     * @param {number} markerUID\tThe unique identifier (UID) of the marker to query\n     * @param {Float64Array} dst\tThe float array to populate with the 3x4 marker transformation matrix\n     * @return\t{Float64Array} The dst array.\n     */\n    ARController.prototype.getTransMatMultiSquare = function (markerUID, dst) {\n        ARToolkitAPI_1.default.getTransMatMultiSquare(this.id, markerUID);\n        dst.set(this.markerTransformMat);\n        return dst;\n    };\n    /**\n     * Populates the provided float array with the current robust transformation for the specified multimarker. After\n     * a call to detectMarker, all marker information will be current. Marker transformations can then be\n     * checked.\n     * @param {number} markerUID\tThe unique identifier (UID) of the marker to query\n     * @param {Float64Array} dst\tThe float array to populate with the 3x4 marker transformation matrix\n     * @return\t{Float64Array} The dst array.\n     */\n    ARController.prototype.getTransMatMultiSquareRobust = function (markerUID, dst) {\n        ARToolkitAPI_1.default.getTransMatMultiSquare(this.id, markerUID);\n        dst.set(this.markerTransformMat);\n        return dst;\n    };\n    /**\n     * Converts the given 3x4 marker transformation matrix in the 12-element transMat array\n     * into a 4x4 WebGL matrix and writes the result into the 16-element glMat array.\n     * If scale parameter is given, scales the transform of the glMat by the scale parameter.\n     * @param {Float64Array} transMat The 3x4 marker transformation matrix.\n     * @param {Float64Array} glMat The 4x4 GL transformation matrix.\n     * @param {number} [scale] The scale for the transform.\n     */\n    ARController.prototype.transMatToGLMat = function (transMat, glMat, scale) {\n        glMat[0 + 0 * 4] = transMat[0]; // R1C1\n        glMat[0 + 1 * 4] = transMat[1]; // R1C2\n        glMat[0 + 2 * 4] = transMat[2];\n        glMat[0 + 3 * 4] = transMat[3];\n        glMat[1 + 0 * 4] = transMat[4]; // R2\n        glMat[1 + 1 * 4] = transMat[5];\n        glMat[1 + 2 * 4] = transMat[6];\n        glMat[1 + 3 * 4] = transMat[7];\n        glMat[2 + 0 * 4] = transMat[8]; // R3\n        glMat[2 + 1 * 4] = transMat[9];\n        glMat[2 + 2 * 4] = transMat[10];\n        glMat[2 + 3 * 4] = transMat[11];\n        glMat[3 + 0 * 4] = 0.0;\n        glMat[3 + 1 * 4] = 0.0;\n        glMat[3 + 2 * 4] = 0.0;\n        glMat[3 + 3 * 4] = 1.0;\n        if (scale !== undefined && scale !== 0.0) {\n            glMat[12] *= scale;\n            glMat[13] *= scale;\n            glMat[14] *= scale;\n        }\n        return glMat;\n    };\n    /**\n     * This is the core ARToolKit marker detection function. It calls through to a set of\n     * internal functions to perform the key marker detection steps of binarization and\n     * labelling, contour extraction, and template matching and/or matrix code extraction.\n     * Typically, the resulting set of detected markers is retrieved by calling arGetMarkerNum\n     * to get the number of markers detected and arGetMarker to get an array of ARMarkerInfo\n     * structures with information on each detected marker, followed by a step in which\n     * detected markers are possibly examined for some measure of goodness of match (e.g. by\n     * examining the match confidence value) and pose extraction.\n     * @param {HTMLImageElement|HTMLVideoElement} [image] to be processed to detect markers.\n     * @return {number}     0 if the function proceeded without error, or a value less than 0 in case of error.\n     * A result of 0 does not however, imply any markers were detected.\n     */\n    ARController.prototype.detectMarker = function (image) {\n        if (this._copyImageToHeap(image)) {\n            return ARToolkitAPI_1.default.detectMarker(this.id);\n        }\n        return -99;\n    };\n    /**\n     * Get the number of markers detected in a video frame.\n     * @return {number}     The number of detected markers in the most recent image passed to arDetectMarker.\n     * \tNote that this is actually a count, not an index. A better name for this function would be\n     * \tarGetDetectedMarkerCount, but the current name lives on for historical reasons.\n     */\n    ARController.prototype.getMarkerNum = function () {\n        return ARToolkitAPI_1.default.getMarkerNum(this.id);\n    };\n    /**\n     * Get the marker info struct for the given marker index in detected markers.\n     * Call this.detectMarker first, then use this.getMarkerNum to get the detected marker count.\n     * The returned object is the global artoolkit.markerInfo object and will be overwritten\n     * by subsequent calls. If you need to hang on to it, create a copy using this.cloneMarkerInfo();\n     * Returns undefined if no marker was found.\n     * A markerIndex of -1 is used to access the global custom marker.\n     * The fields of the markerInfo struct are:\n     *  @field area Area in pixels of the largest connected region, comprising\n     *  the marker border and regions connected to it. Note that this is\n     *  not the same as the actual onscreen area inside the marker border.\n     * @field      id If pattern detection mode is either pattern mode OR\n     *  matrix but not both, will be marker ID (>= 0) if marker is valid, or -1 if invalid.\n     * @field      idPatt If pattern detection mode includes a pattern mode,\n     * will be marker ID (>= 0) if marker is valid, or -1 if invalid.\n     * @field      idMatrix If pattern detection mode includes a matrix mode,\n     * will be marker ID (>= 0) if marker is valid, or -1 if invalid.\n     * @field      dir If pattern detection mode is either pattern mode OR matrix\n     * but not both, and id != -1, will be marker direction (range 0 to 3, inclusive).\n     * @field      dirPatt If pattern detection mode includes a pattern mode, and\n     * id != -1, will be marker direction (range 0 to 3, inclusive).\n     * @field      dirMatrix If pattern detection mode includes a matrix mode,\n     * and id != -1, will be marker direction (range 0 to 3, inclusive).\n     * @field      cf If pattern detection mode is either pattern mode OR\n     * matrix but not both, will be marker matching confidence (range 0.0 to 1.0 inclusive)\n     * if marker is valid, or -1.0 if marker is invalid.\n     * @field      cfPatt If pattern detection mode includes a pattern mode,\n     * will be marker matching confidence (range 0.0 to 1.0 inclusive) if marker is valid, or -1.0 if marker is invalid.\n     * @field      cfMatrix If pattern detection mode includes a matrix mode,\n     * will be marker matching confidence (range 0.0 to 1.0 inclusive) if marker is valid, or -1.0 if marker is invalid.\n     * @field      pos 2D position (in camera image coordinates, origin at top-left)\n     * of the centre of the marker.\n     * @field      line Line equations for the 4 sides of the marker.\n     * @field      vertex 2D positions (in camera image coordinates, origin at top-left)\n     * of the corners of the marker. vertex[(4 - dir)%4][] is the top-left corner of the marker.\n     * Other vertices proceed clockwise from this. These are idealised coordinates\n     * (i.e. the onscreen position aligns correctly with the undistorted camera image.)\n     * @param {number} markerIndex The index of the marker to query.\n     * @returns {Object} The markerInfo struct.\n     */\n    ARController.prototype.getMarker = function (markerIndex) {\n        if (0 === ARToolkitAPI_1.default.getMarker(this.id, markerIndex)) {\n            return ARToolkitAPI_1.default.getMarkerInfo();\n        }\n    };\n    /**\n     * Set marker vertices to the given vertexData[4][2] array.\n     * Sets the marker pos to the center of the vertices.\n     * Useful for building custom markers for getTransMatSquare.\n     * A markerIndex of -1 is used to access the global custom marker.\n     * @param {number} markerIndex The index of the marker to edit.\n     * @param {*} vertexData\n     */\n    ARController.prototype.setMarkerInfoVertex = function (markerIndex, vertexData) {\n        for (var i = 0; i < vertexData.length; i++) {\n            this.markerTransformMat[i * 2 + 0] = vertexData[i][0];\n            this.markerTransformMat[i * 2 + 1] = vertexData[i][1];\n        }\n        return ARToolkitAPI_1.default.setMarkerInfoVertex(this.id, markerIndex);\n    };\n    /**\n     * Makes a deep copy of the given marker info.\n     * @param {Object} markerInfo The marker info object to copy.\n     * @return {Object} The new copy of the marker info.\n     */\n    ARController.prototype.cloneMarkerInfo = function (markerInfo) {\n        return JSON.parse(JSON.stringify(markerInfo));\n    };\n    /**\n     * Get the marker info struct for the given marker index in detected markers.\n     * Call this.detectMarker first, then use this.getMarkerNum to get the detected marker count.\n     * The returned object is the global artoolkit.markerInfo object and will be overwritten\n     * by subsequent calls. If you need to hang on to it, create a copy using this.cloneMarkerInfo();\n     * Returns undefined if no marker was found.\n     * @field {number} pattId The index of the marker.\n     * @field {number} pattType The type of the marker.\n     * Either AR_MULTI_PATTERN_TYPE_TEMPLATE or AR_MULTI_PATTERN_TYPE_MATRIX.\n     * @field {number} visible 0 or larger if the marker is visible\n     * @field {number} width The width of the marker.\n     * @param {number} multiMarkerId The multimarker to query.\n     * @param {number} markerIndex The index of the marker to query.\n     * @returns {Object} The markerInfo struct.\n     */\n    ARController.prototype.getMultiEachMarker = function (multiMarkerId, markerIndex) {\n        if (0 === ARToolkitAPI_1.default.getMultiEachMarker(this.id, multiMarkerId, markerIndex)) {\n            return ARToolkitAPI_1.default.multiEachMarkerInfo;\n        }\n    };\n    /**\n     * Returns the 16-element WebGL transformation matrix used by ARController.process to\n     * pass marker WebGL matrices to event listeners.\n     * Unique to each ARController.\n     * @return {Float64Array} The 16-element WebGL transformation matrix used by the ARController.\n     */\n    ARController.prototype.getTransformationMatrix = function () {\n        return this.transformMat;\n    };\n    /**\n     * Returns the projection matrix computed from camera parameters for the ARController.\n     *\n     * @return {Float64Array} The 16-element WebGL camera matrix for the ARController camera parameters.\n     */\n    ARController.prototype.getCameraMatrix = function () {\n        return this.cameraMat;\n    };\n    ;\n    /**\n     * Returns the shared ARToolKit 3x4 marker transformation matrix, used for passing and receiving\n     * marker transforms to/from the Emscripten side.\n     * @return {Float64Array} The 12-element 3x4 row-major marker transformation matrix used by ARToolKit.\n     */\n    ARController.prototype.getMarkerTransformationMatrix = function () {\n        return this.markerTransformMat;\n    };\n    /* Setter / Getter Proxies */\n    /**\n     * Enables or disables debug mode in the tracker. When enabled, a black and white debug\n     * image is generated during marker detection. The debug image is useful for visualising\n     * the binarization process and choosing a threshold value.\n     * @param {boolean} mode\t\ttrue to enable debug mode, false to disable debug mode\n     * @see\t\t\t\tgetDebugMode()\n     */\n    ARController.prototype.setDebugMode = function (mode) {\n        return ARToolkitAPI_1.default.setDebugMode(this.id, mode);\n    };\n    /**\n     * Returns whether debug mode is currently enabled.\n     * @return {boolean}\ttrue when debug mode is enabled, false when debug mode is disabled\n     * @see\t\t\t\t\tsetDebugMode()\n     */\n    ARController.prototype.getDebugMode = function () {\n        return ARToolkitAPI_1.default.getDebugMode(this.id);\n    };\n    /**\n     * Returns the Emscripten HEAP offset to the debug processing image used by ARToolKit.\n     *\n     * @return {number} HEAP offset to the debug processing image.\n     */\n    ARController.prototype.getProcessingImage = function () {\n        return ARToolkitAPI_1.default.getProcessingImage(this.id);\n    };\n    /**\n     * Sets the logging level to use by ARToolKit.\n     *\n     * //TODOC\n     * @param mode\n     */\n    ARController.prototype.setLogLevel = function (mode) {\n        return ARToolkitAPI_1.default.setLogLevel(mode);\n    };\n    /**\n     * //TODOC\n     * @returns {*}\n     */\n    ARController.prototype.getLogLevel = function () {\n        return ARToolkitAPI_1.default.getLogLevel();\n    };\n    /**\n     * //TODOC\n     * @param markerIndex\n     * @param dir\n     * @returns {*}\n     */\n    ARController.prototype.setMarkerInfoDir = function (markerIndex, dir) {\n        return ARToolkitAPI_1.default.setMarkerInfoDir(this.id, markerIndex, dir);\n    };\n    /**\n     * //TODOC\n     * @param value\n     * @returns {*}\n     */\n    ARController.prototype.setProjectionNearPlane = function (value) {\n        return ARToolkitAPI_1.default.setProjectionNearPlane(this.id, value);\n    };\n    /**\n     * //TODOC\n     * @returns {*}\n     */\n    ARController.prototype.getProjectionNearPlane = function () {\n        return ARToolkitAPI_1.default.getProjectionNearPlane(this.id);\n    };\n    /**\n     * //TODOC\n     * @param value\n     * @returns {*}\n     */\n    ARController.prototype.setProjectionFarPlane = function (value) {\n        return ARToolkitAPI_1.default.setProjectionFarPlane(this.id, value);\n    };\n    /**\n     * //TODOC\n     * @returns {*}\n     */\n    ARController.prototype.getProjectionFarPlane = function () {\n        return ARToolkitAPI_1.default.getProjectionFarPlane(this.id);\n    };\n    /**\n     * Set the labeling threshold mode (auto/manual).\n     * @param {number}\t\tmode An integer specifying the mode. One of:\n     * AR_LABELING_THRESH_MODE_MANUAL,\n     * AR_LABELING_THRESH_MODE_AUTO_MEDIAN,\n     * AR_LABELING_THRESH_MODE_AUTO_OTSU,\n     * AR_LABELING_THRESH_MODE_AUTO_ADAPTIVE,\n     * AR_LABELING_THRESH_MODE_AUTO_BRACKETING\n     */\n    ARController.prototype.setThresholdMode = function (mode) {\n        return ARToolkitAPI_1.default.setThresholdMode(this.id, mode);\n    };\n    /**\n     * Gets the current threshold mode used for image binarization.\n     * @return\t{number}\t\tThe current threshold mode\n     * @see\t\t\t\tgetVideoThresholdMode()\n     */\n    ARController.prototype.getThresholdMode = function () {\n        return ARToolkitAPI_1.default.getThresholdMode(this.id);\n    };\n    /**\n     * Set the labeling threshhold.\n     * This function forces sets the threshold value.\n     * The default value is AR_DEFAULT_LABELING_THRESH which is 100.\n     * The current threshold mode is not affected by this call.\n     * Typically, this function is used when labeling threshold mode\n     * is AR_LABELING_THRESH_MODE_MANUAL.\n     * The threshold value is not relevant if threshold mode is\n     * AR_LABELING_THRESH_MODE_AUTO_ADAPTIVE.\n     *\n     * Background: The labeling threshold is the value which\n     * the AR library uses to differentiate between black and white\n     * portions of an ARToolKit marker. Since the actual brightness,\n     * contrast, and gamma of incoming images can vary signficantly\n     * between different cameras and lighting conditions, this\n     * value typically needs to be adjusted dynamically to a\n     * suitable midpoint between the observed values for black\n     * and white portions of the markers in the image.\n     *\n     * @param {number}     threshold An integer in the range [0,255] (inclusive).\n     */\n    ARController.prototype.setThreshold = function (threshold) {\n        return ARToolkitAPI_1.default.setThreshold(this.id, threshold);\n    };\n    /**\n     * Get the current labeling threshold.\n     *\n     * This function queries the current labeling threshold. For,\n     * AR_LABELING_THRESH_MODE_AUTO_MEDIAN, AR_LABELING_THRESH_MODE_AUTO_OTSU,\n     * and AR_LABELING_THRESH_MODE_AUTO_BRACKETING\n     * the threshold value is only valid until the next auto-update.\n     *\n     * The current threshold mode is not affected by this call.\n     *\n     * The threshold value is not relevant if threshold mode is\n     * AR_LABELING_THRESH_MODE_AUTO_ADAPTIVE.\n     *\n     * @return {number} The current threshold value.\n     */\n    ARController.prototype.getThreshold = function () {\n        return ARToolkitAPI_1.default.getThreshold(this.id);\n    };\n    /**\n     * Set the pattern detection mode\n     *\n     * The pattern detection determines the method by which ARToolKit\n     * matches detected squares in the video image to marker templates\n     * and/or IDs. ARToolKit v4.x can match against pictorial \"template\" markers,\n     * whose pattern files are created with the mk_patt utility, in either colour\n     * or mono, and additionally can match against 2D-barcode-type \"matrix\"\n     * markers, which have an embedded marker ID. Two different two-pass modes\n     * are also available, in which a matrix-detection pass is made first,\n     * followed by a template-matching pass.\n     *\n     * @param {number} mode\n     * \tOptions for this field are:\n     * \tAR_TEMPLATE_MATCHING_COLOR\n     * \tAR_TEMPLATE_MATCHING_MONO\n     * \tAR_MATRIX_CODE_DETECTION\n     * \tAR_TEMPLATE_MATCHING_COLOR_AND_MATRIX\n     * \tAR_TEMPLATE_MATCHING_MONO_AND_MATRIX\n     * \tThe default mode is AR_TEMPLATE_MATCHING_COLOR.\n     */\n    ARController.prototype.setPatternDetectionMode = function (mode) {\n        return ARToolkitAPI_1.default.setPatternDetectionMode(this.id, mode);\n    };\n    /**\n     * Returns the current pattern detection mode.\n     * @return {number} The current pattern detection mode.\n     */\n    ARController.prototype.getPatternDetectionMode = function () {\n        return ARToolkitAPI_1.default.getPatternDetectionMode(this.id);\n    };\n    /**\n     * Set the size and ECC algorithm to be used for matrix code (2D barcode) marker detection.\n     *\n     * When matrix-code (2D barcode) marker detection is enabled (see arSetPatternDetectionMode)\n     * then the size of the barcode pattern and the type of error checking and correction (ECC)\n     * with which the markers were produced can be set via this function.\n     *\n     * This setting is global to a given ARHandle; It is not possible to have two different matrix\n     * code types in use at once.\n     *\n     * @param      type The type of matrix code (2D barcode) in use. Options include:\n     * \tAR_MATRIX_CODE_3x3\n     * \tAR_MATRIX_CODE_3x3_HAMMING63\n     * \tAR_MATRIX_CODE_3x3_PARITY65\n     * \tAR_MATRIX_CODE_4x4\n     * \tAR_MATRIX_CODE_4x4_BCH_13_9_3\n     * \tAR_MATRIX_CODE_4x4_BCH_13_5_5\n     * \tThe default mode is AR_MATRIX_CODE_3x3.\n     */\n    ARController.prototype.setMatrixCodeType = function (type) {\n        return ARToolkitAPI_1.default.setMatrixCodeType(this.id, type);\n    };\n    /**\n     * Returns the current matrix code (2D barcode) marker detection type.\n     * @return {number} The current matrix code type.\n     */\n    ARController.prototype.getMatrixCodeType = function () {\n        return ARToolkitAPI_1.default.getMatrixCodeType(this.id);\n    };\n    /**\n     * Select between detection of black markers and white markers.\n     *\n     * ARToolKit's labelling algorithm can work with both black-bordered\n     * markers on a white background (AR_LABELING_BLACK_REGION) or\n     * white-bordered markers on a black background (AR_LABELING_WHITE_REGION).\n     * This function allows you to specify the type of markers to look for.\n     * Note that this does not affect the pattern-detection algorith\n     * which works on the interior of the marker.\n     *\n     * @param {number}      mode\n     * Options for this field are:\n     * AR_LABELING_WHITE_REGION\n     * AR_LABELING_BLACK_REGION\n     * The default mode is AR_LABELING_BLACK_REGION.\n     */\n    ARController.prototype.setLabelingMode = function (mode) {\n        return ARToolkitAPI_1.default.setLabelingMode(this.id, mode);\n    };\n    /**\n     * Enquire whether detection is looking for black markers or white markers.\n     * See discussion for setLabelingMode.\n     * @result {number} The current labeling mode.\n     */\n    ARController.prototype.getLabelingMode = function () {\n        return ARToolkitAPI_1.default.getLabelingMode(this.id);\n    };\n    /**\n     * Set the width/height of the marker pattern space, as a proportion of marker width/height.\n     * @param {number}\t\tpattRatio The the width/height of the marker pattern space, as a proportion of marker\n     * width/height. To set the default, pass AR_PATT_RATIO.\n     * If compatibility with ARToolKit verions 1.0 through 4.4 is required, this value\n     * must be 0.5.\n     */\n    ARController.prototype.setPattRatio = function (pattRatio) {\n        return ARToolkitAPI_1.default.setPattRatio(this.id, pattRatio);\n    };\n    /**\n     * Returns the current ratio of the marker pattern to the total marker size.\n     * @return {number} The current pattern ratio.\n     */\n    ARController.prototype.getPattRatio = function () {\n        return ARToolkitAPI_1.default.getPattRatio(this.id);\n    };\n    /**\n     * Set the image processing mode.\n     *\n     * When the image processing mode is AR_IMAGE_PROC_FRAME_IMAGE,\n     * ARToolKit processes all pixels in each incoming image\n     * to locate markers. When the mode is AR_IMAGE_PROC_FIELD_IMAGE,\n     * ARToolKit processes pixels in only every second pixel row and\n     * column. This is useful both for handling images from interlaced\n     * video sources (where alternate lines are assembled from alternate\n     * fields and thus have one field time-difference, resulting in a\n     * \"comb\" effect) such as Digital Video cameras.\n     * The effective reduction by 75% in the pixels processed also\n     * has utility in accelerating tracking by effectively reducing\n     * the image size to one quarter size, at the cost of pose accuraccy.\n     *\n     * @param {number} mode\n     * \tOptions for this field are:\n     * \tAR_IMAGE_PROC_FRAME_IMAGE\n     * \tAR_IMAGE_PROC_FIELD_IMAGE\n     * \tThe default mode is AR_IMAGE_PROC_FRAME_IMAGE.\n     */\n    ARController.prototype.setImageProcMode = function (mode) {\n        return ARToolkitAPI_1.default.setImageProcMode(this.id, mode);\n    };\n    /**\n     * Get the image processing mode.\n     * See arSetImageProcMode() for a complete description.\n     * @return {number} The current image processing mode.\n     */\n    ARController.prototype.getImageProcMode = function () {\n        return ARToolkitAPI_1.default.getImageProcMode(this.id);\n    };\n    /**\n     * Draw the black and white image and debug markers to the ARController canvas.\n     * See setDebugMode.\n     */\n    ARController.prototype.debugDraw = function () {\n        var debugBuffer = new Uint8ClampedArray(ARToolkitAPI_1.default.HEAPU8.buffer, this._bwpointer, this.framesize);\n        var id = new ImageData(debugBuffer, this.canvas.width, this.canvas.height);\n        this.ctx.putImageData(id, 0, 0);\n        var marker_num = this.getMarkerNum();\n        for (var i = 0; i < marker_num; i++) {\n            this._debugMarker(this.getMarker(i));\n        }\n    };\n    // /**\n    //  * ARController.getUserMedia gets a device camera video feed and calls the given onSuccess callback with it.\n    //  * Tries to start playing the video. Playing the video can fail on Chrome for Android,\n    //  * so ARController.getUserMedia adds user input event listeners to the window\n    //  * that try to start playing the video. On success, the event listeners are removed.\n    //  * To use ARController.getUserMedia, call it with an object with the onSuccess attribute set to a callback function.\n    //  * \tARController.getUserMedia({\n    //  * \t\tonSuccess: function(video) {\n    //  * \t\t\tconsole.log(\"Got video\", video);\n    //  * \t\t}\n    //  * \t});\n    //  * The configuration object supports the following attributes:\n    //  * \t{\n    //  * \t\tonSuccess : function(video),\n    //  * \t\tonError : function(error),\n    //  * \t\twidth : number | {min: number, ideal: number, max: number},\n    //  * \t\theight : number | {min: number, ideal: number, max: number},\n    //  *\n    //  * \t\tfacingMode : 'environment' | 'user' | 'left' | 'right' | { exact: 'environment' | ... }\n    //  * \t}\n    //  * See https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia for more information about the\n    //  * width, height and facingMode attributes.\n    //  * @param {object} configuration The configuration object.\n    //  * @return {HTMLVideoElement} Returns the created video element.\n    //  */\n    // public getUserMedia(configuration) {\n    // \tconst facing = configuration.facingMode || \"environment\";\n    // \tconst onSuccess = configuration.onSuccess;\n    // \tconst fallbackError = (err) => {\n    // \t\tthrow Error(\"ARController.getUserMedia \" + err);\n    // \t};\n    // \tconst onError = configuration.onError || fallbackError;\n    // \tconst video = document.createElement(\"video\");\n    // \tlet readyToPlay = false;\n    // \tconst eventNames = [\n    // \t\t\"touchstart\", \"touchend\", \"touchmove\", \"touchcancel\",\n    // \t\t\"click\", \"mousedown\", \"mouseup\", \"mousemove\",\n    // \t\t\"keydown\", \"keyup\", \"keypress\", \"scroll\"\n    // \t];\n    // \tconst play = () => {\n    // \t\tif (readyToPlay) {\n    // \t\t\tvideo.play();\n    // \t\t\tif (!video.paused) {\n    // \t\t\t\teventNames.forEach((eventName) => {\n    // \t\t\t\t\twindow.removeEventListener(eventName, play, true);\n    // \t\t\t\t});\n    // \t\t\t}\n    // \t\t}\n    // \t};\n    // \teventNames.forEach((eventName) => {\n    // \t\twindow.addEventListener(eventName, play, true);\n    // \t});\n    // \tconst success = (stream) => {\n    // \t\tconst initProgress = () => {\n    // \t\t\tif (this.videoWidth !== 0) {\n    // \t\t\t\tonSuccess(video);\n    // \t\t\t}\n    // \t\t};\n    // \t\tvideo.addEventListener(\"loadedmetadata\", initProgress, false);\n    // \t\tvideo.src = window.URL.createObjectURL(stream);\n    // \t\treadyToPlay = true;\n    // \t\tplay(); // Try playing without user input, should work on non-Android Chrome\n    // \t};\n    // \tconst constraints = {\n    // \t\tmaxWidth: 0,\n    // \t\tminWidth: 0,\n    // \t\tmaxHeight: 0,\n    // \t\tminHeight: 0\n    // \t};\n    // \tconst mediaDevicesConstraints = {\n    // \t\twidth: 0,\n    // \t\theight: 0,\n    // \t\tfacingMode: null\n    // \t};\n    // \tif (configuration.width) {\n    // \t\tmediaDevicesConstraints.width = configuration.width;\n    // \t\tif (typeof configuration.width === \"object\") {\n    // \t\t\tif (configuration.width.max) {\n    // \t\t\t\tconstraints.maxWidth = configuration.width.max;\n    // \t\t\t}\n    // \t\t\tif (configuration.width.min) {\n    // \t\t\t\tconstraints.minWidth = configuration.width.max;\n    // \t\t\t}\n    // \t\t} else {\n    // \t\t\tconstraints.maxWidth = configuration.width;\n    // \t\t}\n    // \t}\n    // \tif (configuration.height) {\n    // \t\tmediaDevicesConstraints.height = configuration.height;\n    // \t\tif (typeof configuration.height === \"object\") {\n    // \t\t\tif (configuration.height.max) {\n    // \t\t\t\tconstraints.maxHeight = configuration.height.max;\n    // \t\t\t}\n    // \t\t\tif (configuration.height.min) {\n    // \t\t\t\tconstraints.minHeight = configuration.height.max;\n    // \t\t\t}\n    // \t\t} else {\n    // \t\t\tconstraints.maxHeight = configuration.height;\n    // \t\t}\n    // \t}\n    // \tmediaDevicesConstraints.facingMode = facing;\n    // \tnavigator.getUserMedia =\n    // \t\t\t\t\t\t\tnavigator.getUserMedia ||\n    // \t\t\t\t\t\t\t(navigator as any).webkitGetUserMedia ||\n    // \t\t\t\t\t\t\t(navigator as any).mozGetUserMedia ||\n    // \t\t\t\t\t\t\t(navigator as any).msGetUserMedia;\n    // \tconst hdConstraints = {\n    // \t\taudio: false,\n    // \t\tvideo: {\n    // \t\t\tmandatory: constraints\n    // \t\t}\n    // \t};\n    // \t// TODO: This code was unreachable?\n    // \t// if (false) {\n    // \t// // if ( navigator.mediaDevices || window.MediaStreamTrack) {\n    // \t// \tif (navigator.mediaDevices) {\n    // \t// \t\tnavigator.mediaDevices.getUserMedia({\n    // \t// \t\t\taudio: false,\n    // \t// \t\t\tvideo: mediaDevicesConstraints\n    // \t// \t\t}).then(success, onError);\n    // \t// \t} else {\n    // \t// \t\tMediaStreamTrack.getSources(function(sources) {\n    // \t// \t\t\tvar facingDir = mediaDevicesConstraints.facingMode;\n    // \t// \t\t\tif (facing && facing.exact) {\n    // \t// \t\t\t\tfacingDir = facing.exact;\n    // \t// \t\t\t}\n    // \t// \t\t\tfor (var i=0; i<sources.length; i++) {\n    // \t// \t\t\t\tif (sources[i].kind === 'video' && sources[i].facing === facingDir) {\n    // \t// \t\t\t\t\thdConstraints.video.mandatory.sourceId = sources[i].id;\n    // \t// \t\t\t\t\tbreak;\n    // \t// \t\t\t\t}\n    // \t// \t\t\t}\n    // \t// \t\t\tif (facing && facing.exact && !hdConstraints.video.mandatory.sourceId) {\n    // \t// \t\t\t\tonError('Failed to get camera facing the wanted direction');\n    // \t// \t\t\t} else {\n    // \t// \t\t\t\tif (navigator.getUserMedia) {\n    // \t// \t\t\t\t\tnavigator.getUserMedia(hdConstraints, success, onError);\n    // \t// \t\t\t\t} else {\n    // \t// \t\t\t\t\tonError('navigator.getUserMedia is not supported on your browser');\n    // \t// \t\t\t\t}\n    // \t// \t\t\t}\n    // \t// \t\t});\n    // \t// \t}\n    // \t// } else {\n    // \tif (navigator.getUserMedia) {\n    // \t\t// TODO: This interface doesn't seem to match up?\n    // \t\tnavigator.getUserMedia((hdConstraints as any), success, onError);\n    // \t} else {\n    // \t\tonError(\"navigator.getUserMedia is not supported on your browser\");\n    // \t}\n    // \t// }\n    // \treturn video;\n    // }\n    // /**\n    //  * ARController.getUserMediaARController gets an ARController for the device camera video feed and calls the\n    //  * given onSuccess callback with it.\n    //  * To use ARController.getUserMediaARController, call it with an object with the cameraParam attribute set to\n    //  * a camera parameter file URL, and the onSuccess attribute set to a callback function.\n    //  * \tARController.getUserMediaARController({\n    //  * \t\tcameraParam: 'Data/camera_para.dat',\n    //  * \t\tonSuccess: function(arController, arCameraParam) {\n    //  * \t\t\tconsole.log(\"Got ARController\", arController);\n    //  * \t\t\tconsole.log(\"Got ARCameraParam\", arCameraParam);\n    //  * \t\t\tconsole.log(\"Got video\", arController.image);\n    //  * \t\t}\n    //  * \t});\n    //  * The configuration object supports the following attributes:\n    //  *\n    //  * \t{\n    //  * \t\tonSuccess : function(ARController, ARCameraParam),\n    //  * \t\tonError : function(error),\n    //  *\n    //  * \t\tcameraParam: url, // URL to camera parameters definition file.\n    //  * \t\tmaxARVideoSize: number, // Maximum max(width, height) for the AR processing canvas.\n    //  *\n    //  * \t\twidth : number | {min: number, ideal: number, max: number},\n    //  * \t\theight : number | {min: number, ideal: number, max: number}\n    //  *\n    //  * \t\tfacingMode : 'environment' | 'user' | 'left' | 'right' | { exact: 'environment' | ... }\n    //  * \t}\n    //  *\n    //  * See https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia for more information about the\n    //  * width, height and facingMode attributes.\n    //  *\n    //  * The orientation attribute of the returned ARController is set to \"portrait\" if the userMedia video has larger\n    //  * height than width. Otherwise it's set to \"landscape\". The videoWidth and videoHeight attributes of the arController\n    //  * are set to be always in landscape configuration so that width is larger than height.\n    //  *\n    //  * @param {object} configuration The configuration object.\n    //  * @return {HTMLVideoElement} Returns the created video element.\n    //  */\n    // public getUserMediaARController(configuration) {\n    // \tconst userMediaObj = {\n    // \t\tonSuccess: null\n    // \t};\n    // \tfor (const i in configuration) {\n    // \t\tif (configuration[i]) {\n    // \t\t\tuserMediaObj[i] = configuration[i];\n    // \t\t}\n    // \t}\n    // \tconst onSuccess = configuration.onSuccess;\n    // \tconst cameraParamURL = configuration.cameraParam;\n    // \tuserMediaObj.onSuccess = () => {\n    // \t\treturn new ARCameraParam(cameraParamURL, () => {\n    // \t\t\tconst arCameraParam = this;\n    // \t\t\tconst maxSize = configuration.maxARVideoSize || Math.max(video.videoWidth, video.videoHeight);\n    // \t\t\tconst f = maxSize / Math.max(video.videoWidth, video.videoHeight);\n    // \t\t\tlet w = f * video.videoWidth;\n    // \t\t\tlet h = f * video.videoHeight;\n    // \t\t\tif (video.videoWidth < video.videoHeight) {\n    // \t\t\t\tconst tmp = w;\n    // \t\t\t\tw = h;\n    // \t\t\t\th = tmp;\n    // \t\t\t}\n    // \t\t\tconst arController = new ARController(w, h, arCameraParam);\n    // \t\t\tarController.image = video;\n    // \t\t\tif (video.videoWidth < video.videoHeight) {\n    // \t\t\t\tarController.orientation = \"portrait\";\n    // \t\t\t\tarController.videoWidth = video.videoHeight;\n    // \t\t\t\tarController.videoHeight = video.videoWidth;\n    // \t\t\t} else {\n    // \t\t\t\tarController.orientation = \"landscape\";\n    // \t\t\t\tarController.videoWidth = video.videoWidth;\n    // \t\t\t\tarController.videoHeight = video.videoHeight;\n    // \t\t\t}\n    // \t\t\tonSuccess(arController, arCameraParam);\n    // \t\t}, (err) => {\n    // \t\t\tthrow Error(\"ARController: Failed to load ARCameraParam \" + err);\n    // \t\t});\n    // \t};\n    // \tconst video = this.getUserMedia(userMediaObj);\n    // \treturn video;\n    // }\n    // private\n    /**\n     * //TODOC\n     *\n     * @private\n     */\n    ARController.prototype._initialize = function () {\n        var _this = this;\n        this.id = ARToolkitAPI_1.default.setup(this.canvas.width, this.canvas.height, this.cameraParam.id);\n        var params = ARToolkitAPI_1.default.getFrameMalloc();\n        if (params) {\n            this.framepointer = params.framepointer;\n            this.framesize = params.framesize;\n            this.dataHeap = new Uint8Array(ARToolkitAPI_1.default.HEAPU8.buffer, this.framepointer, this.framesize);\n            this.cameraMat = new Float64Array(ARToolkitAPI_1.default.HEAPU8.buffer, params.camera, 16);\n            this.markerTransformMat = new Float64Array(ARToolkitAPI_1.default.HEAPU8.buffer, params.transform, 12);\n        }\n        else {\n            throw Error(\"frameMalloc not set\");\n        }\n        this.setProjectionNearPlane(0.1);\n        this.setProjectionFarPlane(1000);\n        setTimeout(function () {\n            if (_this.onload) {\n                _this.onload();\n            }\n            _this.dispatchEvent({\n                name: \"load\",\n                target: _this\n            });\n        }, 0);\n    };\n    /**\n     * //TODOC\n     *\n     * @param {HTMLImageElement|HTMLVideoElement} [image]\n     * @returns {boolean}\n     * @private\n     */\n    ARController.prototype._copyImageToHeap = function (image) {\n        if (!image) {\n            image = this.image;\n        }\n        this.ctx.save();\n        if (this.orientation === \"portrait\") {\n            this.ctx.translate(this.canvas.width, 0);\n            this.ctx.rotate(Math.PI / 2);\n            this.ctx.drawImage(image, 0, 0, this.canvas.height, this.canvas.width); // draw video\n        }\n        else {\n            this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height); // draw video\n        }\n        this.ctx.restore();\n        var imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n        var data = imageData.data;\n        if (this.dataHeap) {\n            this.dataHeap.set(data);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * //TODOC\n     *\n     * @param marker\n     * @private\n     */\n    ARController.prototype._debugMarker = function (marker) {\n        var vertex;\n        var pos;\n        vertex = marker.vertex;\n        var ctx = this.ctx;\n        ctx.strokeStyle = \"red\";\n        ctx.beginPath();\n        ctx.moveTo(vertex[0][0], vertex[0][1]);\n        ctx.lineTo(vertex[1][0], vertex[1][1]);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(vertex[2][0], vertex[2][1]);\n        ctx.lineTo(vertex[3][0], vertex[3][1]);\n        ctx.stroke();\n        ctx.strokeStyle = \"green\";\n        ctx.beginPath();\n        ctx.lineTo(vertex[1][0], vertex[1][1]);\n        ctx.lineTo(vertex[2][0], vertex[2][1]);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(vertex[3][0], vertex[3][1]);\n        ctx.lineTo(vertex[0][0], vertex[0][1]);\n        ctx.stroke();\n        pos = marker.pos;\n        ctx.beginPath();\n        ctx.arc(pos[0], pos[1], 8, 0, Math.PI * 2);\n        ctx.fillStyle = \"red\";\n        ctx.fill();\n    };\n    return ARController;\n}());\nexports.ARController = ARController;\nexports.default = ARController;\n\n\n//# sourceURL=webpack://THREEAR/./src/ARController.ts?");

/***/ }),

/***/ "./src/ARMarkerControls.ts":
/*!*********************************!*\
  !*** ./src/ARMarkerControls.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ARBaseControls_1 = __webpack_require__(/*! ./ARBaseControls */ \"./src/ARBaseControls.ts\");\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nvar ARToolkitAPI_1 = __webpack_require__(/*! ./ARToolkitAPI */ \"./src/ARToolkitAPI.ts\");\nvar ARMarkerControls = /** @class */ (function (_super) {\n    __extends(ARMarkerControls, _super);\n    function ARMarkerControls(context, object3d, parameters) {\n        var _this = _super.call(this, object3d) || this;\n        _this.context = context;\n        // handle default parameters\n        _this.parameters = {\n            // size of the marker in meter\n            size: 1,\n            // type of marker - ['pattern', 'barcode', 'unknown' ]\n            type: \"unknown\",\n            // url of the pattern - IIF type='pattern'\n            patternUrl: null,\n            // value of the barcode - IIF type='barcode'\n            barcodeValue: null,\n            // change matrix mode - [modelViewMatrix, cameraTransformMatrix]\n            changeMatrixMode: \"modelViewMatrix\",\n            // minimal confidence in the marke recognition - between [0, 1] - default to 1\n            minConfidence: 0.6,\n        };\n        _this.setParameters(parameters);\n        // create the marker Root\n        _this.object3d = object3d;\n        _this.object3d.matrixAutoUpdate = false;\n        _this.object3d.visible = false;\n        context.addMarker(_this);\n        if (_this.context.parameters.trackingBackend === \"artoolkit\") {\n            _this._initArtoolkit();\n        }\n        else if (_this.context.parameters.trackingBackend === \"aruco\") {\n            // TODO create a ._initAruco\n            // put aruco second\n            // this._arucoPosit = new POS.Posit(this.parameters.size, this.context.arucoContext.canvas.width)\n        }\n        else if (_this.context.parameters.trackingBackend === \"tango\") {\n            _this._initTango();\n        }\n        else {\n            console.assert(false);\n        }\n        return _this;\n    }\n    ARMarkerControls.prototype.setParameters = function (parameters) {\n        if (!parameters) {\n            return;\n        }\n        for (var key in parameters) {\n            if (key) {\n                var newValue = parameters[key];\n                if (newValue === undefined) {\n                    console.warn(\"THREEx.ArToolkitContext: '\" + key + \"' parameter is undefined.\");\n                    continue;\n                }\n                var currentValue = this.parameters[key];\n                if (currentValue === undefined) {\n                    console.warn(\"THREEx.ArToolkitContext: '\" + key + \"' is not a property of this material.\");\n                    continue;\n                }\n                this.parameters[key] = newValue;\n            }\n        }\n    };\n    ARMarkerControls.prototype.dispose = function () {\n        this.context.removeMarker(this);\n        // TODO remove the event listener if needed\n        // unloadMaker ???\n    };\n    /**\n     * When you actually got a new modelViewMatrix, you need to perfom a whole bunch\n     * of things. it is done here.\n     */\n    ARMarkerControls.prototype.updateWithModelViewMatrix = function (modelViewMatrix) {\n        var markerObject3D = this.object3d;\n        // mark object as visible\n        markerObject3D.visible = true;\n        if (this.context.parameters.trackingBackend === \"artoolkit\") {\n            // apply context._axisTransformMatrix - change artoolkit axis to match usual webgl one\n            var tmpMatrix = new THREE.Matrix4().copy(this.context._artoolkitProjectionAxisTransformMatrix);\n            tmpMatrix.multiply(modelViewMatrix);\n            modelViewMatrix.copy(tmpMatrix);\n        }\n        else if (this.context.parameters.trackingBackend === \"aruco\") {\n            // ...\n        }\n        else if (this.context.parameters.trackingBackend === \"tango\") {\n            // ...\n        }\n        else {\n            console.assert(false);\n        }\n        if (this.context.parameters.trackingBackend !== \"tango\") {\n            // change axis orientation on marker - artoolkit say Z is normal to the marker - ar.js say Y is normal to the marker\n            var markerAxisTransformMatrix = new THREE.Matrix4().makeRotationX(Math.PI / 2);\n            modelViewMatrix.multiply(markerAxisTransformMatrix);\n        }\n        // change markerObject3D.matrix based on parameters.changeMatrixMode\n        if (this.parameters.changeMatrixMode === \"modelViewMatrix\") {\n            markerObject3D.matrix.copy(modelViewMatrix);\n        }\n        else if (this.parameters.changeMatrixMode === \"cameraTransformMatrix\") {\n            markerObject3D.matrix.getInverse(modelViewMatrix);\n        }\n        else {\n            throw Error();\n        }\n        // decompose - the matrix into .position, .quaternion, .scale\n        markerObject3D.matrix.decompose(markerObject3D.position, markerObject3D.quaternion, markerObject3D.scale);\n        // dispatchEvent\n        this.dispatchEvent({ type: \"markerFound\" });\n    };\n    /**\n     * provide a name for a marker\n     * - silly heuristic for now\n     * - should be improved\n     */\n    ARMarkerControls.prototype.name = function () {\n        var name = \"\";\n        name += this.parameters.type;\n        if (this.parameters.type === \"pattern\") {\n            var url = this.parameters.patternUrl;\n            var basename = url.replace(/^.*\\//g, \"\");\n            name += \" - \" + basename;\n        }\n        else if (this.parameters.type === \"barcode\") {\n            name += \" - \" + this.parameters.barcodeValue;\n        }\n        else {\n            console.assert(false, \"no .name() implemented for this marker controls\");\n        }\n        return name;\n    };\n    ARMarkerControls.prototype._initArtoolkit = function () {\n        var _this = this;\n        var artoolkitMarkerId = null;\n        var delayedInitTimerId = setInterval(function () {\n            // check if arController is init\n            if (_this.context.arController === null) {\n                return;\n            }\n            // stop looping if it is init\n            clearInterval(delayedInitTimerId);\n            delayedInitTimerId = null;\n            // launch the _postInitArtoolkit\n            postInit();\n        }, 1000 / 50);\n        var postInit = function () {\n            // check if arController is init\n            var arController = _this.context.arController;\n            arController.setLogLevel(1);\n            // start tracking this pattern\n            if (_this.parameters.type === \"pattern\") {\n                var onSuccess = function (markerId) {\n                    artoolkitMarkerId = markerId;\n                    arController.trackPatternMarkerId(artoolkitMarkerId, _this.parameters.size);\n                };\n                var onError = function (err) {\n                    throw Error(err);\n                };\n                arController.loadMarker(_this.parameters.patternUrl, onSuccess, onError);\n            }\n            else if (_this.parameters.type === \"barcode\") {\n                artoolkitMarkerId = _this.parameters.barcodeValue;\n                arController.trackBarcodeMarkerId(artoolkitMarkerId, _this.parameters.size);\n            }\n            else if (_this.parameters.type === \"unknown\") {\n                artoolkitMarkerId = null;\n            }\n            else {\n                throw Error(\"invalid marker type\" + _this.parameters.type);\n            }\n            // listen to the event\n            arController.addEventListener(\"getMarker\", function (event) {\n                if (event.data.type === ARToolkitAPI_1.default.PATTERN_MARKER &&\n                    _this.parameters.type === \"pattern\") {\n                    if (artoolkitMarkerId === null) {\n                        return;\n                    }\n                    if (event.data.marker.idPatt === artoolkitMarkerId) {\n                        onMarkerFound(event);\n                    }\n                }\n                else if (event.data.type === ARToolkitAPI_1.default.BARCODE_MARKER &&\n                    _this.parameters.type === \"barcode\") {\n                    // console.log('BARCODE_MARKER idMatrix', event.data.marker.idMatrix, artoolkitMarkerId )\n                    if (artoolkitMarkerId === null) {\n                        return;\n                    }\n                    if (event.data.marker.idMatrix === artoolkitMarkerId) {\n                        onMarkerFound(event);\n                    }\n                }\n                else if (event.data.type === ARToolkitAPI_1.default.UNKNOWN_MARKER &&\n                    _this.parameters.type === \"unknown\") {\n                    onMarkerFound(event);\n                }\n            });\n        };\n        var onMarkerFound = function (event) {\n            // honor his.parameters.minConfidence\n            if (event.data.type === ARToolkitAPI_1.default.PATTERN_MARKER && event.data.marker.cfPatt < _this.parameters.minConfidence) {\n                return;\n            }\n            if (event.data.type === ARToolkitAPI_1.default.BARCODE_MARKER && event.data.marker.cfMatt < _this.parameters.minConfidence) {\n                return;\n            }\n            var modelViewMatrix = new THREE.Matrix4().fromArray(event.data.matrix);\n            _this.updateWithModelViewMatrix(modelViewMatrix);\n        };\n        return;\n    };\n    return ARMarkerControls;\n}(ARBaseControls_1.ARBaseControls));\nexports.ARMarkerControls = ARMarkerControls;\nexports.default = ARMarkerControls;\n\n\n//# sourceURL=webpack://THREEAR/./src/ARMarkerControls.ts?");

/***/ }),

/***/ "./src/ARProfile.ts":
/*!**************************!*\
  !*** ./src/ARProfile.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ARUtils_1 = __webpack_require__(/*! ./ARUtils */ \"./src/ARUtils.ts\");\n/**\n * ArToolkitProfile helps you build parameters for artoolkit\n * - it is fully independent of the rest of the code\n * - all the other classes are still expecting normal parameters\n * - you can use this class to understand how to tune your specific usecase\n * - it is made to help people to build parameters without understanding all the underlying details.\n */\nvar ARProfile = /** @class */ (function () {\n    function ARProfile(parameters) {\n        this.reset(parameters.baseURL);\n        this.performance(\"default\");\n    }\n    /**\n     * reset all parameters\n     */\n    ARProfile.prototype.reset = function (baseURL) {\n        this.sourceParameters = {\n            // to read from the webcam\n            sourceType: \"webcam\",\n        };\n        this.contextParameters = {\n            cameraParametersUrl: baseURL + \"../data/camera_para.dat\",\n            detectionMode: \"mono\",\n        };\n        this.defaultMarkerParameters = {\n            type: \"pattern\",\n            patternUrl: baseURL + \"../data/patt.hiro\",\n            changeMatrixMode: \"modelViewMatrix\",\n        };\n        return this;\n    };\n    ARProfile.prototype.performance = function (label) {\n        if (label === \"default\") {\n            label = this._guessPerformanceLabel();\n        }\n        if (label === \"desktop-fast\") {\n            this.contextParameters.canvasWidth = 640 * 3;\n            this.contextParameters.canvasHeight = 480 * 3;\n            this.contextParameters.maxDetectionRate = 30;\n        }\n        else if (label === \"desktop-normal\") {\n            this.contextParameters.canvasWidth = 640;\n            this.contextParameters.canvasHeight = 480;\n            this.contextParameters.maxDetectionRate = 60;\n        }\n        else if (label === \"phone-normal\") {\n            this.contextParameters.canvasWidth = 80 * 4;\n            this.contextParameters.canvasHeight = 60 * 4;\n            this.contextParameters.maxDetectionRate = 30;\n        }\n        else if (label === \"phone-slow\") {\n            this.contextParameters.canvasWidth = 80 * 3;\n            this.contextParameters.canvasHeight = 60 * 3;\n            this.contextParameters.maxDetectionRate = 30;\n        }\n        else {\n            console.assert(false, \"unknonwn label \" + label);\n        }\n        return this;\n    };\n    ARProfile.prototype.defaultMarker = function (trackingBackend) {\n        trackingBackend = trackingBackend || this.contextParameters.trackingBackend;\n        if (trackingBackend === \"artoolkit\") {\n            this.contextParameters.detectionMode = \"mono\";\n            this.defaultMarkerParameters.type = \"pattern\";\n            this.defaultMarkerParameters.patternUrl = this.parameters.baseURL + \"../data/patt.hiro\";\n        }\n        else if (trackingBackend === \"aruco\") {\n            this.contextParameters.detectionMode = \"mono\";\n            this.defaultMarkerParameters.type = \"barcode\";\n            this.defaultMarkerParameters.barcodeValue = 1001;\n        }\n        else if (trackingBackend === \"tango\") {\n            // FIXME temporary placeholder - to reevaluate later\n            this.defaultMarkerParameters.type = \"barcode\";\n            this.defaultMarkerParameters.barcodeValue = 1001;\n        }\n        else {\n            console.assert(false);\n        }\n        return this;\n    };\n    ARProfile.prototype.sourceWebcam = function () {\n        this.sourceParameters.sourceType = \"webcam\";\n        delete this.sourceParameters.sourceUrl;\n        return this;\n    };\n    ARProfile.prototype.sourceVideo = function (url) {\n        this.sourceParameters.sourceType = \"video\";\n        this.sourceParameters.sourceUrl = url;\n        return this;\n    };\n    ARProfile.prototype.sourceImage = function (url) {\n        this.sourceParameters.sourceType = \"image\";\n        this.sourceParameters.sourceUrl = url;\n        return this;\n    };\n    ARProfile.prototype.trackingBackend = function (trackingBackend) {\n        console.warn(\"stop profile.trackingBackend() obsolete function. use .trackingMethod instead\");\n        this.contextParameters.trackingBackend = trackingBackend;\n        return this;\n    };\n    ARProfile.prototype.changeMatrixMode = function (changeMatrixMode) {\n        this.defaultMarkerParameters.changeMatrixMode = changeMatrixMode;\n        return this;\n    };\n    ARProfile.prototype.trackingMethod = function (trackingMethod) {\n        var data = ARUtils_1.ARUtils.parseTrackingMethod(trackingMethod);\n        this.defaultMarkerParameters.markersAreaEnabled = data.markersAreaEnabled;\n        this.contextParameters.trackingBackend = data.trackingBackend;\n        return this;\n    };\n    ARProfile.prototype.checkIfValid = function () {\n        if (this.contextParameters.trackingBackend === \"tango\") {\n            this.sourceImage(this.parameters.baseURL + \"../data/images/img.jpg\");\n        }\n        return this;\n    };\n    ARProfile.prototype._guessPerformanceLabel = function () {\n        var isMobile = navigator.userAgent.match(/Android/i)\n            || navigator.userAgent.match(/webOS/i)\n            || navigator.userAgent.match(/iPhone/i)\n            || navigator.userAgent.match(/iPad/i)\n            || navigator.userAgent.match(/iPod/i)\n            || navigator.userAgent.match(/BlackBerry/i)\n            || navigator.userAgent.match(/Windows Phone/i)\n            ? true : false;\n        if (isMobile === true) {\n            return \"phone-normal\";\n        }\n        return \"desktop-normal\";\n    };\n    return ARProfile;\n}());\nexports.ARProfile = ARProfile;\nexports.default = ARProfile;\n\n\n//# sourceURL=webpack://THREEAR/./src/ARProfile.ts?");

/***/ }),

/***/ "./src/ARSource.ts":
/*!*************************!*\
  !*** ./src/ARSource.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ARSource = /** @class */ (function () {\n    function ARSource(parameters) {\n        this.ready = false;\n        this.domElement = null;\n        // handle default parameters\n        this.parameters = {\n            // type of source - ['webcam', 'image', 'video']\n            sourceType: \"webcam\",\n            // url of the source - valid if sourceType = image|video\n            sourceUrl: null,\n            // Device id of the camera to use (optional)\n            deviceId: null,\n            // resolution of at which we initialize in the source image\n            sourceWidth: 640,\n            sourceHeight: 480,\n            // resolution displayed for the source\n            displayWidth: 640,\n            displayHeight: 480,\n        };\n        this.setParameters(parameters);\n    }\n    ARSource.prototype.setParameters = function (parameters) {\n        if (!parameters) {\n            return;\n        }\n        for (var key in parameters) {\n            if (key) {\n                var newValue = parameters[key];\n                if (newValue === undefined) {\n                    console.warn(\"THREEx.ArToolkitContext: '\" + key + \"' parameter is undefined.\");\n                    continue;\n                }\n                var currentValue = this.parameters[key];\n                if (currentValue === undefined) {\n                    console.warn(\"THREEx.ArToolkitContext: '\" + key + \"' is not a property of this material.\");\n                    continue;\n                }\n                this.parameters[key] = newValue;\n            }\n        }\n    };\n    ARSource.prototype.init = function (onReady, onError) {\n        var _this = this;\n        var onSourceReady = function () {\n            document.body.appendChild(_this.domElement);\n            _this.ready = true;\n            if (onReady) {\n                onReady();\n            }\n        };\n        if (this.parameters.sourceType === \"image\") {\n            this.domElement = this._initSourceImage(onSourceReady);\n        }\n        else if (this.parameters.sourceType === \"video\") {\n            this.domElement = this._initSourceVideo(onSourceReady);\n        }\n        else if (this.parameters.sourceType === \"webcam\") {\n            this.domElement = this._initSourceWebcam(onSourceReady, onError);\n        }\n        else {\n            console.assert(false);\n        }\n        // attach\n        this.domElement.style.position = \"absolute\";\n        this.domElement.style.top = \"0px\";\n        this.domElement.style.left = \"0px\";\n        this.domElement.style.zIndex = \"-2\";\n        return this;\n    };\n    ARSource.prototype._initSourceImage = function (onReady) {\n        var domElement = document.createElement(\"img\");\n        domElement.src = this.parameters.sourceUrl;\n        domElement.width = this.parameters.sourceWidth;\n        domElement.height = this.parameters.sourceHeight;\n        domElement.style.width = this.parameters.displayWidth + \"px\";\n        domElement.style.height = this.parameters.displayHeight + \"px\";\n        // wait until the video stream is ready\n        var interval = setInterval(function () {\n            if (!domElement.naturalWidth) {\n                return;\n            }\n            onReady();\n            clearInterval(interval);\n        }, 1000 / 50);\n        return domElement;\n    };\n    ARSource.prototype._initSourceVideo = function (onReady) {\n        // TODO make it static\n        var domElement = document.createElement(\"video\");\n        domElement.src = this.parameters.sourceUrl;\n        domElement.style.objectFit = \"initial\";\n        domElement.autoplay = true;\n        domElement.webkitPlaysinline = true;\n        domElement.controls = false;\n        domElement.loop = true;\n        domElement.muted = true;\n        // trick to trigger the video on android\n        document.body.addEventListener(\"click\", function onClick() {\n            document.body.removeEventListener(\"click\", onClick);\n            domElement.play();\n        });\n        domElement.width = this.parameters.sourceWidth;\n        domElement.height = this.parameters.sourceHeight;\n        domElement.style.width = this.parameters.displayWidth + \"px\";\n        domElement.style.height = this.parameters.displayHeight + \"px\";\n        // wait until the video stream is ready\n        var interval = setInterval(function () {\n            // if (!domElement.naturalWidth) {\n            // \treturn;\n            // }\n            onReady();\n            clearInterval(interval);\n        }, 1000 / 50);\n        return domElement;\n    };\n    ARSource.prototype._initSourceWebcam = function (onReady, onError) {\n        var _this = this;\n        // init default value\n        var fallbackError = function (error) {\n            alert(\"Webcam Error\\nName: \" + error.name + \"\\nMessage: \" + error.message);\n        };\n        onError = onError || fallbackError;\n        var domElement = document.createElement(\"video\");\n        domElement.setAttribute(\"autoplay\", \"\");\n        domElement.setAttribute(\"muted\", \"\");\n        domElement.setAttribute(\"playsinline\", \"\");\n        domElement.style.width = this.parameters.displayWidth + \"px\";\n        domElement.style.height = this.parameters.displayHeight + \"px\";\n        // check API is available\n        if (navigator.mediaDevices === undefined\n            || navigator.mediaDevices.enumerateDevices === undefined\n            || navigator.mediaDevices.getUserMedia === undefined) {\n            var fctName = \"\";\n            if (navigator.mediaDevices === undefined) {\n                fctName = \"navigator.mediaDevices\";\n            }\n            else if (navigator.mediaDevices.enumerateDevices === undefined) {\n                fctName = \"navigator.mediaDevices.enumerateDevices\";\n            }\n            else if (navigator.mediaDevices.getUserMedia === undefined) {\n                fctName = \"navigator.mediaDevices.getUserMedia\";\n            }\n            else {\n                console.assert(false);\n            }\n            onError({\n                name: \"\",\n                message: \"WebRTC issue-! \" + fctName + \" not present in your browser\"\n            });\n            return null;\n        }\n        // get available devices\n        navigator.mediaDevices.enumerateDevices().then(function (devices) {\n            var userMediaConstraints = {\n                audio: false,\n                video: {\n                    facingMode: \"environment\",\n                    width: {\n                        ideal: _this.parameters.sourceWidth,\n                    },\n                    height: {\n                        ideal: _this.parameters.sourceHeight,\n                    }\n                }\n            };\n            if (null !== _this.parameters.deviceId) {\n                userMediaConstraints.video.deviceId = {\n                    exact: _this.parameters.deviceId\n                };\n            }\n            // get a device which satisfy the constraints\n            navigator.mediaDevices.getUserMedia(userMediaConstraints).then(function success(stream) {\n                // set the .src of the domElement\n                domElement.srcObject = stream;\n                // to start the video, when it is possible to start it only on userevent. like in android\n                document.body.addEventListener(\"click\", function () {\n                    domElement.play();\n                });\n                // domElement.play();\n                // TODO listen to loadedmetadata instead\n                // wait until the video stream is ready\n                var interval = setInterval(function () {\n                    if (!domElement.videoWidth) {\n                        return;\n                    }\n                    onReady();\n                    clearInterval(interval);\n                }, 1000 / 50);\n            }).catch(function (error) {\n                onError({\n                    name: error.name,\n                    message: error.message\n                });\n            });\n        }).catch(function (error) {\n            onError({\n                message: error.message\n            });\n        });\n        return domElement;\n    };\n    ARSource.prototype.hasMobileTorch = function (domElement) {\n        var stream = domElement.srcObject;\n        if (stream instanceof MediaStream === false) {\n            return false;\n        }\n        if (this.currentTorchStatus === undefined) {\n            this.currentTorchStatus = false;\n        }\n        var videoTrack = stream.getVideoTracks()[0];\n        // if videoTrack.getCapabilities() doesnt exist, return false now\n        if (videoTrack.getCapabilities === undefined) {\n            return false;\n        }\n        var capabilities = videoTrack.getCapabilities();\n        return capabilities.torch ? true : false;\n    };\n    /**\n     * toggle the flash/torch of the mobile fun if applicable.\n     * Great post about it https://www.oberhofer.co/mediastreamtrack-and-its-capabilities/\n     */\n    ARSource.prototype.toggleMobileTorch = function (domElement) {\n        // sanity check\n        if (!this.hasMobileTorch(domElement) === true) {\n            return;\n        }\n        var stream = domElement.srcObject;\n        if (stream instanceof MediaStream === false) {\n            alert(\"enabling mobile torch is available only on webcam\");\n            return;\n        }\n        if (this.currentTorchStatus === undefined) {\n            this.currentTorchStatus = false;\n        }\n        var videoTrack = stream.getVideoTracks()[0];\n        var capabilities = videoTrack.getCapabilities();\n        if (!capabilities.torch) {\n            alert(\"no mobile torch is available on your camera\");\n            return;\n        }\n        this.currentTorchStatus = this.currentTorchStatus === false ? true : false;\n        videoTrack.applyConstraints({\n            advanced: [{\n                    torch: this.currentTorchStatus\n                }]\n        }).catch(function (error) {\n            throw error;\n        });\n    };\n    ARSource.prototype.domElementWidth = function () {\n        return this.domElement ? parseInt(this.domElement.style.width, 10) : 0;\n    };\n    ARSource.prototype.domElementHeight = function () {\n        return this.domElement ? parseInt(this.domElement.style.height, 10) : 0;\n    };\n    ARSource.prototype.onResizeElement = function () {\n        var screenWidth = window.innerWidth;\n        var screenHeight = window.innerHeight;\n        var sourceHeight = 0;\n        var sourceWidth = 0;\n        // compute sourceWidth, sourceHeight\n        if (this.domElement.nodeName === \"IMG\") {\n            sourceWidth = this.domElement.naturalWidth;\n            sourceHeight = this.domElement.naturalHeight;\n        }\n        else if (this.domElement.nodeName === \"VIDEO\") {\n            sourceWidth = this.domElement.videoWidth;\n            sourceHeight = this.domElement.videoHeight;\n        }\n        else {\n            console.assert(false);\n        }\n        // compute sourceAspect\n        var sourceAspect = sourceWidth / sourceHeight;\n        // compute screenAspect\n        var screenAspect = screenWidth / screenHeight;\n        // if screenAspect < sourceAspect, then change the width, else change the height\n        if (screenAspect < sourceAspect) {\n            // compute newWidth and set .width/.marginLeft\n            var newWidth = sourceAspect * screenHeight;\n            this.domElement.style.width = newWidth + \"px\";\n            this.domElement.style.marginLeft = -(newWidth - screenWidth) / 2 + \"px\";\n            // init style.height/.marginTop to normal value\n            this.domElement.style.height = screenHeight + \"px\";\n            this.domElement.style.marginTop = \"0px\";\n        }\n        else {\n            // compute newHeight and set .height/.marginTop\n            var newHeight = 1 / (sourceAspect / screenWidth);\n            this.domElement.style.height = newHeight + \"px\";\n            this.domElement.style.marginTop = -(newHeight - screenHeight) / 2 + \"px\";\n            // init style.width/.marginLeft to normal value\n            this.domElement.style.width = screenWidth + \"px\";\n            this.domElement.style.marginLeft = \"0px\";\n        }\n    };\n    ARSource.prototype.copyElementSizeTo = function (otherElement) {\n        if (window.innerWidth > window.innerHeight) {\n            // landscape\n            otherElement.style.width = this.domElement.style.width;\n            otherElement.style.height = this.domElement.style.height;\n            otherElement.style.marginLeft = this.domElement.style.marginLeft;\n            otherElement.style.marginTop = this.domElement.style.marginTop;\n        }\n        else {\n            // portrait\n            otherElement.style.height = this.domElement.style.height;\n            otherElement.style.width = (parseInt(otherElement.style.height, 10) * 4 / 3) + \"px\";\n            otherElement.style.marginLeft = ((window.innerWidth - parseInt(otherElement.style.width, 10)) / 2) + \"px\";\n            otherElement.style.marginTop = 0;\n        }\n    };\n    ARSource.prototype.onResize = function (arToolkitContext, renderer, camera) {\n        if (arguments.length !== 3) {\n            console.warn(\"obsolete function ARSource.onResize. Use arToolkitSource.onResizeElement\");\n            return this.onResizeElement.apply(this, arguments);\n        }\n        var trackingBackend = arToolkitContext.parameters.trackingBackend;\n        // RESIZE DOMELEMENT\n        if (trackingBackend === \"artoolkit\") {\n            this.onResizeElement();\n            var isAframe = renderer.domElement.dataset.aframeCanvas ? true : false;\n            if (isAframe === false) {\n                this.copyElementSizeTo(renderer.domElement);\n            }\n            if (arToolkitContext.arController !== null) {\n                this.copyElementSizeTo(arToolkitContext.arController.canvas);\n            }\n        }\n        // UPDATE CAMERA\n        if (trackingBackend === \"artoolkit\") {\n            if (arToolkitContext.arController !== null) {\n                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());\n            }\n        }\n    };\n    return ARSource;\n}());\nexports.ARSource = ARSource;\nexports.default = ARSource;\n\n\n//# sourceURL=webpack://THREEAR/./src/ARSource.ts?");

/***/ }),

/***/ "./src/ARToolkitAPI.ts":
/*!*****************************!*\
  !*** ./src/ARToolkitAPI.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar artoolkitx_1 = __webpack_require__(/*! ./vendor/artoolkitx */ \"./src/vendor/artoolkitx.js\");\nvar ARToolkit = /** @class */ (function () {\n    function ARToolkit() {\n    }\n    ARToolkit.getMarkerInfo = function () {\n        return artoolkitx_1.default.markerInfo;\n    };\n    ARToolkit.deleteCamera = function (id) {\n        throw Error(\"deleteCamera not implemented\");\n        // TODO: This was never implemented\n    };\n    ARToolkit.loadCamera = function (url, callback, onerror) {\n        var filename = \"/camera_param_\" + ARToolkit.cameraCount++;\n        var writeCallback = function () {\n            var id = artoolkitx_1.default._loadCamera(filename);\n            if (callback) {\n                callback(id);\n            }\n        };\n        if (typeof url === \"object\") { // Maybe it's a byte array\n            ARToolkit.writeByteArrayToFS(filename, url, writeCallback);\n        }\n        else if (url.indexOf(\"\\n\") > -1) { // Or a string with the camera param\n            ARToolkit.writeStringToFS(filename, url, writeCallback);\n        }\n        else {\n            ARToolkit.ajax(url, filename, writeCallback);\n        }\n    };\n    ARToolkit.getFrameMalloc = function () {\n        return artoolkitx_1.default.frameMalloc;\n    };\n    ARToolkit.runtimeLoad = function () {\n        ARToolkit.FUNCTIONS.forEach(function (n) {\n            ARToolkit[n] = artoolkitx_1.default[n];\n        });\n        ARToolkit.HEAPU8 = artoolkitx_1.default.HEAPU8;\n        for (var m in artoolkitx_1.default) {\n            if (m.match(/^AR/)) {\n                ARToolkit[m] = artoolkitx_1.default[m];\n            }\n        }\n    };\n    ARToolkit.addMarker = function (arId, url, callback, onError) {\n        var filename = \"/marker_\" + ARToolkit.markerCount++;\n        ARToolkit.ajax(url, filename, function () {\n            var id = artoolkitx_1.default._addMarker(arId, filename);\n            if (callback) {\n                callback(id);\n            }\n        });\n    };\n    ARToolkit.addNFTMarker = function (arId, url, callback) {\n        var mId = ARToolkit.markerCount++;\n        var prefix = \"/markerNFT_\" + mId;\n        var filename1 = prefix + \".fset\";\n        var filename2 = prefix + \".iset\";\n        var filename3 = prefix + \".fset3\";\n        ARToolkit.ajax(url + \".fset\", filename1, function () {\n            ARToolkit.ajax(url + \".iset\", filename2, function () {\n                ARToolkit.ajax(url + \".fset3\", filename3, function () {\n                    var id = artoolkitx_1.default._addNFTMarker(arId, prefix);\n                    if (callback) {\n                        callback(id);\n                    }\n                });\n            });\n        });\n    };\n    ARToolkit.bytesToString = function (array) {\n        return String.fromCharCode.apply(String, array);\n    };\n    ARToolkit.parseMultiFile = function (bytes) {\n        var str = this.bytesToString(bytes);\n        var lines = str.split(\"\\n\");\n        var files = [];\n        var state = 0; // 0 - read,\n        var markers = 0;\n        lines.forEach(function (line) {\n            line = line.trim();\n            if (!line || line.startsWith(\"#\")) {\n                return;\n            }\n            switch (state) {\n                case 0:\n                    markers = +line;\n                    state = 1;\n                    return;\n                case 1: // filename or barcode\n                    if (!line.match(/^\\d+$/)) {\n                        files.push(line);\n                    }\n                case 2: // width\n                case 3: // matrices\n                case 4:\n                    state++;\n                    return;\n                case 5:\n                    state = 1;\n                    return;\n            }\n        });\n        return files;\n    };\n    ARToolkit.addMultiMarker = function (arId, url, callback, onError) {\n        var _this = this;\n        var filename = \"/multi_marker_\" + ARToolkit.multiMarkerCount++;\n        ARToolkit.ajax(url, filename, function (bytes) {\n            var files = _this.parseMultiFile(bytes);\n            var ok = function () {\n                var markerID = artoolkitx_1.default._addMultiMarker(arId, filename);\n                var markerNum = artoolkitx_1.default.getMultiMarkerNum(arId, markerID);\n                if (callback) {\n                    callback(markerID, markerNum);\n                }\n            };\n            if (!files.length) {\n                return ok();\n            }\n            var path = url.split(\"/\").slice(0, -1).join(\"/\");\n            files = files.map(function (file) {\n                return [path + \"/\" + file, file];\n            });\n            ARToolkit.ajaxDependencies(files, ok);\n        });\n    };\n    // transfer image\n    ARToolkit.writeStringToFS = function (target, string, callback) {\n        var byteArray = new Uint8Array(string.length);\n        for (var i = 0; i < byteArray.length; i++) {\n            byteArray[i] = string.charCodeAt(i) & 0xff;\n        }\n        ARToolkit.writeByteArrayToFS(target, byteArray, callback);\n    };\n    ARToolkit.writeByteArrayToFS = function (target, byteArray, callback) {\n        artoolkitx_1.default.FS.writeFile(target, byteArray, { encoding: \"binary\" });\n        callback(byteArray);\n    };\n    // Eg.\n    // \tajax('../bin/Data2/markers.dat', '/Data2/markers.dat', callback);\n    // \tajax('../bin/Data/patt.hiro', '/patt.hiro', callback);\n    ARToolkit.ajax = function (url, target, callback) {\n        var oReq = new XMLHttpRequest();\n        oReq.open(\"GET\", url, true);\n        oReq.responseType = \"arraybuffer\"; // blob arraybuffer\n        oReq.onload = function () {\n            var arrayBuffer = oReq.response;\n            var byteArray = new Uint8Array(arrayBuffer);\n            ARToolkit.writeByteArrayToFS(target, byteArray, callback);\n        };\n        oReq.send();\n    };\n    ARToolkit.ajaxDependencies = function (files, callback) {\n        var next = files.pop();\n        if (next) {\n            ARToolkit.ajax(next[0], next[1], function () {\n                ARToolkit.ajaxDependencies(files, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n    ARToolkit.UNKNOWN_MARKER = -1;\n    ARToolkit.PATTERN_MARKER = 0;\n    ARToolkit.BARCODE_MARKER = 1;\n    ARToolkit.FUNCTIONS = [\n        \"setup\",\n        \"teardown\",\n        \"setupAR2\",\n        \"setLogLevel\",\n        \"getLogLevel\",\n        \"setDebugMode\",\n        \"getDebugMode\",\n        \"getProcessingImage\",\n        \"setMarkerInfoDir\",\n        \"setMarkerInfoVertex\",\n        \"getTransMatSquare\",\n        \"getTransMatSquareCont\",\n        \"getTransMatMultiSquare\",\n        \"getTransMatMultiSquareRobust\",\n        \"getMultiMarkerNum\",\n        \"getMultiMarkerCount\",\n        \"detectMarker\",\n        \"getMarkerNum\",\n        \"detectNFTMarker\",\n        \"getMarker\",\n        \"getMultiEachMarker\",\n        \"getNFTMarker\",\n        \"setProjectionNearPlane\",\n        \"getProjectionNearPlane\",\n        \"setProjectionFarPlane\",\n        \"getProjectionFarPlane\",\n        \"setThresholdMode\",\n        \"getThresholdMode\",\n        \"setThreshold\",\n        \"getThreshold\",\n        \"setPatternDetectionMode\",\n        \"getPatternDetectionMode\",\n        \"setMatrixCodeType\",\n        \"getMatrixCodeType\",\n        \"setLabelingMode\",\n        \"getLabelingMode\",\n        \"setPattRatio\",\n        \"getPattRatio\",\n        \"setImageProcMode\",\n        \"getImageProcMode\",\n    ];\n    ARToolkit.markerCount = 0;\n    ARToolkit.multiMarkerCount = 0;\n    ARToolkit.cameraCount = 0;\n    return ARToolkit;\n}());\nexports.ARToolkit = ARToolkit;\nARToolkit.runtimeLoad();\nexports.default = ARToolkit;\n\n\n//# sourceURL=webpack://THREEAR/./src/ARToolkitAPI.ts?");

/***/ }),

/***/ "./src/ARUtils.ts":
/*!************************!*\
  !*** ./src/ARUtils.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nvar ARUtils = /** @class */ (function () {\n    function ARUtils() {\n    }\n    /**\n     * Create a default rendering camera for this trackingBackend.\n     * They may be modified later. to fit physical camera parameters\n     *\n     * @param {string} trackingBackend - the tracking to user\n     * @return {THREE.Camera} the created camera\n     */\n    ARUtils.createDefaultCamera = function (trackingMethod) {\n        var trackingBackend = this.parseTrackingMethod(trackingMethod).trackingBackend;\n        var camera;\n        // Create a camera\n        if (trackingBackend === \"artoolkit\") {\n            camera = new THREE.Camera();\n        }\n        else if (trackingBackend === \"aruco\") {\n            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.01, 100);\n        }\n        else if (trackingBackend === \"tango\") {\n            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.01, 100);\n        }\n        else {\n            throw Error(\"unknown trackingBackend: \" + trackingBackend);\n        }\n        return camera;\n    };\n    /**\n     * test if the code is running on tango\n     *\n     * @return {boolean} - true if running on tango, false otherwise\n     */\n    ARUtils.isTango = function () {\n        // FIXME: this test is super bad\n        var isTango = navigator.userAgent.match(\"Chrome/57.0.2987.5\") !== null ? true : false;\n        return isTango;\n    };\n    /**\n     * parse tracking method\n     *\n     * @param {String} trackingMethod - the tracking method to parse\n     * @return {Object} - various field of the tracking method\n     */\n    ARUtils.parseTrackingMethod = function (trackingMethod) {\n        if (trackingMethod === \"best\") {\n            trackingMethod = ARUtils.isTango() ? \"tango\" : \"area-artoolkit\";\n        }\n        if (trackingMethod.startsWith(\"area-\")) {\n            return {\n                trackingBackend: trackingMethod.replace(\"area-\", \"\"),\n                markersAreaEnabled: true,\n            };\n        }\n        else {\n            return {\n                trackingBackend: trackingMethod,\n                markersAreaEnabled: false,\n            };\n        }\n    };\n    return ARUtils;\n}());\nexports.ARUtils = ARUtils;\nexports.default = ARUtils;\n\n\n//# sourceURL=webpack://THREEAR/./src/ARUtils.ts?");

/***/ }),

/***/ "./src/THREEAR.ts":
/*!************************!*\
  !*** ./src/THREEAR.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ARBaseControls_1 = __webpack_require__(/*! ./ARBaseControls */ \"./src/ARBaseControls.ts\");\nexports.ARBaseControls = ARBaseControls_1.default;\nvar ARCameraParam_1 = __webpack_require__(/*! ./ARCameraParam */ \"./src/ARCameraParam.ts\");\nexports.ARCameraParam = ARCameraParam_1.default;\nvar ARContext_1 = __webpack_require__(/*! ./ARContext */ \"./src/ARContext.ts\");\nexports.ARContext = ARContext_1.default;\nvar ARController_1 = __webpack_require__(/*! ./ARController */ \"./src/ARController.ts\");\nexports.ARController = ARController_1.default;\nvar ARMarkerControls_1 = __webpack_require__(/*! ./ARMarkerControls */ \"./src/ARMarkerControls.ts\");\nexports.ARMarkerControls = ARMarkerControls_1.default;\nvar ARProfile_1 = __webpack_require__(/*! ./ARProfile */ \"./src/ARProfile.ts\");\nexports.ARProfile = ARProfile_1.default;\nvar ARSource_1 = __webpack_require__(/*! ./ARSource */ \"./src/ARSource.ts\");\nexports.ARSource = ARSource_1.default;\nvar ARToolkitAPI_1 = __webpack_require__(/*! ./ARToolkitAPI */ \"./src/ARToolkitAPI.ts\");\nexports.ARToolkitAPI = ARToolkitAPI_1.default;\nvar ARUtils_1 = __webpack_require__(/*! ./ARUtils */ \"./src/ARUtils.ts\");\nexports.ARUtils = ARUtils_1.default;\n\n\n//# sourceURL=webpack://THREEAR/./src/THREEAR.ts?");

/***/ }),

/***/ "./src/vendor/artoolkitx.js":
/*!**********************************!*\
  !*** ./src/vendor/artoolkitx.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process, Buffer) {// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {};\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nModule['arguments'] = [];\nModule['thisProgram'] = './this.program';\nModule['quit'] = function(status, toThrow) {\n  throw toThrow;\n};\nModule['preRun'] = [];\nModule['postRun'] = [];\n\n// The environment setup code below is customized to use Module.\n// *** Environment setup code ***\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\n\n// Three configurations we can be running in:\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\nif (Module['ENVIRONMENT']) {\n  if (Module['ENVIRONMENT'] === 'WEB') {\n    ENVIRONMENT_IS_WEB = true;\n  } else if (Module['ENVIRONMENT'] === 'WORKER') {\n    ENVIRONMENT_IS_WORKER = true;\n  } else if (Module['ENVIRONMENT'] === 'NODE') {\n    ENVIRONMENT_IS_NODE = true;\n  } else if (Module['ENVIRONMENT'] === 'SHELL') {\n    ENVIRONMENT_IS_SHELL = true;\n  } else {\n    throw new Error('Module[\\'ENVIRONMENT\\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.');\n  }\n} else {\n  ENVIRONMENT_IS_WEB = typeof window === 'object';\n  ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n  ENVIRONMENT_IS_NODE = typeof process === 'object' && \"function\" === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n}\n\n\n// if (ENVIRONMENT_IS_NODE) {\n//   // Expose functionality in the same simple way that the shells work\n//   // Note that we pollute the global namespace here, otherwise we break in node\n//   var nodeFS;\n//   var nodePath;\n\n//   Module['read'] = function shell_read(filename, binary) {\n//     var ret;\n//     ret = tryParseAsDataURI(filename);\n//     if (!ret) {\n//       if (!nodeFS) nodeFS = require('fs');\n//       if (!nodePath) nodePath = require('path');\n//       filename = nodePath['normalize'](filename);\n//       ret = nodeFS['readFileSync'](filename);\n//     }\n//     return binary ? ret : ret.toString();\n//   };\n\n//   Module['readBinary'] = function readBinary(filename) {\n//     var ret = Module['read'](filename, true);\n//     if (!ret.buffer) {\n//       ret = new Uint8Array(ret);\n//     }\n//     assert(ret.buffer);\n//     return ret;\n//   };\n\n//   if (process['argv'].length > 1) {\n//     Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n//   }\n\n//   Module['arguments'] = process['argv'].slice(2);\n\n//   if (typeof module !== 'undefined') {\n//     module['exports'] = Module;\n//   }\n\n//   process['on']('uncaughtException', function(ex) {\n//     // suppress ExitStatus exceptions from showing an error\n//     if (!(ex instanceof ExitStatus)) {\n//       throw ex;\n//     }\n//   });\n//   // Currently node will swallow unhandled rejections, but this behavior is\n//   // deprecated, and in the future it will exit with error status.\n//   process['on']('unhandledRejection', function(reason, p) {\n//     Module['printErr']('node.js exiting due to unhandled promise rejection');\n//     process['exit'](1);\n//   });\n\n//   Module['inspect'] = function () { return '[Emscripten Module object]'; };\n// } else\n// if (ENVIRONMENT_IS_SHELL) {\n//   if (typeof read != 'undefined') {\n//     Module['read'] = function shell_read(f) {\n//       var data = tryParseAsDataURI(f);\n//       if (data) {\n//         return intArrayToString(data);\n//       }\n//       return read(f);\n//     };\n//   }\n\n//   Module['readBinary'] = function readBinary(f) {\n//     var data;\n//     data = tryParseAsDataURI(f);\n//     if (data) {\n//       return data;\n//     }\n//     if (typeof readbuffer === 'function') {\n//       return new Uint8Array(readbuffer(f));\n//     }\n//     data = read(f, 'binary');\n//     assert(typeof data === 'object');\n//     return data;\n//   };\n\n//   if (typeof scriptArgs != 'undefined') {\n//     Module['arguments'] = scriptArgs;\n//   } else if (typeof arguments != 'undefined') {\n//     Module['arguments'] = arguments;\n//   }\n\n//   if (typeof quit === 'function') {\n//     Module['quit'] = function(status, toThrow) {\n//       quit(status);\n//     }\n//   }\n// } else\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  Module['read'] = function shell_read(url) {\n    try {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n    } catch (err) {\n      var data = tryParseAsDataURI(url);\n      if (data) {\n        return intArrayToString(data);\n      }\n      throw err;\n    }\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    Module['readBinary'] = function readBinary(url) {\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n      } catch (err) {\n        var data = tryParseAsDataURI(url);\n        if (data) {\n          return data;\n        }\n        throw err;\n      }\n    };\n  }\n\n  Module['readAsync'] = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      var data = tryParseAsDataURI(url);\n      if (data) {\n        onload(data.buffer);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n  Module['setWindowTitle'] = function(title) { document.title = title };\n} else\n{\n  throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n}\n\n// console.log is checked first, as 'print' on the web will open a print dialogue\n// printErr is preferable to console.warn (works better in shells)\n// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\nModule['print'] = typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null);\nModule['printErr'] = typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || Module['print']);\n\n// *** Environment setup code ***\n\n// Closure helpers\nModule.print = Module['print'];\nModule.printErr = Module['printErr'];\n\n// Merge back in the overrides\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = undefined;\n\n\n\n// {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16;\n\n// stack management, and other functionality that is provided by the compiled code,\n// should not be used before it is ready\nstackSave = stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function() {\n  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n};\n\nfunction staticAlloc(size) {\n  assert(!staticSealed);\n  var ret = STATICTOP;\n  STATICTOP = (STATICTOP + size + 15) & -16;\n  return ret;\n}\n\nfunction dynamicAlloc(size) {\n  assert(DYNAMICTOP_PTR);\n  var ret = HEAP32[DYNAMICTOP_PTR>>2];\n  var end = (ret + size + 15) & -16;\n  HEAP32[DYNAMICTOP_PTR>>2] = end;\n  if (end >= TOTAL_MEMORY) {\n    var success = enlargeMemory();\n    if (!success) {\n      HEAP32[DYNAMICTOP_PTR>>2] = ret;\n      return 0;\n    }\n  }\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n  var ret = size = Math.ceil(size / factor) * factor;\n  return ret;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': return 1;\n    case 'i16': return 2;\n    case 'i32': return 4;\n    case 'i64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length-1] === '*') {\n        return 4; // A pointer\n      } else if (type[0] === 'i') {\n        var bits = parseInt(type.substr(1));\n        assert(bits % 8 === 0);\n        return bits / 8;\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    Module.printErr(text);\n  }\n}\n\nvar asm2wasmImports = { // special asm2wasm imports\n    \"f64-rem\": function(x, y) {\n        return x % y;\n    },\n    \"debugger\": function() {\n        debugger;\n    }\n};\n\n\n\nvar jsCallStartIndex = 1;\nvar functionPointers = new Array(0);\n\n// 'sig' parameter is only used on LLVM wasm backend\nfunction addFunction(func, sig) {\n  if (typeof sig === 'undefined') {\n    Module.printErr('warning: addFunction(): You should provide a wasm function signature string as a second argument. This is not necessary for asm.js and asm2wasm, but is required for the LLVM wasm backend, so it is recommended for full portability.');\n  }\n  var base = 0;\n  for (var i = base; i < base + 0; i++) {\n    if (!functionPointers[i]) {\n      functionPointers[i] = func;\n      return jsCallStartIndex + i;\n    }\n  }\n  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n}\n\nfunction removeFunction(index) {\n  functionPointers[index-jsCallStartIndex] = null;\n}\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n  assert(sig);\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n  var sigCache = funcWrappers[sig];\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n  return sigCache[func];\n}\n\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    assert(args.length == sig.length-1);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    assert(sig.length == 1);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\n\nfunction getCompilerSetting(name) {\n  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n}\n\nvar Runtime = {\n  // FIXME backwards compatibility layer for ports. Support some Runtime.*\n  //       for now, fix it there, then remove it from here. That way we\n  //       can minimize any period of breakage.\n  dynCall: dynCall, // for SDL2 port\n  // helpful errors\n  getTempRet0: function() { abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  staticAlloc: function() { abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  stackAlloc: function() { abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n};\n\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\nvar GLOBAL_BASE = 8;\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n\n\n//========================================\n// Runtime essentials\n//========================================\n\nvar ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()\nvar EXITSTATUS = 0;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\nvar globalScope = undefined;\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\nvar JSfuncs = {\n  // Helpers for cwrap -- it can't refer to Runtime directly because it might\n  // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n  // out what the minified function name is.\n  'stackSave': function() {\n    stackSave()\n  },\n  'stackRestore': function() {\n    stackRestore()\n  },\n  // type conversion from js to c\n  'arrayToC' : function(arr) {\n    var ret = stackAlloc(arr.length);\n    writeArrayToMemory(arr, ret);\n    return ret;\n  },\n  'stringToC' : function(str) {\n    var ret = 0;\n    if (str !== null && str !== undefined && str !== 0) { // null string\n      // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n      var len = (str.length << 2) + 1;\n      ret = stackAlloc(len);\n      stringToUTF8(str, ret, len);\n    }\n    return ret;\n  }\n};\n\n// For fast lookup of conversion functions\nvar toC = {\n  'string': JSfuncs['stringToC'], 'array': JSfuncs['arrayToC']\n};\n\n// C calling interface.\nfunction ccall (ident, returnType, argTypes, args, opts) {\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n  if (returnType === 'string') ret = Pointer_stringify(ret);\n  else if (returnType === 'boolean') ret = Boolean(ret);\n  if (stack !== 0) {\n    stackRestore(stack);\n  }\n  return ret;\n}\n\nfunction cwrap (ident, returnType, argTypes) {\n  argTypes = argTypes || [];\n  var cfunc = getCFunc(ident);\n  // When the function takes numbers and returns a number, we can just return\n  // the original function\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\n  var numericRet = returnType !== 'string';\n  if (numericRet && numericArgs) {\n    return cfunc;\n  }\n  return function() {\n    return ccall(ident, returnType, argTypes, arguments);\n  }\n}\n\n/** @type {function(number, number, string, boolean=)} */\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= (+1) ? (tempDouble > (+0) ? ((Math_min((+(Math_floor((tempDouble)/(+4294967296)))), (+4294967295)))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/(+4294967296))))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n}\n\n/** @type {function(number, string, boolean=)} */\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for getValue: ' + type);\n    }\n  return null;\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_STATIC = 2; // Cannot be freed\nvar ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 4; // Do not allocate\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[((ptr)>>2)]=0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[((ptr++)>>0)]=0;\n    }\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n\n  var i = 0, type, typeSize, previousType;\n  while (i < size) {\n    var curr = slab[i];\n\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n    assert(type, 'Must know what type to store in allocate!');\n\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret+i, curr, type);\n\n    // no need to look up size unless type changes, so cache it\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n\n  return ret;\n}\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n  if (!staticSealed) return staticAlloc(size);\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n}\n\n/** @type {function(number, number=)} */\nfunction Pointer_stringify(ptr, length) {\n  if (length === 0 || !ptr) return '';\n  // Find the length, and check for UTF while doing so\n  var hasUtf = 0;\n  var t;\n  var i = 0;\n  while (1) {\n    assert(ptr + i < TOTAL_MEMORY);\n    t = HEAPU8[(((ptr)+(i))>>0)];\n    hasUtf |= t;\n    if (t == 0 && !length) break;\n    i++;\n    if (length && i == length) break;\n  }\n  if (!length) length = i;\n\n  var ret = '';\n\n  if (hasUtf < 128) {\n    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n    var curr;\n    while (length > 0) {\n      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n      ret = ret ? ret + curr : curr;\n      ptr += MAX_CHUNK;\n      length -= MAX_CHUNK;\n    }\n    return ret;\n  }\n  return UTF8ToString(ptr);\n}\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = HEAP8[((ptr++)>>0)];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\nfunction UTF8ArrayToString(u8Array, idx) {\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  while (u8Array[endPtr]) ++endPtr;\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var u0, u1, u2, u3, u4, u5;\n\n    var str = '';\n    while (1) {\n      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n      u0 = u8Array[idx++];\n      if (!u0) return str;\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n      u1 = u8Array[idx++] & 63;\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n      u2 = u8Array[idx++] & 63;\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u3 = u8Array[idx++] & 63;\n        if ((u0 & 0xF8) == 0xF0) {\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n        } else {\n          u4 = u8Array[idx++] & 63;\n          if ((u0 & 0xFC) == 0xF8) {\n            u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;\n          } else {\n            u5 = u8Array[idx++] & 63;\n            u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;\n          }\n        }\n      }\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n      }\n    }\n  }\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction UTF8ToString(ptr) {\n  return UTF8ArrayToString(HEAPU8,ptr);\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x1FFFFF) {\n      if (outIdx + 3 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x3FFFFFF) {\n      if (outIdx + 4 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF8 | (u >> 24);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 5 >= endIdx) break;\n      outU8Array[outIdx++] = 0xFC | (u >> 30);\n      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) {\n      ++len;\n    } else if (u <= 0x7FF) {\n      len += 2;\n    } else if (u <= 0xFFFF) {\n      len += 3;\n    } else if (u <= 0x1FFFFF) {\n      len += 4;\n    } else if (u <= 0x3FFFFFF) {\n      len += 5;\n    } else {\n      len += 6;\n    }\n  }\n  return len;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\nfunction UTF16ToString(ptr) {\n  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n  var endPtr = ptr;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  var idx = endPtr >> 1;\n  while (HEAP16[idx]) ++idx;\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n\n    var str = '';\n    while (1) {\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n      if (codeUnit == 0) return str;\n      ++i;\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    HEAP16[((outPtr)>>1)]=codeUnit;\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP16[((outPtr)>>1)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\nfunction UTF32ToString(ptr) {\n  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n    if (utf32 == 0)\n      return str;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    HEAP32[((outPtr)>>2)]=codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP32[((outPtr)>>2)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n// Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = _malloc(size);\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Allocate stack space for a JS string, and write it there.\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\nfunction demangle(func) {\n  var __cxa_demangle_func = Module['___cxa_demangle'] || Module['__cxa_demangle'];\n  assert(__cxa_demangle_func);\n  try {\n    var s =\n      func.substr(1);\n    var len = lengthBytesUTF8(s)+1;\n    var buf = _malloc(len);\n    stringToUTF8(s, buf, len);\n    var status = _malloc(4);\n    var ret = __cxa_demangle_func(buf, 0, 0, status);\n    if (HEAP32[((status)>>2)] === 0 && ret) {\n      return Pointer_stringify(ret);\n    }\n    // otherwise, libcxxabi failed\n  } catch(e) {\n    // ignore problems here\n  } finally {\n    if (buf) _free(buf);\n    if (status) _free(status);\n    if (ret) _free(ret);\n  }\n  // failure when using libcxxabi, don't demangle\n  return func;\n}\n\nfunction demangleAll(text) {\n  var regex =\n    /__Z[\\w\\d_]+/g;\n  return text.replace(regex,\n    function(x) {\n      var y = demangle(x);\n      return x === y ? x : (x + ' [' + y + ']');\n    });\n}\n\nfunction jsStackTrace() {\n  var err = new Error();\n  if (!err.stack) {\n    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n    // so try that as a special-case.\n    try {\n      throw new Error(0);\n    } catch(e) {\n      err = e;\n    }\n    if (!err.stack) {\n      return '(no stack trace available)';\n    }\n  }\n  return err.stack.toString();\n}\n\nfunction stackTrace() {\n  var js = jsStackTrace();\n  if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n  return demangleAll(js);\n}\n\n// Memory management\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\nvar MIN_TOTAL_MEMORY = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - (x % multiple);\n  }\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\n  buffer,\n/** @type {Int8Array} */\n  HEAP8,\n/** @type {Uint8Array} */\n  HEAPU8,\n/** @type {Int16Array} */\n  HEAP16,\n/** @type {Uint16Array} */\n  HEAPU16,\n/** @type {Int32Array} */\n  HEAP32,\n/** @type {Uint32Array} */\n  HEAPU32,\n/** @type {Float32Array} */\n  HEAPF32,\n/** @type {Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBuffer(buf) {\n  Module['buffer'] = buffer = buf;\n}\n\nfunction updateGlobalBufferViews() {\n  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n}\n\nvar STATIC_BASE, STATICTOP, staticSealed; // static area\nvar STACK_BASE, STACKTOP, STACK_MAX; // stack area\nvar DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\n\n  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\n  staticSealed = false;\n\n\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  assert((STACK_MAX & 3) == 0);\n  HEAPU32[(STACK_MAX >> 2)-1] = 0x02135467;\n  HEAPU32[(STACK_MAX >> 2)-2] = 0x89BACDFE;\n}\n\nfunction checkStackCookie() {\n  if (HEAPU32[(STACK_MAX >> 2)-1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2)-2] != 0x89BACDFE) {\n    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2)-2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2)-1].toString(16));\n  }\n  // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own.\n  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';\n}\n\nfunction abortStackOverflow(allocSize) {\n  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n}\n\nfunction abortOnCannotGrowMemory() {\n  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n}\n\nif (!Module['reallocBuffer']) Module['reallocBuffer'] = function(size) {\n  var ret;\n  try {\n    if (ArrayBuffer.transfer) {\n      ret = ArrayBuffer.transfer(buffer, size);\n    } else {\n      var oldHEAP8 = HEAP8;\n      ret = new ArrayBuffer(size);\n      var temp = new Int8Array(ret);\n      temp.set(oldHEAP8);\n    }\n  } catch(e) {\n    return false;\n  }\n  var success = _emscripten_replace_memory(ret);\n  if (!success) return false;\n  return ret;\n};\n\nfunction enlargeMemory() {\n  // TOTAL_MEMORY is the current size of the actual array, and DYNAMICTOP is the new top.\n  assert(HEAP32[DYNAMICTOP_PTR>>2] > TOTAL_MEMORY); // This function should only ever be called after the ceiling of the dynamic heap has already been bumped to exceed the current total size of the asm.js heap.\n\n\n  var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n  var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.\n\n  if (HEAP32[DYNAMICTOP_PTR>>2] > LIMIT) {\n    Module.printErr('Cannot enlarge memory, asked to go up to ' + HEAP32[DYNAMICTOP_PTR>>2] + ' bytes, but the limit is ' + LIMIT + ' bytes!');\n    return false;\n  }\n\n  var OLD_TOTAL_MEMORY = TOTAL_MEMORY;\n  TOTAL_MEMORY = Math.max(TOTAL_MEMORY, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.\n\n  while (TOTAL_MEMORY < HEAP32[DYNAMICTOP_PTR>>2]) { // Keep incrementing the heap size as long as it's less than what is requested.\n    if (TOTAL_MEMORY <= 536870912) {\n      TOTAL_MEMORY = alignUp(2 * TOTAL_MEMORY, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...\n    } else {\n      // ..., but after that, add smaller increments towards 2GB, which we cannot reach\n      TOTAL_MEMORY = Math.min(alignUp((3 * TOTAL_MEMORY + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);\n      if (TOTAL_MEMORY === OLD_TOTAL_MEMORY) {\n        warnOnce('Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only ' + TOTAL_MEMORY);\n      }\n    }\n  }\n\n  var start = Date.now();\n\n  var replacement = Module['reallocBuffer'](TOTAL_MEMORY);\n  if (!replacement || replacement.byteLength != TOTAL_MEMORY) {\n    Module.printErr('Failed to grow the heap from ' + OLD_TOTAL_MEMORY + ' bytes to ' + TOTAL_MEMORY + ' bytes, not enough memory!');\n    if (replacement) {\n      Module.printErr('Expected to get back a buffer of size ' + TOTAL_MEMORY + ' bytes, but instead got back a buffer of size ' + replacement.byteLength);\n    }\n    // restore the state to before this call, we failed\n    TOTAL_MEMORY = OLD_TOTAL_MEMORY;\n    return false;\n  }\n\n  // everything worked\n\n  updateGlobalBuffer(replacement);\n  updateGlobalBufferViews();\n\n  if (!Module[\"usingWasm\"]) {\n    Module.printErr('Warning: Enlarging memory arrays, this is not fast! ' + [OLD_TOTAL_MEMORY, TOTAL_MEMORY]);\n  }\n\n\n  return true;\n}\n\nvar byteLength;\ntry {\n  byteLength = Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, 'byteLength').get);\n  byteLength(new ArrayBuffer(4)); // can fail on older ie\n} catch(e) { // can fail on older node/v8\n  byteLength = function(buffer) { return buffer.byteLength; };\n}\n\nvar TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;\nvar TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 268435456;\nif (TOTAL_MEMORY < TOTAL_STACK) Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\n\n// Initialize the runtime's memory\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\nassert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,\n       'JS engine does not provide full typed array support');\n\n\n\n// Use a provided buffer, if there is one, or else allocate a new one\nif (Module['buffer']) {\n  buffer = Module['buffer'];\n  assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);\n} else {\n  // Use a WebAssembly memory where available\n  {\n    buffer = new ArrayBuffer(TOTAL_MEMORY);\n  }\n  assert(buffer.byteLength === TOTAL_MEMORY);\n  Module['buffer'] = buffer;\n}\nupdateGlobalBufferViews();\n\n\nfunction getTotalMemory() {\n  return TOTAL_MEMORY;\n}\n\n// Endianness check (note: assumes compiler arch was little-endian)\n  HEAP32[0] = 0x63736d65; /* 'emsc' */\nHEAP16[1] = 0x6373;\nif (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n\nfunction callRuntimeCallbacks(callbacks) {\n  while(callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n  // compatibility - merge in anything from Module['preRun'] at this time\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction ensureInitRuntime() {\n  checkStackCookie();\n  if (runtimeInitialized) return;\n  runtimeInitialized = true;\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  checkStackCookie();\n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  checkStackCookie();\n  callRuntimeCallbacks(__ATEXIT__);\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  checkStackCookie();\n  // compatibility - merge in anything from Module['postRun'] at this time\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n  __ATEXIT__.unshift(cb);\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);\n    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n                    : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n                        : Math.pow(2, bits-1);\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n  return value;\n}\n\nassert(Math['imul'] && Math['fround'] && Math['clz32'] && Math['trunc'], 'this is a legacy browser, build with LEGACY_VM_SUPPORT');\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc;\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// PRE_RUN_ADDITIONS (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function() {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            Module.printErr('still waiting on run dependencies:');\n          }\n          Module.printErr('dependency: ' + dep);\n        }\n        if (shown) {\n          Module.printErr('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    Module.printErr('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    Module.printErr('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n\n\nvar memoryInitializer = null;\n\n\n\n\n\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ?\n      filename.startsWith(dataURIPrefix) :\n      filename.indexOf(dataURIPrefix) === 0;\n}\n\n\n\n\n\n// === Body ===\n\nvar ASM_CONSTS = [function($0, $1, $2, $3, $4, $5) { if (!Module[\"frameMalloc\"]) { Module[\"frameMalloc\"] = ({}); } var frameMalloc = Module[\"frameMalloc\"]; frameMalloc[\"framepointer\"] = $1; frameMalloc[\"framesize\"] = $2; frameMalloc[\"camera\"] = $3; frameMalloc[\"transform\"] = $4; frameMalloc[\"videoLumaPointer\"] = $5; },\n function($0, $1, $2, $3) { if (!Module[\"multiEachMarkerInfo\"]) { Module[\"multiEachMarkerInfo\"] = ({}); } var multiEachMarker = Module[\"multiEachMarkerInfo\"]; multiEachMarker['visible'] = $0; multiEachMarker['pattId'] = $1; multiEachMarker['pattType'] = $2; multiEachMarker['width'] = $3; },\n function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32) { var $a = arguments; var i = 12; if (!Module[\"markerInfo\"]) { Module[\"markerInfo\"] = ({ pos: [0,0], line: [[0,0,0], [0,0,0], [0,0,0], [0,0,0]], vertex: [[0,0], [0,0], [0,0], [0,0]] }); } var markerInfo = Module[\"markerInfo\"]; markerInfo[\"area\"] = $0; markerInfo[\"id\"] = $1; markerInfo[\"idPatt\"] = $2; markerInfo[\"idMatrix\"] = $3; markerInfo[\"dir\"] = $4; markerInfo[\"dirPatt\"] = $5; markerInfo[\"dirMatrix\"] = $6; markerInfo[\"cf\"] = $7; markerInfo[\"cfPatt\"] = $8; markerInfo[\"cfMatrix\"] = $9; markerInfo[\"pos\"][0] = $10; markerInfo[\"pos\"][1] = $11; markerInfo[\"line\"][0][0] = $a[i++]; markerInfo[\"line\"][0][1] = $a[i++]; markerInfo[\"line\"][0][2] = $a[i++]; markerInfo[\"line\"][1][0] = $a[i++]; markerInfo[\"line\"][1][1] = $a[i++]; markerInfo[\"line\"][1][2] = $a[i++]; markerInfo[\"line\"][2][0] = $a[i++]; markerInfo[\"line\"][2][1] = $a[i++]; markerInfo[\"line\"][2][2] = $a[i++]; markerInfo[\"line\"][3][0] = $a[i++]; markerInfo[\"line\"][3][1] = $a[i++]; markerInfo[\"line\"][3][2] = $a[i++]; markerInfo[\"vertex\"][0][0] = $a[i++]; markerInfo[\"vertex\"][0][1] = $a[i++]; markerInfo[\"vertex\"][1][0] = $a[i++]; markerInfo[\"vertex\"][1][1] = $a[i++]; markerInfo[\"vertex\"][2][0] = $a[i++]; markerInfo[\"vertex\"][2][1] = $a[i++]; markerInfo[\"vertex\"][3][0] = $a[i++]; markerInfo[\"vertex\"][3][1] = $a[i++]; markerInfo[\"errorCorrected\"] = $a[i++]; }];\n\nfunction _emscripten_asm_const_iiiiiii(code, a0, a1, a2, a3, a4, a5) {\n  return ASM_CONSTS[code](a0, a1, a2, a3, a4, a5);\n}\n\nfunction _emscripten_asm_const_iiiid(code, a0, a1, a2, a3) {\n  return ASM_CONSTS[code](a0, a1, a2, a3);\n}\n\nfunction _emscripten_asm_const_iiiiiiiidddddddddddddddddddddddddi(code, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32) {\n  return ASM_CONSTS[code](a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32);\n}\n\n\n\n\nSTATIC_BASE = GLOBAL_BASE;\n\nSTATICTOP = STATIC_BASE + 19072;\n/* global initializers */  __ATINIT__.push({ func: function() { __GLOBAL__sub_I_ARToolKitJS_cpp() } }, { func: function() { __GLOBAL__sub_I_bind_cpp() } }, { func: function() { ___emscripten_environ_constructor() } });\n\n\nmemoryInitializer = \"data:application/octet-stream;base64,pA0AAP8lAAAAAAAAAQAAACAAAAAAAAAAEA0AAD4mAAAQDQAASCsAABANAACHKwAAEA0AAMUrAAAQDQAACywAABANAABILAAAEA0AAGcsAAAQDQAAhiwAABANAAClLAAAEA0AAMQsAAAQDQAA4ywAABANAAACLQAAEA0AAD8tAAAQDQAAXi0AAKQNAABxLQAAAAAAAAEAAAAgAAAAAAAAAKQNAACwLQAAAAAAAAEAAAAgAAAAAAAAABANAAAPOQAAOA0AAG85AADYAAAAAAAAADgNAAAcOQAA6AAAAAAAAAAQDQAAPTkAADgNAABKOQAAyAAAAAAAAAA4DQAAUToAAMAAAAAAAAAAOA0AAGE6AAAAAQAAAAAAADgNAAByOgAA2AAAAAAAAACIDQAAmjoAAIgNAACcOgAAiA0AAJ46AACIDQAAoDoAAIgNAACiOgAAiA0AAKQ6AACIDQAApjoAAIgNAACoOgAAiA0AAKo6AACIDQAAAEAAAIgNAACsOgAAiA0AAK46AACIDQAAsDoAADgNAACyOgAAyAAAAAAAAABSDgAAWQ4AAGUOAABvDgAAfQ4AAP//////////AAAAAAEAAAABAAAAAQAAAAAAAAD/////AAAAAAEAAAABAAAAAQAAAAAAAAD///////////////8BAAAAAgAAAAQAAAAIAAAAEAAAAAUAAAAKAAAAFAAAAA0AAAAaAAAAEQAAAAcAAAAOAAAAHAAAAB0AAAAfAAAAGwAAABMAAAADAAAABgAAAAwAAAAYAAAAFQAAAA8AAAAeAAAAGQAAABcAAAALAAAAFgAAAAkAAAASAAAAAQAAAAIAAAAEAAAACAAAAAMAAAAGAAAADAAAAAsAAAAFAAAACgAAAAcAAAAOAAAADwAAAA0AAAAJAAAA/////wAAAAABAAAAEgAAAAIAAAAFAAAAEwAAAAsAAAADAAAAHQAAAAYAAAAbAAAAFAAAAAgAAAAMAAAAFwAAAAQAAAAKAAAAHgAAABEAAAAHAAAAFgAAABwAAAAaAAAAFQAAABkAAAAJAAAAEAAAAA0AAAAOAAAAGAAAAA8AAAD/////AAAAAAEAAAAEAAAAAgAAAAgAAAAFAAAACgAAAAMAAAAOAAAACQAAAAcAAAAGAAAADQAAAAsAAAAMAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAAMAAAAGAAAADAAAABgAAAAwAAAAYAAAAEMAAAAFAAAACgAAABQAAAAoAAAAUAAAACMAAABGAAAADwAAAB4AAAA8AAAAeAAAAHMAAABlAAAASQAAABEAAAAiAAAARAAAAAsAAAAWAAAALAAAAFgAAAAzAAAAZgAAAE8AAAAdAAAAOgAAAHQAAABrAAAAVQAAACkAAABSAAAAJwAAAE4AAAAfAAAAPgAAAHwAAAB7AAAAdQAAAGkAAABRAAAAIQAAAEIAAAAHAAAADgAAABwAAAA4AAAAcAAAAGMAAABFAAAACQAAABIAAAAkAAAASAAAABMAAAAmAAAATAAAABsAAAA2AAAAbAAAAFsAAAA1AAAAagAAAFcAAAAtAAAAWgAAADcAAABuAAAAXwAAAD0AAAB6AAAAdwAAAG0AAABZAAAAMQAAAGIAAABHAAAADQAAABoAAAA0AAAAaAAAAFMAAAAlAAAASgAAABcAAAAuAAAAXAAAADsAAAB2AAAAbwAAAF0AAAA5AAAAcgAAAGcAAABNAAAAGQAAADIAAABkAAAASwAAABUAAAAqAAAAVAAAACsAAABWAAAALwAAAF4AAAA/AAAAfgAAAH8AAAB9AAAAeQAAAHEAAABhAAAAQQAAAP////8AAAAAAQAAAAcAAAACAAAADgAAAAgAAAA4AAAAAwAAAD8AAAAPAAAAHwAAAAkAAABaAAAAOQAAABUAAAAEAAAAHAAAAEAAAABDAAAAEAAAAHAAAAAgAAAAYQAAAAoAAABsAAAAWwAAAEYAAAA6AAAAJgAAABYAAAAvAAAABQAAADYAAAAdAAAAEwAAAEEAAABfAAAARAAAAC0AAAARAAAAKwAAAHEAAABzAAAAIQAAAE0AAABiAAAAdQAAAAsAAABXAAAAbQAAACMAAABcAAAASgAAAEcAAABPAAAAOwAAAGgAAAAnAAAAZAAAABcAAABSAAAAMAAAAHcAAAAGAAAAfgAAADcAAAANAAAAHgAAAD4AAAAUAAAAWQAAAEIAAAAbAAAAYAAAAG8AAABFAAAAawAAAC4AAAAlAAAAEgAAADUAAAAsAAAAXgAAAHIAAAAqAAAAdAAAAEwAAAAiAAAAVgAAAE4AAABJAAAAYwAAAGcAAAB2AAAAUQAAAAwAAAB9AAAAWAAAAD0AAABuAAAAGgAAACQAAABqAAAAXQAAADQAAABLAAAAKQAAAEgAAABVAAAAUAAAAGYAAAA8AAAAfAAAAGkAAAAZAAAAKAAAADMAAABlAAAAVAAAABgAAAB7AAAAUwAAADIAAAAxAAAAegAAAHgAAAB5AAAABAAAAIgAAAAFAAAAkAAAAAYAAACYAAAACQAAALAAAAABAAAA6hUAAPAVAAD1FQAA/RUAAP/////+/////f///zABAABoAQAAiAEAADABAABoAQAAaAEAAJABAABoAQAAMAEAAGgBAACQAQAAaAEAADABAABoAQAAaAEAAAgAAABoAQAAaAEAAGgBAABoAQAAaAEAAAgAAABoAQAAaAEAAGgBAABoAQAAaAEAAGgBAAAkCAAABQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAABtRgAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAA//////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAACAAAAdUYAAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAr/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgCAAAAgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAURgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFX3CJAP8JLw8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAADAAAABQAAAAcAAAALAAAADQAAABEAAAATAAAAFwAAAB0AAAAfAAAAJQAAACkAAAArAAAALwAAADUAAAA7AAAAPQAAAEMAAABHAAAASQAAAE8AAABTAAAAWQAAAGEAAABlAAAAZwAAAGsAAABtAAAAcQAAAH8AAACDAAAAiQAAAIsAAACVAAAAlwAAAJ0AAACjAAAApwAAAK0AAACzAAAAtQAAAL8AAADBAAAAxQAAAMcAAADTAAAAAQAAAAsAAAANAAAAEQAAABMAAAAXAAAAHQAAAB8AAAAlAAAAKQAAACsAAAAvAAAANQAAADsAAAA9AAAAQwAAAEcAAABJAAAATwAAAFMAAABZAAAAYQAAAGUAAABnAAAAawAAAG0AAABxAAAAeQAAAH8AAACDAAAAiQAAAIsAAACPAAAAlQAAAJcAAACdAAAAowAAAKcAAACpAAAArQAAALMAAAC1AAAAuwAAAL8AAADBAAAAxQAAAMcAAADRAAAAAQAAAAAAAADIAAAAAQAAAAIAAAADAAAABAAAAAUAAAABAAAAAQAAAAEAAAAAAAAA8AAAAAEAAAAFAAAAAwAAAAQAAAAFAAAAAgAAAAIAAAACAAAAAAAAAAABAAAGAAAABwAAAAIAAAAAAAAAEAEAAAYAAAAIAAAAAgAAAAAAAAAgAQAAAQAAAAkAAAADAAAABAAAAAYAAAAAAAAAmAEAAAEAAAAKAAAAAwAAAAQAAAAFAAAAAwAAAAMAAAADAAAARXJyb3I6IGxhYmVsaW5nIHdvcmsgb3ZlcmZsb3cuCgBVbmtub3duIG9yIHVuc3VwcG9ydGVkIGxhYmVsaW5nIHRocmVzaG9sZCBtb2RlIHJlcXVlc3RlZC4gU2V0IHRvIG1hbnVhbC4KAExhYmVsaW5nIHRocmVzaG9sZCBtb2RlIHNldCB0byAlcy4KAE1BTlVBTABBVVRPX01FRElBTgBBVVRPX09UU1UAQVVUT19BREFQVElWRQBBVVRPX0JSQUNLRVRJTkcARXJyb3I6IFVuc3VwcG9ydGVkIHBpeGVsIGZvcm1hdCAoJWQpIHJlcXVlc3RlZC4KAEF1dG8gdGhyZXNob2xkIChicmFja2V0KSBtYXJrZXIgY291bnRzIC1bJTNkOiAlM2RdIFslM2Q6ICUzZF0gWyUzZDogJTNkXSsuCgBBdXRvIHRocmVzaG9sZCAoYnJhY2tldCkgYWRqdXN0ZWQgdGhyZXNob2xkIHRvICVkLgoAbWVkaWFuAE90c3UAQXV0byB0aHJlc2hvbGQgKCVzKSBhZGp1c3RlZCB0aHJlc2hvbGQgdG8gJWQuCgA/Pz8gMQoAPz8/IDIKAD8/PyAzCgAAAAABAAEBAQACBP//BQMBAAL/Bgf/AwECAgMCAwIDAwD/BAYHBf8BBAUEBAUFBAUHBgYGBwcHBv8CBAYHBQP/AAEBAQEBAQABAQEAAAEBAQEBAAEBAAEBAQABAQEBAAEBAAEBAQEAAQEBAAEBAAEBAQEBAAABAQEAAQEBAQEBAAD//wP/BQb//wkK/wz//w//ERL/FP//Fxj//xv/HR7//wEC/wT//wcI//8L/w0O/xD//xP/FRb//xka/xz//x9FcnJvcjogdW5zdXBwb3J0ZWQgcGl4ZWwgZm9ybWF0LgoARXJyb3I6IE5VTEwgcGF0dEhhbmRsZS4KAEVycm9yOiBjYW4ndCBsb2FkIHBhdHRlcm4gZnJvbSBOVUxMIGJ1ZmZlci4KAEVycm9yOiBvdXQgb2YgbWVtb3J5LgoAIAkKDQBQYXR0ZXJuIERhdGEgcmVhZCBlcnJvciEhCgBFcnJvciByZWFkaW5nIHBhdHRlcm4gZmlsZSAnJXMnLgoARXJyb3IgKCVkKTogdW5hYmxlIHRvIG9wZW4gY2FtZXJhIHBhcmFtZXRlcnMgZmlsZSAiJXMiIGZvciByZWFkaW5nLgoARXJyb3IgKCVkKTogdW5hYmxlIHRvIGRldGVybWluZSBmaWxlIGxlbmd0aC4ARXJyb3I6IHN1cHBsaWVkIGZpbGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGFuIEFSVG9vbEtpdCBjYW1lcmEgcGFyYW1ldGVyIGZpbGUuCgBFcnJvciAoJWQpOiB1bmFibGUgdG8gcmVhZCBmcm9tIGZpbGUuAGFyZ2xDYW1lcmFGcnVzdHVtUkgoKTogYXJQYXJhbURlY29tcE1hdCgpIGluZGljYXRlZCBwYXJhbWV0ZXIgZXJyb3IuCgBFcnJvcjogaWNwR2V0Sl9VX1hjAEVycm9yOiBtYWxsb2MKAEVycm9yIDE6IGljcEdldEluaXRYdzJYYwoARXJyb3IgMjogaWNwR2V0SW5pdFh3MlhjCgBFcnJvciAzOiBpY3BHZXRJbml0WHcyWGMKAEVycm9yIDQ6IGljcEdldEluaXRYdzJYYwoARXJyb3IgNTogaWNwR2V0SW5pdFh3MlhjCgBFcnJvciA2OiBpY3BHZXRJbml0WHcyWGMKAEVycm9yIDc6IGljcEdldEluaXRYdzJYYwoAcgBFcnJvcjogdW5hYmxlIHRvIG9wZW4gbXVsdGltYXJrZXIgY29uZmlnIGZpbGUgJyVzJy4KACVzJXMKACVkAEVycm9yIHByb2Nlc3NpbmcgbXVsdGltYXJrZXIgY29uZmlnIGZpbGUgJyVzJzogRmlyc3QgbGluZSBtdXN0IGJlIG51bWJlciBvZiBtYXJrZXIgY29uZmlncyB0byByZWFkLgoAT3V0IG9mIG1lbW9yeSEhCgAlbGx1JWMARXJyb3IgcHJvY2Vzc2luZyBtdWx0aW1hcmtlciBjb25maWcgZmlsZSAnJXMnOiBwYXR0ZXJuICclcycgc3BlY2lmaWVkIGluIG11bHRpbWFya2VyIGNvbmZpZ3VyYXRpb24gd2hpbGUgaW4gYmFyY29kZS1vbmx5IG1vZGUuCgBFcnJvciBwcm9jZXNzaW5nIG11bHRpbWFya2VyIGNvbmZpZyBmaWxlICclcyc6IFVuYWJsZSB0byBkZXRlcm1pbmUgZGlyZWN0b3J5IG5hbWUuCgBFcnJvciBwcm9jZXNzaW5nIG11bHRpbWFya2VyIGNvbmZpZyBmaWxlICclcyc6IFVuYWJsZSB0byBsb2FkIHBhdHRlcm4gJyVzJy4KACVsZgBFcnJvciBwcm9jZXNzaW5nIG11bHRpbWFya2VyIGNvbmZpZyBmaWxlICclcycsIG1hcmtlciBkZWZpbml0aW9uICUzZDogRmlyc3QgbGluZSBtdXN0IGJlIHBhdHRlcm4gd2lkdGguCgAlbGYgJWxmICVsZiAlbGYAJWYgJWYARXJyb3IgcHJvY2Vzc2luZyBtdWx0aW1hcmtlciBjb25maWcgZmlsZSAnJXMnLCBtYXJrZXIgZGVmaW5pdGlvbiAlM2Q6IExpbmVzIDIgLSA0IG11c3QgYmUgbWFya2VyIHRyYW5zZm9ybS4KAFslc10gAGRlYnVnAGluZm8Ad2FybmluZwBlcnJvcgByYgBzZXR1cAB0ZWFyZG93bgBfYWRkTWFya2VyAF9hZGRNdWx0aU1hcmtlcgBnZXRNdWx0aU1hcmtlck51bQBnZXRNdWx0aU1hcmtlckNvdW50AF9sb2FkQ2FtZXJhAHNldE1hcmtlckluZm9EaXIAc2V0TWFya2VySW5mb1ZlcnRleABnZXRUcmFuc01hdFNxdWFyZQBnZXRUcmFuc01hdFNxdWFyZUNvbnQAZ2V0VHJhbnNNYXRNdWx0aVNxdWFyZQBnZXRUcmFuc01hdE11bHRpU3F1YXJlUm9idXN0AGRldGVjdE1hcmtlcgBnZXRNYXJrZXJOdW0AZ2V0TXVsdGlFYWNoTWFya2VyAGdldE1hcmtlcgBzZXREZWJ1Z01vZGUAZ2V0RGVidWdNb2RlAGdldFByb2Nlc3NpbmdJbWFnZQBzZXRMb2dMZXZlbABnZXRMb2dMZXZlbABzZXRQcm9qZWN0aW9uTmVhclBsYW5lAGdldFByb2plY3Rpb25OZWFyUGxhbmUAc2V0UHJvamVjdGlvbkZhclBsYW5lAGdldFByb2plY3Rpb25GYXJQbGFuZQBzZXRUaHJlc2hvbGRNb2RlAGdldFRocmVzaG9sZE1vZGUAc2V0VGhyZXNob2xkAGdldFRocmVzaG9sZABzZXRQYXR0ZXJuRGV0ZWN0aW9uTW9kZQBnZXRQYXR0ZXJuRGV0ZWN0aW9uTW9kZQBzZXRQYXR0UmF0aW8AZ2V0UGF0dFJhdGlvAHNldE1hdHJpeENvZGVUeXBlAGdldE1hdHJpeENvZGVUeXBlAHNldExhYmVsaW5nTW9kZQBnZXRMYWJlbGluZ01vZGUAc2V0SW1hZ2VQcm9jTW9kZQBnZXRJbWFnZVByb2NNb2RlAEVSUk9SX0FSQ09OVFJPTExFUl9OT1RfRk9VTkQARVJST1JfTVVMVElNQVJLRVJfTk9UX0ZPVU5EAEVSUk9SX01BUktFUl9JTkRFWF9PVVRfT0ZfQk9VTkRTAEFSX0RFQlVHX0RJU0FCTEUAQVJfREVCVUdfRU5BQkxFAEFSX0RFRkFVTFRfREVCVUdfTU9ERQBBUl9MQUJFTElOR19XSElURV9SRUdJT04AQVJfTEFCRUxJTkdfQkxBQ0tfUkVHSU9OAEFSX0RFRkFVTFRfTEFCRUxJTkdfTU9ERQBBUl9ERUZBVUxUX0xBQkVMSU5HX1RIUkVTSABBUl9JTUFHRV9QUk9DX0ZSQU1FX0lNQUdFAEFSX0lNQUdFX1BST0NfRklFTERfSU1BR0UAQVJfREVGQVVMVF9JTUFHRV9QUk9DX01PREUAQVJfVEVNUExBVEVfTUFUQ0hJTkdfQ09MT1IAQVJfVEVNUExBVEVfTUFUQ0hJTkdfTU9OTwBBUl9NQVRSSVhfQ09ERV9ERVRFQ1RJT04AQVJfVEVNUExBVEVfTUFUQ0hJTkdfQ09MT1JfQU5EX01BVFJJWABBUl9URU1QTEFURV9NQVRDSElOR19NT05PX0FORF9NQVRSSVgAQVJfREVGQVVMVF9QQVRURVJOX0RFVEVDVElPTl9NT0RFAEFSX1VTRV9UUkFDS0lOR19ISVNUT1JZAEFSX05PVVNFX1RSQUNLSU5HX0hJU1RPUlkAQVJfVVNFX1RSQUNLSU5HX0hJU1RPUllfVjIAQVJfREVGQVVMVF9NQVJLRVJfRVhUUkFDVElPTl9NT0RFAEFSX01BWF9MT09QX0NPVU5UAEFSX0xPT1BfQlJFQUtfVEhSRVNIAEFSX0xPR19MRVZFTF9ERUJVRwBBUl9MT0dfTEVWRUxfSU5GTwBBUl9MT0dfTEVWRUxfV0FSTgBBUl9MT0dfTEVWRUxfRVJST1IAQVJfTE9HX0xFVkVMX1JFTF9JTkZPAEFSX01BVFJJWF9DT0RFXzN4MwBBUl9NQVRSSVhfQ09ERV8zeDNfSEFNTUlORzYzAEFSX01BVFJJWF9DT0RFXzN4M19QQVJJVFk2NQBBUl9NQVRSSVhfQ09ERV80eDQAQVJfTUFUUklYX0NPREVfNHg0X0JDSF8xM185XzMAQVJfTUFUUklYX0NPREVfNHg0X0JDSF8xM181XzUAQVJfTEFCRUxJTkdfVEhSRVNIX01PREVfTUFOVUFMAEFSX0xBQkVMSU5HX1RIUkVTSF9NT0RFX0FVVE9fTUVESUFOAEFSX0xBQkVMSU5HX1RIUkVTSF9NT0RFX0FVVE9fT1RTVQBBUl9MQUJFTElOR19USFJFU0hfTU9ERV9BVVRPX0FEQVBUSVZFAEFSX01BUktFUl9JTkZPX0NVVE9GRl9QSEFTRV9OT05FAEFSX01BUktFUl9JTkZPX0NVVE9GRl9QSEFTRV9QQVRURVJOX0VYVFJBQ1RJT04AQVJfTUFSS0VSX0lORk9fQ1VUT0ZGX1BIQVNFX01BVENIX0dFTkVSSUMAQVJfTUFSS0VSX0lORk9fQ1VUT0ZGX1BIQVNFX01BVENIX0NPTlRSQVNUAEFSX01BUktFUl9JTkZPX0NVVE9GRl9QSEFTRV9NQVRDSF9CQVJDT0RFX05PVF9GT1VORABBUl9NQVJLRVJfSU5GT19DVVRPRkZfUEhBU0VfTUFUQ0hfQkFSQ09ERV9FRENfRkFJTABBUl9NQVJLRVJfSU5GT19DVVRPRkZfUEhBU0VfTUFUQ0hfQ09ORklERU5DRQBBUl9NQVJLRVJfSU5GT19DVVRPRkZfUEhBU0VfUE9TRV9FUlJPUgBBUl9NQVJLRVJfSU5GT19DVVRPRkZfUEhBU0VfUE9TRV9FUlJPUl9NVUxUSQBBUl9NQVJLRVJfSU5GT19DVVRPRkZfUEhBU0VfSEVVUklTVElDX1RST1VCTEVTT01FX01BVFJJWF9DT0RFUwBhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAEltYWdlIHByb2MuIG1vZGUgc2V0IHRvICVkLgoATGFiZWxpbmcgbW9kZSBzZXQgdG8gJWQKAHZpaWYAUGF0dGVybiByYXRpbyBzaXplIHNldCB0byAlZi4KAFBhdHRlcm4gZGV0ZWN0aW9uIG1vZGUgc2V0IHRvICVkLgoAVGhyZXNob2xkIHNldCB0byAlZAoAdmlpaQBUaHJlc2hvbGQgbW9kZSBzZXQgdG8gJWQKAGRpaQB2aWlkAGlpAHZpaQBvbi4Ab2ZmLgBEZWJ1ZyBtb2RlIHNldCB0byAlcwoAeyB2YXIgJGEgPSBhcmd1bWVudHM7IHZhciBpID0gMTI7IGlmICghYXJ0b29sa2l0WyJtYXJrZXJJbmZvIl0pIHsgYXJ0b29sa2l0WyJtYXJrZXJJbmZvIl0gPSAoeyBwb3M6IFswLDBdLCBsaW5lOiBbWzAsMCwwXSwgWzAsMCwwXSwgWzAsMCwwXSwgWzAsMCwwXV0sIHZlcnRleDogW1swLDBdLCBbMCwwXSwgWzAsMF0sIFswLDBdXSB9KTsgfSB2YXIgbWFya2VySW5mbyA9IGFydG9vbGtpdFsibWFya2VySW5mbyJdOyBtYXJrZXJJbmZvWyJhcmVhIl0gPSAkMDsgbWFya2VySW5mb1siaWQiXSA9ICQxOyBtYXJrZXJJbmZvWyJpZFBhdHQiXSA9ICQyOyBtYXJrZXJJbmZvWyJpZE1hdHJpeCJdID0gJDM7IG1hcmtlckluZm9bImRpciJdID0gJDQ7IG1hcmtlckluZm9bImRpclBhdHQiXSA9ICQ1OyBtYXJrZXJJbmZvWyJkaXJNYXRyaXgiXSA9ICQ2OyBtYXJrZXJJbmZvWyJjZiJdID0gJDc7IG1hcmtlckluZm9bImNmUGF0dCJdID0gJDg7IG1hcmtlckluZm9bImNmTWF0cml4Il0gPSAkOTsgbWFya2VySW5mb1sicG9zIl1bMF0gPSAkMTA7IG1hcmtlckluZm9bInBvcyJdWzFdID0gJDExOyBtYXJrZXJJbmZvWyJsaW5lIl1bMF1bMF0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bMF1bMV0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bMF1bMl0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bMV1bMF0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bMV1bMV0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bMV1bMl0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bMl1bMF0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bMl1bMV0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bMl1bMl0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bM11bMF0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bM11bMV0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJsaW5lIl1bM11bMl0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJ2ZXJ0ZXgiXVswXVswXSA9ICRhW2krK107IG1hcmtlckluZm9bInZlcnRleCJdWzBdWzFdID0gJGFbaSsrXTsgbWFya2VySW5mb1sidmVydGV4Il1bMV1bMF0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJ2ZXJ0ZXgiXVsxXVsxXSA9ICRhW2krK107IG1hcmtlckluZm9bInZlcnRleCJdWzJdWzBdID0gJGFbaSsrXTsgbWFya2VySW5mb1sidmVydGV4Il1bMl1bMV0gPSAkYVtpKytdOyBtYXJrZXJJbmZvWyJ2ZXJ0ZXgiXVszXVswXSA9ICRhW2krK107IG1hcmtlckluZm9bInZlcnRleCJdWzNdWzFdID0gJGFbaSsrXTsgbWFya2VySW5mb1siZXJyb3JDb3JyZWN0ZWQiXSA9ICRhW2krK107IH0AeyBpZiAoIWFydG9vbGtpdFsibXVsdGlFYWNoTWFya2VySW5mbyJdKSB7IGFydG9vbGtpdFsibXVsdGlFYWNoTWFya2VySW5mbyJdID0gKHt9KTsgfSB2YXIgbXVsdGlFYWNoTWFya2VyID0gYXJ0b29sa2l0WyJtdWx0aUVhY2hNYXJrZXJJbmZvIl07IG11bHRpRWFjaE1hcmtlclsndmlzaWJsZSddID0gJDA7IG11bHRpRWFjaE1hcmtlclsncGF0dElkJ10gPSAkMTsgbXVsdGlFYWNoTWFya2VyWydwYXR0VHlwZSddID0gJDI7IG11bHRpRWFjaE1hcmtlclsnd2lkdGgnXSA9ICQzOyB9AGlpaQBOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQBOU3QzX18yMjFfX2Jhc2ljX3N0cmluZ19jb21tb25JTGIxRUVFAGxvYWRDYW1lcmEoKTogRXJyb3IgbG9hZGluZyBwYXJhbWV0ZXIgZmlsZSAlcyBmb3IgY2FtZXJhLgoAaWlpaQBBUlRvb2xLaXRKUygpOiBVbmFibGUgdG8gc2V0IHVwIEFSIG11bHRpbWFya2VyLgoAY29uZmlnIGRhdGEgbG9hZCBlcnJvciAhIQoAQVJUb29sS2l0SlMoKTogVW5hYmxlIHRvIHNldCB1cCBBUiBtYXJrZXIuCgBsb2FkTWFya2VyKCk6IEVycm9yIGxvYWRpbmcgcGF0dGVybiBmaWxlICVzLgoAaWlpaWkAc2V0dXAoKTogRXJyb3I6IGFyUGF0dENyZWF0ZUhhbmRsZS4KAEFsbG9jYXRlZCB2aWRlb0ZyYW1lU2l6ZSAlZAoAeyBpZiAoIWFydG9vbGtpdFsiZnJhbWVNYWxsb2MiXSkgeyBhcnRvb2xraXRbImZyYW1lTWFsbG9jIl0gPSAoe30pOyB9IHZhciBmcmFtZU1hbGxvYyA9IGFydG9vbGtpdFsiZnJhbWVNYWxsb2MiXTsgZnJhbWVNYWxsb2NbImZyYW1lcG9pbnRlciJdID0gJDE7IGZyYW1lTWFsbG9jWyJmcmFtZXNpemUiXSA9ICQyOyBmcmFtZU1hbGxvY1siY2FtZXJhIl0gPSAkMzsgZnJhbWVNYWxsb2NbInRyYW5zZm9ybSJdID0gJDQ7IGZyYW1lTWFsbG9jWyJ2aWRlb0x1bWFQb2ludGVyIl0gPSAkNTsgfQAqKiogQ2FtZXJhIFBhcmFtZXRlciByZXNpemVkIGZyb20gJWQsICVkLiAqKioKAHNldENhbWVyYSgpOiBFcnJvcjogYXJQYXJhbUxUQ3JlYXRlLgoAc2V0Q2FtZXJhKCk6IEVycm9yOiBhckNyZWF0ZUhhbmRsZS4KAHNldENhbWVyYSgpOiBFcnJvciBjcmVhdGluZyAzRCBoYW5kbGUAc3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4Ac3RkOjp3c3RyaW5nAGVtc2NyaXB0ZW46OnZhbABlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmcgZG91YmxlPgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0llRUUAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQBOMTBlbXNjcmlwdGVuM3ZhbEUATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAcndhAGluZmluaXR5AP////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAEQAKABEREQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAARAA8KERERAwoHAAETCQsLAAAJBgsAAAsABhEAAAAREREAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAEQAKChEREQAKAAACAAkLAAAACQALAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAADAAAAAAJDAAAAAAADAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAANAAAABA0AAAAACQ4AAAAAAA4AAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAADwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhISAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAASEhIAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAKAAAAAAoAAAAACQsAAAAAAAsAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAtKyAgIDBYMHgAKG51bGwpAC0wWCswWCAwWC0weCsweCAweABpbmYASU5GAG5hbgBOQU4AMDEyMzQ1Njc4OUFCQ0RFRlQhIhkNAQIDEUscDBAECx0SHidobm9wcWIgBQYPExQVGggWBygkFxgJCg4bHyUjg4J9JiorPD0+P0NHSk1YWVpbXF1eX2BhY2RlZmdpamtscnN0eXp7fABJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbgAAdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlczogJXMAdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlcwB0ZXJtaW5hdGluZyB3aXRoICVzIGZvcmVpZ24gZXhjZXB0aW9uAHRlcm1pbmF0aW5nAHVuY2F1Z2h0AFN0OWV4Y2VwdGlvbgBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQBTdDl0eXBlX2luZm8ATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQBwdGhyZWFkX29uY2UgZmFpbHVyZSBpbiBfX2N4YV9nZXRfZ2xvYmFsc19mYXN0KCkAY2Fubm90IGNyZWF0ZSBwdGhyZWFkIGtleSBmb3IgX19jeGFfZ2V0X2dsb2JhbHMoKQBjYW5ub3QgemVybyBvdXQgdGhyZWFkIHZhbHVlIGZvciBfX2N4YV9nZXRfZ2xvYmFscygpAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZABTdDExbG9naWNfZXJyb3IAU3QxMmxlbmd0aF9lcnJvcgBOMTBfX2N4eGFiaXYxMjNfX2Z1bmRhbWVudGFsX3R5cGVfaW5mb0UAdgBiAGMAaABhAHMAdABpAGoAbQBmAGQATjEwX19jeHhhYml2MTIxX192bWlfY2xhc3NfdHlwZV9pbmZvRQAgY29uc3QAIHZvbGF0aWxlACByZXN0cmljdAAgY29tcGxleAAgaW1hZ2luYXJ5ACBbACAoACkAKAAmJgBvYmpjX29iamVjdDwAKgAmAG9iamNwcm90bwAgADwAPgAgdmVjdG9yWwBdAHBpeGVsIHZlY3RvclsAJj0APQAsAH4AOjoAZGVsZXRlW10gAGRlbGV0ZSAALwAvPQBeAF49AD09AD49AClbADw9ADw8ADw8PQAtAC09ACo9AC0tACktLQAhPQAhAHx8AHwAfD0ALT4qACsAKz0AKysAKSsrACkgPyAoACkgOiAoACUAJT0APj4APj49AHRocm93AHRocm93IAB0eXBlaWQoAHNpemVvZi4uLigALCAAc2l6ZW9mICgAc3RhdGljX2Nhc3Q8AD4oAHJlaW50ZXJwcmV0X2Nhc3Q8AC0+AG5vZXhjZXB0ICgAW10gACkgAC4ALioAc3RkOjoAb3BlcmF0b3ImJgBvcGVyYXRvciYAb3BlcmF0b3ImPQBvcGVyYXRvcj0Ab3BlcmF0b3IoKQBvcGVyYXRvciwAb3BlcmF0b3J+AG9wZXJhdG9yIABvcGVyYXRvciBkZWxldGVbXQBvcGVyYXRvcioAb3BlcmF0b3IvAG9wZXJhdG9yLz0Ab3BlcmF0b3JeAG9wZXJhdG9yXj0Ab3BlcmF0b3I9PQBvcGVyYXRvcj49AG9wZXJhdG9yPgBvcGVyYXRvcltdAG9wZXJhdG9yPD0Ab3BlcmF0b3IiIiAAb3BlcmF0b3I8PABvcGVyYXRvcjw8PQBvcGVyYXRvcjwAb3BlcmF0b3ItAG9wZXJhdG9yLT0Ab3BlcmF0b3IqPQBvcGVyYXRvci0tAG9wZXJhdG9yIG5ld1tdAG9wZXJhdG9yIT0Ab3BlcmF0b3IhAG9wZXJhdG9yIG5ldwBvcGVyYXRvcnx8AG9wZXJhdG9yfABvcGVyYXRvcnw9AG9wZXJhdG9yLT4qAG9wZXJhdG9yKwBvcGVyYXRvcis9AG9wZXJhdG9yKysAb3BlcmF0b3ItPgBvcGVyYXRvcj8Ab3BlcmF0b3IlAG9wZXJhdG9yJT0Ab3BlcmF0b3I+PgBvcGVyYXRvcj4+PQBvcGVyYXRvciBkZWxldGUAJ3VubmFtZWQAJ2xhbWJkYScoAHN0ZDo6c3RyaW5nAHN0ZDo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6YWxsb2NhdG9yPGNoYXI+ID4AYmFzaWNfc3RyaW5nAHN0ZDo6aXN0cmVhbQBzdGQ6OmJhc2ljX2lzdHJlYW08Y2hhciwgc3RkOjpjaGFyX3RyYWl0czxjaGFyPiA+AGJhc2ljX2lzdHJlYW0Ac3RkOjpvc3RyZWFtAHN0ZDo6YmFzaWNfb3N0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4AYmFzaWNfb3N0cmVhbQBzdGQ6Omlvc3RyZWFtAHN0ZDo6YmFzaWNfaW9zdHJlYW08Y2hhciwgc3RkOjpjaGFyX3RyYWl0czxjaGFyPiA+AGJhc2ljX2lvc3RyZWFtAGR5bmFtaWNfY2FzdDwAKSgAY29uc3RfY2FzdDwAYWxpZ25vZiAoAGZwAHdjaGFyX3QAZmFsc2UAdHJ1ZQBjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAdQBsAHVsAGxsAHVsbABfX2ludDEyOAB1bnNpZ25lZCBfX2ludDEyOAAlTGFMACVhACVhZgBkZWNsdHlwZSgAc3RkOjphbGxvY2F0b3IAc3RkOjpiYXNpY19zdHJpbmcAOjpzdHJpbmcgbGl0ZXJhbABzdGQAX0dMT0JBTF9fTgAoYW5vbnltb3VzIG5hbWVzcGFjZSkAID4AVF8AaWQAOjoqACAmACAmJgAgW10Adm9pZABib29sAGludAB1bnNpZ25lZCBpbnQAbG9uZwB1bnNpZ25lZCBsb25nAGxvbmcgbG9uZwBmbG9hdABsb25nIGRvdWJsZQBfX2Zsb2F0MTI4AC4uLgBkZWNpbWFsNjQAZGVjaW1hbDEyOABkZWNpbWFsMzIAZGVjaW1hbDE2AGNoYXIzMl90AGNoYXIxNl90AGF1dG8Ac3RkOjpudWxscHRyX3QAZG91YmxlAHVuc2lnbmVkIGxvbmcgbG9uZwBfYmxvY2tfaW52b2tlAGludm9jYXRpb24gZnVuY3Rpb24gZm9yIGJsb2NrIGluIAB2dGFibGUgZm9yIABWVFQgZm9yIAB0eXBlaW5mbyBmb3IgAHR5cGVpbmZvIG5hbWUgZm9yIABjb3ZhcmlhbnQgcmV0dXJuIHRodW5rIHRvIABjb25zdHJ1Y3Rpb24gdnRhYmxlIGZvciAALWluLQB2aXJ0dWFsIHRodW5rIHRvIABub24tdmlydHVhbCB0aHVuayB0byAAZ3VhcmQgdmFyaWFibGUgZm9yIAByZWZlcmVuY2UgdGVtcG9yYXJ5IGZvciA=\";\n\n\n\n\n\n/* no memory initializer */\nvar tempDoublePtr = STATICTOP; STATICTOP += 16;\n\nassert(tempDoublePtr % 8 == 0);\n\nfunction copyTempFloat(ptr) { // functions, because inlining this code increases code size too much\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n}\n\nfunction copyTempDouble(ptr) {\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];\n\n  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];\n\n  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];\n\n  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];\n\n}\n\n// {{PRE_LIBRARY}}\n\n\n  \n  var ENV={};function ___buildEnvironment(environ) {\n      // WARNING: Arbitrary limit!\n      var MAX_ENV_VALUES = 64;\n      var TOTAL_ENV_SIZE = 1024;\n  \n      // Statically allocate memory for the environment.\n      var poolPtr;\n      var envPtr;\n      if (!___buildEnvironment.called) {\n        ___buildEnvironment.called = true;\n        // Set default values. Use string keys for Closure Compiler compatibility.\n        ENV['USER'] = ENV['LOGNAME'] = 'web_user';\n        ENV['PATH'] = '/';\n        ENV['PWD'] = '/';\n        ENV['HOME'] = '/home/web_user';\n        ENV['LANG'] = 'C.UTF-8';\n        ENV['_'] = Module['thisProgram'];\n        // Allocate memory.\n        poolPtr = getMemory(TOTAL_ENV_SIZE);\n        envPtr = getMemory(MAX_ENV_VALUES * 4);\n        HEAP32[((envPtr)>>2)]=poolPtr;\n        HEAP32[((environ)>>2)]=envPtr;\n      } else {\n        envPtr = HEAP32[((environ)>>2)];\n        poolPtr = HEAP32[((envPtr)>>2)];\n      }\n  \n      // Collect key=value lines.\n      var strings = [];\n      var totalSize = 0;\n      for (var key in ENV) {\n        if (typeof ENV[key] === 'string') {\n          var line = key + '=' + ENV[key];\n          strings.push(line);\n          totalSize += line.length;\n        }\n      }\n      if (totalSize > TOTAL_ENV_SIZE) {\n        throw new Error('Environment size exceeded TOTAL_ENV_SIZE!');\n      }\n  \n      // Make new.\n      var ptrSize = 4;\n      for (var i = 0; i < strings.length; i++) {\n        var line = strings[i];\n        writeAsciiToMemory(line, poolPtr);\n        HEAP32[(((envPtr)+(i * ptrSize))>>2)]=poolPtr;\n        poolPtr += line.length + 1;\n      }\n      HEAP32[(((envPtr)+(strings.length * ptrSize))>>2)]=0;\n    }\n\n  function ___cxa_allocate_exception(size) {\n      return _malloc(size);\n    }\n\n  \n  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()\n      return !!__ZSt18uncaught_exceptionv.uncaught_exception;\n    }\n  \n  var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:function (adjusted) {\n        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;\n        for (var key in EXCEPTIONS.infos) {\n          var ptr = +key; // the iteration key is a string, and if we throw this, it must be an integer as that is what we look for\n          var info = EXCEPTIONS.infos[ptr];\n          if (info.adjusted === adjusted) {\n            return ptr;\n          }\n        }\n        return adjusted;\n      },addRef:function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount++;\n      },decRef:function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        assert(info.refcount > 0);\n        info.refcount--;\n        // A rethrown exception can reach refcount 0; it must not be discarded\n        // Its next handler will clear the rethrown flag and addRef it, prior to\n        // final decRef and destruction here\n        if (info.refcount === 0 && !info.rethrown) {\n          if (info.destructor) {\n            Module['dynCall_vi'](info.destructor, ptr);\n          }\n          delete EXCEPTIONS.infos[ptr];\n          ___cxa_free_exception(ptr);\n        }\n      },clearRef:function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount = 0;\n      }};function ___cxa_begin_catch(ptr) {\n      var info = EXCEPTIONS.infos[ptr];\n      if (info && !info.caught) {\n        info.caught = true;\n        __ZSt18uncaught_exceptionv.uncaught_exception--;\n      }\n      if (info) info.rethrown = false;\n      EXCEPTIONS.caught.push(ptr);\n      EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));\n      return ptr;\n    }\n\n  \n  \n  function ___resumeException(ptr) {\n      if (!EXCEPTIONS.last) { EXCEPTIONS.last = ptr; }\n      throw ptr + \" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.\";\n    }function ___cxa_find_matching_catch() {\n      var thrown = EXCEPTIONS.last;\n      if (!thrown) {\n        // just pass through the null ptr\n        return ((setTempRet0(0),0)|0);\n      }\n      var info = EXCEPTIONS.infos[thrown];\n      var throwntype = info.type;\n      if (!throwntype) {\n        // just pass through the thrown ptr\n        return ((setTempRet0(0),thrown)|0);\n      }\n      var typeArray = Array.prototype.slice.call(arguments);\n  \n      var pointer = Module['___cxa_is_pointer_type'](throwntype);\n      // can_catch receives a **, add indirection\n      if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);\n      HEAP32[((___cxa_find_matching_catch.buffer)>>2)]=thrown;\n      thrown = ___cxa_find_matching_catch.buffer;\n      // The different catch blocks are denoted by different types.\n      // Due to inheritance, those types may not precisely match the\n      // type of the thrown object. Find one which matches, and\n      // return the type of the catch block which should be called.\n      for (var i = 0; i < typeArray.length; i++) {\n        if (typeArray[i] && Module['___cxa_can_catch'](typeArray[i], throwntype, thrown)) {\n          thrown = HEAP32[((thrown)>>2)]; // undo indirection\n          info.adjusted = thrown;\n          return ((setTempRet0(typeArray[i]),thrown)|0);\n        }\n      }\n      // Shouldn't happen unless we have bogus data in typeArray\n      // or encounter a type for which emscripten doesn't have suitable\n      // typeinfo defined. Best-efforts match just in case.\n      thrown = HEAP32[((thrown)>>2)]; // undo indirection\n      return ((setTempRet0(throwntype),thrown)|0);\n    }function ___cxa_throw(ptr, type, destructor) {\n      EXCEPTIONS.infos[ptr] = {\n        ptr: ptr,\n        adjusted: ptr,\n        type: type,\n        destructor: destructor,\n        refcount: 0,\n        caught: false,\n        rethrown: false\n      };\n      EXCEPTIONS.last = ptr;\n      if (!(\"uncaught_exception\" in __ZSt18uncaught_exceptionv)) {\n        __ZSt18uncaught_exceptionv.uncaught_exception = 1;\n      } else {\n        __ZSt18uncaught_exceptionv.uncaught_exception++;\n      }\n      throw ptr + \" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.\";\n    }\n\n  function ___gxx_personality_v0() {\n    }\n\n  function ___lock() {}\n\n  \n    \n\n  \n  \n  \n  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};\n  \n  var ERRNO_MESSAGES={0:\"Success\",1:\"Not super-user\",2:\"No such file or directory\",3:\"No such process\",4:\"Interrupted system call\",5:\"I/O error\",6:\"No such device or address\",7:\"Arg list too long\",8:\"Exec format error\",9:\"Bad file number\",10:\"No children\",11:\"No more processes\",12:\"Not enough core\",13:\"Permission denied\",14:\"Bad address\",15:\"Block device required\",16:\"Mount device busy\",17:\"File exists\",18:\"Cross-device link\",19:\"No such device\",20:\"Not a directory\",21:\"Is a directory\",22:\"Invalid argument\",23:\"Too many open files in system\",24:\"Too many open files\",25:\"Not a typewriter\",26:\"Text file busy\",27:\"File too large\",28:\"No space left on device\",29:\"Illegal seek\",30:\"Read only file system\",31:\"Too many links\",32:\"Broken pipe\",33:\"Math arg out of domain of func\",34:\"Math result not representable\",35:\"File locking deadlock error\",36:\"File or path name too long\",37:\"No record locks available\",38:\"Function not implemented\",39:\"Directory not empty\",40:\"Too many symbolic links\",42:\"No message of desired type\",43:\"Identifier removed\",44:\"Channel number out of range\",45:\"Level 2 not synchronized\",46:\"Level 3 halted\",47:\"Level 3 reset\",48:\"Link number out of range\",49:\"Protocol driver not attached\",50:\"No CSI structure available\",51:\"Level 2 halted\",52:\"Invalid exchange\",53:\"Invalid request descriptor\",54:\"Exchange full\",55:\"No anode\",56:\"Invalid request code\",57:\"Invalid slot\",59:\"Bad font file fmt\",60:\"Device not a stream\",61:\"No data (for no delay io)\",62:\"Timer expired\",63:\"Out of streams resources\",64:\"Machine is not on the network\",65:\"Package not installed\",66:\"The object is remote\",67:\"The link has been severed\",68:\"Advertise error\",69:\"Srmount error\",70:\"Communication error on send\",71:\"Protocol error\",72:\"Multihop attempted\",73:\"Cross mount point (not really error)\",74:\"Trying to read unreadable message\",75:\"Value too large for defined data type\",76:\"Given log. name not unique\",77:\"f.d. invalid for this operation\",78:\"Remote address changed\",79:\"Can   access a needed shared lib\",80:\"Accessing a corrupted shared lib\",81:\".lib section in a.out corrupted\",82:\"Attempting to link in too many libs\",83:\"Attempting to exec a shared library\",84:\"Illegal byte sequence\",86:\"Streams pipe error\",87:\"Too many users\",88:\"Socket operation on non-socket\",89:\"Destination address required\",90:\"Message too long\",91:\"Protocol wrong type for socket\",92:\"Protocol not available\",93:\"Unknown protocol\",94:\"Socket type not supported\",95:\"Not supported\",96:\"Protocol family not supported\",97:\"Address family not supported by protocol family\",98:\"Address already in use\",99:\"Address not available\",100:\"Network interface is not configured\",101:\"Network is unreachable\",102:\"Connection reset by network\",103:\"Connection aborted\",104:\"Connection reset by peer\",105:\"No buffer space available\",106:\"Socket is already connected\",107:\"Socket is not connected\",108:\"Can't send after socket shutdown\",109:\"Too many references\",110:\"Connection timed out\",111:\"Connection refused\",112:\"Host is down\",113:\"Host is unreachable\",114:\"Socket already connected\",115:\"Connection already in progress\",116:\"Stale file handle\",122:\"Quota exceeded\",123:\"No medium (in tape drive)\",125:\"Operation canceled\",130:\"Previous owner died\",131:\"State not recoverable\"};\n  \n  function ___setErrNo(value) {\n      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;\n      else Module.printErr('failed to set errno from JS');\n      return value;\n    }\n  \n  var PATH={splitPath:function (filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },normalizeArray:function (parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },normalize:function (path) {\n        var isAbsolute = path.charAt(0) === '/',\n            trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter(function(p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },dirname:function (path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },basename:function (path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash+1);\n      },extname:function (path) {\n        return PATH.splitPath(path)[3];\n      },join:function () {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join('/'));\n      },join2:function (l, r) {\n        return PATH.normalize(l + '/' + r);\n      },resolve:function () {\n        var resolvedPath = '',\n          resolvedAbsolute = false;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = (i >= 0) ? arguments[i] : FS.cwd();\n          // Skip empty and invalid entries\n          if (typeof path !== 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            return ''; // an invalid portion invalidates the whole thing\n          }\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = path.charAt(0) === '/';\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {\n          return !!p;\n        }), !resolvedAbsolute).join('/');\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n      },relative:function (from, to) {\n        from = PATH.resolve(from).substr(1);\n        to = PATH.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      }};\n  \n  var TTY={ttys:[],init:function () {\n        // https://github.com/kripken/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n        //   // with text files until FS.init can be refactored.\n        //   process['stdin']['setEncoding']('utf8');\n        // }\n      },shutdown:function () {\n        // https://github.com/kripken/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\n        //   process['stdin']['pause']();\n        // }\n      },register:function (dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },stream_ops:{open:function (stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },close:function (stream) {\n          // flush any pending line data\n          stream.tty.ops.flush(stream.tty);\n        },flush:function (stream) {\n          stream.tty.ops.flush(stream.tty);\n        },read:function (stream, buffer, offset, length, pos /* ignored */) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset+i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },write:function (stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n          }\n          for (var i = 0; i < length; i++) {\n            try {\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\n            } catch (e) {\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\n            }\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }},default_tty_ops:{get_char:function (tty) {\n          if (!tty.input.length) {\n            var result = null;\n            if (ENVIRONMENT_IS_NODE) {\n              // we will read data by chunks of BUFSIZE\n              var BUFSIZE = 256;\n              var buf = new Buffer(BUFSIZE);\n              var bytesRead = 0;\n  \n              var isPosixPlatform = (process.platform != 'win32'); // Node doesn't offer a direct check, so test by exclusion\n  \n              var fd = process.stdin.fd;\n              if (isPosixPlatform) {\n                // Linux and Mac cannot use process.stdin.fd (which isn't set up as sync)\n                var usingDevice = false;\n                try {\n                  fd = fs.openSync('/dev/stdin', 'r');\n                  usingDevice = true;\n                } catch (e) {}\n              }\n  \n              try {\n                bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);\n              } catch(e) {\n                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,\n                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.\n                if (e.toString().indexOf('EOF') != -1) bytesRead = 0;\n                else throw e;\n              }\n  \n              if (usingDevice) { fs.closeSync(fd); }\n              if (bytesRead > 0) {\n                result = buf.slice(0, bytesRead).toString('utf-8');\n              } else {\n                result = null;\n              }\n  \n            } else if (typeof window != 'undefined' &&\n              typeof window.prompt == 'function') {\n              // Browser.\n              result = window.prompt('Input: ');  // returns null on cancel\n              if (result !== null) {\n                result += '\\n';\n              }\n            } else if (typeof readline == 'function') {\n              // Command line.\n              result = readline();\n              if (result !== null) {\n                result += '\\n';\n              }\n            }\n            if (!result) {\n              return null;\n            }\n            tty.input = intArrayFromString(result, true);\n          }\n          return tty.input.shift();\n        },put_char:function (tty, val) {\n          if (val === null || val === 10) {\n            Module['print'](UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\n          }\n        },flush:function (tty) {\n          if (tty.output && tty.output.length > 0) {\n            Module['print'](UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }},default_tty1_ops:{put_char:function (tty, val) {\n          if (val === null || val === 10) {\n            Module['printErr'](UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },flush:function (tty) {\n          if (tty.output && tty.output.length > 0) {\n            Module['printErr'](UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }}};\n  \n  var MEMFS={ops_table:null,mount:function (mount) {\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\n      },createNode:function (parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          // no supported\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek\n              }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n          node.contents = null; \n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        // add the new node to the parent\n        if (parent) {\n          parent.contents[name] = node;\n        }\n        return node;\n      },getFileDataAsRegularArray:function (node) {\n        if (node.contents && node.contents.subarray) {\n          var arr = [];\n          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\n          return arr; // Returns a copy of the original data.\n        }\n        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.\n      },getFileDataAsTypedArray:function (node) {\n        if (!node.contents) return new Uint8Array;\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n        return new Uint8Array(node.contents);\n      },expandFileStorage:function (node, newCapacity) {\n        // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file\n        // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to\n        // increase the size.\n        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {\n          node.contents = MEMFS.getFileDataAsRegularArray(node);\n          node.usedBytes = node.contents.length; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it.\n        }\n  \n        if (!node.contents || node.contents.subarray) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well.\n          var prevCapacity = node.contents ? node.contents.length : 0;\n          if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n          // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n          // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n          // avoid overshooting the allocation cap by a very large margin.\n          var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n          newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0);\n          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n          return;\n        }\n        // Not using a typed array to back the file storage. Use a standard JS array instead.\n        if (!node.contents && newCapacity > 0) node.contents = [];\n        while (node.contents.length < newCapacity) node.contents.push(0);\n      },resizeFileStorage:function (node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null; // Fully decommit when requesting a resize to zero.\n          node.usedBytes = 0;\n          return;\n        }\n        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n          }\n          node.usedBytes = newSize;\n          return;\n        }\n        // Backing with a JS array.\n        if (!node.contents) node.contents = [];\n        if (node.contents.length > newSize) node.contents.length = newSize;\n        else while (node.contents.length < newSize) node.contents.push(0);\n        node.usedBytes = newSize;\n      },node_ops:{getattr:function (node) {\n          var attr = {};\n          // device numbers reuse inode numbers.\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n          //       but this is not required by the standard.\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },setattr:function (node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },lookup:function (parent, name) {\n          throw FS.genericErrors[ERRNO_CODES.ENOENT];\n        },mknod:function (parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },rename:function (old_node, new_dir, new_name) {\n          // if we're overwriting a directory at new_name, make sure it's empty.\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {\n            }\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n              }\n            }\n          }\n          // do the internal rewiring\n          delete old_node.parent.contents[old_node.name];\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          old_node.parent = new_dir;\n        },unlink:function (parent, name) {\n          delete parent.contents[name];\n        },rmdir:function (parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n          }\n          delete parent.contents[name];\n        },readdir:function (node) {\n          var entries = ['.', '..']\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n            entries.push(key);\n          }\n          return entries;\n        },symlink:function (parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },readlink:function (node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n          return node.link;\n        }},stream_ops:{read:function (stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          assert(size >= 0);\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },write:function (stream, buffer, offset, length, position, canOwn) {\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n  \n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\n            if (canOwn) {\n              assert(position === 0, 'canOwn must imply no weird position inside the file');\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\n              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n  \n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n          MEMFS.expandFileStorage(node, position+length);\n          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.\n          else {\n            for (var i = 0; i < length; i++) {\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position+length);\n          return length;\n        },llseek:function (stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {  // SEEK_CUR.\n            position += stream.position;\n          } else if (whence === 2) {  // SEEK_END.\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n          return position;\n        },allocate:function (stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },mmap:function (stream, buffer, offset, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          // Only make a new copy when MAP_PRIVATE is specified.\n          if ( !(flags & 2) &&\n                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {\n            // We can't emulate MAP_SHARED when the file is not backed by the buffer\n            // we're mapping to (e.g. the HEAP buffer).\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            // Try to avoid unnecessary slices.\n            if (position > 0 || position + length < stream.node.usedBytes) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n            allocated = true;\n            ptr = _malloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);\n            }\n            buffer.set(contents, ptr);\n          }\n          return { ptr: ptr, allocated: allocated };\n        },msync:function (stream, buffer, offset, length, mmapFlags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n          if (mmapFlags & 2) {\n            // MAP_PRIVATE calls need not to be synced back to underlying fs\n            return 0;\n          }\n  \n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          // should we check if bytesWritten and length are the same?\n          return 0;\n        }}};\n  \n  var IDBFS={dbs:{},indexedDB:function () {\n        if (typeof indexedDB !== 'undefined') return indexedDB;\n        var ret = null;\n        if (typeof window === 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n        assert(ret, 'IDBFS used, but indexedDB not supported');\n        return ret;\n      },DB_VERSION:21,DB_STORE_NAME:\"FILE_DATA\",mount:function (mount) {\n        // reuse all of the core MEMFS functionality\n        return MEMFS.mount.apply(null, arguments);\n      },syncfs:function (mount, populate, callback) {\n        IDBFS.getLocalSet(mount, function(err, local) {\n          if (err) return callback(err);\n  \n          IDBFS.getRemoteSet(mount, function(err, remote) {\n            if (err) return callback(err);\n  \n            var src = populate ? remote : local;\n            var dst = populate ? local : remote;\n  \n            IDBFS.reconcile(src, dst, callback);\n          });\n        });\n      },getDB:function (name, callback) {\n        // check the cache first\n        var db = IDBFS.dbs[name];\n        if (db) {\n          return callback(null, db);\n        }\n  \n        var req;\n        try {\n          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);\n        } catch (e) {\n          return callback(e);\n        }\n        if (!req) {\n          return callback(\"Unable to connect to IndexedDB\");\n        }\n        req.onupgradeneeded = function(e) {\n          var db = e.target.result;\n          var transaction = e.target.transaction;\n  \n          var fileStore;\n  \n          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {\n            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);\n          } else {\n            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);\n          }\n  \n          if (!fileStore.indexNames.contains('timestamp')) {\n            fileStore.createIndex('timestamp', 'timestamp', { unique: false });\n          }\n        };\n        req.onsuccess = function() {\n          db = req.result;\n  \n          // add to the cache\n          IDBFS.dbs[name] = db;\n          callback(null, db);\n        };\n        req.onerror = function(e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },getLocalSet:function (mount, callback) {\n        var entries = {};\n  \n        function isRealDir(p) {\n          return p !== '.' && p !== '..';\n        };\n        function toAbsolute(root) {\n          return function(p) {\n            return PATH.join2(root, p);\n          }\n        };\n  \n        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));\n  \n        while (check.length) {\n          var path = check.pop();\n          var stat;\n  \n          try {\n            stat = FS.stat(path);\n          } catch (e) {\n            return callback(e);\n          }\n  \n          if (FS.isDir(stat.mode)) {\n            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));\n          }\n  \n          entries[path] = { timestamp: stat.mtime };\n        }\n  \n        return callback(null, { type: 'local', entries: entries });\n      },getRemoteSet:function (mount, callback) {\n        var entries = {};\n  \n        IDBFS.getDB(mount.mountpoint, function(err, db) {\n          if (err) return callback(err);\n  \n          try {\n            var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');\n            transaction.onerror = function(e) {\n              callback(this.error);\n              e.preventDefault();\n            };\n  \n            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n            var index = store.index('timestamp');\n  \n            index.openKeyCursor().onsuccess = function(event) {\n              var cursor = event.target.result;\n  \n              if (!cursor) {\n                return callback(null, { type: 'remote', db: db, entries: entries });\n              }\n  \n              entries[cursor.primaryKey] = { timestamp: cursor.key };\n  \n              cursor.continue();\n            };\n          } catch (e) {\n            return callback(e);\n          }\n        });\n      },loadLocalEntry:function (path, callback) {\n        var stat, node;\n  \n        try {\n          var lookup = FS.lookupPath(path);\n          node = lookup.node;\n          stat = FS.stat(path);\n        } catch (e) {\n          return callback(e);\n        }\n  \n        if (FS.isDir(stat.mode)) {\n          return callback(null, { timestamp: stat.mtime, mode: stat.mode });\n        } else if (FS.isFile(stat.mode)) {\n          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.\n          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.\n          node.contents = MEMFS.getFileDataAsTypedArray(node);\n          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });\n        } else {\n          return callback(new Error('node type not supported'));\n        }\n      },storeLocalEntry:function (path, entry, callback) {\n        try {\n          if (FS.isDir(entry.mode)) {\n            FS.mkdir(path, entry.mode);\n          } else if (FS.isFile(entry.mode)) {\n            FS.writeFile(path, entry.contents, { canOwn: true });\n          } else {\n            return callback(new Error('node type not supported'));\n          }\n  \n          FS.chmod(path, entry.mode);\n          FS.utime(path, entry.timestamp, entry.timestamp);\n        } catch (e) {\n          return callback(e);\n        }\n  \n        callback(null);\n      },removeLocalEntry:function (path, callback) {\n        try {\n          var lookup = FS.lookupPath(path);\n          var stat = FS.stat(path);\n  \n          if (FS.isDir(stat.mode)) {\n            FS.rmdir(path);\n          } else if (FS.isFile(stat.mode)) {\n            FS.unlink(path);\n          }\n        } catch (e) {\n          return callback(e);\n        }\n  \n        callback(null);\n      },loadRemoteEntry:function (store, path, callback) {\n        var req = store.get(path);\n        req.onsuccess = function(event) { callback(null, event.target.result); };\n        req.onerror = function(e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },storeRemoteEntry:function (store, path, entry, callback) {\n        var req = store.put(entry, path);\n        req.onsuccess = function() { callback(null); };\n        req.onerror = function(e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },removeRemoteEntry:function (store, path, callback) {\n        var req = store.delete(path);\n        req.onsuccess = function() { callback(null); };\n        req.onerror = function(e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },reconcile:function (src, dst, callback) {\n        var total = 0;\n  \n        var create = [];\n        Object.keys(src.entries).forEach(function (key) {\n          var e = src.entries[key];\n          var e2 = dst.entries[key];\n          if (!e2 || e.timestamp > e2.timestamp) {\n            create.push(key);\n            total++;\n          }\n        });\n  \n        var remove = [];\n        Object.keys(dst.entries).forEach(function (key) {\n          var e = dst.entries[key];\n          var e2 = src.entries[key];\n          if (!e2) {\n            remove.push(key);\n            total++;\n          }\n        });\n  \n        if (!total) {\n          return callback(null);\n        }\n  \n        var errored = false;\n        var completed = 0;\n        var db = src.type === 'remote' ? src.db : dst.db;\n        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');\n        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n  \n        function done(err) {\n          if (err) {\n            if (!done.errored) {\n              done.errored = true;\n              return callback(err);\n            }\n            return;\n          }\n          if (++completed >= total) {\n            return callback(null);\n          }\n        };\n  \n        transaction.onerror = function(e) {\n          done(this.error);\n          e.preventDefault();\n        };\n  \n        // sort paths in ascending order so directory entries are created\n        // before the files inside them\n        create.sort().forEach(function (path) {\n          if (dst.type === 'local') {\n            IDBFS.loadRemoteEntry(store, path, function (err, entry) {\n              if (err) return done(err);\n              IDBFS.storeLocalEntry(path, entry, done);\n            });\n          } else {\n            IDBFS.loadLocalEntry(path, function (err, entry) {\n              if (err) return done(err);\n              IDBFS.storeRemoteEntry(store, path, entry, done);\n            });\n          }\n        });\n  \n        // sort paths in descending order so files are deleted before their\n        // parent directories\n        remove.sort().reverse().forEach(function(path) {\n          if (dst.type === 'local') {\n            IDBFS.removeLocalEntry(path, done);\n          } else {\n            IDBFS.removeRemoteEntry(store, path, done);\n          }\n        });\n      }};\n  \n  var NODEFS={isWindows:false,staticInit:function () {\n        NODEFS.isWindows = !!process.platform.match(/^win/);\n        var flags = process[\"binding\"](\"constants\");\n        // Node.js 4 compatibility: it has no namespaces for constants\n        if (flags[\"fs\"]) {\n          flags = flags[\"fs\"];\n        }\n        NODEFS.flagsForNodeMap = {\n          \"1024\": flags[\"O_APPEND\"],\n          \"64\": flags[\"O_CREAT\"],\n          \"128\": flags[\"O_EXCL\"],\n          \"0\": flags[\"O_RDONLY\"],\n          \"2\": flags[\"O_RDWR\"],\n          \"4096\": flags[\"O_SYNC\"],\n          \"512\": flags[\"O_TRUNC\"],\n          \"1\": flags[\"O_WRONLY\"]\n        };\n      },bufferFrom:function (arrayBuffer) {\n        // Node.js < 4.5 compatibility: Buffer.from does not support ArrayBuffer\n        // Buffer.from before 4.5 was just a method inherited from Uint8Array\n        // Buffer.alloc has been added with Buffer.from together, so check it instead\n        return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);\n      },mount:function (mount) {\n        assert(ENVIRONMENT_IS_NODE);\n        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);\n      },createNode:function (parent, name, mode, dev) {\n        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var node = FS.createNode(parent, name, mode);\n        node.node_ops = NODEFS.node_ops;\n        node.stream_ops = NODEFS.stream_ops;\n        return node;\n      },getMode:function (path) {\n        var stat;\n        try {\n          stat = fs.lstatSync(path);\n          if (NODEFS.isWindows) {\n            // Node.js on Windows never represents permission bit 'x', so\n            // propagate read bits to execute bits\n            stat.mode = stat.mode | ((stat.mode & 292) >> 2);\n          }\n        } catch (e) {\n          if (!e.code) throw e;\n          throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n        }\n        return stat.mode;\n      },realPath:function (node) {\n        var parts = [];\n        while (node.parent !== node) {\n          parts.push(node.name);\n          node = node.parent;\n        }\n        parts.push(node.mount.opts.root);\n        parts.reverse();\n        return PATH.join.apply(null, parts);\n      },flagsForNode:function (flags) {\n        flags &= ~0x200000 /*O_PATH*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\n        flags &= ~0x800 /*O_NONBLOCK*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\n        flags &= ~0x8000 /*O_LARGEFILE*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\n        flags &= ~0x80000 /*O_CLOEXEC*/; // Some applications may pass it; it makes no sense for a single process.\n        var newFlags = 0;\n        for (var k in NODEFS.flagsForNodeMap) {\n          if (flags & k) {\n            newFlags |= NODEFS.flagsForNodeMap[k];\n            flags ^= k;\n          }\n        }\n  \n        if (!flags) {\n          return newFlags;\n        } else {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n      },node_ops:{getattr:function (node) {\n          var path = NODEFS.realPath(node);\n          var stat;\n          try {\n            stat = fs.lstatSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.\n          // See http://support.microsoft.com/kb/140365\n          if (NODEFS.isWindows && !stat.blksize) {\n            stat.blksize = 4096;\n          }\n          if (NODEFS.isWindows && !stat.blocks) {\n            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;\n          }\n          return {\n            dev: stat.dev,\n            ino: stat.ino,\n            mode: stat.mode,\n            nlink: stat.nlink,\n            uid: stat.uid,\n            gid: stat.gid,\n            rdev: stat.rdev,\n            size: stat.size,\n            atime: stat.atime,\n            mtime: stat.mtime,\n            ctime: stat.ctime,\n            blksize: stat.blksize,\n            blocks: stat.blocks\n          };\n        },setattr:function (node, attr) {\n          var path = NODEFS.realPath(node);\n          try {\n            if (attr.mode !== undefined) {\n              fs.chmodSync(path, attr.mode);\n              // update the common node structure mode as well\n              node.mode = attr.mode;\n            }\n            if (attr.timestamp !== undefined) {\n              var date = new Date(attr.timestamp);\n              fs.utimesSync(path, date, date);\n            }\n            if (attr.size !== undefined) {\n              fs.truncateSync(path, attr.size);\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },lookup:function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n          var mode = NODEFS.getMode(path);\n          return NODEFS.createNode(parent, name, mode);\n        },mknod:function (parent, name, mode, dev) {\n          var node = NODEFS.createNode(parent, name, mode, dev);\n          // create the backing node for this in the fs root as well\n          var path = NODEFS.realPath(node);\n          try {\n            if (FS.isDir(node.mode)) {\n              fs.mkdirSync(path, node.mode);\n            } else {\n              fs.writeFileSync(path, '', { mode: node.mode });\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n          return node;\n        },rename:function (oldNode, newDir, newName) {\n          var oldPath = NODEFS.realPath(oldNode);\n          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);\n          try {\n            fs.renameSync(oldPath, newPath);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },unlink:function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n          try {\n            fs.unlinkSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },rmdir:function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n          try {\n            fs.rmdirSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },readdir:function (node) {\n          var path = NODEFS.realPath(node);\n          try {\n            return fs.readdirSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },symlink:function (parent, newName, oldPath) {\n          var newPath = PATH.join2(NODEFS.realPath(parent), newName);\n          try {\n            fs.symlinkSync(oldPath, newPath);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },readlink:function (node) {\n          var path = NODEFS.realPath(node);\n          try {\n            path = fs.readlinkSync(path);\n            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);\n            return path;\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        }},stream_ops:{open:function (stream) {\n          var path = NODEFS.realPath(stream.node);\n          try {\n            if (FS.isFile(stream.node.mode)) {\n              stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },close:function (stream) {\n          try {\n            if (FS.isFile(stream.node.mode) && stream.nfd) {\n              fs.closeSync(stream.nfd);\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },read:function (stream, buffer, offset, length, position) {\n          // Node.js < 6 compatibility: node errors on 0 length reads\n          if (length === 0) return 0;\n          try {\n            return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },write:function (stream, buffer, offset, length, position) {\n          try {\n            return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },llseek:function (stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {  // SEEK_CUR.\n            position += stream.position;\n          } else if (whence === 2) {  // SEEK_END.\n            if (FS.isFile(stream.node.mode)) {\n              try {\n                var stat = fs.fstatSync(stream.nfd);\n                position += stat.size;\n              } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n              }\n            }\n          }\n  \n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n  \n          return position;\n        }}};\n  \n  var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:function (mount) {\n        assert(ENVIRONMENT_IS_WORKER);\n        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();\n        var root = WORKERFS.createNode(null, '/', WORKERFS.DIR_MODE, 0);\n        var createdParents = {};\n        function ensureParent(path) {\n          // return the parent node, creating subdirs as necessary\n          var parts = path.split('/');\n          var parent = root;\n          for (var i = 0; i < parts.length-1; i++) {\n            var curr = parts.slice(0, i+1).join('/');\n            // Issue 4254: Using curr as a node name will prevent the node\n            // from being found in FS.nameTable when FS.open is called on\n            // a path which holds a child of this node,\n            // given that all FS functions assume node names\n            // are just their corresponding parts within their given path,\n            // rather than incremental aggregates which include their parent's\n            // directories.\n            if (!createdParents[curr]) {\n              createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0);\n            }\n            parent = createdParents[curr];\n          }\n          return parent;\n        }\n        function base(path) {\n          var parts = path.split('/');\n          return parts[parts.length-1];\n        }\n        // We also accept FileList here, by using Array.prototype\n        Array.prototype.forEach.call(mount.opts[\"files\"] || [], function(file) {\n          WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);\n        });\n        (mount.opts[\"blobs\"] || []).forEach(function(obj) {\n          WORKERFS.createNode(ensureParent(obj[\"name\"]), base(obj[\"name\"]), WORKERFS.FILE_MODE, 0, obj[\"data\"]);\n        });\n        (mount.opts[\"packages\"] || []).forEach(function(pack) {\n          pack['metadata'].files.forEach(function(file) {\n            var name = file.filename.substr(1); // remove initial slash\n            WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack['blob'].slice(file.start, file.end));\n          });\n        });\n        return root;\n      },createNode:function (parent, name, mode, dev, contents, mtime) {\n        var node = FS.createNode(parent, name, mode);\n        node.mode = mode;\n        node.node_ops = WORKERFS.node_ops;\n        node.stream_ops = WORKERFS.stream_ops;\n        node.timestamp = (mtime || new Date).getTime();\n        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\n        if (mode === WORKERFS.FILE_MODE) {\n          node.size = contents.size;\n          node.contents = contents;\n        } else {\n          node.size = 4096;\n          node.contents = {};\n        }\n        if (parent) {\n          parent.contents[name] = node;\n        }\n        return node;\n      },node_ops:{getattr:function (node) {\n          return {\n            dev: 1,\n            ino: undefined,\n            mode: node.mode,\n            nlink: 1,\n            uid: 0,\n            gid: 0,\n            rdev: undefined,\n            size: node.size,\n            atime: new Date(node.timestamp),\n            mtime: new Date(node.timestamp),\n            ctime: new Date(node.timestamp),\n            blksize: 4096,\n            blocks: Math.ceil(node.size / 4096),\n          };\n        },setattr:function (node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n        },lookup:function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        },mknod:function (parent, name, mode, dev) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },rename:function (oldNode, newDir, newName) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },unlink:function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },rmdir:function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },readdir:function (node) {\n          var entries = ['.', '..'];\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n            entries.push(key);\n          }\n          return entries;\n        },symlink:function (parent, newName, oldPath) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },readlink:function (node) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }},stream_ops:{read:function (stream, buffer, offset, length, position) {\n          if (position >= stream.node.size) return 0;\n          var chunk = stream.node.contents.slice(position, position + length);\n          var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\n          buffer.set(new Uint8Array(ab), offset);\n          return chunk.size;\n        },write:function (stream, buffer, offset, length, position) {\n          throw new FS.ErrnoError(ERRNO_CODES.EIO);\n        },llseek:function (stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {  // SEEK_CUR.\n            position += stream.position;\n          } else if (whence === 2) {  // SEEK_END.\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.size;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n          return position;\n        }}};\n  \n  var _stdin=STATICTOP; STATICTOP += 16;;\n  \n  var _stdout=STATICTOP; STATICTOP += 16;;\n  \n  var _stderr=STATICTOP; STATICTOP += 16;;var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function (e) {\n        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();\n        return ___setErrNo(e.errno);\n      },lookupPath:function (path, opts) {\n        path = PATH.resolve(FS.cwd(), path);\n        opts = opts || {};\n  \n        if (!path) return { path: '', node: null };\n  \n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        for (var key in defaults) {\n          if (opts[key] === undefined) {\n            opts[key] = defaults[key];\n          }\n        }\n  \n        if (opts.recurse_count > 8) {  // max recursive lookup of 8\n          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);\n        }\n  \n        // split the path\n        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {\n          return !!p;\n        }), false);\n  \n        // start at the root\n        var current = FS.root;\n        var current_path = '/';\n  \n        for (var i = 0; i < parts.length; i++) {\n          var islast = (i === parts.length-1);\n          if (islast && opts.parent) {\n            // stop resolving\n            break;\n          }\n  \n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n  \n          // jump to the mount's root node if this is a mountpoint\n          if (FS.isMountpoint(current)) {\n            if (!islast || (islast && opts.follow_mount)) {\n              current = current.mounted.root;\n            }\n          }\n  \n          // by default, lookupPath will not follow a symlink if it is the final path component.\n          // setting opts.follow = true will override this behavior.\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH.resolve(PATH.dirname(current_path), link);\n  \n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });\n              current = lookup.node;\n  \n              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\n                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);\n              }\n            }\n          }\n        }\n  \n        return { path: current_path, node: current };\n      },getPath:function (node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;\n          }\n          path = path ? node.name + '/' + path : node.name;\n          node = node.parent;\n        }\n      },hashName:function (parentid, name) {\n        var hash = 0;\n  \n  \n        for (var i = 0; i < name.length; i++) {\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n        }\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\n      },hashAddNode:function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },hashRemoveNode:function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },lookupNode:function (parent, name) {\n        var err = FS.mayLookup(parent);\n        if (err) {\n          throw new FS.ErrnoError(err, parent);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        // if we failed to find it in the cache, call into the VFS\n        return FS.lookup(parent, name);\n      },createNode:function (parent, name, mode, rdev) {\n        if (!FS.FSNode) {\n          FS.FSNode = function(parent, name, mode, rdev) {\n            if (!parent) {\n              parent = this;  // root node sets parent to itself\n            }\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n          };\n  \n          FS.FSNode.prototype = {};\n  \n          // compatibility\n          var readMode = 292 | 73;\n          var writeMode = 146;\n  \n          // NOTE we must use Object.defineProperties instead of individual calls to\n          // Object.defineProperty in order to make closure compiler happy\n          Object.defineProperties(FS.FSNode.prototype, {\n            read: {\n              get: function() { return (this.mode & readMode) === readMode; },\n              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }\n            },\n            write: {\n              get: function() { return (this.mode & writeMode) === writeMode; },\n              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }\n            },\n            isFolder: {\n              get: function() { return FS.isDir(this.mode); }\n            },\n            isDevice: {\n              get: function() { return FS.isChrdev(this.mode); }\n            }\n          });\n        }\n  \n        var node = new FS.FSNode(parent, name, mode, rdev);\n  \n        FS.hashAddNode(node);\n  \n        return node;\n      },destroyNode:function (node) {\n        FS.hashRemoveNode(node);\n      },isRoot:function (node) {\n        return node === node.parent;\n      },isMountpoint:function (node) {\n        return !!node.mounted;\n      },isFile:function (mode) {\n        return (mode & 61440) === 32768;\n      },isDir:function (mode) {\n        return (mode & 61440) === 16384;\n      },isLink:function (mode) {\n        return (mode & 61440) === 40960;\n      },isChrdev:function (mode) {\n        return (mode & 61440) === 8192;\n      },isBlkdev:function (mode) {\n        return (mode & 61440) === 24576;\n      },isFIFO:function (mode) {\n        return (mode & 61440) === 4096;\n      },isSocket:function (mode) {\n        return (mode & 49152) === 49152;\n      },flagModes:{\"r\":0,\"rs\":1052672,\"r+\":2,\"w\":577,\"wx\":705,\"xw\":705,\"w+\":578,\"wx+\":706,\"xw+\":706,\"a\":1089,\"ax\":1217,\"xa\":1217,\"a+\":1090,\"ax+\":1218,\"xa+\":1218},modeStringToFlags:function (str) {\n        var flags = FS.flagModes[str];\n        if (typeof flags === 'undefined') {\n          throw new Error('Unknown file open mode: ' + str);\n        }\n        return flags;\n      },flagsToPermissionString:function (flag) {\n        var perms = ['r', 'w', 'rw'][flag & 3];\n        if ((flag & 512)) {\n          perms += 'w';\n        }\n        return perms;\n      },nodePermissions:function (node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        // return 0 if any user, group or owner bits are set.\n        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {\n          return ERRNO_CODES.EACCES;\n        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {\n          return ERRNO_CODES.EACCES;\n        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {\n          return ERRNO_CODES.EACCES;\n        }\n        return 0;\n      },mayLookup:function (dir) {\n        var err = FS.nodePermissions(dir, 'x');\n        if (err) return err;\n        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;\n        return 0;\n      },mayCreate:function (dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return ERRNO_CODES.EEXIST;\n        } catch (e) {\n        }\n        return FS.nodePermissions(dir, 'wx');\n      },mayDelete:function (dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var err = FS.nodePermissions(dir, 'wx');\n        if (err) {\n          return err;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return ERRNO_CODES.ENOTDIR;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return ERRNO_CODES.EBUSY;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return ERRNO_CODES.EISDIR;\n          }\n        }\n        return 0;\n      },mayOpen:function (node, flags) {\n        if (!node) {\n          return ERRNO_CODES.ENOENT;\n        }\n        if (FS.isLink(node.mode)) {\n          return ERRNO_CODES.ELOOP;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\n              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\n            return ERRNO_CODES.EISDIR;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {\n        fd_start = fd_start || 0;\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);\n      },getStream:function (fd) {\n        return FS.streams[fd];\n      },createStream:function (stream, fd_start, fd_end) {\n        if (!FS.FSStream) {\n          FS.FSStream = function(){};\n          FS.FSStream.prototype = {};\n          // compatibility\n          Object.defineProperties(FS.FSStream.prototype, {\n            object: {\n              get: function() { return this.node; },\n              set: function(val) { this.node = val; }\n            },\n            isRead: {\n              get: function() { return (this.flags & 2097155) !== 1; }\n            },\n            isWrite: {\n              get: function() { return (this.flags & 2097155) !== 0; }\n            },\n            isAppend: {\n              get: function() { return (this.flags & 1024); }\n            }\n          });\n        }\n        // clone it, so we can return an instance of FSStream\n        var newStream = new FS.FSStream();\n        for (var p in stream) {\n          newStream[p] = stream[p];\n        }\n        stream = newStream;\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },closeStream:function (fd) {\n        FS.streams[fd] = null;\n      },chrdev_stream_ops:{open:function (stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          // override node's stream ops with the device's\n          stream.stream_ops = device.stream_ops;\n          // forward the open call\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },llseek:function () {\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n        }},major:function (dev) {\n        return ((dev) >> 8);\n      },minor:function (dev) {\n        return ((dev) & 0xff);\n      },makedev:function (ma, mi) {\n        return ((ma) << 8 | (mi));\n      },registerDevice:function (dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },getDevice:function (dev) {\n        return FS.devices[dev];\n      },getMounts:function (mount) {\n        var mounts = [];\n        var check = [mount];\n  \n        while (check.length) {\n          var m = check.pop();\n  \n          mounts.push(m);\n  \n          check.push.apply(check, m.mounts);\n        }\n  \n        return mounts;\n      },syncfs:function (populate, callback) {\n        if (typeof(populate) === 'function') {\n          callback = populate;\n          populate = false;\n        }\n  \n        FS.syncFSRequests++;\n  \n        if (FS.syncFSRequests > 1) {\n          console.log('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');\n        }\n  \n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n  \n        function doCallback(err) {\n          assert(FS.syncFSRequests > 0);\n          FS.syncFSRequests--;\n          return callback(err);\n        }\n  \n        function done(err) {\n          if (err) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(err);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        };\n  \n        // sync all mounts\n        mounts.forEach(function (mount) {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },mount:function (type, opts, mountpoint) {\n        var root = mountpoint === '/';\n        var pseudo = !mountpoint;\n        var node;\n  \n        if (root && FS.root) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n          mountpoint = lookup.path;  // use the absolute path\n          node = lookup.node;\n  \n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n          }\n  \n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n          }\n        }\n  \n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n  \n        // create a root node for the fs\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n  \n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          // set as a mountpoint\n          node.mounted = mount;\n  \n          // add the new mount to the current mount's children\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n  \n        return mountRoot;\n      },unmount:function (mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n  \n        // destroy the nodes for this mount, and all its child mounts\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n  \n        Object.keys(FS.nameTable).forEach(function (hash) {\n          var current = FS.nameTable[hash];\n  \n          while (current) {\n            var next = current.name_next;\n  \n            if (mounts.indexOf(current.mount) !== -1) {\n              FS.destroyNode(current);\n            }\n  \n            current = next;\n          }\n        });\n  \n        // no longer a mountpoint\n        node.mounted = null;\n  \n        // remove this mount from the child mounts\n        var idx = node.mount.mounts.indexOf(mount);\n        assert(idx !== -1);\n        node.mount.mounts.splice(idx, 1);\n      },lookup:function (parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },mknod:function (path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === '.' || name === '..') {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var err = FS.mayCreate(parent, name);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },create:function (path, mode) {\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },mkdir:function (path, mode) {\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },mkdirTree:function (path, mode) {\n        var dirs = path.split('/');\n        var d = '';\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += '/' + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch(e) {\n            if (e.errno != ERRNO_CODES.EEXIST) throw e;\n          }\n        }\n      },mkdev:function (path, mode, dev) {\n        if (typeof(dev) === 'undefined') {\n          dev = mode;\n          mode = 438 /* 0666 */;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },symlink:function (oldpath, newpath) {\n        if (!PATH.resolve(oldpath)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        var newname = PATH.basename(newpath);\n        var err = FS.mayCreate(parent, newname);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },rename:function (old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        // parents must exist\n        var lookup, old_dir, new_dir;\n        try {\n          lookup = FS.lookupPath(old_path, { parent: true });\n          old_dir = lookup.node;\n          lookup = FS.lookupPath(new_path, { parent: true });\n          new_dir = lookup.node;\n        } catch (e) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        }\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        // need to be part of the same mount\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);\n        }\n        // source must exist\n        var old_node = FS.lookupNode(old_dir, old_name);\n        // old path should not be an ancestor of the new path\n        var relative = PATH.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        // new path should not be an ancestor of the old path\n        relative = PATH.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n        }\n        // see if the new path already exists\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n          // not fatal\n        }\n        // early out if nothing needs to change\n        if (old_node === new_node) {\n          return;\n        }\n        // we'll need to delete the old entry\n        var isdir = FS.isDir(old_node.mode);\n        var err = FS.mayDelete(old_dir, old_name, isdir);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        // need delete permissions if we'll be overwriting.\n        // need create permissions if new doesn't already exist.\n        err = new_node ?\n          FS.mayDelete(new_dir, new_name, isdir) :\n          FS.mayCreate(new_dir, new_name);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        }\n        // if we are going to change the parent, check write permissions\n        if (new_dir !== old_dir) {\n          err = FS.nodePermissions(old_dir, 'w');\n          if (err) {\n            throw new FS.ErrnoError(err);\n          }\n        }\n        try {\n          if (FS.trackingDelegate['willMovePath']) {\n            FS.trackingDelegate['willMovePath'](old_path, new_path);\n          }\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['willMovePath']('\"+old_path+\"', '\"+new_path+\"') threw an exception: \" + e.message);\n        }\n        // remove the node from the lookup hash\n        FS.hashRemoveNode(old_node);\n        // do the underlying fs rename\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          // add the node back to the hash (in case node_ops.rename\n          // changed its name)\n          FS.hashAddNode(old_node);\n        }\n        try {\n          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onMovePath']('\"+old_path+\"', '\"+new_path+\"') threw an exception: \" + e.message);\n        }\n      },rmdir:function (path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, true);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        }\n        try {\n          if (FS.trackingDelegate['willDeletePath']) {\n            FS.trackingDelegate['willDeletePath'](path);\n          }\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['willDeletePath']('\"+path+\"') threw an exception: \" + e.message);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n        try {\n          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onDeletePath']('\"+path+\"') threw an exception: \" + e.message);\n        }\n      },readdir:function (path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n        }\n        return node.node_ops.readdir(node);\n      },unlink:function (path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, false);\n        if (err) {\n          // According to POSIX, we should map EISDIR to EPERM, but\n          // we instead do what Linux does (and we must, as we use\n          // the musl linux libc).\n          throw new FS.ErrnoError(err);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        }\n        try {\n          if (FS.trackingDelegate['willDeletePath']) {\n            FS.trackingDelegate['willDeletePath'](path);\n          }\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['willDeletePath']('\"+path+\"') threw an exception: \" + e.message);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n        try {\n          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onDeletePath']('\"+path+\"') threw an exception: \" + e.message);\n        }\n      },readlink:function (path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },stat:function (path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        return node.node_ops.getattr(node);\n      },lstat:function (path) {\n        return FS.stat(path, true);\n      },chmod:function (path, mode, dontFollow) {\n        var node;\n        if (typeof path === 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        node.node_ops.setattr(node, {\n          mode: (mode & 4095) | (node.mode & ~4095),\n          timestamp: Date.now()\n        });\n      },lchmod:function (path, mode) {\n        FS.chmod(path, mode, true);\n      },fchmod:function (fd, mode) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        FS.chmod(stream.node, mode);\n      },chown:function (path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path === 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n          // we ignore the uid / gid for now\n        });\n      },lchown:function (path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },fchown:function (fd, uid, gid) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        FS.chown(stream.node, uid, gid);\n      },truncate:function (path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var node;\n        if (typeof path === 'string') {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var err = FS.nodePermissions(node, 'w');\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },ftruncate:function (fd, len) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        FS.truncate(stream.node, len);\n      },utime:function (path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },open:function (path, flags, mode, fd_start, fd_end) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;\n        if ((flags & 64)) {\n          mode = (mode & 4095) | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path === 'object') {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {\n            // ignore\n          }\n        }\n        // perhaps we need to create the node\n        var created = false;\n        if ((flags & 64)) {\n          if (node) {\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\n            if ((flags & 128)) {\n              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);\n            }\n          } else {\n            // node doesn't exist, try to create it\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        // can't truncate a device\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        // if asked only for a directory, then this must be one\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n        }\n        // check permissions, if this is not a file we just created now (it is ok to\n        // create and write to a file with read-only permissions; it is read-only\n        // for later use)\n        if (!created) {\n          var err = FS.mayOpen(node, flags);\n          if (err) {\n            throw new FS.ErrnoError(err);\n          }\n        }\n        // do truncation if necessary\n        if ((flags & 512)) {\n          FS.truncate(node, 0);\n        }\n        // we've already handled these, don't pass down to the underlying vfs\n        flags &= ~(128 | 512);\n  \n        // register the stream with the filesystem\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),  // we want the absolute path to the node\n          flags: flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n          ungotten: [],\n          error: false\n        }, fd_start, fd_end);\n        // call the new stream's open function\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module['logReadFiles'] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n            Module['printErr']('read file: ' + path);\n          }\n        }\n        try {\n          if (FS.trackingDelegate['onOpenFile']) {\n            var trackingFlags = 0;\n            if ((flags & 2097155) !== 1) {\n              trackingFlags |= FS.tracking.openFlags.READ;\n            }\n            if ((flags & 2097155) !== 0) {\n              trackingFlags |= FS.tracking.openFlags.WRITE;\n            }\n            FS.trackingDelegate['onOpenFile'](path, trackingFlags);\n          }\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onOpenFile']('\"+path+\"', flags) threw an exception: \" + e.message);\n        }\n        return stream;\n      },close:function (stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if (stream.getdents) stream.getdents = null; // free readdir state\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },isClosed:function (stream) {\n        return stream.fd === null;\n      },llseek:function (stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },read:function (stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var seeking = typeof position !== 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },write:function (stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        if (stream.flags & 1024) {\n          // seek to the end before writing in append mode\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position !== 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        try {\n          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onWriteToFile']('\"+path+\"') threw an exception: \" + e.message);\n        }\n        return bytesWritten;\n      },allocate:function (stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },mmap:function (stream, buffer, offset, length, position, prot, flags) {\n        // TODO if PROT is PROT_WRITE, make sure we have write access\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(ERRNO_CODES.EACCES);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n        }\n        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);\n      },msync:function (stream, buffer, offset, length, mmapFlags) {\n        if (!stream || !stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },munmap:function (stream) {\n        return 0;\n      },ioctl:function (stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },readFile:function (path, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 'r';\n        opts.encoding = opts.encoding || 'binary';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === 'utf8') {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === 'binary') {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },writeFile:function (path, data, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 'w';\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data === 'string') {\n          var buf = new Uint8Array(lengthBytesUTF8(data)+1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error('Unsupported data type');\n        }\n        FS.close(stream);\n      },cwd:function () {\n        return FS.currentPath;\n      },chdir:function (path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n        }\n        var err = FS.nodePermissions(lookup.node, 'x');\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        FS.currentPath = lookup.path;\n      },createDefaultDirectories:function () {\n        FS.mkdir('/tmp');\n        FS.mkdir('/home');\n        FS.mkdir('/home/web_user');\n      },createDefaultDevices:function () {\n        // create /dev\n        FS.mkdir('/dev');\n        // setup /dev/null\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: function() { return 0; },\n          write: function(stream, buffer, offset, length, pos) { return length; }\n        });\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\n        // setup /dev/tty and /dev/tty1\n        // stderr needs to print output using Module['printErr']\n        // so we register a second tty just for it.\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n        // setup /dev/[u]random\n        var random_device;\n        if (typeof crypto !== 'undefined') {\n          // for modern web browsers\n          var randomBuffer = new Uint8Array(1);\n          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };\n        } else if (ENVIRONMENT_IS_NODE) {\n          // for nodejs\n          random_device = function() { return __webpack_require__(/*! crypto */ \"./node_modules/crypto-browserify/index.js\")['randomBytes'](1)[0]; };\n        } else {\n          // default for ES5 platforms\n          random_device = function() { return (Math.random()*256)|0; };\n        }\n        FS.createDevice('/dev', 'random', random_device);\n        FS.createDevice('/dev', 'urandom', random_device);\n        // we're not going to emulate the actual shm device,\n        // just create the tmp dirs that reside in it commonly\n        FS.mkdir('/dev/shm');\n        FS.mkdir('/dev/shm/tmp');\n      },createSpecialDirectories:function () {\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)\n        FS.mkdir('/proc');\n        FS.mkdir('/proc/self');\n        FS.mkdir('/proc/self/fd');\n        FS.mount({\n          mount: function() {\n            var node = FS.createNode('/proc/self', 'fd', 16384 | 511 /* 0777 */, 73);\n            node.node_ops = {\n              lookup: function(parent, name) {\n                var fd = +name;\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n                var ret = {\n                  parent: null,\n                  mount: { mountpoint: 'fake' },\n                  node_ops: { readlink: function() { return stream.path } }\n                };\n                ret.parent = ret; // make it look like a simple root node\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, '/proc/self/fd');\n      },createStandardStreams:function () {\n        // TODO deprecate the old functionality of a single\n        // input / output callback and that utilizes FS.createDevice\n        // and instead require a unique set of stream ops\n  \n        // by default, we symlink the standard streams to the\n        // default tty devices. however, if the standard streams\n        // have been overwritten we create a unique device for\n        // them instead.\n        if (Module['stdin']) {\n          FS.createDevice('/dev', 'stdin', Module['stdin']);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdin');\n        }\n        if (Module['stdout']) {\n          FS.createDevice('/dev', 'stdout', null, Module['stdout']);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdout');\n        }\n        if (Module['stderr']) {\n          FS.createDevice('/dev', 'stderr', null, Module['stderr']);\n        } else {\n          FS.symlink('/dev/tty1', '/dev/stderr');\n        }\n  \n        // open default streams for the stdin, stdout and stderr devices\n        var stdin = FS.open('/dev/stdin', 'r');\n        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');\n  \n        var stdout = FS.open('/dev/stdout', 'w');\n        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');\n  \n        var stderr = FS.open('/dev/stderr', 'w');\n        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');\n      },ensureErrnoError:function () {\n        if (FS.ErrnoError) return;\n        FS.ErrnoError = function ErrnoError(errno, node) {\n          //Module.printErr(stackTrace()); // useful for debugging\n          this.node = node;\n          this.setErrno = function(errno) {\n            this.errno = errno;\n            for (var key in ERRNO_CODES) {\n              if (ERRNO_CODES[key] === errno) {\n                this.code = key;\n                break;\n              }\n            }\n          };\n          this.setErrno(errno);\n          this.message = ERRNO_MESSAGES[errno];\n          // Node.js compatibility: assigning on this.stack fails on Node 4 (but fixed on Node 8)\n          if (this.stack) Object.defineProperty(this, \"stack\", { value: (new Error).stack, writable: true });\n          if (this.stack) this.stack = demangleAll(this.stack);\n        };\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\n        [ERRNO_CODES.ENOENT].forEach(function(code) {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = '<generic error, no stack>';\n        });\n      },staticInit:function () {\n        FS.ensureErrnoError();\n  \n        FS.nameTable = new Array(4096);\n  \n        FS.mount(MEMFS, {}, '/');\n  \n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n  \n        FS.filesystems = {\n          'MEMFS': MEMFS,\n          'IDBFS': IDBFS,\n          'NODEFS': NODEFS,\n          'WORKERFS': WORKERFS,\n        };\n      },init:function (input, output, error) {\n        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');\n        FS.init.initialized = true;\n  \n        FS.ensureErrnoError();\n  \n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n        Module['stdin'] = input || Module['stdin'];\n        Module['stdout'] = output || Module['stdout'];\n        Module['stderr'] = error || Module['stderr'];\n  \n        FS.createStandardStreams();\n      },quit:function () {\n        FS.init.initialized = false;\n        // force-flush all streams, so we get musl std streams printed out\n        var fflush = Module['_fflush'];\n        if (fflush) fflush(0);\n        // close all of our streams\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },getMode:function (canRead, canWrite) {\n        var mode = 0;\n        if (canRead) mode |= 292 | 73;\n        if (canWrite) mode |= 146;\n        return mode;\n      },joinPath:function (parts, forceRelative) {\n        var path = PATH.join.apply(null, parts);\n        if (forceRelative && path[0] == '/') path = path.substr(1);\n        return path;\n      },absolutePath:function (relative, base) {\n        return PATH.resolve(base, relative);\n      },standardizePath:function (path) {\n        return PATH.normalize(path);\n      },findObject:function (path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (ret.exists) {\n          return ret.object;\n        } else {\n          ___setErrNo(ret.error);\n          return null;\n        }\n      },analyzePath:function (path, dontResolveLastLink) {\n        // operate from within the context of the symlink's target\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {\n        }\n        var ret = {\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\n          parentExists: false, parentPath: null, parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === '/';\n        } catch (e) {\n          ret.error = e.errno;\n        };\n        return ret;\n      },createFolder:function (parent, name, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.mkdir(path, mode);\n      },createPath:function (parent, path, canRead, canWrite) {\n        parent = typeof parent === 'string' ? parent : FS.getPath(parent);\n        var parts = path.split('/').reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n            // ignore EEXIST\n          }\n          parent = current;\n        }\n        return current;\n      },createFile:function (parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {\n        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data === 'string') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          // make sure we can write to the file\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 'w');\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n        return node;\n      },createDevice:function (parent, name, input, output) {\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        // Create a fake device that a set of stream ops to emulate\n        // the old behavior.\n        FS.registerDevice(dev, {\n          open: function(stream) {\n            stream.seekable = false;\n          },\n          close: function(stream) {\n            // flush any pending line data\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read: function(stream, buffer, offset, length, pos /* ignored */) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES.EIO);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset+i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write: function(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset+i]);\n              } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES.EIO);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },createLink:function (parent, name, target, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\n        return FS.symlink(target, path);\n      },forceLoadFile:function (obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        var success = true;\n        if (typeof XMLHttpRequest !== 'undefined') {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (Module['read']) {\n          // Command-line.\n          try {\n            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\n            //          read() will try to parse UTF8.\n            obj.contents = intArrayFromString(Module['read'](obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            success = false;\n          }\n        } else {\n          throw new Error('Cannot load without read() or XMLHttpRequest.');\n        }\n        if (!success) ___setErrNo(ERRNO_CODES.EIO);\n        return success;\n      },createLazyFile:function (parent, name, url, canRead, canWrite) {\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = []; // Loaded chunks. Index is the chunk number\n        }\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n          if (idx > this.length-1 || idx < 0) {\n            return undefined;\n          }\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = (idx / this.chunkSize)|0;\n          return this.getter(chunkNum)[chunkOffset];\n        }\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        }\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          // Find length\n          var xhr = new XMLHttpRequest();\n          xhr.open('HEAD', url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n  \n          var chunkSize = 1024*1024; // Chunk size in bytes\n  \n          if (!hasByteServing) chunkSize = datalength;\n  \n          // Function to get a range from the remote URL.\n          var doXHR = (function(from, to) {\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n  \n            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n  \n            // Some hints to the browser that we want binary data.\n            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';\n            if (xhr.overrideMimeType) {\n              xhr.overrideMimeType('text/plain; charset=x-user-defined');\n            }\n  \n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n            if (xhr.response !== undefined) {\n              return new Uint8Array(xhr.response || []);\n            } else {\n              return intArrayFromString(xhr.responseText || '', true);\n            }\n          });\n          var lazyArray = this;\n          lazyArray.setDataGetter(function(chunkNum) {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum+1) * chunkSize - 1; // including this byte\n            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\n            if (typeof(lazyArray.chunks[chunkNum]) === \"undefined\") {\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n            if (typeof(lazyArray.chunks[chunkNum]) === \"undefined\") throw new Error(\"doXHR failed!\");\n            return lazyArray.chunks[chunkNum];\n          });\n  \n          if (usesGzip || !datalength) {\n            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\n            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            console.log(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n  \n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        }\n        if (typeof XMLHttpRequest !== 'undefined') {\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: function() {\n                if(!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: function() {\n                if(!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._chunkSize;\n              }\n            }\n          });\n  \n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url: url };\n        }\n  \n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        // This is a total hack, but I want to get this lazy file code out of the\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\n        // be its own thin LAZYFS proxying calls to MEMFS.\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        // Add a function that defers querying the file size until it is asked the first time.\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function() { return this.contents.length; }\n          }\n        });\n        // override each stream op with one that tries to force load the lazy file first\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(function(key) {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = function forceLoadLazyFile() {\n            if (!FS.forceLoadFile(node)) {\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\n            }\n            return fn.apply(null, arguments);\n          };\n        });\n        // use a custom read function\n        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n          if (!FS.forceLoadFile(node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EIO);\n          }\n          var contents = stream.node.contents;\n          if (position >= contents.length)\n            return 0;\n          var size = Math.min(contents.length - position, length);\n          assert(size >= 0);\n          if (contents.slice) { // normal array\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n        Browser.init(); // XXX perhaps this method should move onto Browser?\n        // TODO we should allow people to just pass in a complete filename instead\n        // of parent and name being that we just join them anyways\n        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname\n        function processData(byteArray) {\n          function finish(byteArray) {\n            if (preFinish) preFinish();\n            if (!dontCreateFile) {\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n            }\n            if (onload) onload();\n            removeRunDependency(dep);\n          }\n          var handled = false;\n          Module['preloadPlugins'].forEach(function(plugin) {\n            if (handled) return;\n            if (plugin['canHandle'](fullname)) {\n              plugin['handle'](byteArray, fullname, finish, function() {\n                if (onerror) onerror();\n                removeRunDependency(dep);\n              });\n              handled = true;\n            }\n          });\n          if (!handled) finish(byteArray);\n        }\n        addRunDependency(dep);\n        if (typeof url == 'string') {\n          Browser.asyncLoad(url, function(byteArray) {\n            processData(byteArray);\n          }, onerror);\n        } else {\n          processData(url);\n        }\n      },indexedDB:function () {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      },DB_NAME:function () {\n        return 'EM_FS_' + window.location.pathname;\n      },DB_VERSION:20,DB_STORE_NAME:\"FILE_DATA\",saveFilesToDB:function (paths, onload, onerror) {\n        onload = onload || function(){};\n        onerror = onerror || function(){};\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n          console.log('creating db');\n          var db = openRequest.result;\n          db.createObjectStore(FS.DB_STORE_NAME);\n        };\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0, fail = 0, total = paths.length;\n          function finish() {\n            if (fail == 0) onload(); else onerror();\n          }\n          paths.forEach(function(path) {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };\n            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      },loadFilesFromDB:function (paths, onload, onerror) {\n        onload = onload || function(){};\n        onerror = onerror || function(){};\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = onerror; // no database to load from\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');\n          } catch(e) {\n            onerror(e);\n            return;\n          }\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0, fail = 0, total = paths.length;\n          function finish() {\n            if (fail == 0) onload(); else onerror();\n          }\n          paths.forEach(function(path) {\n            var getRequest = files.get(path);\n            getRequest.onsuccess = function getRequest_onsuccess() {\n              if (FS.analyzePath(path).exists) {\n                FS.unlink(path);\n              }\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n              ok++;\n              if (ok + fail == total) finish();\n            };\n            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      }};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:function (dirfd, path) {\n        if (path[0] !== '/') {\n          // relative path\n          var dir;\n          if (dirfd === -100) {\n            dir = FS.cwd();\n          } else {\n            var dirstream = FS.getStream(dirfd);\n            if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n            dir = dirstream.path;\n          }\n          path = PATH.join2(dir, path);\n        }\n        return path;\n      },doStat:function (func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            // an error occurred while trying to look up the path; we should just report ENOTDIR\n            return -ERRNO_CODES.ENOTDIR;\n          }\n          throw e;\n        }\n        HEAP32[((buf)>>2)]=stat.dev;\n        HEAP32[(((buf)+(4))>>2)]=0;\n        HEAP32[(((buf)+(8))>>2)]=stat.ino;\n        HEAP32[(((buf)+(12))>>2)]=stat.mode;\n        HEAP32[(((buf)+(16))>>2)]=stat.nlink;\n        HEAP32[(((buf)+(20))>>2)]=stat.uid;\n        HEAP32[(((buf)+(24))>>2)]=stat.gid;\n        HEAP32[(((buf)+(28))>>2)]=stat.rdev;\n        HEAP32[(((buf)+(32))>>2)]=0;\n        HEAP32[(((buf)+(36))>>2)]=stat.size;\n        HEAP32[(((buf)+(40))>>2)]=4096;\n        HEAP32[(((buf)+(44))>>2)]=stat.blocks;\n        HEAP32[(((buf)+(48))>>2)]=(stat.atime.getTime() / 1000)|0;\n        HEAP32[(((buf)+(52))>>2)]=0;\n        HEAP32[(((buf)+(56))>>2)]=(stat.mtime.getTime() / 1000)|0;\n        HEAP32[(((buf)+(60))>>2)]=0;\n        HEAP32[(((buf)+(64))>>2)]=(stat.ctime.getTime() / 1000)|0;\n        HEAP32[(((buf)+(68))>>2)]=0;\n        HEAP32[(((buf)+(72))>>2)]=stat.ino;\n        return 0;\n      },doMsync:function (addr, stream, len, flags) {\n        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));\n        FS.msync(stream, buffer, 0, len, flags);\n      },doMkdir:function (path, mode) {\n        // remove a trailing slash, if one - /a/b/ has basename of '', but\n        // we want to create b in the context of this function\n        path = PATH.normalize(path);\n        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      },doMknod:function (path, mode, dev) {\n        // we don't want this in the JS API as it uses mknod to create all nodes.\n        switch (mode & 61440) {\n          case 32768:\n          case 8192:\n          case 24576:\n          case 4096:\n          case 49152:\n            break;\n          default: return -ERRNO_CODES.EINVAL;\n        }\n        FS.mknod(path, mode, dev);\n        return 0;\n      },doReadlink:function (path, buf, bufsize) {\n        if (bufsize <= 0) return -ERRNO_CODES.EINVAL;\n        var ret = FS.readlink(path);\n  \n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf+len];\n        stringToUTF8(ret, buf, bufsize+1);\n        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)\n        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.\n        HEAP8[buf+len] = endChar;\n  \n        return len;\n      },doAccess:function (path, amode) {\n        if (amode & ~7) {\n          // need a valid mode\n          return -ERRNO_CODES.EINVAL;\n        }\n        var node;\n        var lookup = FS.lookupPath(path, { follow: true });\n        node = lookup.node;\n        var perms = '';\n        if (amode & 4) perms += 'r';\n        if (amode & 2) perms += 'w';\n        if (amode & 1) perms += 'x';\n        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {\n          return -ERRNO_CODES.EACCES;\n        }\n        return 0;\n      },doDup:function (path, flags, suggestFD) {\n        var suggest = FS.getStream(suggestFD);\n        if (suggest) FS.close(suggest);\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n      },doReadv:function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[(((iov)+(i*8))>>2)];\n          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n          var curr = FS.read(stream, HEAP8,ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n          if (curr < len) break; // nothing more to read\n        }\n        return ret;\n      },doWritev:function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[(((iov)+(i*8))>>2)];\n          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n          var curr = FS.write(stream, HEAP8,ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n        }\n        return ret;\n      },varargs:0,get:function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n        return ret;\n      },getStr:function () {\n        var ret = Pointer_stringify(SYSCALLS.get());\n        return ret;\n      },getStreamFromFD:function () {\n        var stream = FS.getStream(SYSCALLS.get());\n        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return stream;\n      },getSocketFromFD:function () {\n        var socket = SOCKFS.getSocket(SYSCALLS.get());\n        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return socket;\n      },getSocketAddress:function (allowNull) {\n        var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();\n        if (allowNull && addrp === 0) return null;\n        var info = __read_sockaddr(addrp, addrlen);\n        if (info.errno) throw new FS.ErrnoError(info.errno);\n        info.addr = DNS.lookup_addr(info.addr) || info.addr;\n        return info;\n      },get64:function () {\n        var low = SYSCALLS.get(), high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);\n        else assert(high === -1);\n        return low;\n      },getZero:function () {\n        assert(SYSCALLS.get() === 0);\n      }};function ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // llseek\n      var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();\n      // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\n      var offset = offset_low;\n      FS.llseek(stream, offset, whence);\n      HEAP32[((result)>>2)]=stream.position;\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall145(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // readv\n      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\n      return SYSCALLS.doReadv(stream, iov, iovcnt);\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // writev\n      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\n      return SYSCALLS.doWritev(stream, iov, iovcnt);\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall221(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // fcntl64\n      var stream = SYSCALLS.getStreamFromFD(), cmd = SYSCALLS.get();\n      switch (cmd) {\n        case 0: {\n          var arg = SYSCALLS.get();\n          if (arg < 0) {\n            return -ERRNO_CODES.EINVAL;\n          }\n          var newStream;\n          newStream = FS.open(stream.path, stream.flags, 0, arg);\n          return newStream.fd;\n        }\n        case 1:\n        case 2:\n          return 0;  // FD_CLOEXEC makes no sense for a single process.\n        case 3:\n          return stream.flags;\n        case 4: {\n          var arg = SYSCALLS.get();\n          stream.flags |= arg;\n          return 0;\n        }\n        case 12:\n        case 12: {\n          var arg = SYSCALLS.get();\n          var offset = 0;\n          // We're always unlocked.\n          HEAP16[(((arg)+(offset))>>1)]=2;\n          return 0;\n        }\n        case 13:\n        case 14:\n        case 13:\n        case 14:\n          return 0; // Pretend that the locking is successful.\n        case 16:\n        case 8:\n          return -ERRNO_CODES.EINVAL; // These are for sockets. We don't have them fully implemented yet.\n        case 9:\n          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.\n          ___setErrNo(ERRNO_CODES.EINVAL);\n          return -1;\n        default: {\n          return -ERRNO_CODES.EINVAL;\n        }\n      }\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall5(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // open\n      var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get() // optional TODO\n      var stream = FS.open(pathname, flags, mode);\n      return stream.fd;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // ioctl\n      var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();\n      switch (op) {\n        case 21509:\n        case 21505: {\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          return 0;\n        }\n        case 21510:\n        case 21511:\n        case 21512:\n        case 21506:\n        case 21507:\n        case 21508: {\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          return 0; // no-op, not actually adjusting terminal settings\n        }\n        case 21519: {\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          var argp = SYSCALLS.get();\n          HEAP32[((argp)>>2)]=0;\n          return 0;\n        }\n        case 21520: {\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          return -ERRNO_CODES.EINVAL; // not supported\n        }\n        case 21531: {\n          var argp = SYSCALLS.get();\n          return FS.ioctl(stream, op, argp);\n        }\n        case 21523: {\n          // TODO: in theory we should write to the winsize struct that gets\n          // passed in, but for now musl doesn't read anything on it\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          return 0;\n        }\n        case 21524: {\n          // TODO: technically, this ioctl call should change the window size.\n          // but, since emscripten doesn't have any concept of a terminal window\n          // yet, we'll just silently throw it away as we do TIOCGWINSZ\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          return 0;\n        }\n        default: abort('bad ioctl syscall ' + op);\n      }\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // close\n      var stream = SYSCALLS.getStreamFromFD();\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  \n  \n   \n  \n   \n  \n     \n\n  function ___unlock() {}\n\n  \n  function getShiftFromSize(size) {\n      switch (size) {\n          case 1: return 0;\n          case 2: return 1;\n          case 4: return 2;\n          case 8: return 3;\n          default:\n              throw new TypeError('Unknown type size: ' + size);\n      }\n    }\n  \n  \n  \n  function embind_init_charCodes() {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n          codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    }var embind_charCodes=undefined;function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n      while (HEAPU8[c]) {\n          ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    }\n  \n  \n  var awaitingDependencies={};\n  \n  var registeredTypes={};\n  \n  var typeDependencies={};\n  \n  \n  \n  \n  \n  \n  var char_0=48;\n  \n  var char_9=57;function makeLegalFunctionName(name) {\n      if (undefined === name) {\n          return '_unknown';\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n          return '_' + name;\n      } else {\n          return name;\n      }\n    }function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      /*jshint evil:true*/\n      return new Function(\n          \"body\",\n          \"return function \" + name + \"() {\\n\" +\n          \"    \\\"use strict\\\";\" +\n          \"    return body.apply(this, arguments);\\n\" +\n          \"};\\n\"\n      )(body);\n    }function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function(message) {\n          this.name = errorName;\n          this.message = message;\n  \n          var stack = (new Error(message)).stack;\n          if (stack !== undefined) {\n              this.stack = this.toString() + '\\n' +\n                  stack.replace(/^Error(:[^\\n]*)?\\n/, '');\n          }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function() {\n          if (this.message === undefined) {\n              return this.name;\n          } else {\n              return this.name + ': ' + this.message;\n          }\n      };\n  \n      return errorClass;\n    }var BindingError=undefined;function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n  \n  \n  \n  var InternalError=undefined;function throwInternalError(message) {\n      throw new InternalError(message);\n    }function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n      myTypes.forEach(function(type) {\n          typeDependencies[type] = dependentTypes;\n      });\n  \n      function onComplete(typeConverters) {\n          var myTypeConverters = getTypeConverters(typeConverters);\n          if (myTypeConverters.length !== myTypes.length) {\n              throwInternalError('Mismatched type converter count');\n          }\n          for (var i = 0; i < myTypes.length; ++i) {\n              registerType(myTypes[i], myTypeConverters[i]);\n          }\n      }\n  \n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach(function(dt, i) {\n          if (registeredTypes.hasOwnProperty(dt)) {\n              typeConverters[i] = registeredTypes[dt];\n          } else {\n              unregisteredTypes.push(dt);\n              if (!awaitingDependencies.hasOwnProperty(dt)) {\n                  awaitingDependencies[dt] = [];\n              }\n              awaitingDependencies[dt].push(function() {\n                  typeConverters[i] = registeredTypes[dt];\n                  ++registered;\n                  if (registered === unregisteredTypes.length) {\n                      onComplete(typeConverters);\n                  }\n              });\n          }\n      });\n      if (0 === unregisteredTypes.length) {\n          onComplete(typeConverters);\n      }\n    }function registerType(rawType, registeredInstance, options) {\n      options = options || {};\n  \n      if (!('argPackAdvance' in registeredInstance)) {\n          throw new TypeError('registerType registeredInstance requires argPackAdvance');\n      }\n  \n      var name = registeredInstance.name;\n      if (!rawType) {\n          throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n          if (options.ignoreDuplicateRegistrations) {\n              return;\n          } else {\n              throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n          }\n      }\n  \n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n  \n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n          var callbacks = awaitingDependencies[rawType];\n          delete awaitingDependencies[rawType];\n          callbacks.forEach(function(cb) {\n              cb();\n          });\n      }\n    }function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n      var shift = getShiftFromSize(size);\n  \n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(wt) {\n              // ambiguous emscripten ABI: sometimes return values are\n              // true or false, and sometimes integers (0 or 1)\n              return !!wt;\n          },\n          'toWireType': function(destructors, o) {\n              return o ? trueValue : falseValue;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': function(pointer) {\n              // TODO: if heap is fixed (like in asm.js) this could be executed outside\n              var heap;\n              if (size === 1) {\n                  heap = HEAP8;\n              } else if (size === 2) {\n                  heap = HEAP16;\n              } else if (size === 4) {\n                  heap = HEAP32;\n              } else {\n                  throw new TypeError(\"Unknown boolean type size: \" + name);\n              }\n              return this['fromWireType'](heap[pointer >> shift]);\n          },\n          destructorFunction: null, // This type does not need a destructor\n      });\n    }\n\n  function __embind_register_constant(name, type, value) {\n      name = readLatin1String(name);\n      whenDependentTypesAreResolved([], [type], function(type) {\n          type = type[0];\n          Module[name] = type['fromWireType'](value);\n          return [];\n      });\n    }\n\n  \n  \n  var emval_free_list=[];\n  \n  var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle) {\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n          emval_handle_array[handle] = undefined;\n          emval_free_list.push(handle);\n      }\n    }\n  \n  \n  \n  function count_emval_handles() {\n      var count = 0;\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n          if (emval_handle_array[i] !== undefined) {\n              ++count;\n          }\n      }\n      return count;\n    }\n  \n  function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n          if (emval_handle_array[i] !== undefined) {\n              return emval_handle_array[i];\n          }\n      }\n      return null;\n    }function init_emval() {\n      Module['count_emval_handles'] = count_emval_handles;\n      Module['get_first_emval'] = get_first_emval;\n    }function __emval_register(value) {\n  \n      switch(value){\n        case undefined :{ return 1; }\n        case null :{ return 2; }\n        case true :{ return 3; }\n        case false :{ return 4; }\n        default:{\n          var handle = emval_free_list.length ?\n              emval_free_list.pop() :\n              emval_handle_array.length;\n  \n          emval_handle_array[handle] = {refcount: 1, value: value};\n          return handle;\n          }\n        }\n    }\n  \n  function simpleReadValueFromPointer(pointer) {\n      return this['fromWireType'](HEAPU32[pointer >> 2]);\n    }function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(handle) {\n              var rv = emval_handle_array[handle].value;\n              __emval_decref(handle);\n              return rv;\n          },\n          'toWireType': function(destructors, value) {\n              return __emval_register(value);\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': simpleReadValueFromPointer,\n          destructorFunction: null, // This type does not need a destructor\n  \n          // TODO: do we need a deleteObject here?  write a test where\n          // emval is passed into JS via an interface\n      });\n    }\n\n  \n  function _embind_repr(v) {\n      if (v === null) {\n          return 'null';\n      }\n      var t = typeof v;\n      if (t === 'object' || t === 'array' || t === 'function') {\n          return v.toString();\n      } else {\n          return '' + v;\n      }\n    }\n  \n  function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n          case 2: return function(pointer) {\n              return this['fromWireType'](HEAPF32[pointer >> 2]);\n          };\n          case 3: return function(pointer) {\n              return this['fromWireType'](HEAPF64[pointer >> 3]);\n          };\n          default:\n              throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(value) {\n              return value;\n          },\n          'toWireType': function(destructors, value) {\n              // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations: we could\n              // avoid the following if() and assume value is of proper type.\n              if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n                  throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n              }\n              return value;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': floatReadValueFromPointer(name, shift),\n          destructorFunction: null, // This type does not need a destructor\n      });\n    }\n\n  \n  \n  function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n          throw new TypeError('new_ called with constructor type ' + typeof(constructor) + \" which is not a function\");\n      }\n  \n      /*\n       * Previously, the following line was just:\n  \n       function dummy() {};\n  \n       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even though at creation, the 'dummy' has the\n       * correct constructor name.  Thus, objects created with IMVU.new would show up in the debugger as 'dummy', which\n       * isn't very helpful.  Using IMVU.createNamedFunction addresses the issue.  Doublely-unfortunately, there's no way\n       * to write a test for this behavior.  -NRD 2013.02.22\n       */\n      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy;\n  \n      var r = constructor.apply(obj, argumentList);\n      return (r instanceof Object) ? r : obj;\n    }\n  \n  function runDestructors(destructors) {\n      while (destructors.length) {\n          var ptr = destructors.pop();\n          var del = destructors.pop();\n          del(ptr);\n      }\n    }function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n      // humanName: a human-readable string name for the function to be generated.\n      // argTypes: An array that contains the embind type objects for all types in the function signature.\n      //    argTypes[0] is the type object for the function return value.\n      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\n      //    argTypes[2...] are the actual function parameters.\n      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\n      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\n      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\n      var argCount = argTypes.length;\n  \n      if (argCount < 2) {\n          throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n  \n      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);\n  \n      // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\n  // TODO: This omits argument count check - enable only at -O3 or similar.\n  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\n  //       return FUNCTION_TABLE[fn];\n  //    }\n  \n  \n      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\n      // TODO: Remove this completely once all function invokers are being dynamically generated.\n      var needsDestructorStack = false;\n  \n      for(var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.\n          if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack\n              needsDestructorStack = true;\n              break;\n          }\n      }\n  \n      var returns = (argTypes[0].name !== \"void\");\n  \n      var argsList = \"\";\n      var argsListWired = \"\";\n      for(var i = 0; i < argCount - 2; ++i) {\n          argsList += (i!==0?\", \":\"\")+\"arg\"+i;\n          argsListWired += (i!==0?\", \":\"\")+\"arg\"+i+\"Wired\";\n      }\n  \n      var invokerFnBody =\n          \"return function \"+makeLegalFunctionName(humanName)+\"(\"+argsList+\") {\\n\" +\n          \"if (arguments.length !== \"+(argCount - 2)+\") {\\n\" +\n              \"throwBindingError('function \"+humanName+\" called with ' + arguments.length + ' arguments, expected \"+(argCount - 2)+\" args!');\\n\" +\n          \"}\\n\";\n  \n  \n      if (needsDestructorStack) {\n          invokerFnBody +=\n              \"var destructors = [];\\n\";\n      }\n  \n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n  \n  \n      if (isClassMethodFunc) {\n          invokerFnBody += \"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\";\n      }\n  \n      for(var i = 0; i < argCount - 2; ++i) {\n          invokerFnBody += \"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";\n          args1.push(\"argType\"+i);\n          args2.push(argTypes[i+2]);\n      }\n  \n      if (isClassMethodFunc) {\n          argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n  \n      invokerFnBody +=\n          (returns?\"var rv = \":\"\") + \"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";\n  \n      if (needsDestructorStack) {\n          invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n          for(var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\n              var paramName = (i === 1 ? \"thisWired\" : (\"arg\"+(i - 2)+\"Wired\"));\n              if (argTypes[i].destructorFunction !== null) {\n                  invokerFnBody += paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";\n                  args1.push(paramName+\"_dtor\");\n                  args2.push(argTypes[i].destructorFunction);\n              }\n          }\n      }\n  \n      if (returns) {\n          invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" +\n                           \"return ret;\\n\";\n      } else {\n      }\n      invokerFnBody += \"}\\n\";\n  \n      args1.push(invokerFnBody);\n  \n      var invokerFunction = new_(Function, args1).apply(null, args2);\n      return invokerFunction;\n    }\n  \n  \n  function ensureOverloadTable(proto, methodName, humanName) {\n      if (undefined === proto[methodName].overloadTable) {\n          var prevFunc = proto[methodName];\n          // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\n          proto[methodName] = function() {\n              // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\n              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n                  throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n              }\n              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n          };\n          // Move the previous function into the overload table.\n          proto[methodName].overloadTable = [];\n          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n          if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {\n              throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n          }\n  \n          // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\n          // that routes between the two.\n          ensureOverloadTable(Module, name, name);\n          if (Module.hasOwnProperty(numArguments)) {\n              throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n          }\n          // Add the new function into the overload table.\n          Module[name].overloadTable[numArguments] = value;\n      }\n      else {\n          Module[name] = value;\n          if (undefined !== numArguments) {\n              Module[name].numArguments = numArguments;\n          }\n      }\n    }\n  \n  function heap32VectorToArray(count, firstElement) {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n          array.push(HEAP32[(firstElement >> 2) + i]);\n      }\n      return array;\n    }\n  \n  function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n          throwInternalError('Replacing nonexistant public symbol');\n      }\n      // If there's an overload table for this symbol, replace the symbol in the overload table instead.\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n          Module[name].overloadTable[numArguments] = value;\n      }\n      else {\n          Module[name] = value;\n          Module[name].argCount = numArguments;\n      }\n    }\n  \n  function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n  \n      function makeDynCaller(dynCall) {\n          var args = [];\n          for (var i = 1; i < signature.length; ++i) {\n              args.push('a' + i);\n          }\n  \n          var name = 'dynCall_' + signature + '_' + rawFunction;\n          var body = 'return function ' + name + '(' + args.join(', ') + ') {\\n';\n          body    += '    return dynCall(rawFunction' + (args.length ? ', ' : '') + args.join(', ') + ');\\n';\n          body    += '};\\n';\n  \n          return (new Function('dynCall', 'rawFunction', body))(dynCall, rawFunction);\n      }\n  \n      var fp;\n      if (Module['FUNCTION_TABLE_' + signature] !== undefined) {\n          fp = Module['FUNCTION_TABLE_' + signature][rawFunction];\n      } else if (typeof FUNCTION_TABLE !== \"undefined\") {\n          fp = FUNCTION_TABLE[rawFunction];\n      } else {\n          // asm.js does not give direct access to the function tables,\n          // and thus we must go through the dynCall interface which allows\n          // calling into a signature's function table by pointer value.\n          //\n          // https://github.com/dherman/asm.js/issues/83\n          //\n          // This has three main penalties:\n          // - dynCall is another function call in the path from JavaScript to C++.\n          // - JITs may not predict through the function table indirection at runtime.\n          var dc = Module[\"asm\"]['dynCall_' + signature];\n          if (dc === undefined) {\n              // We will always enter this branch if the signature\n              // contains 'f' and PRECISE_F32 is not enabled.\n              //\n              // Try again, replacing 'f' with 'd'.\n              dc = Module[\"asm\"]['dynCall_' + signature.replace(/f/g, 'd')];\n              if (dc === undefined) {\n                  throwBindingError(\"No dynCall invoker for signature: \" + signature);\n              }\n          }\n          fp = makeDynCaller(dc);\n      }\n  \n      if (typeof fp !== \"function\") {\n          throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n      }\n      return fp;\n    }\n  \n  \n  var UnboundTypeError=undefined;\n  \n  function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    }function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n          if (seen[type]) {\n              return;\n          }\n          if (registeredTypes[type]) {\n              return;\n          }\n          if (typeDependencies[type]) {\n              typeDependencies[type].forEach(visit);\n              return;\n          }\n          unboundTypes.push(type);\n          seen[type] = true;\n      }\n      types.forEach(visit);\n  \n      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));\n    }function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n  \n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n  \n      exposePublicSymbol(name, function() {\n          throwUnboundTypeError('Cannot call ' + name + ' due to unbound types', argTypes);\n      }, argCount - 1);\n  \n      whenDependentTypesAreResolved([], argTypes, function(argTypes) {\n          var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);\n          replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn), argCount - 1);\n          return [];\n      });\n    }\n\n  \n  function integerReadValueFromPointer(name, shift, signed) {\n      // integers are quite common, so generate very specialized functions\n      switch (shift) {\n          case 0: return signed ?\n              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :\n              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };\n          case 1: return signed ?\n              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :\n              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };\n          case 2: return signed ?\n              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :\n              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };\n          default:\n              throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      name = readLatin1String(name);\n      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.\n          maxRange = 4294967295;\n      }\n  \n      var shift = getShiftFromSize(size);\n  \n      var fromWireType = function(value) {\n          return value;\n      };\n  \n      if (minRange === 0) {\n          var bitshift = 32 - 8*size;\n          fromWireType = function(value) {\n              return (value << bitshift) >>> bitshift;\n          };\n      }\n  \n      var isUnsignedType = (name.indexOf('unsigned') != -1);\n  \n      registerType(primitiveType, {\n          name: name,\n          'fromWireType': fromWireType,\n          'toWireType': function(destructors, value) {\n              // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations: we could\n              // avoid the following two if()s and assume value is of proper type.\n              if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n                  throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n              }\n              if (value < minRange || value > maxRange) {\n                  throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + ', ' + maxRange + ']!');\n              }\n              return isUnsignedType ? (value >>> 0) : (value | 0);\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),\n          destructorFunction: null, // This type does not need a destructor\n      });\n    }\n\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [\n          Int8Array,\n          Uint8Array,\n          Int16Array,\n          Uint16Array,\n          Int32Array,\n          Uint32Array,\n          Float32Array,\n          Float64Array,\n      ];\n  \n      var TA = typeMapping[dataTypeIndex];\n  \n      function decodeMemoryView(handle) {\n          handle = handle >> 2;\n          var heap = HEAPU32;\n          var size = heap[handle]; // in elements\n          var data = heap[handle + 1]; // byte offset into emscripten heap\n          return new TA(heap['buffer'], data, size);\n      }\n  \n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': decodeMemoryView,\n          'argPackAdvance': 8,\n          'readValueFromPointer': decodeMemoryView,\n      }, {\n          ignoreDuplicateRegistrations: true,\n      });\n    }\n\n  function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(value) {\n              var length = HEAPU32[value >> 2];\n              var a = new Array(length);\n              for (var i = 0; i < length; ++i) {\n                  a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n              }\n              _free(value);\n              return a.join('');\n          },\n          'toWireType': function(destructors, value) {\n              if (value instanceof ArrayBuffer) {\n                  value = new Uint8Array(value);\n              }\n  \n              function getTAElement(ta, index) {\n                  return ta[index];\n              }\n              function getStringElement(string, index) {\n                  return string.charCodeAt(index);\n              }\n              var getElement;\n              if (value instanceof Uint8Array) {\n                  getElement = getTAElement;\n              } else if (value instanceof Uint8ClampedArray) {\n                  getElement = getTAElement;\n              } else if (value instanceof Int8Array) {\n                  getElement = getTAElement;\n              } else if (typeof value === 'string') {\n                  getElement = getStringElement;\n              } else {\n                  throwBindingError('Cannot pass non-string to std::string');\n              }\n  \n              // assumes 4-byte alignment\n              var length = value.length;\n              var ptr = _malloc(4 + length);\n              HEAPU32[ptr >> 2] = length;\n              for (var i = 0; i < length; ++i) {\n                  var charCode = getElement(value, i);\n                  if (charCode > 255) {\n                      _free(ptr);\n                      throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\n                  }\n                  HEAPU8[ptr + 4 + i] = charCode;\n              }\n              if (destructors !== null) {\n                  destructors.push(_free, ptr);\n              }\n              return ptr;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': simpleReadValueFromPointer,\n          destructorFunction: function(ptr) { _free(ptr); },\n      });\n    }\n\n  function __embind_register_std_wstring(rawType, charSize, name) {\n      // nb. do not cache HEAPU16 and HEAPU32, they may be destroyed by enlargeMemory().\n      name = readLatin1String(name);\n      var getHeap, shift;\n      if (charSize === 2) {\n          getHeap = function() { return HEAPU16; };\n          shift = 1;\n      } else if (charSize === 4) {\n          getHeap = function() { return HEAPU32; };\n          shift = 2;\n      }\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(value) {\n              var HEAP = getHeap();\n              var length = HEAPU32[value >> 2];\n              var a = new Array(length);\n              var start = (value + 4) >> shift;\n              for (var i = 0; i < length; ++i) {\n                  a[i] = String.fromCharCode(HEAP[start + i]);\n              }\n              _free(value);\n              return a.join('');\n          },\n          'toWireType': function(destructors, value) {\n              // assumes 4-byte alignment\n              var HEAP = getHeap();\n              var length = value.length;\n              var ptr = _malloc(4 + length * charSize);\n              HEAPU32[ptr >> 2] = length;\n              var start = (ptr + 4) >> shift;\n              for (var i = 0; i < length; ++i) {\n                  HEAP[start + i] = value.charCodeAt(i);\n              }\n              if (destructors !== null) {\n                  destructors.push(_free, ptr);\n              }\n              return ptr;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': simpleReadValueFromPointer,\n          destructorFunction: function(ptr) { _free(ptr); },\n      });\n    }\n\n  function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n          isVoid: true, // void return values can be optimized out sometimes\n          name: name,\n          'argPackAdvance': 0,\n          'fromWireType': function() {\n              return undefined;\n          },\n          'toWireType': function(destructors, o) {\n              // TODO: assert if anything else is given?\n              return undefined;\n          },\n      });\n    }\n\n  function _abort() {\n      Module['abort']();\n    }\n\n   \n\n   \n\n  var _emscripten_asm_const_int=true;\n\n  \n  function __exit(status) {\n      // void _exit(int status);\n      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html\n      Module['exit'](status);\n    }function _exit(status) {\n      __exit(status);\n    }\n\n\n\n   \n\n  var _llvm_ceil_f32=Math_ceil;\n\n  var _llvm_ctlz_i32=true;\n\n  var _llvm_fabs_f64=Math_abs;\n\n  \n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n      return dest;\n    } \n\n   \n\n   \n\n  \n  var PTHREAD_SPECIFIC={};function _pthread_getspecific(key) {\n      return PTHREAD_SPECIFIC[key] || 0;\n    }\n\n  \n  var PTHREAD_SPECIFIC_NEXT_KEY=1;function _pthread_key_create(key, destructor) {\n      if (key == 0) {\n        return ERRNO_CODES.EINVAL;\n      }\n      HEAP32[((key)>>2)]=PTHREAD_SPECIFIC_NEXT_KEY;\n      // values start at 0\n      PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;\n      PTHREAD_SPECIFIC_NEXT_KEY++;\n      return 0;\n    }\n\n  function _pthread_once(ptr, func) {\n      if (!_pthread_once.seen) _pthread_once.seen = {};\n      if (ptr in _pthread_once.seen) return;\n      Module['dynCall_v'](func);\n      _pthread_once.seen[ptr] = 1;\n    }\n\n  function _pthread_setspecific(key, value) {\n      if (!(key in PTHREAD_SPECIFIC)) {\n        return ERRNO_CODES.EINVAL;\n      }\n      PTHREAD_SPECIFIC[key] = value;\n      return 0;\n    }\n\n   \nFS.staticInit();__ATINIT__.unshift(function() { if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init() });__ATMAIN__.push(function() { FS.ignorePermissions = false });__ATEXIT__.push(function() { FS.quit() });;\n__ATINIT__.unshift(function() { TTY.init() });__ATEXIT__.push(function() { TTY.shutdown() });;\n// if (ENVIRONMENT_IS_NODE) { var fs = require(\"fs\"); var NODEJS_PATH = require(\"path\"); NODEFS.staticInit(); };\nembind_init_charCodes();\nBindingError = Module['BindingError'] = extendError(Error, 'BindingError');;\nInternalError = Module['InternalError'] = extendError(Error, 'InternalError');;\ninit_emval();;\nUnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;\nDYNAMICTOP_PTR = staticAlloc(4);\n\nSTACK_BASE = STACKTOP = alignMemory(STATICTOP);\n\nSTACK_MAX = STACK_BASE + TOTAL_STACK;\n\nDYNAMIC_BASE = alignMemory(STACK_MAX);\n\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\n\nstaticSealed = true; // seal the static portion of memory\n\nassert(DYNAMIC_BASE < TOTAL_MEMORY, \"TOTAL_MEMORY not big enough for stack\");\n\nvar ASSERTIONS = true;\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\n\n\n// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149\n\n// This code was written by Tyler Akins and has been placed in the\n// public domain.  It would be nice if you left this header intact.\n// Base64 code from Tyler Akins -- http://rumkin.com\n\n/**\n * Decodes a base64 string.\n * @param {String} input The string to decode.\n */\nvar decodeBase64 = typeof atob === 'function' ? atob : function (input) {\n  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  var output = '';\n  var chr1, chr2, chr3;\n  var enc1, enc2, enc3, enc4;\n  var i = 0;\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n  do {\n    enc1 = keyStr.indexOf(input.charAt(i++));\n    enc2 = keyStr.indexOf(input.charAt(i++));\n    enc3 = keyStr.indexOf(input.charAt(i++));\n    enc4 = keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 !== 64) {\n      output = output + String.fromCharCode(chr2);\n    }\n    if (enc4 !== 64) {\n      output = output + String.fromCharCode(chr3);\n    }\n  } while (i < input.length);\n  return output;\n};\n\n// Converts a string of base64 into a byte array.\n// Throws error on invalid input.\nfunction intArrayFromBase64(s) {\n  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {\n    var buf;\n    try {\n      buf = Buffer.from(s, 'base64');\n    } catch (_) {\n      buf = new Buffer(s, 'base64');\n    }\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n\n  try {\n    var decoded = decodeBase64(s);\n    var bytes = new Uint8Array(decoded.length);\n    for (var i = 0 ; i < decoded.length ; ++i) {\n      bytes[i] = decoded.charCodeAt(i);\n    }\n    return bytes;\n  } catch (_) {\n    throw new Error('Converting base64 string to bytes failed.');\n  }\n}\n\n// If filename is a base64 data URI, parses and returns data (Buffer on node,\n// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\nfunction tryParseAsDataURI(filename) {\n  if (!isDataURI(filename)) {\n    return;\n  }\n\n  return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n}\n\n\n\nfunction nullFunc_di(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'di'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_dii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'dii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_i(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'i'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_ii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_iii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_iiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_iiiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_v(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_vi(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_vid(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'vid'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_vii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_viid(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viid'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_viii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_viiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_viiiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_viiiiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction invoke_di(index,a1) {\n  try {\n    return Module[\"dynCall_di\"](index,a1);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_dii(index,a1,a2) {\n  try {\n    return Module[\"dynCall_dii\"](index,a1,a2);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_i(index) {\n  try {\n    return Module[\"dynCall_i\"](index);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_ii(index,a1) {\n  try {\n    return Module[\"dynCall_ii\"](index,a1);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iii(index,a1,a2) {\n  try {\n    return Module[\"dynCall_iii\"](index,a1,a2);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iiii(index,a1,a2,a3) {\n  try {\n    return Module[\"dynCall_iiii\"](index,a1,a2,a3);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iiiii(index,a1,a2,a3,a4) {\n  try {\n    return Module[\"dynCall_iiiii\"](index,a1,a2,a3,a4);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_v(index) {\n  try {\n    Module[\"dynCall_v\"](index);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_vi(index,a1) {\n  try {\n    Module[\"dynCall_vi\"](index,a1);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_vid(index,a1,a2) {\n  try {\n    Module[\"dynCall_vid\"](index,a1,a2);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_vii(index,a1,a2) {\n  try {\n    Module[\"dynCall_vii\"](index,a1,a2);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viid(index,a1,a2,a3) {\n  try {\n    Module[\"dynCall_viid\"](index,a1,a2,a3);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viii(index,a1,a2,a3) {\n  try {\n    Module[\"dynCall_viii\"](index,a1,a2,a3);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viiii(index,a1,a2,a3,a4) {\n  try {\n    Module[\"dynCall_viiii\"](index,a1,a2,a3,a4);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viiiii(index,a1,a2,a3,a4,a5) {\n  try {\n    Module[\"dynCall_viiiii\"](index,a1,a2,a3,a4,a5);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viiiiii(index,a1,a2,a3,a4,a5,a6) {\n  try {\n    Module[\"dynCall_viiiiii\"](index,a1,a2,a3,a4,a5,a6);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    Module[\"setThrew\"](1, 0);\n  }\n}\n\nModule.asmGlobalArg = { \"Math\": Math, \"Int8Array\": Int8Array, \"Int16Array\": Int16Array, \"Int32Array\": Int32Array, \"Uint8Array\": Uint8Array, \"Uint16Array\": Uint16Array, \"Uint32Array\": Uint32Array, \"Float32Array\": Float32Array, \"Float64Array\": Float64Array, \"NaN\": NaN, \"Infinity\": Infinity, \"byteLength\": byteLength };\n\nModule.asmLibraryArg = { \"abort\": abort, \"assert\": assert, \"enlargeMemory\": enlargeMemory, \"getTotalMemory\": getTotalMemory, \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory, \"abortStackOverflow\": abortStackOverflow, \"nullFunc_di\": nullFunc_di, \"nullFunc_dii\": nullFunc_dii, \"nullFunc_i\": nullFunc_i, \"nullFunc_ii\": nullFunc_ii, \"nullFunc_iii\": nullFunc_iii, \"nullFunc_iiii\": nullFunc_iiii, \"nullFunc_iiiii\": nullFunc_iiiii, \"nullFunc_v\": nullFunc_v, \"nullFunc_vi\": nullFunc_vi, \"nullFunc_vid\": nullFunc_vid, \"nullFunc_vii\": nullFunc_vii, \"nullFunc_viid\": nullFunc_viid, \"nullFunc_viii\": nullFunc_viii, \"nullFunc_viiii\": nullFunc_viiii, \"nullFunc_viiiii\": nullFunc_viiiii, \"nullFunc_viiiiii\": nullFunc_viiiiii, \"invoke_di\": invoke_di, \"invoke_dii\": invoke_dii, \"invoke_i\": invoke_i, \"invoke_ii\": invoke_ii, \"invoke_iii\": invoke_iii, \"invoke_iiii\": invoke_iiii, \"invoke_iiiii\": invoke_iiiii, \"invoke_v\": invoke_v, \"invoke_vi\": invoke_vi, \"invoke_vid\": invoke_vid, \"invoke_vii\": invoke_vii, \"invoke_viid\": invoke_viid, \"invoke_viii\": invoke_viii, \"invoke_viiii\": invoke_viiii, \"invoke_viiiii\": invoke_viiiii, \"invoke_viiiiii\": invoke_viiiiii, \"__ZSt18uncaught_exceptionv\": __ZSt18uncaught_exceptionv, \"___buildEnvironment\": ___buildEnvironment, \"___cxa_allocate_exception\": ___cxa_allocate_exception, \"___cxa_begin_catch\": ___cxa_begin_catch, \"___cxa_find_matching_catch\": ___cxa_find_matching_catch, \"___cxa_throw\": ___cxa_throw, \"___gxx_personality_v0\": ___gxx_personality_v0, \"___lock\": ___lock, \"___resumeException\": ___resumeException, \"___setErrNo\": ___setErrNo, \"___syscall140\": ___syscall140, \"___syscall145\": ___syscall145, \"___syscall146\": ___syscall146, \"___syscall221\": ___syscall221, \"___syscall5\": ___syscall5, \"___syscall54\": ___syscall54, \"___syscall6\": ___syscall6, \"___unlock\": ___unlock, \"__embind_register_bool\": __embind_register_bool, \"__embind_register_constant\": __embind_register_constant, \"__embind_register_emval\": __embind_register_emval, \"__embind_register_float\": __embind_register_float, \"__embind_register_function\": __embind_register_function, \"__embind_register_integer\": __embind_register_integer, \"__embind_register_memory_view\": __embind_register_memory_view, \"__embind_register_std_string\": __embind_register_std_string, \"__embind_register_std_wstring\": __embind_register_std_wstring, \"__embind_register_void\": __embind_register_void, \"__emval_decref\": __emval_decref, \"__emval_register\": __emval_register, \"__exit\": __exit, \"_abort\": _abort, \"_embind_repr\": _embind_repr, \"_emscripten_asm_const_iiiid\": _emscripten_asm_const_iiiid, \"_emscripten_asm_const_iiiiiii\": _emscripten_asm_const_iiiiiii, \"_emscripten_asm_const_iiiiiiiidddddddddddddddddddddddddi\": _emscripten_asm_const_iiiiiiiidddddddddddddddddddddddddi, \"_emscripten_memcpy_big\": _emscripten_memcpy_big, \"_exit\": _exit, \"_llvm_ceil_f32\": _llvm_ceil_f32, \"_llvm_fabs_f64\": _llvm_fabs_f64, \"_pthread_getspecific\": _pthread_getspecific, \"_pthread_key_create\": _pthread_key_create, \"_pthread_once\": _pthread_once, \"_pthread_setspecific\": _pthread_setspecific, \"count_emval_handles\": count_emval_handles, \"craftInvokerFunction\": craftInvokerFunction, \"createNamedFunction\": createNamedFunction, \"embind__requireFunction\": embind__requireFunction, \"embind_init_charCodes\": embind_init_charCodes, \"ensureOverloadTable\": ensureOverloadTable, \"exposePublicSymbol\": exposePublicSymbol, \"extendError\": extendError, \"floatReadValueFromPointer\": floatReadValueFromPointer, \"getShiftFromSize\": getShiftFromSize, \"getTypeName\": getTypeName, \"get_first_emval\": get_first_emval, \"heap32VectorToArray\": heap32VectorToArray, \"init_emval\": init_emval, \"integerReadValueFromPointer\": integerReadValueFromPointer, \"makeLegalFunctionName\": makeLegalFunctionName, \"new_\": new_, \"readLatin1String\": readLatin1String, \"registerType\": registerType, \"replacePublicSymbol\": replacePublicSymbol, \"runDestructors\": runDestructors, \"simpleReadValueFromPointer\": simpleReadValueFromPointer, \"throwBindingError\": throwBindingError, \"throwInternalError\": throwInternalError, \"throwUnboundTypeError\": throwUnboundTypeError, \"whenDependentTypesAreResolved\": whenDependentTypesAreResolved, \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR, \"tempDoublePtr\": tempDoublePtr, \"ABORT\": ABORT, \"STACKTOP\": STACKTOP, \"STACK_MAX\": STACK_MAX };\n// EMSCRIPTEN_START_ASM\nvar asm = (/** @suppress {uselessCode} */ function(global, env, buffer) {\n'almost asm';\n\n\n  var Int8View = global.Int8Array;\n  var HEAP8 = new Int8View(buffer);\n  var Int16View = global.Int16Array;\n  var HEAP16 = new Int16View(buffer);\n  var Int32View = global.Int32Array;\n  var HEAP32 = new Int32View(buffer);\n  var Uint8View = global.Uint8Array;\n  var HEAPU8 = new Uint8View(buffer);\n  var Uint16View = global.Uint16Array;\n  var HEAPU16 = new Uint16View(buffer);\n  var Uint32View = global.Uint32Array;\n  var HEAPU32 = new Uint32View(buffer);\n  var Float32View = global.Float32Array;\n  var HEAPF32 = new Float32View(buffer);\n  var Float64View = global.Float64Array;\n  var HEAPF64 = new Float64View(buffer);\n  var byteLength = global.byteLength;\n\n  var DYNAMICTOP_PTR=env.DYNAMICTOP_PTR|0;\n  var tempDoublePtr=env.tempDoublePtr|0;\n  var ABORT=env.ABORT|0;\n  var STACKTOP=env.STACKTOP|0;\n  var STACK_MAX=env.STACK_MAX|0;\n\n  var __THREW__ = 0;\n  var threwValue = 0;\n  var setjmpId = 0;\n  var undef = 0;\n  var nan = global.NaN, inf = global.Infinity;\n  var tempInt = 0, tempBigInt = 0, tempBigIntS = 0, tempValue = 0, tempDouble = 0.0;\n  var tempRet0 = 0;\n\n  var Math_floor=global.Math.floor;\n  var Math_abs=global.Math.abs;\n  var Math_sqrt=global.Math.sqrt;\n  var Math_pow=global.Math.pow;\n  var Math_cos=global.Math.cos;\n  var Math_sin=global.Math.sin;\n  var Math_tan=global.Math.tan;\n  var Math_acos=global.Math.acos;\n  var Math_asin=global.Math.asin;\n  var Math_atan=global.Math.atan;\n  var Math_atan2=global.Math.atan2;\n  var Math_exp=global.Math.exp;\n  var Math_log=global.Math.log;\n  var Math_ceil=global.Math.ceil;\n  var Math_imul=global.Math.imul;\n  var Math_min=global.Math.min;\n  var Math_max=global.Math.max;\n  var Math_clz32=global.Math.clz32;\n  var abort=env.abort;\n  var assert=env.assert;\n  var enlargeMemory=env.enlargeMemory;\n  var getTotalMemory=env.getTotalMemory;\n  var abortOnCannotGrowMemory=env.abortOnCannotGrowMemory;\n  var abortStackOverflow=env.abortStackOverflow;\n  var nullFunc_di=env.nullFunc_di;\n  var nullFunc_dii=env.nullFunc_dii;\n  var nullFunc_i=env.nullFunc_i;\n  var nullFunc_ii=env.nullFunc_ii;\n  var nullFunc_iii=env.nullFunc_iii;\n  var nullFunc_iiii=env.nullFunc_iiii;\n  var nullFunc_iiiii=env.nullFunc_iiiii;\n  var nullFunc_v=env.nullFunc_v;\n  var nullFunc_vi=env.nullFunc_vi;\n  var nullFunc_vid=env.nullFunc_vid;\n  var nullFunc_vii=env.nullFunc_vii;\n  var nullFunc_viid=env.nullFunc_viid;\n  var nullFunc_viii=env.nullFunc_viii;\n  var nullFunc_viiii=env.nullFunc_viiii;\n  var nullFunc_viiiii=env.nullFunc_viiiii;\n  var nullFunc_viiiiii=env.nullFunc_viiiiii;\n  var invoke_di=env.invoke_di;\n  var invoke_dii=env.invoke_dii;\n  var invoke_i=env.invoke_i;\n  var invoke_ii=env.invoke_ii;\n  var invoke_iii=env.invoke_iii;\n  var invoke_iiii=env.invoke_iiii;\n  var invoke_iiiii=env.invoke_iiiii;\n  var invoke_v=env.invoke_v;\n  var invoke_vi=env.invoke_vi;\n  var invoke_vid=env.invoke_vid;\n  var invoke_vii=env.invoke_vii;\n  var invoke_viid=env.invoke_viid;\n  var invoke_viii=env.invoke_viii;\n  var invoke_viiii=env.invoke_viiii;\n  var invoke_viiiii=env.invoke_viiiii;\n  var invoke_viiiiii=env.invoke_viiiiii;\n  var __ZSt18uncaught_exceptionv=env.__ZSt18uncaught_exceptionv;\n  var ___buildEnvironment=env.___buildEnvironment;\n  var ___cxa_allocate_exception=env.___cxa_allocate_exception;\n  var ___cxa_begin_catch=env.___cxa_begin_catch;\n  var ___cxa_find_matching_catch=env.___cxa_find_matching_catch;\n  var ___cxa_throw=env.___cxa_throw;\n  var ___gxx_personality_v0=env.___gxx_personality_v0;\n  var ___lock=env.___lock;\n  var ___resumeException=env.___resumeException;\n  var ___setErrNo=env.___setErrNo;\n  var ___syscall140=env.___syscall140;\n  var ___syscall145=env.___syscall145;\n  var ___syscall146=env.___syscall146;\n  var ___syscall221=env.___syscall221;\n  var ___syscall5=env.___syscall5;\n  var ___syscall54=env.___syscall54;\n  var ___syscall6=env.___syscall6;\n  var ___unlock=env.___unlock;\n  var __embind_register_bool=env.__embind_register_bool;\n  var __embind_register_constant=env.__embind_register_constant;\n  var __embind_register_emval=env.__embind_register_emval;\n  var __embind_register_float=env.__embind_register_float;\n  var __embind_register_function=env.__embind_register_function;\n  var __embind_register_integer=env.__embind_register_integer;\n  var __embind_register_memory_view=env.__embind_register_memory_view;\n  var __embind_register_std_string=env.__embind_register_std_string;\n  var __embind_register_std_wstring=env.__embind_register_std_wstring;\n  var __embind_register_void=env.__embind_register_void;\n  var __emval_decref=env.__emval_decref;\n  var __emval_register=env.__emval_register;\n  var __exit=env.__exit;\n  var _abort=env._abort;\n  var _embind_repr=env._embind_repr;\n  var _emscripten_asm_const_iiiid=env._emscripten_asm_const_iiiid;\n  var _emscripten_asm_const_iiiiiii=env._emscripten_asm_const_iiiiiii;\n  var _emscripten_asm_const_iiiiiiiidddddddddddddddddddddddddi=env._emscripten_asm_const_iiiiiiiidddddddddddddddddddddddddi;\n  var _emscripten_memcpy_big=env._emscripten_memcpy_big;\n  var _exit=env._exit;\n  var _llvm_ceil_f32=env._llvm_ceil_f32;\n  var _llvm_fabs_f64=env._llvm_fabs_f64;\n  var _pthread_getspecific=env._pthread_getspecific;\n  var _pthread_key_create=env._pthread_key_create;\n  var _pthread_once=env._pthread_once;\n  var _pthread_setspecific=env._pthread_setspecific;\n  var count_emval_handles=env.count_emval_handles;\n  var craftInvokerFunction=env.craftInvokerFunction;\n  var createNamedFunction=env.createNamedFunction;\n  var embind__requireFunction=env.embind__requireFunction;\n  var embind_init_charCodes=env.embind_init_charCodes;\n  var ensureOverloadTable=env.ensureOverloadTable;\n  var exposePublicSymbol=env.exposePublicSymbol;\n  var extendError=env.extendError;\n  var floatReadValueFromPointer=env.floatReadValueFromPointer;\n  var getShiftFromSize=env.getShiftFromSize;\n  var getTypeName=env.getTypeName;\n  var get_first_emval=env.get_first_emval;\n  var heap32VectorToArray=env.heap32VectorToArray;\n  var init_emval=env.init_emval;\n  var integerReadValueFromPointer=env.integerReadValueFromPointer;\n  var makeLegalFunctionName=env.makeLegalFunctionName;\n  var new_=env.new_;\n  var readLatin1String=env.readLatin1String;\n  var registerType=env.registerType;\n  var replacePublicSymbol=env.replacePublicSymbol;\n  var runDestructors=env.runDestructors;\n  var simpleReadValueFromPointer=env.simpleReadValueFromPointer;\n  var throwBindingError=env.throwBindingError;\n  var throwInternalError=env.throwInternalError;\n  var throwUnboundTypeError=env.throwUnboundTypeError;\n  var whenDependentTypesAreResolved=env.whenDependentTypesAreResolved;\n  var tempFloat = 0.0;\n\nfunction _emscripten_replace_memory(newBuffer) {\n  if ((byteLength(newBuffer) & 0xffffff || byteLength(newBuffer) <= 0xffffff) || byteLength(newBuffer) > 0x80000000) return false;\n  HEAP8 = new Int8View(newBuffer);\n  HEAP16 = new Int16View(newBuffer);\n  HEAP32 = new Int32View(newBuffer);\n  HEAPU8 = new Uint8View(newBuffer);\n  HEAPU16 = new Uint16View(newBuffer);\n  HEAPU32 = new Uint32View(newBuffer);\n  HEAPF32 = new Float32View(newBuffer);\n  HEAPF64 = new Float64View(newBuffer);\n  buffer = newBuffer;\n  return true;\n}\n\n// EMSCRIPTEN_START_FUNCS\n\nfunction _arPattGetImage2($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n $7 = $7 | 0;\n $8 = $8 | 0;\n $9 = $9 | 0;\n $10 = +$10;\n $11 = $11 | 0;\n var $$0 = 0, $$01442 = 0, $$01443 = 0, $$01464 = 0, $$01468 = 0, $$01474 = 0, $$01495 = 0, $$1 = 0, $$10 = 0, $$101453 = 0, $$101484 = 0, $$101505 = 0, $$11 = 0, $$111454 = 0, $$111485 = 0, $$111506 = 0, $$11444 = 0, $$11465 = 0, $$11469 = 0, $$11475 = 0, $$11496 = 0, $$12 = 0, $$121455 = 0, $$121486 = 0, $$121507 = 0, $$13 = 0, $$131456 = 0, $$131487 = 0, $$131508 = 0, $$14 = 0, $$141457 = 0, $$141488 = 0, $$141509 = 0, $$15 = 0, $$151458 = 0, $$151489 = 0, $$151510 = 0, $$16 = 0, $$161459 = 0, $$161490 = 0, $$161511 = 0, $$17 = 0, $$171460 = 0, $$171491 = 0, $$171512 = 0, $$18 = 0, $$181461 = 0, $$181492 = 0, $$181513 = 0, $$19 = 0, $$191462 = 0, $$191493 = 0, $$191514 = 0, $$2 = 0, $$20 = 0, $$201463 = 0, $$201494 = 0, $$201515 = 0, $$21 = 0, $$21445 = 0, $$21466 = 0, $$21470 = 0, $$21476 = 0, $$21497 = 0, $$22 = 0, $$23 = 0, $$3 = 0, $$31446 = 0, $$31471 = 0, $$31477 = 0, $$31498 = 0, $$4 = 0, $$41447 = 0, $$41478 = 0, $$41499 = 0, $$5 = 0, $$51448 = 0, $$51479 = 0, $$51500 = 0, $$6 = 0, $$61449 = 0, $$61480 = 0, $$61501 = 0, $$7 = 0, $$71450 = 0, $$71481 = 0, $$71502 = 0, $$8 = 0, $$81451 = 0, $$81482 = 0, $$81503 = 0, $$9 = 0, $$91452 = 0, $$91483 = 0, $$91504 = 0, $101 = 0, $1016 = 0, $102 = 0, $1026 = 0, $1032 = 0.0, $1038 = 0.0, $1039 = 0.0, $1043 = 0, $1049 = 0, $105 = 0.0, $1053 = 0, $1055 = 0, $106 = 0.0, $1061 = 0, $1062 = 0, $1066 = 0, $1070 = 0, $1074 = 0, $1077 = 0, $108 = 0, $1082 = 0.0, $1083 = 0.0, $1084 = 0.0, $1085 = 0, $1086 = 0, $1087 = 0, $1088 = 0, $1089 = 0, $109 = 0, $1090 = 0, $1091 = 0, $1092 = 0, $1093 = 0, $1099 = 0.0, $110 = 0, $1105 = 0.0, $1112 = 0.0, $112 = 0.0, $1122 = 0.0, $113 = 0.0, $1131 = 0.0, $1132 = 0.0, $114 = 0.0, $115 = 0, $1153 = 0, $1156 = 0, $116 = 0, $1164 = 0, $1165 = 0, $1169 = 0, $117 = 0, $1178 = 0, $118 = 0, $1185 = 0, $119 = 0, $1190 = 0.0, $1191 = 0.0, $1192 = 0.0, $1193 = 0, $1194 = 0, $1195 = 0, $1196 = 0, $1197 = 0, $1198 = 0, $1199 = 0, $12 = 0, $120 = 0, $1200 = 0, $1201 = 0, $1207 = 0.0, $121 = 0, $1213 = 0.0, $122 = 0, $1220 = 0.0, $123 = 0, $1230 = 0.0, $1239 = 0.0, $1240 = 0.0, $1261 = 0, $1264 = 0, $1272 = 0, $1273 = 0, $1277 = 0, $1286 = 0, $129 = 0.0, $1293 = 0, $1298 = 0.0, $1299 = 0.0, $13 = 0, $1300 = 0.0, $1301 = 0, $1302 = 0, $1303 = 0, $1304 = 0, $1305 = 0, $1306 = 0, $1307 = 0, $1308 = 0, $1309 = 0, $1315 = 0.0, $1321 = 0.0, $1328 = 0.0, $1338 = 0.0, $1347 = 0.0, $1348 = 0.0, $135 = 0.0, $1369 = 0, $1380 = 0, $1381 = 0, $1385 = 0, $1390 = 0, $1397 = 0, $14 = 0, $1402 = 0, $1409 = 0, $1412 = 0.0, $1413 = 0.0, $1414 = 0.0, $1415 = 0, $1416 = 0, $1417 = 0, $1418 = 0, $1419 = 0, $142 = 0.0, $1420 = 0, $1421 = 0, $1422 = 0, $1423 = 0, $1429 = 0.0, $1435 = 0.0, $1442 = 0.0, $1452 = 0.0, $1461 = 0.0, $1462 = 0.0, $1483 = 0, $15 = 0, $1502 = 0, $1509 = 0.0, $1510 = 0.0, $1511 = 0.0, $1512 = 0, $1513 = 0, $1514 = 0, $1515 = 0, $1516 = 0, $1517 = 0, $1518 = 0, $1519 = 0, $152 = 0.0, $1520 = 0, $1526 = 0.0, $1532 = 0.0, $1539 = 0.0, $1549 = 0.0, $1558 = 0.0, $1559 = 0.0, $1580 = 0, $1599 = 0, $16 = 0, $1606 = 0.0, $1607 = 0.0, $1608 = 0.0, $1609 = 0, $161 = 0.0, $1610 = 0, $1611 = 0, $1612 = 0, $1613 = 0, $1614 = 0, $1615 = 0, $1616 = 0, $1617 = 0, $162 = 0.0, $1623 = 0.0, $1629 = 0.0, $1636 = 0.0, $1646 = 0.0, $1655 = 0.0, $1656 = 0.0, $1677 = 0, $1697 = 0, $1702 = 0.0, $1703 = 0.0, $1704 = 0.0, $1705 = 0, $1706 = 0, $1707 = 0, $1708 = 0, $1709 = 0, $1710 = 0, $1711 = 0, $1712 = 0, $1713 = 0, $1719 = 0.0, $1725 = 0.0, $1732 = 0.0, $1742 = 0.0, $1751 = 0.0, $1752 = 0.0, $1773 = 0, $1780 = 0, $1785 = 0.0, $1786 = 0.0, $1787 = 0.0, $1788 = 0, $1789 = 0, $1790 = 0, $1791 = 0, $1792 = 0, $1793 = 0, $1794 = 0, $1795 = 0, $1796 = 0, $1802 = 0.0, $1808 = 0.0, $1815 = 0.0, $1825 = 0.0, $183 = 0, $1834 = 0.0, $1835 = 0.0, $1858 = 0, $1865 = 0, $1870 = 0.0, $1871 = 0.0, $1872 = 0.0, $1873 = 0, $1874 = 0, $1875 = 0, $1876 = 0, $1877 = 0, $1878 = 0, $1879 = 0, $1880 = 0, $1881 = 0, $1887 = 0.0, $1893 = 0.0, $1900 = 0.0, $1910 = 0.0, $1919 = 0.0, $192 = 0, $1920 = 0.0, $193 = 0, $1942 = 0, $1949 = 0, $1954 = 0.0, $1955 = 0.0, $1956 = 0.0, $1957 = 0, $1958 = 0, $1959 = 0, $1960 = 0, $1961 = 0, $1962 = 0, $1963 = 0, $1964 = 0, $1965 = 0, $1971 = 0.0, $1977 = 0.0, $1984 = 0.0, $1994 = 0.0, $2003 = 0.0, $2004 = 0.0, $201 = 0, $2025 = 0, $2028 = 0, $2036 = 0, $2051 = 0, $2056 = 0.0, $2057 = 0.0, $2058 = 0.0, $2059 = 0, $2060 = 0, $2061 = 0, $2062 = 0, $2063 = 0, $2064 = 0, $2065 = 0, $2066 = 0, $2067 = 0, $2073 = 0.0, $2079 = 0.0, $208 = 0, $2086 = 0.0, $2096 = 0.0, $2105 = 0.0, $2106 = 0.0, $2127 = 0, $213 = 0.0, $2130 = 0, $2138 = 0, $214 = 0.0, $215 = 0.0, $2153 = 0, $2158 = 0.0, $2159 = 0.0, $216 = 0, $2160 = 0.0, $2161 = 0, $2162 = 0, $2163 = 0, $2164 = 0, $2165 = 0, $2166 = 0, $2167 = 0, $2168 = 0, $2169 = 0, $217 = 0, $2175 = 0.0, $218 = 0, $2181 = 0.0, $2188 = 0.0, $219 = 0, $2198 = 0.0, $220 = 0, $2207 = 0.0, $2208 = 0.0, $221 = 0, $222 = 0, $2229 = 0, $223 = 0, $2232 = 0, $224 = 0, $2251 = 0, $2256 = 0, $2263 = 0, $230 = 0.0, $236 = 0.0, $243 = 0.0, $253 = 0.0, $262 = 0.0, $263 = 0.0, $284 = 0, $292 = 0, $293 = 0, $301 = 0, $309 = 0, $31 = 0.0, $314 = 0.0, $315 = 0.0, $316 = 0.0, $317 = 0, $318 = 0, $319 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $33 = 0.0, $331 = 0.0, $337 = 0.0, $34 = 0.0, $344 = 0.0, $354 = 0.0, $363 = 0.0, $364 = 0.0, $37 = 0.0, $385 = 0, $39 = 0.0, $394 = 0, $395 = 0, $40 = 0.0, $403 = 0, $410 = 0, $415 = 0.0, $416 = 0.0, $417 = 0.0, $418 = 0, $419 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $43 = 0, $432 = 0.0, $438 = 0.0, $445 = 0.0, $45 = 0.0, $455 = 0.0, $464 = 0.0, $465 = 0.0, $47 = 0.0, $48 = 0.0, $486 = 0, $494 = 0, $495 = 0, $503 = 0, $51 = 0.0, $511 = 0, $516 = 0.0, $517 = 0.0, $518 = 0.0, $519 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $53 = 0.0, $533 = 0.0, $539 = 0.0, $54 = 0.0, $546 = 0.0, $556 = 0.0, $565 = 0.0, $566 = 0.0, $57 = 0, $58 = 0.0, $587 = 0, $596 = 0, $597 = 0, $60 = 0.0, $605 = 0, $613 = 0, $618 = 0.0, $619 = 0.0, $620 = 0.0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $635 = 0.0, $64 = 0.0, $641 = 0.0, $648 = 0.0, $658 = 0.0, $66 = 0.0, $667 = 0.0, $668 = 0.0, $689 = 0, $69 = 0, $691 = 0, $696 = 0, $697 = 0, $701 = 0, $705 = 0, $710 = 0.0, $711 = 0.0, $712 = 0.0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $720 = 0, $721 = 0, $727 = 0.0, $733 = 0.0, $740 = 0.0, $75 = 0, $750 = 0.0, $759 = 0.0, $760 = 0.0, $781 = 0, $79 = 0, $790 = 0, $791 = 0, $799 = 0, $807 = 0, $812 = 0.0, $813 = 0.0, $814 = 0.0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $829 = 0.0, $835 = 0.0, $842 = 0.0, $852 = 0.0, $861 = 0.0, $862 = 0.0, $881 = 0, $884 = 0, $889 = 0.0, $903 = 0.0, $904 = 0.0, $908 = 0, $914 = 0, $918 = 0, $920 = 0, $926 = 0, $927 = 0, $931 = 0, $935 = 0, $939 = 0, $942 = 0, $947 = 0.0, $948 = 0.0, $949 = 0.0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0, $964 = 0.0, $970 = 0.0, $977 = 0.0, $987 = 0.0, $996 = 0.0, $997 = 0.0, $spec$select1520 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer3 = 0, $vararg_buffer5 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 240 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(240);\n $vararg_buffer5 = sp + 224 | 0;\n $vararg_buffer3 = sp + 216 | 0;\n $vararg_buffer1 = sp + 208 | 0;\n $vararg_buffer = sp + 200 | 0;\n $12 = sp + 136 | 0;\n $13 = sp + 72 | 0;\n $14 = sp;\n $15 = sp + 232 | 0;\n $16 = sp + 228 | 0;\n HEAPF64[$12 >> 3] = 100.0;\n HEAPF64[$12 + 8 >> 3] = 100.0;\n HEAPF64[$12 + 16 >> 3] = 110.0;\n HEAPF64[$12 + 24 >> 3] = 100.0;\n HEAPF64[$12 + 32 >> 3] = 110.0;\n HEAPF64[$12 + 40 >> 3] = 110.0;\n HEAPF64[$12 + 48 >> 3] = 100.0;\n HEAPF64[$12 + 56 >> 3] = 110.0;\n $$01474 = 0;\n while (1) {\n  if (($$01474 | 0) == 4) break;\n  HEAPF64[$13 + ($$01474 << 4) >> 3] = +HEAPF64[$9 + ($$01474 << 4) >> 3];\n  HEAPF64[$13 + ($$01474 << 4) + 8 >> 3] = +HEAPF64[$9 + ($$01474 << 4) + 8 >> 3];\n  $$01474 = $$01474 + 1 | 0;\n }\n _get_cpara($12, $13, $14);\n $31 = +HEAPF64[$13 >> 3];\n $33 = +HEAPF64[$13 + 16 >> 3];\n $34 = $31 - $33;\n $37 = +HEAPF64[$13 + 8 >> 3];\n $39 = +HEAPF64[$13 + 24 >> 3];\n $40 = $37 - $39;\n $43 = ~~($34 * $34 + $40 * $40);\n $45 = +HEAPF64[$13 + 32 >> 3];\n $47 = +HEAPF64[$13 + 48 >> 3];\n $48 = $45 - $47;\n $51 = +HEAPF64[$13 + 40 >> 3];\n $53 = +HEAPF64[$13 + 56 >> 3];\n $54 = $51 - $53;\n $57 = ~~($48 * $48 + $54 * $54);\n $58 = $33 - $45;\n $60 = $39 - $51;\n $63 = ~~($58 * $58 + $60 * $60);\n $64 = $47 - $31;\n $66 = $53 - $37;\n $69 = ~~($64 * $64 + $66 * $66);\n $75 = ~~(+((($57 | 0) > ($43 | 0) ? $57 : $43) | 0) * $10 * $10);\n $79 = ~~(+((($69 | 0) > ($63 | 0) ? $69 : $63) | 0) * $10 * $10);\n if (!$0) {\n  $$01464 = $2;\n  while (1) if (($$01464 | 0) < ($3 | 0) & (Math_imul($$01464, $$01464) | 0) < ($75 | 0)) $$01464 = $$01464 << 1; else break;\n  $$01468 = $2;\n  while (1) if (($$01468 | 0) < ($3 | 0) & (Math_imul($$01468, $$01468) | 0) < ($79 | 0)) $$01468 = $$01468 << 1; else {\n   $$21466 = $$01464;\n   $$21470 = $$01468;\n   break;\n  }\n } else {\n  $$11465 = $2;\n  while (1) if (($$11465 | 0) < ($3 | 0) & (Math_imul($$11465 << 2, $$11465) | 0) < ($75 | 0)) $$11465 = $$11465 << 1; else break;\n  $$11469 = $2;\n  while (1) if (($$11469 | 0) < ($3 | 0) & (Math_imul($$11469 << 2, $$11469) | 0) < ($79 | 0)) $$11469 = $$11469 << 1; else {\n   $$21466 = $$11465;\n   $$21470 = $$11469;\n   break;\n  }\n }\n $spec$select1520 = ($$21466 | 0) > ($3 | 0) ? $3 : $$21466;\n $$31471 = ($$21470 | 0) > ($3 | 0) ? $3 : $$21470;\n $101 = ($spec$select1520 | 0) / ($2 | 0) | 0;\n $102 = ($$31471 | 0) / ($2 | 0) | 0;\n $105 = (1.0 - $10) * .5 * 10.0;\n $106 = $10 * 10.0;\n $108 = Math_imul($2, $2) | 0;\n L19 : do if (!$1) {\n  $109 = $108 * 3 | 0;\n  $110 = _calloc($109, 4) | 0;\n  if (!$110) {\n   _arLog(0, 3, 5051, $vararg_buffer);\n   _exit(1);\n  }\n  L24 : do switch ($7 | 0) {\n  case 0:\n   {\n    $112 = $105 + 100.0;\n    $113 = +($$31471 | 0);\n    $114 = +($spec$select1520 | 0);\n    $115 = $14 + 48 | 0;\n    $116 = $14 + 56 | 0;\n    $117 = $14 + 64 | 0;\n    $118 = $14 + 8 | 0;\n    $119 = $14 + 16 | 0;\n    $120 = $14 + 24 | 0;\n    $121 = $14 + 32 | 0;\n    $122 = $14 + 40 | 0;\n    $123 = ($0 | 0) == 1;\n    $$01495 = 0;\n    while (1) {\n     if (($$01495 | 0) >= ($$31471 | 0)) break L24;\n     $129 = $112 + $106 * (+($$01495 | 0) + .5) / $113;\n     $$11475 = 0;\n     while (1) {\n      if (($$11475 | 0) >= ($spec$select1520 | 0)) break;\n      $135 = $112 + $106 * (+($$11475 | 0) + .5) / $114;\n      $142 = +HEAPF64[$117 >> 3] + ($135 * +HEAPF64[$115 >> 3] + $129 * +HEAPF64[$116 >> 3]);\n      if ($142 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $152 = (+HEAPF64[$119 >> 3] + ($135 * +HEAPF64[$14 >> 3] + $129 * +HEAPF64[$118 >> 3])) / $142;\n      HEAPF32[$15 >> 2] = $152;\n      $161 = (+HEAPF64[$122 >> 3] + ($135 * +HEAPF64[$120 >> 3] + $129 * +HEAPF64[$121 >> 3])) / $142;\n      HEAPF32[$16 >> 2] = $161;\n      _arParamIdeal2ObservLTf($8, $152, $161, $15, $16) | 0;\n      $162 = +HEAPF32[$15 >> 2];\n      if ($123) {\n       $$01442 = ((~~($162 + 1.0) | 0) / 2 | 0) << 1;\n       $$01443 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$01442 = ~~($162 + .5);\n       $$01443 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$01442 | 0) > -1) if (($$01443 | 0) < ($6 | 0) & (($$01443 | 0) > -1 & ($$01442 | 0) < ($5 | 0))) {\n       $183 = ((Math_imul($$01443, $5) | 0) + $$01442 | 0) * 3 | 0;\n       $192 = ((Math_imul(($$01495 | 0) / ($102 | 0) | 0, $2) | 0) + (($$11475 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $193 = $110 + ($192 << 2) | 0;\n       HEAP32[$193 >> 2] = (HEAP32[$193 >> 2] | 0) + (HEAPU8[$4 + ($183 + 2) >> 0] | 0);\n       $201 = $110 + ($192 + 1 << 2) | 0;\n       HEAP32[$201 >> 2] = (HEAP32[$201 >> 2] | 0) + (HEAPU8[$4 + ($183 + 1) >> 0] | 0);\n       $208 = $110 + ($192 + 2 << 2) | 0;\n       HEAP32[$208 >> 2] = (HEAP32[$208 >> 2] | 0) + (HEAPU8[$4 + $183 >> 0] | 0);\n      }\n      $$11475 = $$11475 + 1 | 0;\n     }\n     $$01495 = $$01495 + 1 | 0;\n    }\n    break;\n   }\n  case 1:\n   {\n    $213 = $105 + 100.0;\n    $214 = +($$31471 | 0);\n    $215 = +($spec$select1520 | 0);\n    $216 = $14 + 48 | 0;\n    $217 = $14 + 56 | 0;\n    $218 = $14 + 64 | 0;\n    $219 = $14 + 8 | 0;\n    $220 = $14 + 16 | 0;\n    $221 = $14 + 24 | 0;\n    $222 = $14 + 32 | 0;\n    $223 = $14 + 40 | 0;\n    $224 = ($0 | 0) == 1;\n    $$11496 = 0;\n    while (1) {\n     if (($$11496 | 0) >= ($$31471 | 0)) break L24;\n     $230 = $213 + $106 * (+($$11496 | 0) + .5) / $214;\n     $$21476 = 0;\n     while (1) {\n      if (($$21476 | 0) >= ($spec$select1520 | 0)) break;\n      $236 = $213 + $106 * (+($$21476 | 0) + .5) / $215;\n      $243 = +HEAPF64[$218 >> 3] + ($236 * +HEAPF64[$216 >> 3] + $230 * +HEAPF64[$217 >> 3]);\n      if ($243 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $253 = (+HEAPF64[$220 >> 3] + ($236 * +HEAPF64[$14 >> 3] + $230 * +HEAPF64[$219 >> 3])) / $243;\n      HEAPF32[$15 >> 2] = $253;\n      $262 = (+HEAPF64[$223 >> 3] + ($236 * +HEAPF64[$221 >> 3] + $230 * +HEAPF64[$222 >> 3])) / $243;\n      HEAPF32[$16 >> 2] = $262;\n      _arParamIdeal2ObservLTf($8, $253, $262, $15, $16) | 0;\n      $263 = +HEAPF32[$15 >> 2];\n      if ($224) {\n       $$1 = ((~~($263 + 1.0) | 0) / 2 | 0) << 1;\n       $$11444 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$1 = ~~($263 + .5);\n       $$11444 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$1 | 0) > -1) if (($$11444 | 0) < ($6 | 0) & (($$11444 | 0) > -1 & ($$1 | 0) < ($5 | 0))) {\n       $284 = ((Math_imul($$11444, $5) | 0) + $$1 | 0) * 3 | 0;\n       $292 = ((Math_imul(($$11496 | 0) / ($102 | 0) | 0, $2) | 0) + (($$21476 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $293 = $110 + ($292 << 2) | 0;\n       HEAP32[$293 >> 2] = (HEAP32[$293 >> 2] | 0) + (HEAPU8[$4 + $284 >> 0] | 0);\n       $301 = $110 + ($292 + 1 << 2) | 0;\n       HEAP32[$301 >> 2] = (HEAP32[$301 >> 2] | 0) + (HEAPU8[$4 + ($284 + 1) >> 0] | 0);\n       $309 = $110 + ($292 + 2 << 2) | 0;\n       HEAP32[$309 >> 2] = (HEAP32[$309 >> 2] | 0) + (HEAPU8[$4 + ($284 + 2) >> 0] | 0);\n      }\n      $$21476 = $$21476 + 1 | 0;\n     }\n     $$11496 = $$11496 + 1 | 0;\n    }\n    break;\n   }\n  case 2:\n   {\n    $314 = $105 + 100.0;\n    $315 = +($$31471 | 0);\n    $316 = +($spec$select1520 | 0);\n    $317 = $14 + 48 | 0;\n    $318 = $14 + 56 | 0;\n    $319 = $14 + 64 | 0;\n    $320 = $14 + 8 | 0;\n    $321 = $14 + 16 | 0;\n    $322 = $14 + 24 | 0;\n    $323 = $14 + 32 | 0;\n    $324 = $14 + 40 | 0;\n    $325 = ($0 | 0) == 1;\n    $$21497 = 0;\n    while (1) {\n     if (($$21497 | 0) >= ($$31471 | 0)) break L24;\n     $331 = $314 + $106 * (+($$21497 | 0) + .5) / $315;\n     $$31477 = 0;\n     while (1) {\n      if (($$31477 | 0) >= ($spec$select1520 | 0)) break;\n      $337 = $314 + $106 * (+($$31477 | 0) + .5) / $316;\n      $344 = +HEAPF64[$319 >> 3] + ($337 * +HEAPF64[$317 >> 3] + $331 * +HEAPF64[$318 >> 3]);\n      if ($344 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $354 = (+HEAPF64[$321 >> 3] + ($337 * +HEAPF64[$14 >> 3] + $331 * +HEAPF64[$320 >> 3])) / $344;\n      HEAPF32[$15 >> 2] = $354;\n      $363 = (+HEAPF64[$324 >> 3] + ($337 * +HEAPF64[$322 >> 3] + $331 * +HEAPF64[$323 >> 3])) / $344;\n      HEAPF32[$16 >> 2] = $363;\n      _arParamIdeal2ObservLTf($8, $354, $363, $15, $16) | 0;\n      $364 = +HEAPF32[$15 >> 2];\n      if ($325) {\n       $$2 = ((~~($364 + 1.0) | 0) / 2 | 0) << 1;\n       $$21445 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$2 = ~~($364 + .5);\n       $$21445 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$2 | 0) > -1) if (($$21445 | 0) < ($6 | 0) & (($$21445 | 0) > -1 & ($$2 | 0) < ($5 | 0))) {\n       $385 = (Math_imul($$21445, $5) | 0) + $$2 << 2;\n       $394 = ((Math_imul(($$21497 | 0) / ($102 | 0) | 0, $2) | 0) + (($$31477 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $395 = $110 + ($394 << 2) | 0;\n       HEAP32[$395 >> 2] = (HEAP32[$395 >> 2] | 0) + (HEAPU8[$4 + ($385 | 2) >> 0] | 0);\n       $403 = $110 + ($394 + 1 << 2) | 0;\n       HEAP32[$403 >> 2] = (HEAP32[$403 >> 2] | 0) + (HEAPU8[$4 + ($385 | 1) >> 0] | 0);\n       $410 = $110 + ($394 + 2 << 2) | 0;\n       HEAP32[$410 >> 2] = (HEAP32[$410 >> 2] | 0) + (HEAPU8[$4 + $385 >> 0] | 0);\n      }\n      $$31477 = $$31477 + 1 | 0;\n     }\n     $$21497 = $$21497 + 1 | 0;\n    }\n    break;\n   }\n  case 3:\n   {\n    $415 = $105 + 100.0;\n    $416 = +($$31471 | 0);\n    $417 = +($spec$select1520 | 0);\n    $418 = $14 + 48 | 0;\n    $419 = $14 + 56 | 0;\n    $420 = $14 + 64 | 0;\n    $421 = $14 + 8 | 0;\n    $422 = $14 + 16 | 0;\n    $423 = $14 + 24 | 0;\n    $424 = $14 + 32 | 0;\n    $425 = $14 + 40 | 0;\n    $426 = ($0 | 0) == 1;\n    $$31498 = 0;\n    while (1) {\n     if (($$31498 | 0) >= ($$31471 | 0)) break L24;\n     $432 = $415 + $106 * (+($$31498 | 0) + .5) / $416;\n     $$41478 = 0;\n     while (1) {\n      if (($$41478 | 0) >= ($spec$select1520 | 0)) break;\n      $438 = $415 + $106 * (+($$41478 | 0) + .5) / $417;\n      $445 = +HEAPF64[$420 >> 3] + ($438 * +HEAPF64[$418 >> 3] + $432 * +HEAPF64[$419 >> 3]);\n      if ($445 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $455 = (+HEAPF64[$422 >> 3] + ($438 * +HEAPF64[$14 >> 3] + $432 * +HEAPF64[$421 >> 3])) / $445;\n      HEAPF32[$15 >> 2] = $455;\n      $464 = (+HEAPF64[$425 >> 3] + ($438 * +HEAPF64[$423 >> 3] + $432 * +HEAPF64[$424 >> 3])) / $445;\n      HEAPF32[$16 >> 2] = $464;\n      _arParamIdeal2ObservLTf($8, $455, $464, $15, $16) | 0;\n      $465 = +HEAPF32[$15 >> 2];\n      if ($426) {\n       $$3 = ((~~($465 + 1.0) | 0) / 2 | 0) << 1;\n       $$31446 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$3 = ~~($465 + .5);\n       $$31446 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$3 | 0) > -1) if (($$31446 | 0) < ($6 | 0) & (($$31446 | 0) > -1 & ($$3 | 0) < ($5 | 0))) {\n       $486 = (Math_imul($$31446, $5) | 0) + $$3 << 2;\n       $494 = ((Math_imul(($$31498 | 0) / ($102 | 0) | 0, $2) | 0) + (($$41478 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $495 = $110 + ($494 << 2) | 0;\n       HEAP32[$495 >> 2] = (HEAP32[$495 >> 2] | 0) + (HEAPU8[$4 + $486 >> 0] | 0);\n       $503 = $110 + ($494 + 1 << 2) | 0;\n       HEAP32[$503 >> 2] = (HEAP32[$503 >> 2] | 0) + (HEAPU8[$4 + ($486 | 1) >> 0] | 0);\n       $511 = $110 + ($494 + 2 << 2) | 0;\n       HEAP32[$511 >> 2] = (HEAP32[$511 >> 2] | 0) + (HEAPU8[$4 + ($486 | 2) >> 0] | 0);\n      }\n      $$41478 = $$41478 + 1 | 0;\n     }\n     $$31498 = $$31498 + 1 | 0;\n    }\n    break;\n   }\n  case 4:\n   {\n    $516 = $105 + 100.0;\n    $517 = +($$31471 | 0);\n    $518 = +($spec$select1520 | 0);\n    $519 = $14 + 48 | 0;\n    $520 = $14 + 56 | 0;\n    $521 = $14 + 64 | 0;\n    $522 = $14 + 8 | 0;\n    $523 = $14 + 16 | 0;\n    $524 = $14 + 24 | 0;\n    $525 = $14 + 32 | 0;\n    $526 = $14 + 40 | 0;\n    $527 = ($0 | 0) == 1;\n    $$41499 = 0;\n    while (1) {\n     if (($$41499 | 0) >= ($$31471 | 0)) break L24;\n     $533 = $516 + $106 * (+($$41499 | 0) + .5) / $517;\n     $$51479 = 0;\n     while (1) {\n      if (($$51479 | 0) >= ($spec$select1520 | 0)) break;\n      $539 = $516 + $106 * (+($$51479 | 0) + .5) / $518;\n      $546 = +HEAPF64[$521 >> 3] + ($539 * +HEAPF64[$519 >> 3] + $533 * +HEAPF64[$520 >> 3]);\n      if ($546 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $556 = (+HEAPF64[$523 >> 3] + ($539 * +HEAPF64[$14 >> 3] + $533 * +HEAPF64[$522 >> 3])) / $546;\n      HEAPF32[$15 >> 2] = $556;\n      $565 = (+HEAPF64[$526 >> 3] + ($539 * +HEAPF64[$524 >> 3] + $533 * +HEAPF64[$525 >> 3])) / $546;\n      HEAPF32[$16 >> 2] = $565;\n      _arParamIdeal2ObservLTf($8, $556, $565, $15, $16) | 0;\n      $566 = +HEAPF32[$15 >> 2];\n      if ($527) {\n       $$4 = ((~~($566 + 1.0) | 0) / 2 | 0) << 1;\n       $$41447 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$4 = ~~($566 + .5);\n       $$41447 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$4 | 0) > -1) if (($$41447 | 0) < ($6 | 0) & (($$41447 | 0) > -1 & ($$4 | 0) < ($5 | 0))) {\n       $587 = (Math_imul($$41447, $5) | 0) + $$4 << 2;\n       $596 = ((Math_imul(($$41499 | 0) / ($102 | 0) | 0, $2) | 0) + (($$51479 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $597 = $110 + ($596 << 2) | 0;\n       HEAP32[$597 >> 2] = (HEAP32[$597 >> 2] | 0) + (HEAPU8[$4 + ($587 | 1) >> 0] | 0);\n       $605 = $110 + ($596 + 1 << 2) | 0;\n       HEAP32[$605 >> 2] = (HEAP32[$605 >> 2] | 0) + (HEAPU8[$4 + ($587 | 2) >> 0] | 0);\n       $613 = $110 + ($596 + 2 << 2) | 0;\n       HEAP32[$613 >> 2] = (HEAP32[$613 >> 2] | 0) + (HEAPU8[$4 + ($587 | 3) >> 0] | 0);\n      }\n      $$51479 = $$51479 + 1 | 0;\n     }\n     $$41499 = $$41499 + 1 | 0;\n    }\n    break;\n   }\n  case 5:\n  case 12:\n  case 13:\n  case 14:\n   {\n    $618 = $105 + 100.0;\n    $619 = +($$31471 | 0);\n    $620 = +($spec$select1520 | 0);\n    $621 = $14 + 48 | 0;\n    $622 = $14 + 56 | 0;\n    $623 = $14 + 64 | 0;\n    $624 = $14 + 8 | 0;\n    $625 = $14 + 16 | 0;\n    $626 = $14 + 24 | 0;\n    $627 = $14 + 32 | 0;\n    $628 = $14 + 40 | 0;\n    $629 = ($0 | 0) == 1;\n    $$51500 = 0;\n    while (1) {\n     if (($$51500 | 0) >= ($$31471 | 0)) break L24;\n     $635 = $618 + $106 * (+($$51500 | 0) + .5) / $619;\n     $$61480 = 0;\n     while (1) {\n      if (($$61480 | 0) >= ($spec$select1520 | 0)) break;\n      $641 = $618 + $106 * (+($$61480 | 0) + .5) / $620;\n      $648 = +HEAPF64[$623 >> 3] + ($641 * +HEAPF64[$621 >> 3] + $635 * +HEAPF64[$622 >> 3]);\n      if ($648 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $658 = (+HEAPF64[$625 >> 3] + ($641 * +HEAPF64[$14 >> 3] + $635 * +HEAPF64[$624 >> 3])) / $648;\n      HEAPF32[$15 >> 2] = $658;\n      $667 = (+HEAPF64[$628 >> 3] + ($641 * +HEAPF64[$626 >> 3] + $635 * +HEAPF64[$627 >> 3])) / $648;\n      HEAPF32[$16 >> 2] = $667;\n      _arParamIdeal2ObservLTf($8, $658, $667, $15, $16) | 0;\n      $668 = +HEAPF32[$15 >> 2];\n      if ($629) {\n       $$5 = ((~~($668 + 1.0) | 0) / 2 | 0) << 1;\n       $$51448 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$5 = ~~($668 + .5);\n       $$51448 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$5 | 0) > -1) if (($$51448 | 0) < ($6 | 0) & (($$51448 | 0) > -1 & ($$5 | 0) < ($5 | 0))) {\n       $689 = $4 + ((Math_imul($$51448, $5) | 0) + $$5) | 0;\n       $691 = HEAPU8[$689 >> 0] | 0;\n       $696 = ((Math_imul(($$51500 | 0) / ($102 | 0) | 0, $2) | 0) + (($$61480 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $697 = $110 + ($696 << 2) | 0;\n       HEAP32[$697 >> 2] = (HEAP32[$697 >> 2] | 0) + $691;\n       $701 = $110 + ($696 + 1 << 2) | 0;\n       HEAP32[$701 >> 2] = (HEAP32[$701 >> 2] | 0) + $691;\n       $705 = $110 + ($696 + 2 << 2) | 0;\n       HEAP32[$705 >> 2] = (HEAP32[$705 >> 2] | 0) + $691;\n      }\n      $$61480 = $$61480 + 1 | 0;\n     }\n     $$51500 = $$51500 + 1 | 0;\n    }\n    break;\n   }\n  case 6:\n   {\n    $710 = $105 + 100.0;\n    $711 = +($$31471 | 0);\n    $712 = +($spec$select1520 | 0);\n    $713 = $14 + 48 | 0;\n    $714 = $14 + 56 | 0;\n    $715 = $14 + 64 | 0;\n    $716 = $14 + 8 | 0;\n    $717 = $14 + 16 | 0;\n    $718 = $14 + 24 | 0;\n    $719 = $14 + 32 | 0;\n    $720 = $14 + 40 | 0;\n    $721 = ($0 | 0) == 1;\n    $$61501 = 0;\n    while (1) {\n     if (($$61501 | 0) >= ($$31471 | 0)) break L24;\n     $727 = $710 + $106 * (+($$61501 | 0) + .5) / $711;\n     $$71481 = 0;\n     while (1) {\n      if (($$71481 | 0) >= ($spec$select1520 | 0)) break;\n      $733 = $710 + $106 * (+($$71481 | 0) + .5) / $712;\n      $740 = +HEAPF64[$715 >> 3] + ($733 * +HEAPF64[$713 >> 3] + $727 * +HEAPF64[$714 >> 3]);\n      if ($740 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $750 = (+HEAPF64[$717 >> 3] + ($733 * +HEAPF64[$14 >> 3] + $727 * +HEAPF64[$716 >> 3])) / $740;\n      HEAPF32[$15 >> 2] = $750;\n      $759 = (+HEAPF64[$720 >> 3] + ($733 * +HEAPF64[$718 >> 3] + $727 * +HEAPF64[$719 >> 3])) / $740;\n      HEAPF32[$16 >> 2] = $759;\n      _arParamIdeal2ObservLTf($8, $750, $759, $15, $16) | 0;\n      $760 = +HEAPF32[$15 >> 2];\n      if ($721) {\n       $$6 = ((~~($760 + 1.0) | 0) / 2 | 0) << 1;\n       $$61449 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$6 = ~~($760 + .5);\n       $$61449 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$6 | 0) > -1) if (($$61449 | 0) < ($6 | 0) & (($$61449 | 0) > -1 & ($$6 | 0) < ($5 | 0))) {\n       $781 = (Math_imul($$61449, $5) | 0) + $$6 << 2;\n       $790 = ((Math_imul(($$61501 | 0) / ($102 | 0) | 0, $2) | 0) + (($$71481 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $791 = $110 + ($790 << 2) | 0;\n       HEAP32[$791 >> 2] = (HEAP32[$791 >> 2] | 0) + (HEAPU8[$4 + ($781 | 3) >> 0] | 0);\n       $799 = $110 + ($790 + 1 << 2) | 0;\n       HEAP32[$799 >> 2] = (HEAP32[$799 >> 2] | 0) + (HEAPU8[$4 + ($781 | 2) >> 0] | 0);\n       $807 = $110 + ($790 + 2 << 2) | 0;\n       HEAP32[$807 >> 2] = (HEAP32[$807 >> 2] | 0) + (HEAPU8[$4 + ($781 | 1) >> 0] | 0);\n      }\n      $$71481 = $$71481 + 1 | 0;\n     }\n     $$61501 = $$61501 + 1 | 0;\n    }\n    break;\n   }\n  case 7:\n   {\n    $812 = $105 + 100.0;\n    $813 = +($$31471 | 0);\n    $814 = +($spec$select1520 | 0);\n    $815 = $14 + 48 | 0;\n    $816 = $14 + 56 | 0;\n    $817 = $14 + 64 | 0;\n    $818 = $14 + 8 | 0;\n    $819 = $14 + 16 | 0;\n    $820 = $14 + 24 | 0;\n    $821 = $14 + 32 | 0;\n    $822 = $14 + 40 | 0;\n    $823 = ($0 | 0) == 1;\n    $$71502 = 0;\n    while (1) {\n     if (($$71502 | 0) >= ($$31471 | 0)) break L24;\n     $829 = $812 + $106 * (+($$71502 | 0) + .5) / $813;\n     $$81482 = 0;\n     while (1) {\n      if (($$81482 | 0) >= ($spec$select1520 | 0)) break;\n      $835 = $812 + $106 * (+($$81482 | 0) + .5) / $814;\n      $842 = +HEAPF64[$817 >> 3] + ($835 * +HEAPF64[$815 >> 3] + $829 * +HEAPF64[$816 >> 3]);\n      if ($842 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $852 = (+HEAPF64[$819 >> 3] + ($835 * +HEAPF64[$14 >> 3] + $829 * +HEAPF64[$818 >> 3])) / $842;\n      HEAPF32[$15 >> 2] = $852;\n      $861 = (+HEAPF64[$822 >> 3] + ($835 * +HEAPF64[$820 >> 3] + $829 * +HEAPF64[$821 >> 3])) / $842;\n      HEAPF32[$16 >> 2] = $861;\n      _arParamIdeal2ObservLTf($8, $852, $861, $15, $16) | 0;\n      $862 = +HEAPF32[$15 >> 2];\n      if ($823) {\n       $$7 = ((~~($862 + 1.0) | 0) / 2 | 0) << 1;\n       $$71450 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$7 = ~~($862 + .5);\n       $$71450 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$7 | 0) > -1) if (($$71450 | 0) < ($6 | 0) & (($$71450 | 0) > -1 & ($$7 | 0) < ($5 | 0))) {\n       $881 = Math_imul($$71450, $5) | 0;\n       $884 = ($$7 & 65534) + $881 << 1;\n       $889 = +((HEAPU8[$4 + $884 >> 0] | 0) + -128 | 0);\n       $903 = +((HEAPU8[$4 + ($884 + 2) >> 0] | 0) + -128 | 0);\n       $904 = +((HEAPU8[$4 + ($881 + $$7 << 1 | 1) >> 0] | 0) + -16 | 0) * 298.0820007324219;\n       $908 = ~~($889 * 516.4110107421875 + $904) >> 8;\n       $914 = ~~($904 - $889 * 100.29100036621094 - $903 * 208.1199951171875) >> 8;\n       $918 = ~~($904 + $903 * 408.5830078125) >> 8;\n       $920 = ($908 | 0) > 0 ? $908 : 0;\n       $926 = ((Math_imul(($$71502 | 0) / ($102 | 0) | 0, $2) | 0) + (($$81482 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $927 = $110 + ($926 << 2) | 0;\n       HEAP32[$927 >> 2] = (($920 | 0) < 255 ? $920 : 255) + (HEAP32[$927 >> 2] | 0);\n       $931 = ($914 | 0) > 0 ? $914 : 0;\n       $935 = $110 + ($926 + 1 << 2) | 0;\n       HEAP32[$935 >> 2] = (($931 | 0) < 255 ? $931 : 255) + (HEAP32[$935 >> 2] | 0);\n       $939 = ($918 | 0) > 0 ? $918 : 0;\n       $942 = $110 + ($926 + 2 << 2) | 0;\n       HEAP32[$942 >> 2] = (($939 | 0) < 255 ? $939 : 255) + (HEAP32[$942 >> 2] | 0);\n      }\n      $$81482 = $$81482 + 1 | 0;\n     }\n     $$71502 = $$71502 + 1 | 0;\n    }\n    break;\n   }\n  case 8:\n   {\n    $947 = $105 + 100.0;\n    $948 = +($$31471 | 0);\n    $949 = +($spec$select1520 | 0);\n    $950 = $14 + 48 | 0;\n    $951 = $14 + 56 | 0;\n    $952 = $14 + 64 | 0;\n    $953 = $14 + 8 | 0;\n    $954 = $14 + 16 | 0;\n    $955 = $14 + 24 | 0;\n    $956 = $14 + 32 | 0;\n    $957 = $14 + 40 | 0;\n    $958 = ($0 | 0) == 1;\n    $$81503 = 0;\n    while (1) {\n     if (($$81503 | 0) >= ($$31471 | 0)) break L24;\n     $964 = $947 + $106 * (+($$81503 | 0) + .5) / $948;\n     $$91483 = 0;\n     while (1) {\n      if (($$91483 | 0) >= ($spec$select1520 | 0)) break;\n      $970 = $947 + $106 * (+($$91483 | 0) + .5) / $949;\n      $977 = +HEAPF64[$952 >> 3] + ($970 * +HEAPF64[$950 >> 3] + $964 * +HEAPF64[$951 >> 3]);\n      if ($977 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $987 = (+HEAPF64[$954 >> 3] + ($970 * +HEAPF64[$14 >> 3] + $964 * +HEAPF64[$953 >> 3])) / $977;\n      HEAPF32[$15 >> 2] = $987;\n      $996 = (+HEAPF64[$957 >> 3] + ($970 * +HEAPF64[$955 >> 3] + $964 * +HEAPF64[$956 >> 3])) / $977;\n      HEAPF32[$16 >> 2] = $996;\n      _arParamIdeal2ObservLTf($8, $987, $996, $15, $16) | 0;\n      $997 = +HEAPF32[$15 >> 2];\n      if ($958) {\n       $$8 = ((~~($997 + 1.0) | 0) / 2 | 0) << 1;\n       $$81451 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$8 = ~~($997 + .5);\n       $$81451 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$8 | 0) > -1) if (($$81451 | 0) < ($6 | 0) & (($$81451 | 0) > -1 & ($$8 | 0) < ($5 | 0))) {\n       $1016 = Math_imul($$81451, $5) | 0;\n       $1026 = ($$8 & 65534) + $1016 << 1;\n       $1032 = +((HEAPU8[$4 + ($1026 | 1) >> 0] | 0) + -128 | 0);\n       $1038 = +((HEAPU8[$4 + ($1026 + 3) >> 0] | 0) + -128 | 0);\n       $1039 = +((HEAPU8[$4 + ($1016 + $$8 << 1) >> 0] | 0) + -16 | 0) * 298.0820007324219;\n       $1043 = ~~($1039 + $1032 * 516.4110107421875) >> 8;\n       $1049 = ~~($1039 - $1032 * 100.29100036621094 - $1038 * 208.1199951171875) >> 8;\n       $1053 = ~~($1039 + $1038 * 408.5830078125) >> 8;\n       $1055 = ($1043 | 0) > 0 ? $1043 : 0;\n       $1061 = ((Math_imul(($$81503 | 0) / ($102 | 0) | 0, $2) | 0) + (($$91483 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $1062 = $110 + ($1061 << 2) | 0;\n       HEAP32[$1062 >> 2] = (($1055 | 0) < 255 ? $1055 : 255) + (HEAP32[$1062 >> 2] | 0);\n       $1066 = ($1049 | 0) > 0 ? $1049 : 0;\n       $1070 = $110 + ($1061 + 1 << 2) | 0;\n       HEAP32[$1070 >> 2] = (($1066 | 0) < 255 ? $1066 : 255) + (HEAP32[$1070 >> 2] | 0);\n       $1074 = ($1053 | 0) > 0 ? $1053 : 0;\n       $1077 = $110 + ($1061 + 2 << 2) | 0;\n       HEAP32[$1077 >> 2] = (($1074 | 0) < 255 ? $1074 : 255) + (HEAP32[$1077 >> 2] | 0);\n      }\n      $$91483 = $$91483 + 1 | 0;\n     }\n     $$81503 = $$81503 + 1 | 0;\n    }\n    break;\n   }\n  case 9:\n   {\n    $1082 = $105 + 100.0;\n    $1083 = +($$31471 | 0);\n    $1084 = +($spec$select1520 | 0);\n    $1085 = $14 + 48 | 0;\n    $1086 = $14 + 56 | 0;\n    $1087 = $14 + 64 | 0;\n    $1088 = $14 + 8 | 0;\n    $1089 = $14 + 16 | 0;\n    $1090 = $14 + 24 | 0;\n    $1091 = $14 + 32 | 0;\n    $1092 = $14 + 40 | 0;\n    $1093 = ($0 | 0) == 1;\n    $$91504 = 0;\n    while (1) {\n     if (($$91504 | 0) >= ($$31471 | 0)) break L24;\n     $1099 = $1082 + $106 * (+($$91504 | 0) + .5) / $1083;\n     $$101484 = 0;\n     while (1) {\n      if (($$101484 | 0) >= ($spec$select1520 | 0)) break;\n      $1105 = $1082 + $106 * (+($$101484 | 0) + .5) / $1084;\n      $1112 = +HEAPF64[$1087 >> 3] + ($1105 * +HEAPF64[$1085 >> 3] + $1099 * +HEAPF64[$1086 >> 3]);\n      if ($1112 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $1122 = (+HEAPF64[$1089 >> 3] + ($1105 * +HEAPF64[$14 >> 3] + $1099 * +HEAPF64[$1088 >> 3])) / $1112;\n      HEAPF32[$15 >> 2] = $1122;\n      $1131 = (+HEAPF64[$1092 >> 3] + ($1105 * +HEAPF64[$1090 >> 3] + $1099 * +HEAPF64[$1091 >> 3])) / $1112;\n      HEAPF32[$16 >> 2] = $1131;\n      _arParamIdeal2ObservLTf($8, $1122, $1131, $15, $16) | 0;\n      $1132 = +HEAPF32[$15 >> 2];\n      if ($1093) {\n       $$9 = ((~~($1132 + 1.0) | 0) / 2 | 0) << 1;\n       $$91452 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$9 = ~~($1132 + .5);\n       $$91452 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$9 | 0) > -1) if (($$91452 | 0) < ($6 | 0) & (($$91452 | 0) > -1 & ($$9 | 0) < ($5 | 0))) {\n       $1153 = (Math_imul($$91452, $5) | 0) + $$9 << 1;\n       $1156 = HEAP8[$4 + ($1153 | 1) >> 0] | 0;\n       $1164 = ((Math_imul(($$91504 | 0) / ($102 | 0) | 0, $2) | 0) + (($$101484 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $1165 = $110 + ($1164 << 2) | 0;\n       HEAP32[$1165 >> 2] = (HEAP32[$1165 >> 2] | 0) + (($1156 << 3 & 255 | 4) & 255);\n       $1169 = HEAP8[$4 + $1153 >> 0] | 0;\n       $1178 = $110 + ($1164 + 1 << 2) | 0;\n       HEAP32[$1178 >> 2] = (($1156 & -32 & 255) >>> 3 | $1169 << 5 & 255 | 2) + (HEAP32[$1178 >> 2] | 0);\n       $1185 = $110 + ($1164 + 2 << 2) | 0;\n       HEAP32[$1185 >> 2] = (HEAP32[$1185 >> 2] | 0) + (($1169 & -8 | 4) & 255);\n      }\n      $$101484 = $$101484 + 1 | 0;\n     }\n     $$91504 = $$91504 + 1 | 0;\n    }\n    break;\n   }\n  case 10:\n   {\n    $1190 = $105 + 100.0;\n    $1191 = +($$31471 | 0);\n    $1192 = +($spec$select1520 | 0);\n    $1193 = $14 + 48 | 0;\n    $1194 = $14 + 56 | 0;\n    $1195 = $14 + 64 | 0;\n    $1196 = $14 + 8 | 0;\n    $1197 = $14 + 16 | 0;\n    $1198 = $14 + 24 | 0;\n    $1199 = $14 + 32 | 0;\n    $1200 = $14 + 40 | 0;\n    $1201 = ($0 | 0) == 1;\n    $$101505 = 0;\n    while (1) {\n     if (($$101505 | 0) >= ($$31471 | 0)) break L24;\n     $1207 = $1190 + $106 * (+($$101505 | 0) + .5) / $1191;\n     $$111485 = 0;\n     while (1) {\n      if (($$111485 | 0) >= ($spec$select1520 | 0)) break;\n      $1213 = $1190 + $106 * (+($$111485 | 0) + .5) / $1192;\n      $1220 = +HEAPF64[$1195 >> 3] + ($1213 * +HEAPF64[$1193 >> 3] + $1207 * +HEAPF64[$1194 >> 3]);\n      if ($1220 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $1230 = (+HEAPF64[$1197 >> 3] + ($1213 * +HEAPF64[$14 >> 3] + $1207 * +HEAPF64[$1196 >> 3])) / $1220;\n      HEAPF32[$15 >> 2] = $1230;\n      $1239 = (+HEAPF64[$1200 >> 3] + ($1213 * +HEAPF64[$1198 >> 3] + $1207 * +HEAPF64[$1199 >> 3])) / $1220;\n      HEAPF32[$16 >> 2] = $1239;\n      _arParamIdeal2ObservLTf($8, $1230, $1239, $15, $16) | 0;\n      $1240 = +HEAPF32[$15 >> 2];\n      if ($1201) {\n       $$10 = ((~~($1240 + 1.0) | 0) / 2 | 0) << 1;\n       $$101453 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$10 = ~~($1240 + .5);\n       $$101453 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$10 | 0) > -1) if (($$101453 | 0) < ($6 | 0) & (($$101453 | 0) > -1 & ($$10 | 0) < ($5 | 0))) {\n       $1261 = (Math_imul($$101453, $5) | 0) + $$10 << 1;\n       $1264 = HEAP8[$4 + ($1261 | 1) >> 0] | 0;\n       $1272 = ((Math_imul(($$101505 | 0) / ($102 | 0) | 0, $2) | 0) + (($$111485 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $1273 = $110 + ($1272 << 2) | 0;\n       HEAP32[$1273 >> 2] = (HEAP32[$1273 >> 2] | 0) + (($1264 << 2 & 255 | 4) & 255);\n       $1277 = HEAP8[$4 + $1261 >> 0] | 0;\n       $1286 = $110 + ($1272 + 1 << 2) | 0;\n       HEAP32[$1286 >> 2] = (($1264 & -64 & 255) >>> 3 | $1277 << 5 & 255 | 4) + (HEAP32[$1286 >> 2] | 0);\n       $1293 = $110 + ($1272 + 2 << 2) | 0;\n       HEAP32[$1293 >> 2] = (HEAP32[$1293 >> 2] | 0) + (($1277 & -8 | 4) & 255);\n      }\n      $$111485 = $$111485 + 1 | 0;\n     }\n     $$101505 = $$101505 + 1 | 0;\n    }\n    break;\n   }\n  case 11:\n   {\n    $1298 = $105 + 100.0;\n    $1299 = +($$31471 | 0);\n    $1300 = +($spec$select1520 | 0);\n    $1301 = $14 + 48 | 0;\n    $1302 = $14 + 56 | 0;\n    $1303 = $14 + 64 | 0;\n    $1304 = $14 + 8 | 0;\n    $1305 = $14 + 16 | 0;\n    $1306 = $14 + 24 | 0;\n    $1307 = $14 + 32 | 0;\n    $1308 = $14 + 40 | 0;\n    $1309 = ($0 | 0) == 1;\n    $$111506 = 0;\n    while (1) {\n     if (($$111506 | 0) >= ($$31471 | 0)) break L24;\n     $1315 = $1298 + $106 * (+($$111506 | 0) + .5) / $1299;\n     $$121486 = 0;\n     while (1) {\n      if (($$121486 | 0) >= ($spec$select1520 | 0)) break;\n      $1321 = $1298 + $106 * (+($$121486 | 0) + .5) / $1300;\n      $1328 = +HEAPF64[$1303 >> 3] + ($1321 * +HEAPF64[$1301 >> 3] + $1315 * +HEAPF64[$1302 >> 3]);\n      if ($1328 == 0.0) {\n       $2263 = $110;\n       label = 306;\n       break L19;\n      }\n      $1338 = (+HEAPF64[$1305 >> 3] + ($1321 * +HEAPF64[$14 >> 3] + $1315 * +HEAPF64[$1304 >> 3])) / $1328;\n      HEAPF32[$15 >> 2] = $1338;\n      $1347 = (+HEAPF64[$1308 >> 3] + ($1321 * +HEAPF64[$1306 >> 3] + $1315 * +HEAPF64[$1307 >> 3])) / $1328;\n      HEAPF32[$16 >> 2] = $1347;\n      _arParamIdeal2ObservLTf($8, $1338, $1347, $15, $16) | 0;\n      $1348 = +HEAPF32[$15 >> 2];\n      if ($1309) {\n       $$11 = ((~~($1348 + 1.0) | 0) / 2 | 0) << 1;\n       $$111454 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$11 = ~~($1348 + .5);\n       $$111454 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$11 | 0) > -1) if (($$111454 | 0) < ($6 | 0) & (($$111454 | 0) > -1 & ($$11 | 0) < ($5 | 0))) {\n       $1369 = (Math_imul($$111454, $5) | 0) + $$11 << 1;\n       $1380 = ((Math_imul(($$111506 | 0) / ($102 | 0) | 0, $2) | 0) + (($$121486 | 0) / ($101 | 0) | 0) | 0) * 3 | 0;\n       $1381 = $110 + ($1380 << 2) | 0;\n       HEAP32[$1381 >> 2] = (HEAP32[$1381 >> 2] | 0) + ((HEAP8[$4 + ($1369 | 1) >> 0] & -16 | 8) & 255);\n       $1385 = HEAP8[$4 + $1369 >> 0] | 0;\n       $1390 = $110 + ($1380 + 1 << 2) | 0;\n       HEAP32[$1390 >> 2] = (HEAP32[$1390 >> 2] | 0) + (($1385 << 4 & 255 | 8) & 255);\n       $1397 = $110 + ($1380 + 2 << 2) | 0;\n       HEAP32[$1397 >> 2] = (HEAP32[$1397 >> 2] | 0) + (($1385 & -16 | 8) & 255);\n      }\n      $$121486 = $$121486 + 1 | 0;\n     }\n     $$111506 = $$111506 + 1 | 0;\n    }\n    break;\n   }\n  default:\n   {\n    _arLog(0, 3, 4174, $vararg_buffer1);\n    $2263 = $110;\n    label = 306;\n    break L19;\n   }\n  } while (0);\n  $1402 = Math_imul($102, $101) | 0;\n  $$131487 = 0;\n  while (1) {\n   if (($$131487 | 0) == ($109 | 0)) break;\n   HEAP8[$11 + $$131487 >> 0] = ((HEAP32[$110 + ($$131487 << 2) >> 2] | 0) >>> 0) / ($1402 >>> 0) | 0;\n   $$131487 = $$131487 + 1 | 0;\n  }\n  _free($110);\n  $$0 = 0;\n } else {\n  $1409 = _calloc($108, 4) | 0;\n  if (!$1409) {\n   _arLog(0, 3, 5051, $vararg_buffer3);\n   _exit(1);\n  }\n  L239 : do if ($7 >>> 0 < 2) {\n   $1412 = $105 + 100.0;\n   $1413 = +($$31471 | 0);\n   $1414 = +($spec$select1520 | 0);\n   $1415 = $14 + 48 | 0;\n   $1416 = $14 + 56 | 0;\n   $1417 = $14 + 64 | 0;\n   $1418 = $14 + 8 | 0;\n   $1419 = $14 + 16 | 0;\n   $1420 = $14 + 24 | 0;\n   $1421 = $14 + 32 | 0;\n   $1422 = $14 + 40 | 0;\n   $1423 = ($0 | 0) == 1;\n   $$121507 = 0;\n   while (1) {\n    if (($$121507 | 0) >= ($$31471 | 0)) break L239;\n    $1429 = $1412 + $106 * (+($$121507 | 0) + .5) / $1413;\n    $$141488 = 0;\n    while (1) {\n     if (($$141488 | 0) >= ($spec$select1520 | 0)) break;\n     $1435 = $1412 + $106 * (+($$141488 | 0) + .5) / $1414;\n     $1442 = +HEAPF64[$1417 >> 3] + ($1435 * +HEAPF64[$1415 >> 3] + $1429 * +HEAPF64[$1416 >> 3]);\n     if ($1442 == 0.0) {\n      $2263 = $1409;\n      label = 306;\n      break L19;\n     }\n     $1452 = (+HEAPF64[$1419 >> 3] + ($1435 * +HEAPF64[$14 >> 3] + $1429 * +HEAPF64[$1418 >> 3])) / $1442;\n     HEAPF32[$15 >> 2] = $1452;\n     $1461 = (+HEAPF64[$1422 >> 3] + ($1435 * +HEAPF64[$1420 >> 3] + $1429 * +HEAPF64[$1421 >> 3])) / $1442;\n     HEAPF32[$16 >> 2] = $1461;\n     _arParamIdeal2ObservLTf($8, $1452, $1461, $15, $16) | 0;\n     $1462 = +HEAPF32[$15 >> 2];\n     if ($1423) {\n      $$12 = ((~~($1462 + 1.0) | 0) / 2 | 0) << 1;\n      $$121455 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n     } else {\n      $$12 = ~~($1462 + .5);\n      $$121455 = ~~(+HEAPF32[$16 >> 2] + .5);\n     }\n     if (($$12 | 0) > -1) if (($$121455 | 0) < ($6 | 0) & (($$121455 | 0) > -1 & ($$12 | 0) < ($5 | 0))) {\n      $1483 = ((Math_imul($$121455, $5) | 0) + $$12 | 0) * 3 | 0;\n      $1502 = $1409 + ((Math_imul(($$121507 | 0) / ($102 | 0) | 0, $2) | 0) + (($$141488 | 0) / ($101 | 0) | 0) << 2) | 0;\n      HEAP32[$1502 >> 2] = (HEAP32[$1502 >> 2] | 0) + ((((HEAPU8[$4 + ($1483 + 1) >> 0] | 0) + (HEAPU8[$4 + $1483 >> 0] | 0) + (HEAPU8[$4 + ($1483 + 2) >> 0] | 0) | 0) >>> 0) / 3 | 0);\n     }\n     $$141488 = $$141488 + 1 | 0;\n    }\n    $$121507 = $$121507 + 1 | 0;\n   }\n  } else {\n   if (($7 | 1 | 0) == 3) {\n    $1509 = $105 + 100.0;\n    $1510 = +($$31471 | 0);\n    $1511 = +($spec$select1520 | 0);\n    $1512 = $14 + 48 | 0;\n    $1513 = $14 + 56 | 0;\n    $1514 = $14 + 64 | 0;\n    $1515 = $14 + 8 | 0;\n    $1516 = $14 + 16 | 0;\n    $1517 = $14 + 24 | 0;\n    $1518 = $14 + 32 | 0;\n    $1519 = $14 + 40 | 0;\n    $1520 = ($0 | 0) == 1;\n    $$131508 = 0;\n    while (1) {\n     if (($$131508 | 0) >= ($$31471 | 0)) break L239;\n     $1526 = $1509 + $106 * (+($$131508 | 0) + .5) / $1510;\n     $$151489 = 0;\n     while (1) {\n      if (($$151489 | 0) >= ($spec$select1520 | 0)) break;\n      $1532 = $1509 + $106 * (+($$151489 | 0) + .5) / $1511;\n      $1539 = +HEAPF64[$1514 >> 3] + ($1532 * +HEAPF64[$1512 >> 3] + $1526 * +HEAPF64[$1513 >> 3]);\n      if ($1539 == 0.0) {\n       $2263 = $1409;\n       label = 306;\n       break L19;\n      }\n      $1549 = (+HEAPF64[$1516 >> 3] + ($1532 * +HEAPF64[$14 >> 3] + $1526 * +HEAPF64[$1515 >> 3])) / $1539;\n      HEAPF32[$15 >> 2] = $1549;\n      $1558 = (+HEAPF64[$1519 >> 3] + ($1532 * +HEAPF64[$1517 >> 3] + $1526 * +HEAPF64[$1518 >> 3])) / $1539;\n      HEAPF32[$16 >> 2] = $1558;\n      _arParamIdeal2ObservLTf($8, $1549, $1558, $15, $16) | 0;\n      $1559 = +HEAPF32[$15 >> 2];\n      if ($1520) {\n       $$13 = ((~~($1559 + 1.0) | 0) / 2 | 0) << 1;\n       $$131456 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$13 = ~~($1559 + .5);\n       $$131456 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$13 | 0) > -1) if (($$131456 | 0) < ($6 | 0) & (($$131456 | 0) > -1 & ($$13 | 0) < ($5 | 0))) {\n       $1580 = (Math_imul($$131456, $5) | 0) + $$13 << 2;\n       $1599 = $1409 + ((Math_imul(($$131508 | 0) / ($102 | 0) | 0, $2) | 0) + (($$151489 | 0) / ($101 | 0) | 0) << 2) | 0;\n       HEAP32[$1599 >> 2] = (HEAP32[$1599 >> 2] | 0) + ((((HEAPU8[$4 + ($1580 | 1) >> 0] | 0) + (HEAPU8[$4 + $1580 >> 0] | 0) + (HEAPU8[$4 + ($1580 | 2) >> 0] | 0) | 0) >>> 0) / 3 | 0);\n      }\n      $$151489 = $$151489 + 1 | 0;\n     }\n     $$131508 = $$131508 + 1 | 0;\n    }\n   }\n   if (($7 | 2 | 0) == 6) {\n    $1606 = $105 + 100.0;\n    $1607 = +($$31471 | 0);\n    $1608 = +($spec$select1520 | 0);\n    $1609 = $14 + 48 | 0;\n    $1610 = $14 + 56 | 0;\n    $1611 = $14 + 64 | 0;\n    $1612 = $14 + 8 | 0;\n    $1613 = $14 + 16 | 0;\n    $1614 = $14 + 24 | 0;\n    $1615 = $14 + 32 | 0;\n    $1616 = $14 + 40 | 0;\n    $1617 = ($0 | 0) == 1;\n    $$141509 = 0;\n    while (1) {\n     if (($$141509 | 0) >= ($$31471 | 0)) break L239;\n     $1623 = $1606 + $106 * (+($$141509 | 0) + .5) / $1607;\n     $$161490 = 0;\n     while (1) {\n      if (($$161490 | 0) >= ($spec$select1520 | 0)) break;\n      $1629 = $1606 + $106 * (+($$161490 | 0) + .5) / $1608;\n      $1636 = +HEAPF64[$1611 >> 3] + ($1629 * +HEAPF64[$1609 >> 3] + $1623 * +HEAPF64[$1610 >> 3]);\n      if ($1636 == 0.0) {\n       $2263 = $1409;\n       label = 306;\n       break L19;\n      }\n      $1646 = (+HEAPF64[$1613 >> 3] + ($1629 * +HEAPF64[$14 >> 3] + $1623 * +HEAPF64[$1612 >> 3])) / $1636;\n      HEAPF32[$15 >> 2] = $1646;\n      $1655 = (+HEAPF64[$1616 >> 3] + ($1629 * +HEAPF64[$1614 >> 3] + $1623 * +HEAPF64[$1615 >> 3])) / $1636;\n      HEAPF32[$16 >> 2] = $1655;\n      _arParamIdeal2ObservLTf($8, $1646, $1655, $15, $16) | 0;\n      $1656 = +HEAPF32[$15 >> 2];\n      if ($1617) {\n       $$14 = ((~~($1656 + 1.0) | 0) / 2 | 0) << 1;\n       $$141457 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n      } else {\n       $$14 = ~~($1656 + .5);\n       $$141457 = ~~(+HEAPF32[$16 >> 2] + .5);\n      }\n      if (($$14 | 0) > -1) if (($$141457 | 0) < ($6 | 0) & (($$141457 | 0) > -1 & ($$14 | 0) < ($5 | 0))) {\n       $1677 = (Math_imul($$141457, $5) | 0) + $$14 << 2;\n       $1697 = $1409 + ((Math_imul(($$141509 | 0) / ($102 | 0) | 0, $2) | 0) + (($$161490 | 0) / ($101 | 0) | 0) << 2) | 0;\n       HEAP32[$1697 >> 2] = (HEAP32[$1697 >> 2] | 0) + ((((HEAPU8[$4 + ($1677 | 2) >> 0] | 0) + (HEAPU8[$4 + ($1677 | 1) >> 0] | 0) + (HEAPU8[$4 + ($1677 | 3) >> 0] | 0) | 0) >>> 0) / 3 | 0);\n      }\n      $$161490 = $$161490 + 1 | 0;\n     }\n     $$141509 = $$141509 + 1 | 0;\n    }\n   }\n   switch ($7 | 0) {\n   case 5:\n   case 12:\n   case 13:\n   case 14:\n    {\n     $1702 = $105 + 100.0;\n     $1703 = +($$31471 | 0);\n     $1704 = +($spec$select1520 | 0);\n     $1705 = $14 + 48 | 0;\n     $1706 = $14 + 56 | 0;\n     $1707 = $14 + 64 | 0;\n     $1708 = $14 + 8 | 0;\n     $1709 = $14 + 16 | 0;\n     $1710 = $14 + 24 | 0;\n     $1711 = $14 + 32 | 0;\n     $1712 = $14 + 40 | 0;\n     $1713 = ($0 | 0) == 1;\n     $$151510 = 0;\n     while (1) {\n      if (($$151510 | 0) >= ($$31471 | 0)) break L239;\n      $1719 = $1702 + $106 * (+($$151510 | 0) + .5) / $1703;\n      $$171491 = 0;\n      while (1) {\n       if (($$171491 | 0) >= ($spec$select1520 | 0)) break;\n       $1725 = $1702 + $106 * (+($$171491 | 0) + .5) / $1704;\n       $1732 = +HEAPF64[$1707 >> 3] + ($1725 * +HEAPF64[$1705 >> 3] + $1719 * +HEAPF64[$1706 >> 3]);\n       if ($1732 == 0.0) {\n        $2263 = $1409;\n        label = 306;\n        break L19;\n       }\n       $1742 = (+HEAPF64[$1709 >> 3] + ($1725 * +HEAPF64[$14 >> 3] + $1719 * +HEAPF64[$1708 >> 3])) / $1732;\n       HEAPF32[$15 >> 2] = $1742;\n       $1751 = (+HEAPF64[$1712 >> 3] + ($1725 * +HEAPF64[$1710 >> 3] + $1719 * +HEAPF64[$1711 >> 3])) / $1732;\n       HEAPF32[$16 >> 2] = $1751;\n       _arParamIdeal2ObservLTf($8, $1742, $1751, $15, $16) | 0;\n       $1752 = +HEAPF32[$15 >> 2];\n       if ($1713) {\n        $$15 = ((~~($1752 + 1.0) | 0) / 2 | 0) << 1;\n        $$151458 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n       } else {\n        $$15 = ~~($1752 + .5);\n        $$151458 = ~~(+HEAPF32[$16 >> 2] + .5);\n       }\n       if (($$15 | 0) > -1) if (($$151458 | 0) < ($6 | 0) & (($$151458 | 0) > -1 & ($$15 | 0) < ($5 | 0))) {\n        $1773 = $4 + ((Math_imul($$151458, $5) | 0) + $$15) | 0;\n        $1780 = $1409 + ((Math_imul(($$151510 | 0) / ($102 | 0) | 0, $2) | 0) + (($$171491 | 0) / ($101 | 0) | 0) << 2) | 0;\n        HEAP32[$1780 >> 2] = (HEAP32[$1780 >> 2] | 0) + (HEAPU8[$1773 >> 0] | 0);\n       }\n       $$171491 = $$171491 + 1 | 0;\n      }\n      $$151510 = $$151510 + 1 | 0;\n     }\n     break;\n    }\n   case 7:\n    {\n     $1785 = $105 + 100.0;\n     $1786 = +($$31471 | 0);\n     $1787 = +($spec$select1520 | 0);\n     $1788 = $14 + 48 | 0;\n     $1789 = $14 + 56 | 0;\n     $1790 = $14 + 64 | 0;\n     $1791 = $14 + 8 | 0;\n     $1792 = $14 + 16 | 0;\n     $1793 = $14 + 24 | 0;\n     $1794 = $14 + 32 | 0;\n     $1795 = $14 + 40 | 0;\n     $1796 = ($0 | 0) == 1;\n     $$161511 = 0;\n     while (1) {\n      if (($$161511 | 0) >= ($$31471 | 0)) break L239;\n      $1802 = $1785 + $106 * (+($$161511 | 0) + .5) / $1786;\n      $$181492 = 0;\n      while (1) {\n       if (($$181492 | 0) >= ($spec$select1520 | 0)) break;\n       $1808 = $1785 + $106 * (+($$181492 | 0) + .5) / $1787;\n       $1815 = +HEAPF64[$1790 >> 3] + ($1808 * +HEAPF64[$1788 >> 3] + $1802 * +HEAPF64[$1789 >> 3]);\n       if ($1815 == 0.0) {\n        $2263 = $1409;\n        label = 306;\n        break L19;\n       }\n       $1825 = (+HEAPF64[$1792 >> 3] + ($1808 * +HEAPF64[$14 >> 3] + $1802 * +HEAPF64[$1791 >> 3])) / $1815;\n       HEAPF32[$15 >> 2] = $1825;\n       $1834 = (+HEAPF64[$1795 >> 3] + ($1808 * +HEAPF64[$1793 >> 3] + $1802 * +HEAPF64[$1794 >> 3])) / $1815;\n       HEAPF32[$16 >> 2] = $1834;\n       _arParamIdeal2ObservLTf($8, $1825, $1834, $15, $16) | 0;\n       $1835 = +HEAPF32[$15 >> 2];\n       if ($1796) {\n        $$16 = ((~~($1835 + 1.0) | 0) / 2 | 0) << 1;\n        $$161459 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n       } else {\n        $$16 = ~~($1835 + .5);\n        $$161459 = ~~(+HEAPF32[$16 >> 2] + .5);\n       }\n       if (($$16 | 0) > -1) if (($$161459 | 0) < ($6 | 0) & (($$161459 | 0) > -1 & ($$16 | 0) < ($5 | 0))) {\n        $1858 = $4 + ((Math_imul($$161459, $5) | 0) + $$16 << 1 | 1) | 0;\n        $1865 = $1409 + ((Math_imul(($$161511 | 0) / ($102 | 0) | 0, $2) | 0) + (($$181492 | 0) / ($101 | 0) | 0) << 2) | 0;\n        HEAP32[$1865 >> 2] = (HEAP32[$1865 >> 2] | 0) + (HEAPU8[$1858 >> 0] | 0);\n       }\n       $$181492 = $$181492 + 1 | 0;\n      }\n      $$161511 = $$161511 + 1 | 0;\n     }\n     break;\n    }\n   case 8:\n    {\n     $1870 = $105 + 100.0;\n     $1871 = +($$31471 | 0);\n     $1872 = +($spec$select1520 | 0);\n     $1873 = $14 + 48 | 0;\n     $1874 = $14 + 56 | 0;\n     $1875 = $14 + 64 | 0;\n     $1876 = $14 + 8 | 0;\n     $1877 = $14 + 16 | 0;\n     $1878 = $14 + 24 | 0;\n     $1879 = $14 + 32 | 0;\n     $1880 = $14 + 40 | 0;\n     $1881 = ($0 | 0) == 1;\n     $$171512 = 0;\n     while (1) {\n      if (($$171512 | 0) >= ($$31471 | 0)) break L239;\n      $1887 = $1870 + $106 * (+($$171512 | 0) + .5) / $1871;\n      $$191493 = 0;\n      while (1) {\n       if (($$191493 | 0) >= ($spec$select1520 | 0)) break;\n       $1893 = $1870 + $106 * (+($$191493 | 0) + .5) / $1872;\n       $1900 = +HEAPF64[$1875 >> 3] + ($1893 * +HEAPF64[$1873 >> 3] + $1887 * +HEAPF64[$1874 >> 3]);\n       if ($1900 == 0.0) {\n        $2263 = $1409;\n        label = 306;\n        break L19;\n       }\n       $1910 = (+HEAPF64[$1877 >> 3] + ($1893 * +HEAPF64[$14 >> 3] + $1887 * +HEAPF64[$1876 >> 3])) / $1900;\n       HEAPF32[$15 >> 2] = $1910;\n       $1919 = (+HEAPF64[$1880 >> 3] + ($1893 * +HEAPF64[$1878 >> 3] + $1887 * +HEAPF64[$1879 >> 3])) / $1900;\n       HEAPF32[$16 >> 2] = $1919;\n       _arParamIdeal2ObservLTf($8, $1910, $1919, $15, $16) | 0;\n       $1920 = +HEAPF32[$15 >> 2];\n       if ($1881) {\n        $$17 = ((~~($1920 + 1.0) | 0) / 2 | 0) << 1;\n        $$171460 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n       } else {\n        $$17 = ~~($1920 + .5);\n        $$171460 = ~~(+HEAPF32[$16 >> 2] + .5);\n       }\n       if (($$17 | 0) > -1) if (($$171460 | 0) < ($6 | 0) & (($$171460 | 0) > -1 & ($$17 | 0) < ($5 | 0))) {\n        $1942 = $4 + ((Math_imul($$171460, $5) | 0) + $$17 << 1) | 0;\n        $1949 = $1409 + ((Math_imul(($$171512 | 0) / ($102 | 0) | 0, $2) | 0) + (($$191493 | 0) / ($101 | 0) | 0) << 2) | 0;\n        HEAP32[$1949 >> 2] = (HEAP32[$1949 >> 2] | 0) + (HEAPU8[$1942 >> 0] | 0);\n       }\n       $$191493 = $$191493 + 1 | 0;\n      }\n      $$171512 = $$171512 + 1 | 0;\n     }\n     break;\n    }\n   case 9:\n    {\n     $1954 = $105 + 100.0;\n     $1955 = +($$31471 | 0);\n     $1956 = +($spec$select1520 | 0);\n     $1957 = $14 + 48 | 0;\n     $1958 = $14 + 56 | 0;\n     $1959 = $14 + 64 | 0;\n     $1960 = $14 + 8 | 0;\n     $1961 = $14 + 16 | 0;\n     $1962 = $14 + 24 | 0;\n     $1963 = $14 + 32 | 0;\n     $1964 = $14 + 40 | 0;\n     $1965 = ($0 | 0) == 1;\n     $$181513 = 0;\n     while (1) {\n      if (($$181513 | 0) >= ($$31471 | 0)) break L239;\n      $1971 = $1954 + $106 * (+($$181513 | 0) + .5) / $1955;\n      $$201494 = 0;\n      while (1) {\n       if (($$201494 | 0) >= ($spec$select1520 | 0)) break;\n       $1977 = $1954 + $106 * (+($$201494 | 0) + .5) / $1956;\n       $1984 = +HEAPF64[$1959 >> 3] + ($1977 * +HEAPF64[$1957 >> 3] + $1971 * +HEAPF64[$1958 >> 3]);\n       if ($1984 == 0.0) {\n        $2263 = $1409;\n        label = 306;\n        break L19;\n       }\n       $1994 = (+HEAPF64[$1961 >> 3] + ($1977 * +HEAPF64[$14 >> 3] + $1971 * +HEAPF64[$1960 >> 3])) / $1984;\n       HEAPF32[$15 >> 2] = $1994;\n       $2003 = (+HEAPF64[$1964 >> 3] + ($1977 * +HEAPF64[$1962 >> 3] + $1971 * +HEAPF64[$1963 >> 3])) / $1984;\n       HEAPF32[$16 >> 2] = $2003;\n       _arParamIdeal2ObservLTf($8, $1994, $2003, $15, $16) | 0;\n       $2004 = +HEAPF32[$15 >> 2];\n       if ($1965) {\n        $$18 = ((~~($2004 + 1.0) | 0) / 2 | 0) << 1;\n        $$181461 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n       } else {\n        $$18 = ~~($2004 + .5);\n        $$181461 = ~~(+HEAPF32[$16 >> 2] + .5);\n       }\n       if (($$18 | 0) > -1) if (($$181461 | 0) < ($6 | 0) & (($$181461 | 0) > -1 & ($$18 | 0) < ($5 | 0))) {\n        $2025 = (Math_imul($$181461, $5) | 0) + $$18 << 1;\n        $2028 = HEAPU8[$4 + $2025 >> 0] | 0;\n        $2036 = HEAPU8[$4 + ($2025 | 1) >> 0] | 0;\n        $2051 = $1409 + ((Math_imul(($$181513 | 0) / ($102 | 0) | 0, $2) | 0) + (($$201494 | 0) / ($101 | 0) | 0) << 2) | 0;\n        HEAP32[$2051 >> 2] = (((($2028 << 5 & 224 | $2036 >>> 3 & 28 | 2) + ($2028 & 248 | 4) + ($2036 << 3 & 248 | 4) | 0) >>> 0) / 3 | 0) + (HEAP32[$2051 >> 2] | 0);\n       }\n       $$201494 = $$201494 + 1 | 0;\n      }\n      $$181513 = $$181513 + 1 | 0;\n     }\n     break;\n    }\n   case 10:\n    {\n     $2056 = $105 + 100.0;\n     $2057 = +($$31471 | 0);\n     $2058 = +($spec$select1520 | 0);\n     $2059 = $14 + 48 | 0;\n     $2060 = $14 + 56 | 0;\n     $2061 = $14 + 64 | 0;\n     $2062 = $14 + 8 | 0;\n     $2063 = $14 + 16 | 0;\n     $2064 = $14 + 24 | 0;\n     $2065 = $14 + 32 | 0;\n     $2066 = $14 + 40 | 0;\n     $2067 = ($0 | 0) == 1;\n     $$191514 = 0;\n     while (1) {\n      if (($$191514 | 0) >= ($$31471 | 0)) break L239;\n      $2073 = $2056 + $106 * (+($$191514 | 0) + .5) / $2057;\n      $$21 = 0;\n      while (1) {\n       if (($$21 | 0) >= ($spec$select1520 | 0)) break;\n       $2079 = $2056 + $106 * (+($$21 | 0) + .5) / $2058;\n       $2086 = +HEAPF64[$2061 >> 3] + ($2079 * +HEAPF64[$2059 >> 3] + $2073 * +HEAPF64[$2060 >> 3]);\n       if ($2086 == 0.0) {\n        $2263 = $1409;\n        label = 306;\n        break L19;\n       }\n       $2096 = (+HEAPF64[$2063 >> 3] + ($2079 * +HEAPF64[$14 >> 3] + $2073 * +HEAPF64[$2062 >> 3])) / $2086;\n       HEAPF32[$15 >> 2] = $2096;\n       $2105 = (+HEAPF64[$2066 >> 3] + ($2079 * +HEAPF64[$2064 >> 3] + $2073 * +HEAPF64[$2065 >> 3])) / $2086;\n       HEAPF32[$16 >> 2] = $2105;\n       _arParamIdeal2ObservLTf($8, $2096, $2105, $15, $16) | 0;\n       $2106 = +HEAPF32[$15 >> 2];\n       if ($2067) {\n        $$19 = ((~~($2106 + 1.0) | 0) / 2 | 0) << 1;\n        $$191462 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n       } else {\n        $$19 = ~~($2106 + .5);\n        $$191462 = ~~(+HEAPF32[$16 >> 2] + .5);\n       }\n       if (($$19 | 0) > -1) if (($$191462 | 0) < ($6 | 0) & (($$191462 | 0) > -1 & ($$19 | 0) < ($5 | 0))) {\n        $2127 = (Math_imul($$191462, $5) | 0) + $$19 << 1;\n        $2130 = HEAPU8[$4 + $2127 >> 0] | 0;\n        $2138 = HEAPU8[$4 + ($2127 | 1) >> 0] | 0;\n        $2153 = $1409 + ((Math_imul(($$191514 | 0) / ($102 | 0) | 0, $2) | 0) + (($$21 | 0) / ($101 | 0) | 0) << 2) | 0;\n        HEAP32[$2153 >> 2] = (((($2130 << 5 & 224 | $2138 >>> 3 & 24 | 4) + ($2130 & 248 | 4) + ($2138 << 2 & 248 | 4) | 0) >>> 0) / 3 | 0) + (HEAP32[$2153 >> 2] | 0);\n       }\n       $$21 = $$21 + 1 | 0;\n      }\n      $$191514 = $$191514 + 1 | 0;\n     }\n     break;\n    }\n   case 11:\n    {\n     $2158 = $105 + 100.0;\n     $2159 = +($$31471 | 0);\n     $2160 = +($spec$select1520 | 0);\n     $2161 = $14 + 48 | 0;\n     $2162 = $14 + 56 | 0;\n     $2163 = $14 + 64 | 0;\n     $2164 = $14 + 8 | 0;\n     $2165 = $14 + 16 | 0;\n     $2166 = $14 + 24 | 0;\n     $2167 = $14 + 32 | 0;\n     $2168 = $14 + 40 | 0;\n     $2169 = ($0 | 0) == 1;\n     $$201515 = 0;\n     while (1) {\n      if (($$201515 | 0) >= ($$31471 | 0)) break L239;\n      $2175 = $2158 + $106 * (+($$201515 | 0) + .5) / $2159;\n      $$22 = 0;\n      while (1) {\n       if (($$22 | 0) >= ($spec$select1520 | 0)) break;\n       $2181 = $2158 + $106 * (+($$22 | 0) + .5) / $2160;\n       $2188 = +HEAPF64[$2163 >> 3] + ($2181 * +HEAPF64[$2161 >> 3] + $2175 * +HEAPF64[$2162 >> 3]);\n       if ($2188 == 0.0) {\n        $2263 = $1409;\n        label = 306;\n        break L19;\n       }\n       $2198 = (+HEAPF64[$2165 >> 3] + ($2181 * +HEAPF64[$14 >> 3] + $2175 * +HEAPF64[$2164 >> 3])) / $2188;\n       HEAPF32[$15 >> 2] = $2198;\n       $2207 = (+HEAPF64[$2168 >> 3] + ($2181 * +HEAPF64[$2166 >> 3] + $2175 * +HEAPF64[$2167 >> 3])) / $2188;\n       HEAPF32[$16 >> 2] = $2207;\n       _arParamIdeal2ObservLTf($8, $2198, $2207, $15, $16) | 0;\n       $2208 = +HEAPF32[$15 >> 2];\n       if ($2169) {\n        $$20 = ((~~($2208 + 1.0) | 0) / 2 | 0) << 1;\n        $$201463 = ((~~(+HEAPF32[$16 >> 2] + 1.0) | 0) / 2 | 0) << 1;\n       } else {\n        $$20 = ~~($2208 + .5);\n        $$201463 = ~~(+HEAPF32[$16 >> 2] + .5);\n       }\n       if (($$20 | 0) > -1) if (($$201463 | 0) < ($6 | 0) & (($$201463 | 0) > -1 & ($$20 | 0) < ($5 | 0))) {\n        $2229 = (Math_imul($$201463, $5) | 0) + $$20 << 1;\n        $2232 = HEAPU8[$4 + $2229 >> 0] | 0;\n        $2251 = $1409 + ((Math_imul(($$201515 | 0) / ($102 | 0) | 0, $2) | 0) + (($$22 | 0) / ($101 | 0) | 0) << 2) | 0;\n        HEAP32[$2251 >> 2] = (((($2232 << 4 & 240 | 8) + ($2232 & 240 | 8) + ((HEAP8[$4 + ($2229 | 1) >> 0] & -16 | 8) & 255) | 0) >>> 0) / 3 | 0) + (HEAP32[$2251 >> 2] | 0);\n       }\n       $$22 = $$22 + 1 | 0;\n      }\n      $$201515 = $$201515 + 1 | 0;\n     }\n     break;\n    }\n   default:\n    {\n     _arLog(0, 3, 4174, $vararg_buffer5);\n     $2263 = $1409;\n     label = 306;\n     break L19;\n    }\n   }\n  } while (0);\n  $2256 = Math_imul($102, $101) | 0;\n  $$23 = 0;\n  while (1) {\n   if (($$23 | 0) == ($108 | 0)) break;\n   HEAP8[$11 + $$23 >> 0] = ((HEAP32[$1409 + ($$23 << 2) >> 2] | 0) >>> 0) / ($2256 >>> 0) | 0;\n   $$23 = $$23 + 1 | 0;\n  }\n  _free($1409);\n  $$0 = 0;\n } while (0);\n if ((label | 0) == 306) {\n  _free($2263);\n  $$0 = -1;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i = 0, $$0$i$i$add$i = 0, $$0$i$i$add$i630 = 0, $$0$i$i$add$i649 = 0, $$0$i$i$add$i653 = 0, $$0$i$i$add$i677 = 0, $$0$i$i$add$i681 = 0, $$0$i$i$add$i685 = 0, $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i$i615 = 0, $$0$i$i$i599 = 0, $$0$i$i$i605 = 0, $$0$i$i$i609 = 0, $$0$i$i$i618 = 0, $$0$i$i$i622 = 0, $$0$i$i$i625 = 0, $$0$i$i$i633 = 0, $$0$i$i$i636 = 0, $$0$i$i$i640 = 0, $$0$i$i$i644 = 0, $$0$i$i$i656 = 0, $$0$i$i$i660 = 0, $$0$i$i$i664 = 0, $$0$i$i$i668 = 0, $$0$i$i$i672 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i629 = 0, $$0$i$i$idx$i648 = 0, $$0$i$i$idx$i652 = 0, $$0$i$i$idx$i676 = 0, $$0$i$i$idx$i680 = 0, $$0$i$i$idx$i684 = 0, $$0$i$i602 = 0, $$0503 = 0, $$0504$off0 = 0, $$14 = 0, $10 = 0, $101 = 0, $102 = 0, $103 = 0, $106 = 0, $11 = 0, $111 = 0, $113 = 0, $115 = 0, $116 = 0, $119 = 0, $12 = 0, $13 = 0, $131 = 0, $132 = 0, $14 = 0, $142 = 0, $143 = 0, $144 = 0, $147 = 0, $15 = 0, $154 = 0, $156 = 0, $158 = 0, $16 = 0, $160 = 0, $165 = 0, $167 = 0, $169 = 0, $171 = 0, $173 = 0, $175 = 0, $18 = 0, $180 = 0, $182 = 0, $184 = 0, $186 = 0, $191 = 0, $192 = 0, $194 = 0, $196 = 0, $197 = 0, $204 = 0, $212 = 0, $213 = 0, $228 = 0, $234 = 0, $236 = 0, $238 = 0, $240 = 0, $242 = 0, $244 = 0, $246 = 0, $248 = 0, $25 = 0, $253 = 0, $255 = 0, $257 = 0, $259 = 0, $261 = 0, $263 = 0, $265 = 0, $267 = 0, $269 = 0, $273 = 0, $275 = 0, $277 = 0, $280 = 0, $281 = 0, $296 = 0, $298 = 0, $3 = 0, $300 = 0, $302 = 0, $304 = 0, $306 = 0, $308 = 0, $309 = 0, $315 = 0, $317 = 0, $319 = 0, $321 = 0, $323 = 0, $325 = 0, $330 = 0, $332 = 0, $334 = 0, $336 = 0, $338 = 0, $340 = 0, $342 = 0, $346 = 0, $348 = 0, $35 = 0, $350 = 0, $353 = 0, $354 = 0, $365 = 0, $367 = 0, $37 = 0, $373 = 0, $374 = 0, $376 = 0, $378 = 0, $380 = 0, $381 = 0, $388 = 0, $39 = 0, $392 = 0, $4 = 0, $400 = 0, $401 = 0, $41 = 0, $415 = 0, $416 = 0, $43 = 0, $431 = 0, $433 = 0, $436 = 0, $437 = 0, $444 = 0, $446 = 0, $448 = 0, $45 = 0, $450 = 0, $452 = 0, $454 = 0, $456 = 0, $458 = 0, $47 = 0, $480 = 0, $481 = 0, $49 = 0, $5 = 0, $51 = 0, $53 = 0, $6 = 0, $62 = 0, $64 = 0, $66 = 0, $68 = 0, $7 = 0, $74 = 0, $75 = 0, $78 = 0, $8 = 0, $9 = 0, $90 = 0, $91 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 208 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(208);\n $3 = sp + 176 | 0;\n $4 = sp + 112 | 0;\n $5 = sp + 88 | 0;\n $6 = sp + 64 | 0;\n $7 = sp + 48 | 0;\n $8 = sp + 160 | 0;\n $9 = sp + 36 | 0;\n $10 = sp + 148 | 0;\n $11 = sp + 136 | 0;\n $12 = sp + 124 | 0;\n $13 = sp + 24 | 0;\n $14 = sp + 12 | 0;\n $15 = sp;\n $16 = $1;\n $18 = $16 - $0 | 0;\n L1 : do if (($18 | 0) > 1) {\n  if (($18 | 0) > 3) if ((HEAP8[$0 >> 0] | 0) == 103) {\n   $25 = (HEAP8[$0 + 1 >> 0] | 0) == 115;\n   $$0503 = $25 ? $0 + 2 | 0 : $0;\n   $$0504$off0 = $25;\n  } else {\n   $$0503 = $0;\n   $$0504$off0 = 0;\n  } else {\n   $$0503 = $0;\n   $$0504$off0 = 0;\n  }\n  do switch (HEAP8[$$0503 >> 0] | 0) {\n  case 76:\n   {\n    $$14 = __ZN10__cxxabiv112_GLOBAL__N_118parse_expr_primaryINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n    break L1;\n    break;\n   }\n  case 84:\n   {\n    $$14 = __ZN10__cxxabiv112_GLOBAL__N_120parse_template_paramINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n    break L1;\n    break;\n   }\n  case 102:\n   {\n    $$14 = __ZN10__cxxabiv112_GLOBAL__N_120parse_function_paramINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n    break L1;\n    break;\n   }\n  case 97:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 97:\n     {\n      $35 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15121, __ZNSt3__211char_traitsIcE6lengthEPKc(15121) | 0);\n      $37 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($35, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($37 | 0) == ($35 | 0) ? $0 : $37;\n      break L1;\n      break;\n     }\n    case 100:\n     {\n      $39 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15139, __ZNSt3__211char_traitsIcE6lengthEPKc(15139) | 0);\n      $41 = __ZN10__cxxabiv112_GLOBAL__N_123parse_prefix_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($39, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($41 | 0) == ($39 | 0) ? $0 : $41;\n      break L1;\n      break;\n     }\n    case 110:\n     {\n      $43 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15139, __ZNSt3__211char_traitsIcE6lengthEPKc(15139) | 0);\n      $45 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($43, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($45 | 0) == ($43 | 0) ? $0 : $45;\n      break L1;\n      break;\n     }\n    case 78:\n     {\n      $47 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15182, __ZNSt3__211char_traitsIcE6lengthEPKc(15182) | 0);\n      $49 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($47, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($49 | 0) == ($47 | 0) ? $0 : $49;\n      break L1;\n      break;\n     }\n    case 83:\n     {\n      $51 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15185, __ZNSt3__211char_traitsIcE6lengthEPKc(15185) | 0);\n      $53 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($51, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($53 | 0) == ($51 | 0) ? $0 : $53;\n      break L1;\n      break;\n     }\n    case 116:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_118parse_alignof_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 122:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_118parse_alignof_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 99:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 99:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_121parse_const_cast_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 108:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_115parse_call_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 109:\n     {\n      $62 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15187, __ZNSt3__211char_traitsIcE6lengthEPKc(15187) | 0);\n      $64 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($62, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($64 | 0) == ($62 | 0) ? $0 : $64;\n      break L1;\n      break;\n     }\n    case 111:\n     {\n      $66 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15189, __ZNSt3__211char_traitsIcE6lengthEPKc(15189) | 0);\n      $68 = __ZN10__cxxabiv112_GLOBAL__N_123parse_prefix_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($66, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($68 | 0) == ($66 | 0) ? $0 : $68;\n      break L1;\n      break;\n     }\n    case 118:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_121parse_conversion_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 100:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 97:\n     {\n      $74 = $$0503 + 2 | 0;\n      $75 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($74, $1, $2) | 0;\n      if (($75 | 0) == ($74 | 0)) {\n       $$14 = $0;\n       break L1;\n      }\n      $78 = $2 + 4 | 0;\n      if ((HEAP32[$2 >> 2] | 0) == (HEAP32[$78 >> 2] | 0)) {\n       $$14 = $0;\n       break L1;\n      };\n      HEAP32[$6 >> 2] = 0;\n      HEAP32[$6 + 4 >> 2] = 0;\n      HEAP32[$6 + 8 >> 2] = 0;\n      L32 : do if ($$0504$off0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($6, 15191, __ZNSt3__211char_traitsIcE6lengthEPKc(15191) | 0); else {\n       $$0$i$i = 0;\n       while (1) {\n        if (($$0$i$i | 0) == 3) break L32;\n        HEAP32[$6 + ($$0$i$i << 2) >> 2] = 0;\n        $$0$i$i = $$0$i$i + 1 | 0;\n       }\n      } while (0);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15194) | 0;\n      HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n      HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n      HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n      $$0$i$i$i = 0;\n      while (1) {\n       if (($$0$i$i$i | 0) == 3) break;\n       HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n       $$0$i$i$i = $$0$i$i$i + 1 | 0;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($7, (HEAP32[$78 >> 2] | 0) + -24 | 0);\n      $90 = HEAP8[$7 + 11 >> 0] | 0;\n      $91 = $90 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($5, $91 ? HEAP32[$7 >> 2] | 0 : $7, $91 ? HEAP32[$7 + 4 >> 2] | 0 : $90 & 255) | 0;\n      HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n      HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n      $$0$i$i$i599 = 0;\n      while (1) {\n       if (($$0$i$i$i599 | 0) == 3) break;\n       HEAP32[$5 + ($$0$i$i$i599 << 2) >> 2] = 0;\n       $$0$i$i$i599 = $$0$i$i$i599 + 1 | 0;\n      }\n      $101 = HEAP32[$78 >> 2] | 0;\n      $102 = $101 + -24 | 0;\n      $103 = $102 + 11 | 0;\n      if ((HEAP8[$103 >> 0] | 0) < 0) {\n       $106 = HEAP32[$102 >> 2] | 0;\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($106, $3);\n       HEAP32[$101 + -20 >> 2] = 0;\n      } else {\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($102, $3);\n       HEAP8[$103 >> 0] = 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($102);\n      HEAP32[$102 >> 2] = HEAP32[$4 >> 2];\n      HEAP32[$102 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n      HEAP32[$102 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n      $$0$i$i$i$i = 0;\n      while (1) {\n       if (($$0$i$i$i$i | 0) == 3) break;\n       HEAP32[$4 + ($$0$i$i$i$i << 2) >> 2] = 0;\n       $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n      $$14 = $75;\n      break L1;\n      break;\n     }\n    case 99:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_123parse_dynamic_cast_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 101:\n     {\n      $111 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15137, __ZNSt3__211char_traitsIcE6lengthEPKc(15137) | 0);\n      $113 = __ZN10__cxxabiv112_GLOBAL__N_123parse_prefix_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($111, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($113 | 0) == ($111 | 0) ? $0 : $113;\n      break L1;\n      break;\n     }\n    case 108:\n     {\n      $115 = $$0503 + 2 | 0;\n      $116 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($115, $1, $2) | 0;\n      if (($116 | 0) == ($115 | 0)) {\n       $$14 = $0;\n       break L1;\n      }\n      $119 = $2 + 4 | 0;\n      if ((HEAP32[$2 >> 2] | 0) == (HEAP32[$119 >> 2] | 0)) {\n       $$14 = $0;\n       break L1;\n      };\n      HEAP32[$6 >> 2] = 0;\n      HEAP32[$6 + 4 >> 2] = 0;\n      HEAP32[$6 + 8 >> 2] = 0;\n      L60 : do if ($$0504$off0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($6, 15191, __ZNSt3__211char_traitsIcE6lengthEPKc(15191) | 0); else {\n       $$0$i$i602 = 0;\n       while (1) {\n        if (($$0$i$i602 | 0) == 3) break L60;\n        HEAP32[$6 + ($$0$i$i602 << 2) >> 2] = 0;\n        $$0$i$i602 = $$0$i$i602 + 1 | 0;\n       }\n      } while (0);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15204) | 0;\n      HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n      HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n      HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n      $$0$i$i$i605 = 0;\n      while (1) {\n       if (($$0$i$i$i605 | 0) == 3) break;\n       HEAP32[$6 + ($$0$i$i$i605 << 2) >> 2] = 0;\n       $$0$i$i$i605 = $$0$i$i$i605 + 1 | 0;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($7, (HEAP32[$119 >> 2] | 0) + -24 | 0);\n      $131 = HEAP8[$7 + 11 >> 0] | 0;\n      $132 = $131 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($5, $132 ? HEAP32[$7 >> 2] | 0 : $7, $132 ? HEAP32[$7 + 4 >> 2] | 0 : $131 & 255) | 0;\n      HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n      HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n      $$0$i$i$i609 = 0;\n      while (1) {\n       if (($$0$i$i$i609 | 0) == 3) break;\n       HEAP32[$5 + ($$0$i$i$i609 << 2) >> 2] = 0;\n       $$0$i$i$i609 = $$0$i$i$i609 + 1 | 0;\n      }\n      $142 = HEAP32[$119 >> 2] | 0;\n      $143 = $142 + -24 | 0;\n      $144 = $143 + 11 | 0;\n      if ((HEAP8[$144 >> 0] | 0) < 0) {\n       $147 = HEAP32[$143 >> 2] | 0;\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($147, $3);\n       HEAP32[$142 + -20 >> 2] = 0;\n      } else {\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($143, $3);\n       HEAP8[$144 >> 0] = 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($143);\n      HEAP32[$143 >> 2] = HEAP32[$4 >> 2];\n      HEAP32[$143 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n      HEAP32[$143 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n      $$0$i$i$i$i615 = 0;\n      while (1) {\n       if (($$0$i$i$i$i615 | 0) == 3) break;\n       HEAP32[$4 + ($$0$i$i$i$i615 << 2) >> 2] = 0;\n       $$0$i$i$i$i615 = $$0$i$i$i$i615 + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n      $$14 = $116;\n      break L1;\n      break;\n     }\n    case 110:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 115:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_119parse_dot_star_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 116:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_114parse_dot_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 118:\n     {\n      $154 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15212, __ZNSt3__211char_traitsIcE6lengthEPKc(15212) | 0);\n      $156 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($154, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($156 | 0) == ($154 | 0) ? $0 : $156;\n      break L1;\n      break;\n     }\n    case 86:\n     {\n      $158 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15214, __ZNSt3__211char_traitsIcE6lengthEPKc(15214) | 0);\n      $160 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($158, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($160 | 0) == ($158 | 0) ? $0 : $160;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 101:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 111:\n     {\n      $165 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15217, __ZNSt3__211char_traitsIcE6lengthEPKc(15217) | 0);\n      $167 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($165, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($167 | 0) == ($165 | 0) ? $0 : $167;\n      break L1;\n      break;\n     }\n    case 79:\n     {\n      $169 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15219, __ZNSt3__211char_traitsIcE6lengthEPKc(15219) | 0);\n      $171 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($169, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($171 | 0) == ($169 | 0) ? $0 : $171;\n      break L1;\n      break;\n     }\n    case 113:\n     {\n      $173 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15222, __ZNSt3__211char_traitsIcE6lengthEPKc(15222) | 0);\n      $175 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($173, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($175 | 0) == ($173 | 0) ? $0 : $175;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 103:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 101:\n     {\n      $180 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15225, __ZNSt3__211char_traitsIcE6lengthEPKc(15225) | 0);\n      $182 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($180, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($182 | 0) == ($180 | 0) ? $0 : $182;\n      break L1;\n      break;\n     }\n    case 116:\n     {\n      $184 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15155, __ZNSt3__211char_traitsIcE6lengthEPKc(15155) | 0);\n      $186 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($184, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($186 | 0) == ($184 | 0) ? $0 : $186;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 105:\n   {\n    if ((HEAP8[$$0503 + 1 >> 0] | 0) != 120) {\n     $$14 = $0;\n     break L1;\n    }\n    $191 = $0 + 2 | 0;\n    $192 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($191, $1, $2) | 0;\n    if (($192 | 0) == ($191 | 0)) {\n     $$14 = $0;\n     break L1;\n    }\n    $194 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($192, $1, $2) | 0;\n    $196 = $2 + 4 | 0;\n    if (($194 | 0) == ($192 | 0)) {\n     $228 = HEAP32[$196 >> 2] | 0;\n     $$0$i$i$idx$i629 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i629 | 0) == -1) break;\n      $$0$i$i$add$i630 = $$0$i$i$idx$i629 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($228 + ($$0$i$i$add$i630 * 24 | 0) | 0);\n      $$0$i$i$idx$i629 = $$0$i$i$add$i630;\n     }\n     HEAP32[$196 >> 2] = $228 + -24;\n     $$14 = $0;\n     break L1;\n    }\n    $197 = HEAP32[$196 >> 2] | 0;\n    if ((($197 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n     $$14 = $0;\n     break L1;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $197 + -24 | 0);\n    $204 = HEAP32[$196 >> 2] | 0;\n    $$0$i$i$idx$i = 0;\n    while (1) {\n     if (($$0$i$i$idx$i | 0) == -1) break;\n     $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($204 + ($$0$i$i$add$i * 24 | 0) | 0);\n     $$0$i$i$idx$i = $$0$i$i$add$i;\n    }\n    HEAP32[$196 >> 2] = $204 + -24;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, $204 + -48 | 0);\n    __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($9, 15119, $4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($9, 15228) | 0;\n    HEAP32[$7 >> 2] = HEAP32[$9 >> 2];\n    HEAP32[$7 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n    HEAP32[$7 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n    $$0$i$i$i618 = 0;\n    while (1) {\n     if (($$0$i$i$i618 | 0) == 3) break;\n     HEAP32[$9 + ($$0$i$i$i618 << 2) >> 2] = 0;\n     $$0$i$i$i618 = $$0$i$i$i618 + 1 | 0;\n    }\n    $212 = HEAP8[$3 + 11 >> 0] | 0;\n    $213 = $212 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($7, $213 ? HEAP32[$3 >> 2] | 0 : $3, $213 ? HEAP32[$3 + 4 >> 2] | 0 : $212 & 255) | 0;\n    HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n    HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n    HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n    $$0$i$i$i622 = 0;\n    while (1) {\n     if (($$0$i$i$i622 | 0) == 3) break;\n     HEAP32[$7 + ($$0$i$i$i622 << 2) >> 2] = 0;\n     $$0$i$i$i622 = $$0$i$i$i622 + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15166) | 0;\n    HEAP32[$8 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$8 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$8 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i625 = 0;\n    while (1) {\n     if (($$0$i$i$i625 | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i625 << 2) >> 2] = 0;\n     $$0$i$i$i625 = $$0$i$i$i625 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($5, $8);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$196 >> 2] | 0) + -24 | 0, $5);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$14 = $194;\n    break L1;\n    break;\n   }\n  case 108:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 101:\n     {\n      $234 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15231, __ZNSt3__211char_traitsIcE6lengthEPKc(15231) | 0);\n      $236 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($234, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($236 | 0) == ($234 | 0) ? $0 : $236;\n      break L1;\n      break;\n     }\n    case 115:\n     {\n      $238 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15234, __ZNSt3__211char_traitsIcE6lengthEPKc(15234) | 0);\n      $240 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($238, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($240 | 0) == ($238 | 0) ? $0 : $240;\n      break L1;\n      break;\n     }\n    case 83:\n     {\n      $242 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15237, __ZNSt3__211char_traitsIcE6lengthEPKc(15237) | 0);\n      $244 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($242, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($244 | 0) == ($242 | 0) ? $0 : $244;\n      break L1;\n      break;\n     }\n    case 116:\n     {\n      $246 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15153, __ZNSt3__211char_traitsIcE6lengthEPKc(15153) | 0);\n      $248 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($246, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($248 | 0) == ($246 | 0) ? $0 : $248;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 109:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 105:\n     {\n      $253 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15241, __ZNSt3__211char_traitsIcE6lengthEPKc(15241) | 0);\n      $255 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($253, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($255 | 0) == ($253 | 0) ? $0 : $255;\n      break L1;\n      break;\n     }\n    case 73:\n     {\n      $257 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15243, __ZNSt3__211char_traitsIcE6lengthEPKc(15243) | 0);\n      $259 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($257, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($259 | 0) == ($257 | 0) ? $0 : $259;\n      break L1;\n      break;\n     }\n    case 108:\n     {\n      $261 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15137, __ZNSt3__211char_traitsIcE6lengthEPKc(15137) | 0);\n      $263 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($261, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($263 | 0) == ($261 | 0) ? $0 : $263;\n      break L1;\n      break;\n     }\n    case 76:\n     {\n      $265 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15246, __ZNSt3__211char_traitsIcE6lengthEPKc(15246) | 0);\n      $267 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($265, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($267 | 0) == ($265 | 0) ? $0 : $267;\n      break L1;\n      break;\n     }\n    case 109:\n     {\n      $269 = $0 + 2 | 0;\n      if (($269 | 0) != ($1 | 0)) if ((HEAP8[$269 >> 0] | 0) == 95) {\n       $273 = $0 + 3 | 0;\n       HEAP32[$3 >> 2] = 0;\n       HEAP32[$3 + 4 >> 2] = 0;\n       HEAP32[$3 + 8 >> 2] = 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15249, __ZNSt3__211char_traitsIcE6lengthEPKc(15249) | 0);\n       $275 = __ZN10__cxxabiv112_GLOBAL__N_123parse_prefix_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($273, $1, $3, $2) | 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n       $$14 = ($275 | 0) == ($273 | 0) ? $0 : $275;\n       break L1;\n      }\n      $277 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($269, $1, $2) | 0;\n      if (($277 | 0) == ($269 | 0)) {\n       $$14 = $0;\n       break L1;\n      }\n      $280 = $2 + 4 | 0;\n      $281 = HEAP32[$280 >> 2] | 0;\n      if ((HEAP32[$2 >> 2] | 0) == ($281 | 0)) {\n       $$14 = $0;\n       break L1;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, $281 + -24 | 0);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($5, 0, 15119) | 0;\n      HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n      HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n      $$0$i$i$i633 = 0;\n      while (1) {\n       if (($$0$i$i$i633 | 0) == 3) break;\n       HEAP32[$5 + ($$0$i$i$i633 << 2) >> 2] = 0;\n       $$0$i$i$i633 = $$0$i$i$i633 + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15252) | 0;\n      HEAP32[$10 >> 2] = HEAP32[$4 >> 2];\n      HEAP32[$10 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n      HEAP32[$10 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n      $$0$i$i$i636 = 0;\n      while (1) {\n       if (($$0$i$i$i636 | 0) == 3) break;\n       HEAP32[$4 + ($$0$i$i$i636 << 2) >> 2] = 0;\n       $$0$i$i$i636 = $$0$i$i$i636 + 1 | 0;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $10);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$280 >> 2] | 0) + -24 | 0, $3);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($10);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n      $$14 = $277;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 110:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 119:\n    case 97:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_114parse_new_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 101:\n     {\n      $296 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15256, __ZNSt3__211char_traitsIcE6lengthEPKc(15256) | 0);\n      $298 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($296, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($298 | 0) == ($296 | 0) ? $0 : $298;\n      break L1;\n      break;\n     }\n    case 103:\n     {\n      $300 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15241, __ZNSt3__211char_traitsIcE6lengthEPKc(15241) | 0);\n      $302 = __ZN10__cxxabiv112_GLOBAL__N_123parse_prefix_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($300, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($302 | 0) == ($300 | 0) ? $0 : $302;\n      break L1;\n      break;\n     }\n    case 116:\n     {\n      $304 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15259, __ZNSt3__211char_traitsIcE6lengthEPKc(15259) | 0);\n      $306 = __ZN10__cxxabiv112_GLOBAL__N_123parse_prefix_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($304, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($306 | 0) == ($304 | 0) ? $0 : $306;\n      break L1;\n      break;\n     }\n    case 120:\n     {\n      $308 = $0 + 2 | 0;\n      $309 = __ZN10__cxxabiv112_GLOBAL__N_125parse_noexcept_expressionINS0_2DbEEEPKcS4_S4_RT_($308, $1, $2) | 0;\n      $$14 = ($309 | 0) == ($308 | 0) ? $0 : $309;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 111:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 110:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 111:\n     {\n      $315 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15261, __ZNSt3__211char_traitsIcE6lengthEPKc(15261) | 0);\n      $317 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($315, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($317 | 0) == ($315 | 0) ? $0 : $317;\n      break L1;\n      break;\n     }\n    case 114:\n     {\n      $319 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15264, __ZNSt3__211char_traitsIcE6lengthEPKc(15264) | 0);\n      $321 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($319, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($321 | 0) == ($319 | 0) ? $0 : $321;\n      break L1;\n      break;\n     }\n    case 82:\n     {\n      $323 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15266, __ZNSt3__211char_traitsIcE6lengthEPKc(15266) | 0);\n      $325 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($323, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($325 | 0) == ($323 | 0) ? $0 : $325;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 112:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 109:\n     {\n      $330 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15269, __ZNSt3__211char_traitsIcE6lengthEPKc(15269) | 0);\n      $332 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($330, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($332 | 0) == ($330 | 0) ? $0 : $332;\n      break L1;\n      break;\n     }\n    case 108:\n     {\n      $334 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15273, __ZNSt3__211char_traitsIcE6lengthEPKc(15273) | 0);\n      $336 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($334, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($336 | 0) == ($334 | 0) ? $0 : $336;\n      break L1;\n      break;\n     }\n    case 76:\n     {\n      $338 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15275, __ZNSt3__211char_traitsIcE6lengthEPKc(15275) | 0);\n      $340 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($338, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($340 | 0) == ($338 | 0) ? $0 : $340;\n      break L1;\n      break;\n     }\n    case 112:\n     {\n      $342 = $0 + 2 | 0;\n      if (($342 | 0) != ($1 | 0)) if ((HEAP8[$342 >> 0] | 0) == 95) {\n       $346 = $0 + 3 | 0;\n       HEAP32[$3 >> 2] = 0;\n       HEAP32[$3 + 4 >> 2] = 0;\n       HEAP32[$3 + 8 >> 2] = 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15278, __ZNSt3__211char_traitsIcE6lengthEPKc(15278) | 0);\n       $348 = __ZN10__cxxabiv112_GLOBAL__N_123parse_prefix_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($346, $1, $3, $2) | 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n       $$14 = ($348 | 0) == ($346 | 0) ? $0 : $348;\n       break L1;\n      }\n      $350 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($342, $1, $2) | 0;\n      if (($350 | 0) == ($342 | 0)) {\n       $$14 = $0;\n       break L1;\n      }\n      $353 = $2 + 4 | 0;\n      $354 = HEAP32[$353 >> 2] | 0;\n      if ((HEAP32[$2 >> 2] | 0) == ($354 | 0)) {\n       $$14 = $0;\n       break L1;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, $354 + -24 | 0);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($5, 0, 15119) | 0;\n      HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n      HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n      $$0$i$i$i640 = 0;\n      while (1) {\n       if (($$0$i$i$i640 | 0) == 3) break;\n       HEAP32[$5 + ($$0$i$i$i640 << 2) >> 2] = 0;\n       $$0$i$i$i640 = $$0$i$i$i640 + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15281) | 0;\n      HEAP32[$11 >> 2] = HEAP32[$4 >> 2];\n      HEAP32[$11 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n      HEAP32[$11 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n      $$0$i$i$i644 = 0;\n      while (1) {\n       if (($$0$i$i$i644 | 0) == 3) break;\n       HEAP32[$4 + ($$0$i$i$i644 << 2) >> 2] = 0;\n       $$0$i$i$i644 = $$0$i$i$i644 + 1 | 0;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $11);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$353 >> 2] | 0) + -24 | 0, $3);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($11);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n      $$14 = $350;\n      break L1;\n      break;\n     }\n    case 115:\n     {\n      $365 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15273, __ZNSt3__211char_traitsIcE6lengthEPKc(15273) | 0);\n      $367 = __ZN10__cxxabiv112_GLOBAL__N_123parse_prefix_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($365, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($367 | 0) == ($365 | 0) ? $0 : $367;\n      break L1;\n      break;\n     }\n    case 116:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_116parse_arrow_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 113:\n   {\n    if ((HEAP8[$$0503 + 1 >> 0] | 0) != 117) {\n     $$14 = $0;\n     break L1;\n    }\n    $373 = $0 + 2 | 0;\n    $374 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($373, $1, $2) | 0;\n    if (($374 | 0) == ($373 | 0)) {\n     $$14 = $0;\n     break L1;\n    }\n    $376 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($374, $1, $2) | 0;\n    if (($376 | 0) == ($374 | 0)) {\n     $436 = $2 + 4 | 0;\n     $437 = HEAP32[$436 >> 2] | 0;\n     $$0$i$i$idx$i684 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i684 | 0) == -1) break;\n      $$0$i$i$add$i685 = $$0$i$i$idx$i684 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($437 + ($$0$i$i$add$i685 * 24 | 0) | 0);\n      $$0$i$i$idx$i684 = $$0$i$i$add$i685;\n     }\n     HEAP32[$436 >> 2] = $437 + -24;\n     $$14 = $0;\n     break L1;\n    }\n    $378 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($376, $1, $2) | 0;\n    $380 = $2 + 4 | 0;\n    if (($378 | 0) == ($376 | 0)) {\n     $431 = HEAP32[$380 >> 2] | 0;\n     $$0$i$i$idx$i676 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i676 | 0) == -1) break;\n      $$0$i$i$add$i677 = $$0$i$i$idx$i676 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($431 + ($$0$i$i$add$i677 * 24 | 0) | 0);\n      $$0$i$i$idx$i676 = $$0$i$i$add$i677;\n     }\n     $433 = $431 + -24 | 0;\n     HEAP32[$380 >> 2] = $433;\n     $$0$i$i$idx$i680 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i680 | 0) == -1) break;\n      $$0$i$i$add$i681 = $$0$i$i$idx$i680 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($433 + ($$0$i$i$add$i681 * 24 | 0) | 0);\n      $$0$i$i$idx$i680 = $$0$i$i$add$i681;\n     }\n     HEAP32[$380 >> 2] = $431 + -48;\n     $$14 = $0;\n     break L1;\n    }\n    $381 = HEAP32[$380 >> 2] | 0;\n    if ((($381 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 3) {\n     $$14 = $0;\n     break L1;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $381 + -24 | 0);\n    $388 = HEAP32[$380 >> 2] | 0;\n    $$0$i$i$idx$i648 = 0;\n    while (1) {\n     if (($$0$i$i$idx$i648 | 0) == -1) break;\n     $$0$i$i$add$i649 = $$0$i$i$idx$i648 + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($388 + ($$0$i$i$add$i649 * 24 | 0) | 0);\n     $$0$i$i$idx$i648 = $$0$i$i$add$i649;\n    }\n    HEAP32[$380 >> 2] = $388 + -24;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, $388 + -48 | 0);\n    $392 = HEAP32[$380 >> 2] | 0;\n    $$0$i$i$idx$i652 = 0;\n    while (1) {\n     if (($$0$i$i$idx$i652 | 0) == -1) break;\n     $$0$i$i$add$i653 = $$0$i$i$idx$i652 + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($392 + ($$0$i$i$add$i653 * 24 | 0) | 0);\n     $$0$i$i$idx$i652 = $$0$i$i$add$i653;\n    }\n    HEAP32[$380 >> 2] = $392 + -24;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, $392 + -48 | 0);\n    __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($15, 15119, $5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($15, 15285) | 0;\n    HEAP32[$14 >> 2] = HEAP32[$15 >> 2];\n    HEAP32[$14 + 4 >> 2] = HEAP32[$15 + 4 >> 2];\n    HEAP32[$14 + 8 >> 2] = HEAP32[$15 + 8 >> 2];\n    $$0$i$i$i656 = 0;\n    while (1) {\n     if (($$0$i$i$i656 | 0) == 3) break;\n     HEAP32[$15 + ($$0$i$i$i656 << 2) >> 2] = 0;\n     $$0$i$i$i656 = $$0$i$i$i656 + 1 | 0;\n    }\n    $400 = HEAP8[$4 + 11 >> 0] | 0;\n    $401 = $400 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($14, $401 ? HEAP32[$4 >> 2] | 0 : $4, $401 ? HEAP32[$4 + 4 >> 2] | 0 : $400 & 255) | 0;\n    HEAP32[$13 >> 2] = HEAP32[$14 >> 2];\n    HEAP32[$13 + 4 >> 2] = HEAP32[$14 + 4 >> 2];\n    HEAP32[$13 + 8 >> 2] = HEAP32[$14 + 8 >> 2];\n    $$0$i$i$i660 = 0;\n    while (1) {\n     if (($$0$i$i$i660 | 0) == 3) break;\n     HEAP32[$14 + ($$0$i$i$i660 << 2) >> 2] = 0;\n     $$0$i$i$i660 = $$0$i$i$i660 + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($13, 15291) | 0;\n    HEAP32[$9 >> 2] = HEAP32[$13 >> 2];\n    HEAP32[$9 + 4 >> 2] = HEAP32[$13 + 4 >> 2];\n    HEAP32[$9 + 8 >> 2] = HEAP32[$13 + 8 >> 2];\n    $$0$i$i$i664 = 0;\n    while (1) {\n     if (($$0$i$i$i664 | 0) == 3) break;\n     HEAP32[$13 + ($$0$i$i$i664 << 2) >> 2] = 0;\n     $$0$i$i$i664 = $$0$i$i$i664 + 1 | 0;\n    }\n    $415 = HEAP8[$3 + 11 >> 0] | 0;\n    $416 = $415 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($9, $416 ? HEAP32[$3 >> 2] | 0 : $3, $416 ? HEAP32[$3 + 4 >> 2] | 0 : $415 & 255) | 0;\n    HEAP32[$7 >> 2] = HEAP32[$9 >> 2];\n    HEAP32[$7 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n    HEAP32[$7 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n    $$0$i$i$i668 = 0;\n    while (1) {\n     if (($$0$i$i$i668 | 0) == 3) break;\n     HEAP32[$9 + ($$0$i$i$i668 << 2) >> 2] = 0;\n     $$0$i$i$i668 = $$0$i$i$i668 + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($7, 15117) | 0;\n    HEAP32[$12 >> 2] = HEAP32[$7 >> 2];\n    HEAP32[$12 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n    HEAP32[$12 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n    $$0$i$i$i672 = 0;\n    while (1) {\n     if (($$0$i$i$i672 | 0) == 3) break;\n     HEAP32[$7 + ($$0$i$i$i672 << 2) >> 2] = 0;\n     $$0$i$i$i672 = $$0$i$i$i672 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($6, $12);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$380 >> 2] | 0) + -24 | 0, $6);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($6);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($12);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($13);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($14);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($15);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$14 = $378;\n    break L1;\n    break;\n   }\n  case 114:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 99:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_127parse_reinterpret_cast_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 109:\n     {\n      $444 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15297, __ZNSt3__211char_traitsIcE6lengthEPKc(15297) | 0);\n      $446 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($444, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($446 | 0) == ($444 | 0) ? $0 : $446;\n      break L1;\n      break;\n     }\n    case 77:\n     {\n      $448 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15299, __ZNSt3__211char_traitsIcE6lengthEPKc(15299) | 0);\n      $450 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($448, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($450 | 0) == ($448 | 0) ? $0 : $450;\n      break L1;\n      break;\n     }\n    case 115:\n     {\n      $452 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15302, __ZNSt3__211char_traitsIcE6lengthEPKc(15302) | 0);\n      $454 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($452, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($454 | 0) == ($452 | 0) ? $0 : $454;\n      break L1;\n      break;\n     }\n    case 83:\n     {\n      $456 = $0 + 2 | 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$3 + 4 >> 2] = 0;\n      HEAP32[$3 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15305, __ZNSt3__211char_traitsIcE6lengthEPKc(15305) | 0);\n      $458 = __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($456, $1, $3, $2) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$14 = ($458 | 0) == ($456 | 0) ? $0 : $458;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 115:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 99:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_122parse_static_cast_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 112:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_120parse_pack_expansionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 114:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 116:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_122parse_sizeof_type_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 122:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_122parse_sizeof_expr_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 90:\n     {\n      if (($16 - $$0503 | 0) <= 2) {\n       $$14 = $0;\n       break L1;\n      }\n      switch (HEAP8[$$0503 + 2 >> 0] | 0) {\n      case 84:\n       {\n        $$14 = __ZN10__cxxabiv112_GLOBAL__N_128parse_sizeof_param_pack_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n        break L1;\n        break;\n       }\n      case 102:\n       {\n        $$14 = __ZN10__cxxabiv112_GLOBAL__N_137parse_sizeof_function_param_pack_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n        break L1;\n        break;\n       }\n      default:\n       {\n        $$14 = $0;\n        break L1;\n       }\n      }\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 116:\n   {\n    switch (HEAP8[$$0503 + 1 >> 0] | 0) {\n    case 105:\n    case 101:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_117parse_typeid_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    case 114:\n     {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj6EEERAT__Kc($3, 15309);\n      $480 = $2 + 4 | 0;\n      $481 = HEAP32[$480 >> 2] | 0;\n      if ($481 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($481, $3);\n       HEAP32[$480 >> 2] = (HEAP32[$480 >> 2] | 0) + 24;\n      } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n      $$14 = $0 + 2 | 0;\n      break L1;\n      break;\n     }\n    case 119:\n     {\n      $$14 = __ZN10__cxxabiv112_GLOBAL__N_116parse_throw_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$14 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 57:\n  case 56:\n  case 55:\n  case 54:\n  case 53:\n  case 52:\n  case 51:\n  case 50:\n  case 49:\n   {\n    $$14 = __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n    break L1;\n    break;\n   }\n  default:\n   {\n    $$14 = $0;\n    break L1;\n   }\n  } while (0);\n } else $$14 = $0; while (0);\n STACKTOP = sp;\n return $$14 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0$i = 0, $$0$i$i$add$i = 0, $$0$i$i$add$i497 = 0, $$0$i$i$add$i549 = 0, $$0$i$i$add$i561 = 0, $$0$i$i$add$i569 = 0, $$0$i$i$i = 0, $$0$i$i$i575 = 0, $$0$i$i$i579 = 0, $$0$i$i$i582 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i496 = 0, $$0$i$i$idx$i548 = 0, $$0$i$i$idx$i560 = 0, $$0$i$i$idx$i568 = 0, $$0$i533 = 0, $$0$i540 = 0, $$0434 = 0, $$0435 = 0, $$0438 = 0, $$0444 = 0, $$0478 = 0, $$0479 = 0, $$1429 = 0, $$1436 = 0, $$2437 = 0, $$5 = 0, $$in = 0, $$ph = 0, $$sroa$0$0$$sroa_idx$i544 = 0, $$sroa$0$0$copyload$i490598 = 0, $$sroa$0$0$copyload$i499594 = 0, $$sroa$0$0$copyload$i527606 = 0, $$sroa$0$0$copyload$i531605 = 0, $$sroa$0$0$copyload$i538604 = 0, $$sroa$0$0$copyload$i545602 = 0, $10 = 0, $102 = 0, $106 = 0, $11 = 0, $110 = 0, $113 = 0, $114 = 0, $119 = 0, $120 = 0, $124 = 0, $126 = 0, $131 = 0, $132 = 0, $135 = 0, $136 = 0, $140 = 0, $141 = 0, $142 = 0, $147 = 0, $148 = 0, $15 = 0, $152 = 0, $154 = 0, $159 = 0, $163 = 0, $166 = 0, $167 = 0, $172 = 0, $173 = 0, $177 = 0, $179 = 0, $18 = 0, $184 = 0, $185 = 0, $188 = 0, $189 = 0, $19 = 0, $193 = 0, $194 = 0, $195 = 0, $200 = 0, $201 = 0, $205 = 0, $207 = 0, $212 = 0, $216 = 0, $219 = 0, $220 = 0, $225 = 0, $226 = 0, $23 = 0, $230 = 0, $232 = 0, $237 = 0, $24 = 0, $241 = 0, $242 = 0, $243 = 0, $247 = 0, $249 = 0, $250 = 0, $260 = 0, $261 = 0, $265 = 0, $266 = 0, $274 = 0, $275 = 0, $278 = 0, $28 = 0, $284 = 0, $290 = 0, $292 = 0, $293 = 0, $294 = 0, $3 = 0, $30 = 0, $302 = 0, $306 = 0, $307 = 0, $308 = 0, $31 = 0, $312 = 0, $314 = 0, $315 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $332 = 0, $333 = 0, $34 = 0, $341 = 0, $342 = 0, $345 = 0, $351 = 0, $361 = 0, $362 = 0, $371 = 0, $372 = 0, $373 = 0, $375 = 0, $376 = 0, $377 = 0, $38 = 0, $385 = 0, $389 = 0, $390 = 0, $391 = 0, $395 = 0, $397 = 0, $398 = 0, $4 = 0, $408 = 0, $409 = 0, $413 = 0, $414 = 0, $422 = 0, $423 = 0, $426 = 0, $432 = 0, $438 = 0, $440 = 0, $441 = 0, $442 = 0, $45 = 0, $450 = 0, $454 = 0, $455 = 0, $459 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $47 = 0, $478 = 0, $480 = 0, $481 = 0, $482 = 0, $49 = 0, $490 = 0, $494 = 0, $499 = 0, $5 = 0, $500 = 0, $508 = 0, $509 = 0, $51 = 0, $513 = 0, $514 = 0, $518 = 0, $520 = 0, $524 = 0, $526 = 0, $528 = 0, $53 = 0, $530 = 0, $531 = 0, $538 = 0, $54 = 0, $542 = 0, $544 = 0, $552 = 0, $556 = 0, $557 = 0, $56 = 0, $57 = 0, $571 = 0, $574 = 0, $575 = 0, $576 = 0, $578 = 0, $581 = 0, $585 = 0, $595 = 0, $596 = 0, $6 = 0, $611 = 0, $612 = 0, $62 = 0, $621 = 0, $628 = 0, $629 = 0, $630 = 0, $635 = 0, $636 = 0, $64 = 0, $640 = 0, $642 = 0, $647 = 0, $651 = 0, $655 = 0, $658 = 0, $659 = 0, $664 = 0, $665 = 0, $669 = 0, $671 = 0, $676 = 0, $678 = 0, $680 = 0, $681 = 0, $688 = 0, $693 = 0, $694 = 0, $7 = 0, $702 = 0, $703 = 0, $704 = 0, $709 = 0, $710 = 0, $714 = 0, $716 = 0, $721 = 0, $725 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $735 = 0, $737 = 0, $738 = 0, $74 = 0, $749 = 0, $751 = 0, $752 = 0, $753 = 0, $761 = 0, $765 = 0, $768 = 0, $769 = 0, $774 = 0, $775 = 0, $779 = 0, $781 = 0, $786 = 0, $790 = 0, $793 = 0, $794 = 0, $799 = 0, $8 = 0, $800 = 0, $804 = 0, $806 = 0, $811 = 0, $813 = 0, $817 = 0, $820 = 0, $821 = 0, $826 = 0, $827 = 0, $831 = 0, $833 = 0, $9 = 0, $90 = 0, $92 = 0, $93 = 0, $94 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 144 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(144);\n $3 = sp + 128 | 0;\n $4 = sp + 104 | 0;\n $5 = sp + 40 | 0;\n $6 = sp + 88 | 0;\n $7 = sp + 24 | 0;\n $8 = sp + 76 | 0;\n $9 = sp + 12 | 0;\n $10 = sp;\n $11 = sp + 64 | 0;\n L1 : do if (($0 | 0) == ($1 | 0)) $$5 = $0; else {\n  switch (HEAP8[$0 >> 0] | 0) {\n  case 75:\n  case 86:\n  case 114:\n   {\n    HEAP32[$3 >> 2] = 0;\n    $15 = __ZN10__cxxabiv112_GLOBAL__N_119parse_cv_qualifiersEPKcS2_Rj($0, $1, $3) | 0;\n    L5 : do if (($15 | 0) == ($0 | 0)) $$1429 = $0; else {\n     $18 = (HEAP8[$15 >> 0] | 0) == 70;\n     $19 = $2 + 4 | 0;\n     $23 = ((HEAP32[$19 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     $24 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($15, $1, $2) | 0;\n     $28 = ((HEAP32[$19 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     if (($24 | 0) == ($15 | 0)) $$1429 = $0; else {\n      $30 = $2 + 20 | 0;\n      $31 = HEAP32[$30 >> 2] | 0;\n      if ($18) {\n       $$0$i$i$idx$i496 = 0;\n       while (1) {\n        if (($$0$i$i$idx$i496 | 0) == -1) break;\n        $$0$i$i$add$i497 = $$0$i$i$idx$i496 + -1 | 0;\n        __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($31 + ($$0$i$i$add$i497 << 4) | 0);\n        $$0$i$i$idx$i496 = $$0$i$i$add$i497;\n       }\n       $34 = $31 + -16 | 0;\n       HEAP32[$30 >> 2] = $34;\n       $38 = $34;\n      } else $38 = $31;\n      $$sroa$0$0$copyload$i499594 = HEAP32[$2 + 12 >> 2] | 0;\n      HEAP32[$4 >> 2] = $$sroa$0$0$copyload$i499594;\n      if ($38 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n       HEAP32[$38 >> 2] = 0;\n       HEAP32[$38 + 4 >> 2] = 0;\n       HEAP32[$38 + 8 >> 2] = 0;\n       HEAP32[$38 + 12 >> 2] = $$sroa$0$0$copyload$i499594;\n       HEAP32[$30 >> 2] = (HEAP32[$30 >> 2] | 0) + 16;\n      } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($2 + 16 | 0, $4);\n      $45 = HEAP32[$3 >> 2] | 0;\n      $47 = ($45 & 1 | 0) == 0;\n      $49 = ($45 & 2 | 0) == 0;\n      $51 = ($45 & 4 | 0) == 0;\n      $$0434 = $23;\n      while (1) {\n       if ($$0434 >>> 0 >= $28 >>> 0) {\n        $$1429 = $24;\n        break L5;\n       }\n       if ($18) {\n        $53 = HEAP32[$2 >> 2] | 0;\n        $54 = $53 + ($$0434 * 24 | 0) + 12 | 0;\n        $56 = HEAP8[$54 + 11 >> 0] | 0;\n        $57 = $56 << 24 >> 24 < 0;\n        if ($57) {\n         $$in = HEAP32[$53 + ($$0434 * 24 | 0) + 16 >> 2] | 0;\n         $64 = HEAP32[$54 >> 2] | 0;\n        } else {\n         $$in = $56 & 255;\n         $64 = $54;\n        }\n        $62 = $$in + -2 | 0;\n        if ((HEAP8[$64 + $62 >> 0] | 0) == 38) $$0435 = $$in + -3 | 0; else {\n         if ($57) {\n          $73 = HEAP32[$54 >> 2] | 0;\n          $74 = HEAP32[$53 + ($$0434 * 24 | 0) + 16 >> 2] | 0;\n         } else {\n          $73 = $54;\n          $74 = $56 & 255;\n         }\n         $$0435 = (HEAP8[$73 + $74 + -1 >> 0] | 0) == 38 ? $62 : $$in;\n        }\n        if ($47) $$1436 = $$0435; else {\n         __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($54, $$0435, 15064) | 0;\n         $$1436 = $$0435 + 6 | 0;\n        }\n        if ($49) $$2437 = $$1436; else {\n         __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc((HEAP32[$2 >> 2] | 0) + ($$0434 * 24 | 0) + 12 | 0, $$1436, 15071) | 0;\n         $$2437 = $$1436 + 9 | 0;\n        }\n        if (!$51) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc((HEAP32[$2 >> 2] | 0) + ($$0434 * 24 | 0) + 12 | 0, $$2437, 15081) | 0;\n       } else {\n        if (!$47) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$2 >> 2] | 0) + ($$0434 * 24 | 0) | 0, 15064) | 0;\n        if (!$49) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$2 >> 2] | 0) + ($$0434 * 24 | 0) | 0, 15071) | 0;\n        if (!$51) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$2 >> 2] | 0) + ($$0434 * 24 | 0) | 0, 15081) | 0;\n       }\n       $90 = HEAP32[$30 >> 2] | 0;\n       $92 = (HEAP32[$2 >> 2] | 0) + ($$0434 * 24 | 0) | 0;\n       $93 = $90 + -12 | 0;\n       $94 = HEAP32[$93 >> 2] | 0;\n       if (($94 | 0) == (HEAP32[$90 + -8 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($90 + -16 | 0, $92); else {\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($94, $92);\n        HEAP32[$93 >> 2] = (HEAP32[$93 >> 2] | 0) + 24;\n       }\n       $$0434 = $$0434 + 1 | 0;\n      }\n     }\n    } while (0);\n    $$5 = $$1429;\n    break L1;\n    break;\n   }\n  default:\n   {}\n  }\n  $102 = __ZN10__cxxabiv112_GLOBAL__N_118parse_builtin_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n  if (($102 | 0) == ($0 | 0)) {\n   L59 : do switch (HEAP8[$0 >> 0] | 0) {\n   case 65:\n    {\n     $106 = __ZN10__cxxabiv112_GLOBAL__N_116parse_array_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n     if (($106 | 0) == ($0 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $110 = HEAP32[$2 + 4 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($110 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $110 + -24 | 0, $4);\n     $113 = $2 + 20 | 0;\n     $114 = HEAP32[$113 >> 2] | 0;\n     if ($114 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$114 >> 2] = 0;\n      $119 = $114 + 4 | 0;\n      HEAP32[$119 >> 2] = 0;\n      $120 = $114 + 8 | 0;\n      HEAP32[$120 >> 2] = 0;\n      HEAP32[$114 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n      HEAP32[$114 >> 2] = HEAP32[$3 >> 2];\n      $124 = $3 + 4 | 0;\n      HEAP32[$119 >> 2] = HEAP32[$124 >> 2];\n      $126 = $3 + 8 | 0;\n      HEAP32[$120 >> 2] = HEAP32[$126 >> 2];\n      HEAP32[$126 >> 2] = 0;\n      HEAP32[$124 >> 2] = 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$113 >> 2] = (HEAP32[$113 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n     $$5 = $106;\n     break L1;\n     break;\n    }\n   case 67:\n    {\n     $131 = $0 + 1 | 0;\n     $132 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($131, $1, $2) | 0;\n     if (($132 | 0) == ($131 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $135 = $2 + 4 | 0;\n     $136 = HEAP32[$135 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($136 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($136 + -24 | 0, 15091) | 0;\n     $140 = (HEAP32[$135 >> 2] | 0) + -24 | 0;\n     HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $140, $4);\n     $141 = $2 + 20 | 0;\n     $142 = HEAP32[$141 >> 2] | 0;\n     if ($142 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$142 >> 2] = 0;\n      $147 = $142 + 4 | 0;\n      HEAP32[$147 >> 2] = 0;\n      $148 = $142 + 8 | 0;\n      HEAP32[$148 >> 2] = 0;\n      HEAP32[$142 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n      HEAP32[$142 >> 2] = HEAP32[$3 >> 2];\n      $152 = $3 + 4 | 0;\n      HEAP32[$147 >> 2] = HEAP32[$152 >> 2];\n      $154 = $3 + 8 | 0;\n      HEAP32[$148 >> 2] = HEAP32[$154 >> 2];\n      HEAP32[$154 >> 2] = 0;\n      HEAP32[$152 >> 2] = 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$141 >> 2] = (HEAP32[$141 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n     $$5 = $132;\n     break L1;\n     break;\n    }\n   case 70:\n    {\n     $159 = __ZN10__cxxabiv112_GLOBAL__N_119parse_function_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n     if (($159 | 0) == ($0 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $163 = HEAP32[$2 + 4 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($163 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $163 + -24 | 0, $4);\n     $166 = $2 + 20 | 0;\n     $167 = HEAP32[$166 >> 2] | 0;\n     if ($167 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$167 >> 2] = 0;\n      $172 = $167 + 4 | 0;\n      HEAP32[$172 >> 2] = 0;\n      $173 = $167 + 8 | 0;\n      HEAP32[$173 >> 2] = 0;\n      HEAP32[$167 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n      HEAP32[$167 >> 2] = HEAP32[$3 >> 2];\n      $177 = $3 + 4 | 0;\n      HEAP32[$172 >> 2] = HEAP32[$177 >> 2];\n      $179 = $3 + 8 | 0;\n      HEAP32[$173 >> 2] = HEAP32[$179 >> 2];\n      HEAP32[$179 >> 2] = 0;\n      HEAP32[$177 >> 2] = 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$166 >> 2] = (HEAP32[$166 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n     $$5 = $159;\n     break L1;\n     break;\n    }\n   case 71:\n    {\n     $184 = $0 + 1 | 0;\n     $185 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($184, $1, $2) | 0;\n     if (($185 | 0) == ($184 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $188 = $2 + 4 | 0;\n     $189 = HEAP32[$188 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($189 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($189 + -24 | 0, 15100) | 0;\n     $193 = (HEAP32[$188 >> 2] | 0) + -24 | 0;\n     HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $193, $4);\n     $194 = $2 + 20 | 0;\n     $195 = HEAP32[$194 >> 2] | 0;\n     if ($195 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$195 >> 2] = 0;\n      $200 = $195 + 4 | 0;\n      HEAP32[$200 >> 2] = 0;\n      $201 = $195 + 8 | 0;\n      HEAP32[$201 >> 2] = 0;\n      HEAP32[$195 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n      HEAP32[$195 >> 2] = HEAP32[$3 >> 2];\n      $205 = $3 + 4 | 0;\n      HEAP32[$200 >> 2] = HEAP32[$205 >> 2];\n      $207 = $3 + 8 | 0;\n      HEAP32[$201 >> 2] = HEAP32[$207 >> 2];\n      HEAP32[$207 >> 2] = 0;\n      HEAP32[$205 >> 2] = 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$194 >> 2] = (HEAP32[$194 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n     $$5 = $185;\n     break L1;\n     break;\n    }\n   case 77:\n    {\n     $212 = __ZN10__cxxabiv112_GLOBAL__N_128parse_pointer_to_member_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n     if (($212 | 0) == ($0 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $216 = HEAP32[$2 + 4 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($216 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $216 + -24 | 0, $4);\n     $219 = $2 + 20 | 0;\n     $220 = HEAP32[$219 >> 2] | 0;\n     if ($220 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$220 >> 2] = 0;\n      $225 = $220 + 4 | 0;\n      HEAP32[$225 >> 2] = 0;\n      $226 = $220 + 8 | 0;\n      HEAP32[$226 >> 2] = 0;\n      HEAP32[$220 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n      HEAP32[$220 >> 2] = HEAP32[$3 >> 2];\n      $230 = $3 + 4 | 0;\n      HEAP32[$225 >> 2] = HEAP32[$230 >> 2];\n      $232 = $3 + 8 | 0;\n      HEAP32[$226 >> 2] = HEAP32[$232 >> 2];\n      HEAP32[$232 >> 2] = 0;\n      HEAP32[$230 >> 2] = 0;\n      HEAP32[$3 >> 2] = 0;\n      HEAP32[$219 >> 2] = (HEAP32[$219 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n     $$5 = $212;\n     break L1;\n     break;\n    }\n   case 79:\n    {\n     $237 = $2 + 4 | 0;\n     $241 = ((HEAP32[$237 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     $242 = $0 + 1 | 0;\n     $243 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($242, $1, $2) | 0;\n     $247 = ((HEAP32[$237 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     if (($243 | 0) == ($242 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $$sroa$0$0$copyload$i527606 = HEAP32[$2 + 12 >> 2] | 0;\n     HEAP32[$3 >> 2] = $$sroa$0$0$copyload$i527606;\n     $249 = $2 + 20 | 0;\n     $250 = HEAP32[$249 >> 2] | 0;\n     if ($250 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$250 >> 2] = 0;\n      HEAP32[$250 + 4 >> 2] = 0;\n      HEAP32[$250 + 8 >> 2] = 0;\n      HEAP32[$250 + 12 >> 2] = $$sroa$0$0$copyload$i527606;\n      HEAP32[$249 >> 2] = (HEAP32[$249 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($2 + 16 | 0, $3);\n     $260 = $3 + 11 | 0;\n     $261 = $3 + 4 | 0;\n     $$0479 = $241;\n     while (1) {\n      if ($$0479 >>> 0 >= $247 >>> 0) {\n       $$5 = $243;\n       break L1;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($3, (HEAP32[$2 >> 2] | 0) + ($$0479 * 24 | 0) + 12 | 0, 2);\n      $265 = __ZNSt3__211char_traitsIcE6lengthEPKc(15111) | 0;\n      $266 = HEAP8[$260 >> 0] | 0;\n      if (($265 | 0) == (($266 << 24 >> 24 < 0 ? HEAP32[$261 >> 2] | 0 : $266 & 255) | 0)) $$0$i = (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($3, 15111, $265) | 0) == 0; else $$0$i = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $274 = HEAP32[$2 >> 2] | 0;\n      $275 = $274 + ($$0479 * 24 | 0) | 0;\n      if ($$0$i) {\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($275, 15114) | 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc((HEAP32[$2 >> 2] | 0) + ($$0479 * 24 | 0) + 12 | 0, 0, 15117) | 0;\n      } else {\n       $278 = $274 + ($$0479 * 24 | 0) + 12 | 0;\n       if ((HEAP8[$278 + 11 >> 0] | 0) < 0) $284 = HEAP32[$278 >> 2] | 0; else $284 = $278;\n       if ((HEAP8[$284 >> 0] | 0) == 40) {\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($275, 15119) | 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc((HEAP32[$2 >> 2] | 0) + ($$0479 * 24 | 0) + 12 | 0, 0, 15117) | 0;\n       }\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$2 >> 2] | 0) + ($$0479 * 24 | 0) | 0, 15121) | 0;\n      $290 = HEAP32[$249 >> 2] | 0;\n      $292 = (HEAP32[$2 >> 2] | 0) + ($$0479 * 24 | 0) | 0;\n      $293 = $290 + -12 | 0;\n      $294 = HEAP32[$293 >> 2] | 0;\n      if (($294 | 0) == (HEAP32[$290 + -8 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($290 + -16 | 0, $292); else {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($294, $292);\n       HEAP32[$293 >> 2] = (HEAP32[$293 >> 2] | 0) + 24;\n      }\n      $$0479 = $$0479 + 1 | 0;\n     }\n     break;\n    }\n   case 80:\n    {\n     $302 = $2 + 4 | 0;\n     $306 = ((HEAP32[$302 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     $307 = $0 + 1 | 0;\n     $308 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($307, $1, $2) | 0;\n     $312 = ((HEAP32[$302 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     if (($308 | 0) == ($307 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $$sroa$0$0$copyload$i531605 = HEAP32[$2 + 12 >> 2] | 0;\n     HEAP32[$3 >> 2] = $$sroa$0$0$copyload$i531605;\n     $314 = $2 + 20 | 0;\n     $315 = HEAP32[$314 >> 2] | 0;\n     if ($315 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$315 >> 2] = 0;\n      HEAP32[$315 + 4 >> 2] = 0;\n      HEAP32[$315 + 8 >> 2] = 0;\n      HEAP32[$315 + 12 >> 2] = $$sroa$0$0$copyload$i531605;\n      HEAP32[$314 >> 2] = (HEAP32[$314 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($2 + 16 | 0, $3);\n     $325 = $3 + 11 | 0;\n     $326 = $3 + 4 | 0;\n     $327 = $3 + 11 | 0;\n     $328 = $3 + 4 | 0;\n     $$0478 = $306;\n     while (1) {\n      if ($$0478 >>> 0 >= $312 >>> 0) {\n       $$5 = $308;\n       break L1;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($3, (HEAP32[$2 >> 2] | 0) + ($$0478 * 24 | 0) + 12 | 0, 2);\n      $332 = __ZNSt3__211char_traitsIcE6lengthEPKc(15111) | 0;\n      $333 = HEAP8[$325 >> 0] | 0;\n      if (($332 | 0) == (($333 << 24 >> 24 < 0 ? HEAP32[$326 >> 2] | 0 : $333 & 255) | 0)) $$0$i533 = (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($3, 15111, $332) | 0) == 0; else $$0$i533 = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $341 = HEAP32[$2 >> 2] | 0;\n      $342 = $341 + ($$0478 * 24 | 0) | 0;\n      if ($$0$i533) {\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($342, 15114) | 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc((HEAP32[$2 >> 2] | 0) + ($$0478 * 24 | 0) + 12 | 0, 0, 15117) | 0;\n      } else {\n       $345 = $341 + ($$0478 * 24 | 0) + 12 | 0;\n       if ((HEAP8[$345 + 11 >> 0] | 0) < 0) $351 = HEAP32[$345 >> 2] | 0; else $351 = $345;\n       if ((HEAP8[$351 >> 0] | 0) == 40) {\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($342, 15119) | 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc((HEAP32[$2 >> 2] | 0) + ($$0478 * 24 | 0) + 12 | 0, 0, 15117) | 0;\n       }\n      }\n      if ((HEAP8[$307 >> 0] | 0) == 85) {\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($3, (HEAP32[$2 >> 2] | 0) + ($$0478 * 24 | 0) | 0, 12);\n       $361 = __ZNSt3__211char_traitsIcE6lengthEPKc(15124) | 0;\n       $362 = HEAP8[$327 >> 0] | 0;\n       if (($361 | 0) == (($362 << 24 >> 24 < 0 ? HEAP32[$328 >> 2] | 0 : $362 & 255) | 0)) $$ph = (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($3, 15124, $361) | 0) != 0; else $$ph = 1;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n       $371 = (HEAP32[$2 >> 2] | 0) + ($$0478 * 24 | 0) | 0;\n       if ($$ph) {\n        $372 = $371;\n        label = 113;\n       } else __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7replaceEjjPKc($371);\n      } else {\n       $372 = (HEAP32[$2 >> 2] | 0) + ($$0478 * 24 | 0) | 0;\n       label = 113;\n      }\n      if ((label | 0) == 113) {\n       label = 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($372, 15137) | 0;\n      }\n      $373 = HEAP32[$314 >> 2] | 0;\n      $375 = (HEAP32[$2 >> 2] | 0) + ($$0478 * 24 | 0) | 0;\n      $376 = $373 + -12 | 0;\n      $377 = HEAP32[$376 >> 2] | 0;\n      if (($377 | 0) == (HEAP32[$373 + -8 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($373 + -16 | 0, $375); else {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($377, $375);\n       HEAP32[$376 >> 2] = (HEAP32[$376 >> 2] | 0) + 24;\n      }\n      $$0478 = $$0478 + 1 | 0;\n     }\n     break;\n    }\n   case 82:\n    {\n     $385 = $2 + 4 | 0;\n     $389 = ((HEAP32[$385 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     $390 = $0 + 1 | 0;\n     $391 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($390, $1, $2) | 0;\n     $395 = ((HEAP32[$385 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     if (($391 | 0) == ($390 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $$sroa$0$0$copyload$i538604 = HEAP32[$2 + 12 >> 2] | 0;\n     HEAP32[$3 >> 2] = $$sroa$0$0$copyload$i538604;\n     $397 = $2 + 20 | 0;\n     $398 = HEAP32[$397 >> 2] | 0;\n     if ($398 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$398 >> 2] = 0;\n      HEAP32[$398 + 4 >> 2] = 0;\n      HEAP32[$398 + 8 >> 2] = 0;\n      HEAP32[$398 + 12 >> 2] = $$sroa$0$0$copyload$i538604;\n      HEAP32[$397 >> 2] = (HEAP32[$397 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($2 + 16 | 0, $3);\n     $408 = $3 + 11 | 0;\n     $409 = $3 + 4 | 0;\n     $$0444 = $389;\n     while (1) {\n      if ($$0444 >>> 0 >= $395 >>> 0) {\n       $$5 = $391;\n       break L1;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($3, (HEAP32[$2 >> 2] | 0) + ($$0444 * 24 | 0) + 12 | 0, 2);\n      $413 = __ZNSt3__211char_traitsIcE6lengthEPKc(15111) | 0;\n      $414 = HEAP8[$408 >> 0] | 0;\n      if (($413 | 0) == (($414 << 24 >> 24 < 0 ? HEAP32[$409 >> 2] | 0 : $414 & 255) | 0)) $$0$i540 = (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($3, 15111, $413) | 0) == 0; else $$0$i540 = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $422 = HEAP32[$2 >> 2] | 0;\n      $423 = $422 + ($$0444 * 24 | 0) | 0;\n      if ($$0$i540) {\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($423, 15114) | 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc((HEAP32[$2 >> 2] | 0) + ($$0444 * 24 | 0) + 12 | 0, 0, 15117) | 0;\n      } else {\n       $426 = $422 + ($$0444 * 24 | 0) + 12 | 0;\n       if ((HEAP8[$426 + 11 >> 0] | 0) < 0) $432 = HEAP32[$426 >> 2] | 0; else $432 = $426;\n       if ((HEAP8[$432 >> 0] | 0) == 40) {\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($423, 15119) | 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc((HEAP32[$2 >> 2] | 0) + ($$0444 * 24 | 0) + 12 | 0, 0, 15117) | 0;\n       }\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$2 >> 2] | 0) + ($$0444 * 24 | 0) | 0, 15139) | 0;\n      $438 = HEAP32[$397 >> 2] | 0;\n      $440 = (HEAP32[$2 >> 2] | 0) + ($$0444 * 24 | 0) | 0;\n      $441 = $438 + -12 | 0;\n      $442 = HEAP32[$441 >> 2] | 0;\n      if (($442 | 0) == (HEAP32[$438 + -8 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($438 + -16 | 0, $440); else {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($442, $440);\n       HEAP32[$441 >> 2] = (HEAP32[$441 >> 2] | 0) + 24;\n      }\n      $$0444 = $$0444 + 1 | 0;\n     }\n     break;\n    }\n   case 84:\n    {\n     $450 = $2 + 4 | 0;\n     $454 = ((HEAP32[$450 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     $455 = __ZN10__cxxabiv112_GLOBAL__N_120parse_template_paramINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n     $459 = ((HEAP32[$450 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n     if (($455 | 0) == ($0 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $461 = $2 + 16 | 0;\n     $$sroa$0$0$$sroa_idx$i544 = $2 + 12 | 0;\n     $$sroa$0$0$copyload$i545602 = HEAP32[$$sroa$0$0$$sroa_idx$i544 >> 2] | 0;\n     HEAP32[$3 >> 2] = $$sroa$0$0$copyload$i545602;\n     $462 = $2 + 20 | 0;\n     $463 = HEAP32[$462 >> 2] | 0;\n     $464 = $2 + 24 | 0;\n     if ($463 >>> 0 < (HEAP32[$464 >> 2] | 0) >>> 0) {\n      HEAP32[$463 >> 2] = 0;\n      HEAP32[$463 + 4 >> 2] = 0;\n      HEAP32[$463 + 8 >> 2] = 0;\n      HEAP32[$463 + 12 >> 2] = $$sroa$0$0$copyload$i545602;\n      HEAP32[$462 >> 2] = (HEAP32[$462 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($461, $3);\n     $$0438 = $454;\n     while (1) {\n      if ($$0438 >>> 0 >= $459 >>> 0) break;\n      $478 = HEAP32[$462 >> 2] | 0;\n      $480 = (HEAP32[$2 >> 2] | 0) + ($$0438 * 24 | 0) | 0;\n      $481 = $478 + -12 | 0;\n      $482 = HEAP32[$481 >> 2] | 0;\n      if (($482 | 0) == (HEAP32[$478 + -8 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($478 + -16 | 0, $480); else {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($482, $480);\n       HEAP32[$481 >> 2] = (HEAP32[$481 >> 2] | 0) + 24;\n      }\n      $$0438 = $$0438 + 1 | 0;\n     }\n     if (!(($459 | 0) == ($454 + 1 | 0) & (HEAP8[$2 + 63 >> 0] | 0) != 0)) {\n      $$5 = $455;\n      break L1;\n     }\n     $490 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($455, $1, $2) | 0;\n     if (($490 | 0) == ($455 | 0)) {\n      $$5 = $455;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, (HEAP32[$450 >> 2] | 0) + -24 | 0);\n     $494 = HEAP32[$450 >> 2] | 0;\n     $$0$i$i$idx$i548 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i548 | 0) == -1) break;\n      $$0$i$i$add$i549 = $$0$i$i$idx$i548 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($494 + ($$0$i$i$add$i549 * 24 | 0) | 0);\n      $$0$i$i$idx$i548 = $$0$i$i$add$i549;\n     }\n     HEAP32[$450 >> 2] = $494 + -24;\n     $499 = HEAP8[$3 + 11 >> 0] | 0;\n     $500 = $499 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($494 + -48 | 0, $500 ? HEAP32[$3 >> 2] | 0 : $3, $500 ? HEAP32[$3 + 4 >> 2] | 0 : $499 & 255) | 0;\n     $508 = (HEAP32[$450 >> 2] | 0) + -24 | 0;\n     HEAP32[$5 >> 2] = HEAP32[$$sroa$0$0$$sroa_idx$i544 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($4, $508, $5);\n     $509 = HEAP32[$462 >> 2] | 0;\n     if ($509 >>> 0 < (HEAP32[$464 >> 2] | 0) >>> 0) {\n      HEAP32[$509 >> 2] = 0;\n      $513 = $509 + 4 | 0;\n      HEAP32[$513 >> 2] = 0;\n      $514 = $509 + 8 | 0;\n      HEAP32[$514 >> 2] = 0;\n      HEAP32[$509 + 12 >> 2] = HEAP32[$4 + 12 >> 2];\n      HEAP32[$509 >> 2] = HEAP32[$4 >> 2];\n      $518 = $4 + 4 | 0;\n      HEAP32[$513 >> 2] = HEAP32[$518 >> 2];\n      $520 = $4 + 8 | 0;\n      HEAP32[$514 >> 2] = HEAP32[$520 >> 2];\n      HEAP32[$520 >> 2] = 0;\n      HEAP32[$518 >> 2] = 0;\n      HEAP32[$4 >> 2] = 0;\n      HEAP32[$462 >> 2] = (HEAP32[$462 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($461, $4);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$5 = $490;\n     break L1;\n     break;\n    }\n   case 85:\n    {\n     $524 = $0 + 1 | 0;\n     if (($524 | 0) == ($1 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $526 = __ZN10__cxxabiv112_GLOBAL__N_117parse_source_nameINS0_2DbEEEPKcS4_S4_RT_($524, $1, $2) | 0;\n     if (($526 | 0) == ($524 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $528 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($526, $1, $2) | 0;\n     if (($528 | 0) == ($526 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $530 = $2 + 4 | 0;\n     $531 = HEAP32[$530 >> 2] | 0;\n     if ((($531 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$5 = $0;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $531 + -24 | 0);\n     $538 = HEAP32[$530 >> 2] | 0;\n     $$0$i$i$idx$i560 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i560 | 0) == -1) break;\n      $$0$i$i$add$i561 = $$0$i$i$idx$i560 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($538 + ($$0$i$i$add$i561 * 24 | 0) | 0);\n      $$0$i$i$idx$i560 = $$0$i$i$add$i561;\n     }\n     HEAP32[$530 >> 2] = $538 + -24;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($4, $538 + -48 | 0, 9);\n     $542 = __ZNSt3__211char_traitsIcE6lengthEPKc(15141) | 0;\n     $544 = HEAP8[$4 + 11 >> 0] | 0;\n     if (($542 | 0) == (($544 << 24 >> 24 < 0 ? HEAP32[$4 + 4 >> 2] | 0 : $544 & 255) | 0)) {\n      $552 = (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($4, 15141, $542) | 0) == 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n      if ($552) {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, (HEAP32[$530 >> 2] | 0) + -24 | 0);\n       $571 = HEAP32[$530 >> 2] | 0;\n       $$0$i$i$idx$i568 = 0;\n       while (1) {\n        if (($$0$i$i$idx$i568 | 0) == -1) break;\n        $$0$i$i$add$i569 = $$0$i$i$idx$i568 + -1 | 0;\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($571 + ($$0$i$i$add$i569 * 24 | 0) | 0);\n        $$0$i$i$idx$i568 = $$0$i$i$add$i569;\n       }\n       HEAP32[$530 >> 2] = $571 + -24;\n       $574 = $4 + 11 | 0;\n       $575 = HEAP8[$574 >> 0] | 0;\n       $576 = $575 << 24 >> 24 < 0;\n       $578 = $4 + 4 | 0;\n       $581 = $576 ? HEAP32[$4 >> 2] | 0 : $4;\n       $585 = __ZN10__cxxabiv112_GLOBAL__N_117parse_source_nameINS0_2DbEEEPKcS4_S4_RT_($581 + 9 | 0, $581 + ($576 ? HEAP32[$578 >> 2] | 0 : $575 & 255) | 0, $2) | 0;\n       if (($585 | 0) == (((HEAP8[$574 >> 0] | 0) < 0 ? HEAP32[$4 >> 2] | 0 : $4) + 9 | 0)) {\n        __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EERKSB_PKS8_($7, $3, 15151);\n        $611 = HEAP8[$574 >> 0] | 0;\n        $612 = $611 << 24 >> 24 < 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($7, $612 ? HEAP32[$4 >> 2] | 0 : $4, $612 ? HEAP32[$578 >> 2] | 0 : $611 & 255) | 0;\n        HEAP32[$11 >> 2] = HEAP32[$7 >> 2];\n        HEAP32[$11 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n        HEAP32[$11 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n        $$0$i$i$i582 = 0;\n        while (1) {\n         if (($$0$i$i$i582 | 0) == 3) break;\n         HEAP32[$7 + ($$0$i$i$i582 << 2) >> 2] = 0;\n         $$0$i$i$i582 = $$0$i$i$i582 + 1 | 0;\n        }\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($5, $11);\n        $621 = HEAP32[$530 >> 2] | 0;\n        if ($621 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n         __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($621, $5);\n         HEAP32[$530 >> 2] = (HEAP32[$530 >> 2] | 0) + 24;\n        } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $5);\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($5);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($11);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n       } else {\n        __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EERKSB_PKS8_($9, $3, 15153);\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($10, (HEAP32[$530 >> 2] | 0) + -24 | 0);\n        $595 = HEAP8[$10 + 11 >> 0] | 0;\n        $596 = $595 << 24 >> 24 < 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($9, $596 ? HEAP32[$10 >> 2] | 0 : $10, $596 ? HEAP32[$10 + 4 >> 2] | 0 : $595 & 255) | 0;\n        HEAP32[$7 >> 2] = HEAP32[$9 >> 2];\n        HEAP32[$7 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n        HEAP32[$7 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n        $$0$i$i$i575 = 0;\n        while (1) {\n         if (($$0$i$i$i575 | 0) == 3) break;\n         HEAP32[$9 + ($$0$i$i$i575 << 2) >> 2] = 0;\n         $$0$i$i$i575 = $$0$i$i$i575 + 1 | 0;\n        }\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($7, 15155) | 0;\n        HEAP32[$8 >> 2] = HEAP32[$7 >> 2];\n        HEAP32[$8 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n        HEAP32[$8 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n        $$0$i$i$i579 = 0;\n        while (1) {\n         if (($$0$i$i$i579 | 0) == 3) break;\n         HEAP32[$7 + ($$0$i$i$i579 << 2) >> 2] = 0;\n         $$0$i$i$i579 = $$0$i$i$i579 + 1 | 0;\n        }\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($5, $8);\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$530 >> 2] | 0) + -24 | 0, $5);\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($5);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($10);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n       }\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n      } else label = 167;\n     } else {\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n      label = 167;\n     }\n     if ((label | 0) == 167) {\n      __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EERKSB_PKS8_($5, $3, 15151);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($7, (HEAP32[$530 >> 2] | 0) + -24 | 0);\n      $556 = HEAP8[$7 + 11 >> 0] | 0;\n      $557 = $556 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($5, $557 ? HEAP32[$7 >> 2] | 0 : $7, $557 ? HEAP32[$7 + 4 >> 2] | 0 : $556 & 255) | 0;\n      HEAP32[$6 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$6 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n      HEAP32[$6 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n      $$0$i$i$i = 0;\n      while (1) {\n       if (($$0$i$i$i | 0) == 3) break;\n       HEAP32[$5 + ($$0$i$i$i << 2) >> 2] = 0;\n       $$0$i$i$i = $$0$i$i$i + 1 | 0;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $6);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$530 >> 2] | 0) + -24 | 0, $4);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     }\n     $628 = (HEAP32[$530 >> 2] | 0) + -24 | 0;\n     HEAP32[$5 >> 2] = HEAP32[$2 + 12 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($4, $628, $5);\n     $629 = $2 + 20 | 0;\n     $630 = HEAP32[$629 >> 2] | 0;\n     if ($630 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$630 >> 2] = 0;\n      $635 = $630 + 4 | 0;\n      HEAP32[$635 >> 2] = 0;\n      $636 = $630 + 8 | 0;\n      HEAP32[$636 >> 2] = 0;\n      HEAP32[$630 + 12 >> 2] = HEAP32[$4 + 12 >> 2];\n      HEAP32[$630 >> 2] = HEAP32[$4 >> 2];\n      $640 = $4 + 4 | 0;\n      HEAP32[$635 >> 2] = HEAP32[$640 >> 2];\n      $642 = $4 + 8 | 0;\n      HEAP32[$636 >> 2] = HEAP32[$642 >> 2];\n      HEAP32[$642 >> 2] = 0;\n      HEAP32[$640 >> 2] = 0;\n      HEAP32[$4 >> 2] = 0;\n      HEAP32[$629 >> 2] = (HEAP32[$629 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $4);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$5 = $528;\n     break L1;\n     break;\n    }\n   case 83:\n    {\n     $647 = $0 + 1 | 0;\n     if (($647 | 0) != ($1 | 0)) if ((HEAP8[$647 >> 0] | 0) == 116) {\n      $651 = __ZN10__cxxabiv112_GLOBAL__N_110parse_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n      if (($651 | 0) == ($0 | 0)) {\n       $$5 = $0;\n       break L1;\n      }\n      $655 = HEAP32[$2 + 4 >> 2] | 0;\n      if ((HEAP32[$2 >> 2] | 0) == ($655 | 0)) {\n       $$5 = $0;\n       break L1;\n      }\n      HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n      __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $655 + -24 | 0, $4);\n      $658 = $2 + 20 | 0;\n      $659 = HEAP32[$658 >> 2] | 0;\n      if ($659 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n       HEAP32[$659 >> 2] = 0;\n       $664 = $659 + 4 | 0;\n       HEAP32[$664 >> 2] = 0;\n       $665 = $659 + 8 | 0;\n       HEAP32[$665 >> 2] = 0;\n       HEAP32[$659 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n       HEAP32[$659 >> 2] = HEAP32[$3 >> 2];\n       $669 = $3 + 4 | 0;\n       HEAP32[$664 >> 2] = HEAP32[$669 >> 2];\n       $671 = $3 + 8 | 0;\n       HEAP32[$665 >> 2] = HEAP32[$671 >> 2];\n       HEAP32[$671 >> 2] = 0;\n       HEAP32[$669 >> 2] = 0;\n       HEAP32[$3 >> 2] = 0;\n       HEAP32[$658 >> 2] = (HEAP32[$658 >> 2] | 0) + 16;\n      } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n      __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n      $$5 = $651;\n      break L1;\n     }\n     $676 = __ZN10__cxxabiv112_GLOBAL__N_118parse_substitutionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n     if (($676 | 0) == ($0 | 0)) {\n      $$5 = $0;\n      break L1;\n     }\n     $678 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($676, $1, $2) | 0;\n     if (($678 | 0) == ($676 | 0)) {\n      $$5 = $676;\n      break L1;\n     }\n     $680 = $2 + 4 | 0;\n     $681 = HEAP32[$680 >> 2] | 0;\n     if ((($681 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$5 = $676;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $681 + -24 | 0);\n     $688 = HEAP32[$680 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($688 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$680 >> 2] = $688 + -24;\n     $693 = HEAP8[$3 + 11 >> 0] | 0;\n     $694 = $693 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($688 + -48 | 0, $694 ? HEAP32[$3 >> 2] | 0 : $3, $694 ? HEAP32[$3 + 4 >> 2] | 0 : $693 & 255) | 0;\n     $702 = (HEAP32[$680 >> 2] | 0) + -24 | 0;\n     HEAP32[$5 >> 2] = HEAP32[$2 + 12 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($4, $702, $5);\n     $703 = $2 + 20 | 0;\n     $704 = HEAP32[$703 >> 2] | 0;\n     if ($704 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n      HEAP32[$704 >> 2] = 0;\n      $709 = $704 + 4 | 0;\n      HEAP32[$709 >> 2] = 0;\n      $710 = $704 + 8 | 0;\n      HEAP32[$710 >> 2] = 0;\n      HEAP32[$704 + 12 >> 2] = HEAP32[$4 + 12 >> 2];\n      HEAP32[$704 >> 2] = HEAP32[$4 >> 2];\n      $714 = $4 + 4 | 0;\n      HEAP32[$709 >> 2] = HEAP32[$714 >> 2];\n      $716 = $4 + 8 | 0;\n      HEAP32[$710 >> 2] = HEAP32[$716 >> 2];\n      HEAP32[$716 >> 2] = 0;\n      HEAP32[$714 >> 2] = 0;\n      HEAP32[$4 >> 2] = 0;\n      HEAP32[$703 >> 2] = (HEAP32[$703 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $4);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$5 = $678;\n     break L1;\n     break;\n    }\n   case 68:\n    {\n     $721 = $0 + 1 | 0;\n     if (($721 | 0) != ($1 | 0)) switch (HEAP8[$721 >> 0] | 0) {\n     case 112:\n      {\n       $725 = $2 + 4 | 0;\n       $729 = ((HEAP32[$725 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n       $730 = $0 + 2 | 0;\n       $731 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($730, $1, $2) | 0;\n       $735 = ((HEAP32[$725 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n       if (($731 | 0) == ($730 | 0)) break L59;\n       $$sroa$0$0$copyload$i490598 = HEAP32[$2 + 12 >> 2] | 0;\n       HEAP32[$3 >> 2] = $$sroa$0$0$copyload$i490598;\n       $737 = $2 + 20 | 0;\n       $738 = HEAP32[$737 >> 2] | 0;\n       if ($738 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n        HEAP32[$738 >> 2] = 0;\n        HEAP32[$738 + 4 >> 2] = 0;\n        HEAP32[$738 + 8 >> 2] = 0;\n        HEAP32[$738 + 12 >> 2] = $$sroa$0$0$copyload$i490598;\n        HEAP32[$737 >> 2] = (HEAP32[$737 >> 2] | 0) + 16;\n       } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($2 + 16 | 0, $3);\n       $$0 = $729;\n       while (1) {\n        if ($$0 >>> 0 >= $735 >>> 0) {\n         $$5 = $731;\n         break L1;\n        }\n        $749 = HEAP32[$737 >> 2] | 0;\n        $751 = (HEAP32[$2 >> 2] | 0) + ($$0 * 24 | 0) | 0;\n        $752 = $749 + -12 | 0;\n        $753 = HEAP32[$752 >> 2] | 0;\n        if (($753 | 0) == (HEAP32[$749 + -8 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($749 + -16 | 0, $751); else {\n         __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($753, $751);\n         HEAP32[$752 >> 2] = (HEAP32[$752 >> 2] | 0) + 24;\n        }\n        $$0 = $$0 + 1 | 0;\n       }\n       break;\n      }\n     case 84:\n     case 116:\n      {\n       $761 = __ZN10__cxxabiv112_GLOBAL__N_114parse_decltypeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n       if (($761 | 0) == ($0 | 0)) break L59;\n       $765 = HEAP32[$2 + 4 >> 2] | 0;\n       if ((HEAP32[$2 >> 2] | 0) == ($765 | 0)) {\n        $$5 = $0;\n        break L1;\n       }\n       HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n       __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $765 + -24 | 0, $4);\n       $768 = $2 + 20 | 0;\n       $769 = HEAP32[$768 >> 2] | 0;\n       if ($769 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n        HEAP32[$769 >> 2] = 0;\n        $774 = $769 + 4 | 0;\n        HEAP32[$774 >> 2] = 0;\n        $775 = $769 + 8 | 0;\n        HEAP32[$775 >> 2] = 0;\n        HEAP32[$769 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n        HEAP32[$769 >> 2] = HEAP32[$3 >> 2];\n        $779 = $3 + 4 | 0;\n        HEAP32[$774 >> 2] = HEAP32[$779 >> 2];\n        $781 = $3 + 8 | 0;\n        HEAP32[$775 >> 2] = HEAP32[$781 >> 2];\n        HEAP32[$781 >> 2] = 0;\n        HEAP32[$779 >> 2] = 0;\n        HEAP32[$3 >> 2] = 0;\n        HEAP32[$768 >> 2] = (HEAP32[$768 >> 2] | 0) + 16;\n       } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n       __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n       $$5 = $761;\n       break L1;\n       break;\n      }\n     case 118:\n      {\n       $786 = __ZN10__cxxabiv112_GLOBAL__N_117parse_vector_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n       if (($786 | 0) == ($0 | 0)) break L59;\n       $790 = HEAP32[$2 + 4 >> 2] | 0;\n       if ((HEAP32[$2 >> 2] | 0) == ($790 | 0)) {\n        $$5 = $0;\n        break L1;\n       }\n       HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n       __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $790 + -24 | 0, $4);\n       $793 = $2 + 20 | 0;\n       $794 = HEAP32[$793 >> 2] | 0;\n       if ($794 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n        HEAP32[$794 >> 2] = 0;\n        $799 = $794 + 4 | 0;\n        HEAP32[$799 >> 2] = 0;\n        $800 = $794 + 8 | 0;\n        HEAP32[$800 >> 2] = 0;\n        HEAP32[$794 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n        HEAP32[$794 >> 2] = HEAP32[$3 >> 2];\n        $804 = $3 + 4 | 0;\n        HEAP32[$799 >> 2] = HEAP32[$804 >> 2];\n        $806 = $3 + 8 | 0;\n        HEAP32[$800 >> 2] = HEAP32[$806 >> 2];\n        HEAP32[$806 >> 2] = 0;\n        HEAP32[$804 >> 2] = 0;\n        HEAP32[$3 >> 2] = 0;\n        HEAP32[$793 >> 2] = (HEAP32[$793 >> 2] | 0) + 16;\n       } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n       __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n       $$5 = $786;\n       break L1;\n       break;\n      }\n     default:\n      break L59;\n     }\n     break;\n    }\n   default:\n    {}\n   } while (0);\n   $811 = __ZN10__cxxabiv112_GLOBAL__N_118parse_builtin_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   if (($811 | 0) == ($0 | 0)) {\n    $813 = __ZN10__cxxabiv112_GLOBAL__N_110parse_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n    if (($813 | 0) == ($0 | 0)) $$5 = $0; else {\n     $817 = HEAP32[$2 + 4 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($817 | 0)) $$5 = $0; else {\n      HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n      __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $817 + -24 | 0, $4);\n      $820 = $2 + 20 | 0;\n      $821 = HEAP32[$820 >> 2] | 0;\n      if ($821 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n       HEAP32[$821 >> 2] = 0;\n       $826 = $821 + 4 | 0;\n       HEAP32[$826 >> 2] = 0;\n       $827 = $821 + 8 | 0;\n       HEAP32[$827 >> 2] = 0;\n       HEAP32[$821 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n       HEAP32[$821 >> 2] = HEAP32[$3 >> 2];\n       $831 = $3 + 4 | 0;\n       HEAP32[$826 >> 2] = HEAP32[$831 >> 2];\n       $833 = $3 + 8 | 0;\n       HEAP32[$827 >> 2] = HEAP32[$833 >> 2];\n       HEAP32[$833 >> 2] = 0;\n       HEAP32[$831 >> 2] = 0;\n       HEAP32[$3 >> 2] = 0;\n       HEAP32[$820 >> 2] = (HEAP32[$820 >> 2] | 0) + 16;\n      } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n      __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n      $$5 = $813;\n     }\n    }\n   } else $$5 = $811;\n  } else $$5 = $102;\n } while (0);\n STACKTOP = sp;\n return $$5 | 0;\n}\n\nfunction _malloc($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$0$i$i = 0, $$0$i$i$i = 0, $$0$i16$i = 0, $$0187$i = 0, $$0189$i = 0, $$0190$i = 0, $$0191$i = 0, $$0197 = 0, $$0199 = 0, $$02065$i$i = 0, $$0207$lcssa$i$i = 0, $$02074$i$i = 0, $$0211$i$i = 0, $$0212$i$i = 0, $$024372$i = 0, $$0286$i$i = 0, $$028711$i$i = 0, $$0288$lcssa$i$i = 0, $$028810$i$i = 0, $$0294$i$i = 0, $$0295$i$i = 0, $$0340$i = 0, $$034217$i = 0, $$0343$lcssa$i = 0, $$034316$i = 0, $$0345$i = 0, $$0351$i = 0, $$0357$i = 0, $$0358$i = 0, $$0360$i = 0, $$0361$i = 0, $$0367$i = 0, $$1194$i = 0, $$1194$i$be = 0, $$1194$i$ph = 0, $$1196$i = 0, $$1196$i$be = 0, $$1196$i$ph = 0, $$124471$i = 0, $$1290$i$i = 0, $$1290$i$i$be = 0, $$1290$i$i$ph = 0, $$1292$i$i = 0, $$1292$i$i$be = 0, $$1292$i$i$ph = 0, $$1341$i = 0, $$1346$i = 0, $$1362$i = 0, $$1369$i = 0, $$1369$i$be = 0, $$1369$i$ph = 0, $$1373$i = 0, $$1373$i$be = 0, $$1373$i$ph = 0, $$2234243136$i = 0, $$2247$ph$i = 0, $$2253$ph$i = 0, $$2353$i = 0, $$3$i = 0, $$3$i$i = 0, $$3$i203 = 0, $$3$i203218 = 0, $$3348$i = 0, $$3371$i = 0, $$4$lcssa$i = 0, $$420$i = 0, $$420$i$ph = 0, $$4236$i = 0, $$4349$lcssa$i = 0, $$434919$i = 0, $$434919$i$ph = 0, $$4355$i = 0, $$535618$i = 0, $$535618$i$ph = 0, $$723947$i = 0, $$748$i = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i18$iZ2D = 0, $$pre$phi$i209Z2D = 0, $$pre$phi$iZ2D = 0, $$pre$phi17$i$iZ2D = 0, $$pre$phiZ2D = 0, $1 = 0, $1000 = 0, $1003 = 0, $1008 = 0, $101 = 0, $1014 = 0, $1017 = 0, $1018 = 0, $102 = 0, $1025 = 0, $1037 = 0, $1042 = 0, $1049 = 0, $1050 = 0, $1051 = 0, $1060 = 0, $1062 = 0, $1063 = 0, $1064 = 0, $1070 = 0, $108 = 0, $112 = 0, $114 = 0, $115 = 0, $117 = 0, $119 = 0, $121 = 0, $123 = 0, $125 = 0, $127 = 0, $129 = 0, $134 = 0, $14 = 0, $140 = 0, $143 = 0, $146 = 0, $149 = 0, $150 = 0, $151 = 0, $153 = 0, $156 = 0, $158 = 0, $16 = 0, $161 = 0, $163 = 0, $166 = 0, $169 = 0, $17 = 0, $170 = 0, $172 = 0, $173 = 0, $175 = 0, $176 = 0, $178 = 0, $179 = 0, $18 = 0, $184 = 0, $185 = 0, $19 = 0, $193 = 0, $198 = 0, $20 = 0, $202 = 0, $208 = 0, $215 = 0, $219 = 0, $228 = 0, $229 = 0, $231 = 0, $232 = 0, $236 = 0, $237 = 0, $245 = 0, $246 = 0, $247 = 0, $249 = 0, $250 = 0, $255 = 0, $256 = 0, $259 = 0, $261 = 0, $264 = 0, $269 = 0, $27 = 0, $276 = 0, $286 = 0, $290 = 0, $299 = 0, $30 = 0, $302 = 0, $306 = 0, $308 = 0, $309 = 0, $311 = 0, $313 = 0, $315 = 0, $317 = 0, $319 = 0, $321 = 0, $323 = 0, $333 = 0, $334 = 0, $336 = 0, $34 = 0, $341 = 0, $346 = 0, $348 = 0, $351 = 0, $353 = 0, $356 = 0, $358 = 0, $361 = 0, $364 = 0, $365 = 0, $367 = 0, $368 = 0, $37 = 0, $370 = 0, $371 = 0, $373 = 0, $374 = 0, $379 = 0, $380 = 0, $385 = 0, $388 = 0, $393 = 0, $397 = 0, $403 = 0, $41 = 0, $410 = 0, $414 = 0, $422 = 0, $425 = 0, $426 = 0, $427 = 0, $431 = 0, $432 = 0, $438 = 0, $44 = 0, $443 = 0, $444 = 0, $447 = 0, $449 = 0, $452 = 0, $457 = 0, $463 = 0, $465 = 0, $467 = 0, $469 = 0, $47 = 0, $475 = 0, $487 = 0, $49 = 0, $492 = 0, $499 = 0, $50 = 0, $500 = 0, $501 = 0, $510 = 0, $512 = 0, $513 = 0, $515 = 0, $52 = 0, $524 = 0, $528 = 0, $530 = 0, $531 = 0, $532 = 0, $54 = 0, $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $550 = 0, $552 = 0, $553 = 0, $559 = 0, $56 = 0, $561 = 0, $568 = 0, $570 = 0, $572 = 0, $573 = 0, $574 = 0, $58 = 0, $582 = 0, $583 = 0, $586 = 0, $590 = 0, $593 = 0, $596 = 0, $6 = 0, $60 = 0, $602 = 0, $606 = 0, $610 = 0, $619 = 0, $62 = 0, $620 = 0, $626 = 0, $628 = 0, $632 = 0, $635 = 0, $637 = 0, $64 = 0, $641 = 0, $643 = 0, $648 = 0, $649 = 0, $650 = 0, $656 = 0, $658 = 0, $662 = 0, $664 = 0, $67 = 0, $673 = 0, $675 = 0, $680 = 0, $681 = 0, $682 = 0, $688 = 0, $69 = 0, $690 = 0, $694 = 0, $7 = 0, $70 = 0, $700 = 0, $704 = 0, $71 = 0, $710 = 0, $712 = 0, $718 = 0, $72 = 0, $722 = 0, $723 = 0, $728 = 0, $73 = 0, $734 = 0, $739 = 0, $742 = 0, $743 = 0, $746 = 0, $748 = 0, $750 = 0, $753 = 0, $764 = 0, $769 = 0, $77 = 0, $771 = 0, $774 = 0, $776 = 0, $779 = 0, $782 = 0, $783 = 0, $784 = 0, $786 = 0, $788 = 0, $789 = 0, $791 = 0, $792 = 0, $797 = 0, $798 = 0, $8 = 0, $80 = 0, $807 = 0, $812 = 0, $815 = 0, $816 = 0, $822 = 0, $83 = 0, $830 = 0, $836 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $845 = 0, $846 = 0, $852 = 0, $857 = 0, $858 = 0, $861 = 0, $863 = 0, $866 = 0, $87 = 0, $871 = 0, $877 = 0, $879 = 0, $881 = 0, $882 = 0, $889 = 0, $9 = 0, $901 = 0, $906 = 0, $913 = 0, $914 = 0, $915 = 0, $92 = 0, $923 = 0, $927 = 0, $93 = 0, $931 = 0, $933 = 0, $939 = 0, $940 = 0, $942 = 0, $943 = 0, $945 = 0, $947 = 0, $95 = 0, $952 = 0, $953 = 0, $954 = 0, $96 = 0, $960 = 0, $962 = 0, $968 = 0, $973 = 0, $976 = 0, $977 = 0, $978 = 0, $98 = 0, $982 = 0, $983 = 0, $989 = 0, $994 = 0, $995 = 0, $998 = 0, $spec$select$i205 = 0, $spec$select3$i = 0, $spec$select49$i = 0, label = 0, sp = 0, $962$looptemp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n do if ($0 >>> 0 < 245) {\n  $6 = $0 >>> 0 < 11 ? 16 : $0 + 11 & -8;\n  $7 = $6 >>> 3;\n  $8 = HEAP32[4351] | 0;\n  $9 = $8 >>> $7;\n  if ($9 & 3 | 0) {\n   $14 = ($9 & 1 ^ 1) + $7 | 0;\n   $16 = 17444 + ($14 << 1 << 2) | 0;\n   $17 = $16 + 8 | 0;\n   $18 = HEAP32[$17 >> 2] | 0;\n   $19 = $18 + 8 | 0;\n   $20 = HEAP32[$19 >> 2] | 0;\n   do if (($20 | 0) == ($16 | 0)) HEAP32[4351] = $8 & ~(1 << $14); else {\n    if ((HEAP32[4355] | 0) >>> 0 > $20 >>> 0) _abort();\n    $27 = $20 + 12 | 0;\n    if ((HEAP32[$27 >> 2] | 0) == ($18 | 0)) {\n     HEAP32[$27 >> 2] = $16;\n     HEAP32[$17 >> 2] = $20;\n     break;\n    } else _abort();\n   } while (0);\n   $30 = $14 << 3;\n   HEAP32[$18 + 4 >> 2] = $30 | 3;\n   $34 = $18 + $30 + 4 | 0;\n   HEAP32[$34 >> 2] = HEAP32[$34 >> 2] | 1;\n   $$0 = $19;\n   STACKTOP = sp;\n   return $$0 | 0;\n  }\n  $37 = HEAP32[4353] | 0;\n  if ($6 >>> 0 > $37 >>> 0) {\n   if ($9 | 0) {\n    $41 = 2 << $7;\n    $44 = $9 << $7 & ($41 | 0 - $41);\n    $47 = ($44 & 0 - $44) + -1 | 0;\n    $49 = $47 >>> 12 & 16;\n    $50 = $47 >>> $49;\n    $52 = $50 >>> 5 & 8;\n    $54 = $50 >>> $52;\n    $56 = $54 >>> 2 & 4;\n    $58 = $54 >>> $56;\n    $60 = $58 >>> 1 & 2;\n    $62 = $58 >>> $60;\n    $64 = $62 >>> 1 & 1;\n    $67 = ($52 | $49 | $56 | $60 | $64) + ($62 >>> $64) | 0;\n    $69 = 17444 + ($67 << 1 << 2) | 0;\n    $70 = $69 + 8 | 0;\n    $71 = HEAP32[$70 >> 2] | 0;\n    $72 = $71 + 8 | 0;\n    $73 = HEAP32[$72 >> 2] | 0;\n    do if (($73 | 0) == ($69 | 0)) {\n     $77 = $8 & ~(1 << $67);\n     HEAP32[4351] = $77;\n     $98 = $77;\n    } else {\n     if ((HEAP32[4355] | 0) >>> 0 > $73 >>> 0) _abort();\n     $80 = $73 + 12 | 0;\n     if ((HEAP32[$80 >> 2] | 0) == ($71 | 0)) {\n      HEAP32[$80 >> 2] = $69;\n      HEAP32[$70 >> 2] = $73;\n      $98 = $8;\n      break;\n     } else _abort();\n    } while (0);\n    $83 = $67 << 3;\n    $84 = $83 - $6 | 0;\n    HEAP32[$71 + 4 >> 2] = $6 | 3;\n    $87 = $71 + $6 | 0;\n    HEAP32[$87 + 4 >> 2] = $84 | 1;\n    HEAP32[$71 + $83 >> 2] = $84;\n    if ($37 | 0) {\n     $92 = HEAP32[4356] | 0;\n     $93 = $37 >>> 3;\n     $95 = 17444 + ($93 << 1 << 2) | 0;\n     $96 = 1 << $93;\n     if (!($98 & $96)) {\n      HEAP32[4351] = $98 | $96;\n      $$0199 = $95;\n      $$pre$phiZ2D = $95 + 8 | 0;\n     } else {\n      $101 = $95 + 8 | 0;\n      $102 = HEAP32[$101 >> 2] | 0;\n      if ((HEAP32[4355] | 0) >>> 0 > $102 >>> 0) _abort(); else {\n       $$0199 = $102;\n       $$pre$phiZ2D = $101;\n      }\n     }\n     HEAP32[$$pre$phiZ2D >> 2] = $92;\n     HEAP32[$$0199 + 12 >> 2] = $92;\n     HEAP32[$92 + 8 >> 2] = $$0199;\n     HEAP32[$92 + 12 >> 2] = $95;\n    }\n    HEAP32[4353] = $84;\n    HEAP32[4356] = $87;\n    $$0 = $72;\n    STACKTOP = sp;\n    return $$0 | 0;\n   }\n   $108 = HEAP32[4352] | 0;\n   if (!$108) $$0197 = $6; else {\n    $112 = ($108 & 0 - $108) + -1 | 0;\n    $114 = $112 >>> 12 & 16;\n    $115 = $112 >>> $114;\n    $117 = $115 >>> 5 & 8;\n    $119 = $115 >>> $117;\n    $121 = $119 >>> 2 & 4;\n    $123 = $119 >>> $121;\n    $125 = $123 >>> 1 & 2;\n    $127 = $123 >>> $125;\n    $129 = $127 >>> 1 & 1;\n    $134 = HEAP32[17708 + (($117 | $114 | $121 | $125 | $129) + ($127 >>> $129) << 2) >> 2] | 0;\n    $$0189$i = $134;\n    $$0190$i = $134;\n    $$0191$i = (HEAP32[$134 + 4 >> 2] & -8) - $6 | 0;\n    while (1) {\n     $140 = HEAP32[$$0189$i + 16 >> 2] | 0;\n     if (!$140) {\n      $143 = HEAP32[$$0189$i + 20 >> 2] | 0;\n      if (!$143) break; else $146 = $143;\n     } else $146 = $140;\n     $149 = (HEAP32[$146 + 4 >> 2] & -8) - $6 | 0;\n     $150 = $149 >>> 0 < $$0191$i >>> 0;\n     $$0189$i = $146;\n     $$0190$i = $150 ? $146 : $$0190$i;\n     $$0191$i = $150 ? $149 : $$0191$i;\n    }\n    $151 = HEAP32[4355] | 0;\n    if ($151 >>> 0 > $$0190$i >>> 0) _abort();\n    $153 = $$0190$i + $6 | 0;\n    if ($153 >>> 0 <= $$0190$i >>> 0) _abort();\n    $156 = HEAP32[$$0190$i + 24 >> 2] | 0;\n    $158 = HEAP32[$$0190$i + 12 >> 2] | 0;\n    do if (($158 | 0) == ($$0190$i | 0)) {\n     $169 = $$0190$i + 20 | 0;\n     $170 = HEAP32[$169 >> 2] | 0;\n     if (!$170) {\n      $172 = $$0190$i + 16 | 0;\n      $173 = HEAP32[$172 >> 2] | 0;\n      if (!$173) {\n       $$3$i = 0;\n       break;\n      } else {\n       $$1194$i$ph = $173;\n       $$1196$i$ph = $172;\n      }\n     } else {\n      $$1194$i$ph = $170;\n      $$1196$i$ph = $169;\n     }\n     $$1194$i = $$1194$i$ph;\n     $$1196$i = $$1196$i$ph;\n     while (1) {\n      $175 = $$1194$i + 20 | 0;\n      $176 = HEAP32[$175 >> 2] | 0;\n      if (!$176) {\n       $178 = $$1194$i + 16 | 0;\n       $179 = HEAP32[$178 >> 2] | 0;\n       if (!$179) break; else {\n        $$1194$i$be = $179;\n        $$1196$i$be = $178;\n       }\n      } else {\n       $$1194$i$be = $176;\n       $$1196$i$be = $175;\n      }\n      $$1194$i = $$1194$i$be;\n      $$1196$i = $$1196$i$be;\n     }\n     if ($151 >>> 0 > $$1196$i >>> 0) _abort(); else {\n      HEAP32[$$1196$i >> 2] = 0;\n      $$3$i = $$1194$i;\n      break;\n     }\n    } else {\n     $161 = HEAP32[$$0190$i + 8 >> 2] | 0;\n     if ($151 >>> 0 > $161 >>> 0) _abort();\n     $163 = $161 + 12 | 0;\n     if ((HEAP32[$163 >> 2] | 0) != ($$0190$i | 0)) _abort();\n     $166 = $158 + 8 | 0;\n     if ((HEAP32[$166 >> 2] | 0) == ($$0190$i | 0)) {\n      HEAP32[$163 >> 2] = $158;\n      HEAP32[$166 >> 2] = $161;\n      $$3$i = $158;\n      break;\n     } else _abort();\n    } while (0);\n    L78 : do if ($156 | 0) {\n     $184 = HEAP32[$$0190$i + 28 >> 2] | 0;\n     $185 = 17708 + ($184 << 2) | 0;\n     do if (($$0190$i | 0) == (HEAP32[$185 >> 2] | 0)) {\n      HEAP32[$185 >> 2] = $$3$i;\n      if (!$$3$i) {\n       HEAP32[4352] = $108 & ~(1 << $184);\n       break L78;\n      }\n     } else if ((HEAP32[4355] | 0) >>> 0 > $156 >>> 0) _abort(); else {\n      $193 = $156 + 16 | 0;\n      HEAP32[((HEAP32[$193 >> 2] | 0) == ($$0190$i | 0) ? $193 : $156 + 20 | 0) >> 2] = $$3$i;\n      if (!$$3$i) break L78; else break;\n     } while (0);\n     $198 = HEAP32[4355] | 0;\n     if ($198 >>> 0 > $$3$i >>> 0) _abort();\n     HEAP32[$$3$i + 24 >> 2] = $156;\n     $202 = HEAP32[$$0190$i + 16 >> 2] | 0;\n     do if ($202 | 0) if ($198 >>> 0 > $202 >>> 0) _abort(); else {\n      HEAP32[$$3$i + 16 >> 2] = $202;\n      HEAP32[$202 + 24 >> 2] = $$3$i;\n      break;\n     } while (0);\n     $208 = HEAP32[$$0190$i + 20 >> 2] | 0;\n     if ($208 | 0) if ((HEAP32[4355] | 0) >>> 0 > $208 >>> 0) _abort(); else {\n      HEAP32[$$3$i + 20 >> 2] = $208;\n      HEAP32[$208 + 24 >> 2] = $$3$i;\n      break;\n     }\n    } while (0);\n    if ($$0191$i >>> 0 < 16) {\n     $215 = $$0191$i + $6 | 0;\n     HEAP32[$$0190$i + 4 >> 2] = $215 | 3;\n     $219 = $$0190$i + $215 + 4 | 0;\n     HEAP32[$219 >> 2] = HEAP32[$219 >> 2] | 1;\n    } else {\n     HEAP32[$$0190$i + 4 >> 2] = $6 | 3;\n     HEAP32[$153 + 4 >> 2] = $$0191$i | 1;\n     HEAP32[$153 + $$0191$i >> 2] = $$0191$i;\n     if ($37 | 0) {\n      $228 = HEAP32[4356] | 0;\n      $229 = $37 >>> 3;\n      $231 = 17444 + ($229 << 1 << 2) | 0;\n      $232 = 1 << $229;\n      if (!($232 & $8)) {\n       HEAP32[4351] = $232 | $8;\n       $$0187$i = $231;\n       $$pre$phi$iZ2D = $231 + 8 | 0;\n      } else {\n       $236 = $231 + 8 | 0;\n       $237 = HEAP32[$236 >> 2] | 0;\n       if ((HEAP32[4355] | 0) >>> 0 > $237 >>> 0) _abort(); else {\n        $$0187$i = $237;\n        $$pre$phi$iZ2D = $236;\n       }\n      }\n      HEAP32[$$pre$phi$iZ2D >> 2] = $228;\n      HEAP32[$$0187$i + 12 >> 2] = $228;\n      HEAP32[$228 + 8 >> 2] = $$0187$i;\n      HEAP32[$228 + 12 >> 2] = $231;\n     }\n     HEAP32[4353] = $$0191$i;\n     HEAP32[4356] = $153;\n    }\n    $$0 = $$0190$i + 8 | 0;\n    STACKTOP = sp;\n    return $$0 | 0;\n   }\n  } else $$0197 = $6;\n } else if ($0 >>> 0 > 4294967231) $$0197 = -1; else {\n  $245 = $0 + 11 | 0;\n  $246 = $245 & -8;\n  $247 = HEAP32[4352] | 0;\n  if (!$247) $$0197 = $246; else {\n   $249 = 0 - $246 | 0;\n   $250 = $245 >>> 8;\n   if (!$250) $$0357$i = 0; else if ($246 >>> 0 > 16777215) $$0357$i = 31; else {\n    $255 = ($250 + 1048320 | 0) >>> 16 & 8;\n    $256 = $250 << $255;\n    $259 = ($256 + 520192 | 0) >>> 16 & 4;\n    $261 = $256 << $259;\n    $264 = ($261 + 245760 | 0) >>> 16 & 2;\n    $269 = 14 - ($259 | $255 | $264) + ($261 << $264 >>> 15) | 0;\n    $$0357$i = $246 >>> ($269 + 7 | 0) & 1 | $269 << 1;\n   }\n   $276 = HEAP32[17708 + ($$0357$i << 2) >> 2] | 0;\n   L122 : do if (!$276) {\n    $$2353$i = 0;\n    $$3$i203 = 0;\n    $$3348$i = $249;\n    label = 85;\n   } else {\n    $$0340$i = 0;\n    $$0345$i = $249;\n    $$0351$i = $276;\n    $$0358$i = $246 << (($$0357$i | 0) == 31 ? 0 : 25 - ($$0357$i >>> 1) | 0);\n    $$0361$i = 0;\n    while (1) {\n     $286 = (HEAP32[$$0351$i + 4 >> 2] & -8) - $246 | 0;\n     if ($286 >>> 0 < $$0345$i >>> 0) if (!$286) {\n      $$420$i$ph = $$0351$i;\n      $$434919$i$ph = 0;\n      $$535618$i$ph = $$0351$i;\n      label = 89;\n      break L122;\n     } else {\n      $$1341$i = $$0351$i;\n      $$1346$i = $286;\n     } else {\n      $$1341$i = $$0340$i;\n      $$1346$i = $$0345$i;\n     }\n     $290 = HEAP32[$$0351$i + 20 >> 2] | 0;\n     $$0351$i = HEAP32[$$0351$i + 16 + ($$0358$i >>> 31 << 2) >> 2] | 0;\n     $$1362$i = ($290 | 0) == 0 | ($290 | 0) == ($$0351$i | 0) ? $$0361$i : $290;\n     if (!$$0351$i) {\n      $$2353$i = $$1362$i;\n      $$3$i203 = $$1341$i;\n      $$3348$i = $$1346$i;\n      label = 85;\n      break;\n     } else {\n      $$0340$i = $$1341$i;\n      $$0345$i = $$1346$i;\n      $$0358$i = $$0358$i << 1;\n      $$0361$i = $$1362$i;\n     }\n    }\n   } while (0);\n   if ((label | 0) == 85) {\n    if (($$2353$i | 0) == 0 & ($$3$i203 | 0) == 0) {\n     $299 = 2 << $$0357$i;\n     $302 = ($299 | 0 - $299) & $247;\n     if (!$302) {\n      $$0197 = $246;\n      break;\n     }\n     $306 = ($302 & 0 - $302) + -1 | 0;\n     $308 = $306 >>> 12 & 16;\n     $309 = $306 >>> $308;\n     $311 = $309 >>> 5 & 8;\n     $313 = $309 >>> $311;\n     $315 = $313 >>> 2 & 4;\n     $317 = $313 >>> $315;\n     $319 = $317 >>> 1 & 2;\n     $321 = $317 >>> $319;\n     $323 = $321 >>> 1 & 1;\n     $$3$i203218 = 0;\n     $$4355$i = HEAP32[17708 + (($311 | $308 | $315 | $319 | $323) + ($321 >>> $323) << 2) >> 2] | 0;\n    } else {\n     $$3$i203218 = $$3$i203;\n     $$4355$i = $$2353$i;\n    }\n    if (!$$4355$i) {\n     $$4$lcssa$i = $$3$i203218;\n     $$4349$lcssa$i = $$3348$i;\n    } else {\n     $$420$i$ph = $$3$i203218;\n     $$434919$i$ph = $$3348$i;\n     $$535618$i$ph = $$4355$i;\n     label = 89;\n    }\n   }\n   if ((label | 0) == 89) {\n    $$420$i = $$420$i$ph;\n    $$434919$i = $$434919$i$ph;\n    $$535618$i = $$535618$i$ph;\n    while (1) {\n     $333 = (HEAP32[$$535618$i + 4 >> 2] & -8) - $246 | 0;\n     $334 = $333 >>> 0 < $$434919$i >>> 0;\n     $spec$select$i205 = $334 ? $333 : $$434919$i;\n     $spec$select3$i = $334 ? $$535618$i : $$420$i;\n     $336 = HEAP32[$$535618$i + 16 >> 2] | 0;\n     if (!$336) $341 = HEAP32[$$535618$i + 20 >> 2] | 0; else $341 = $336;\n     if (!$341) {\n      $$4$lcssa$i = $spec$select3$i;\n      $$4349$lcssa$i = $spec$select$i205;\n      break;\n     } else {\n      $$420$i = $spec$select3$i;\n      $$434919$i = $spec$select$i205;\n      $$535618$i = $341;\n     }\n    }\n   }\n   if (!$$4$lcssa$i) $$0197 = $246; else if ($$4349$lcssa$i >>> 0 < ((HEAP32[4353] | 0) - $246 | 0) >>> 0) {\n    $346 = HEAP32[4355] | 0;\n    if ($346 >>> 0 > $$4$lcssa$i >>> 0) _abort();\n    $348 = $$4$lcssa$i + $246 | 0;\n    if ($348 >>> 0 <= $$4$lcssa$i >>> 0) _abort();\n    $351 = HEAP32[$$4$lcssa$i + 24 >> 2] | 0;\n    $353 = HEAP32[$$4$lcssa$i + 12 >> 2] | 0;\n    do if (($353 | 0) == ($$4$lcssa$i | 0)) {\n     $364 = $$4$lcssa$i + 20 | 0;\n     $365 = HEAP32[$364 >> 2] | 0;\n     if (!$365) {\n      $367 = $$4$lcssa$i + 16 | 0;\n      $368 = HEAP32[$367 >> 2] | 0;\n      if (!$368) {\n       $$3371$i = 0;\n       break;\n      } else {\n       $$1369$i$ph = $368;\n       $$1373$i$ph = $367;\n      }\n     } else {\n      $$1369$i$ph = $365;\n      $$1373$i$ph = $364;\n     }\n     $$1369$i = $$1369$i$ph;\n     $$1373$i = $$1373$i$ph;\n     while (1) {\n      $370 = $$1369$i + 20 | 0;\n      $371 = HEAP32[$370 >> 2] | 0;\n      if (!$371) {\n       $373 = $$1369$i + 16 | 0;\n       $374 = HEAP32[$373 >> 2] | 0;\n       if (!$374) break; else {\n        $$1369$i$be = $374;\n        $$1373$i$be = $373;\n       }\n      } else {\n       $$1369$i$be = $371;\n       $$1373$i$be = $370;\n      }\n      $$1369$i = $$1369$i$be;\n      $$1373$i = $$1373$i$be;\n     }\n     if ($346 >>> 0 > $$1373$i >>> 0) _abort(); else {\n      HEAP32[$$1373$i >> 2] = 0;\n      $$3371$i = $$1369$i;\n      break;\n     }\n    } else {\n     $356 = HEAP32[$$4$lcssa$i + 8 >> 2] | 0;\n     if ($346 >>> 0 > $356 >>> 0) _abort();\n     $358 = $356 + 12 | 0;\n     if ((HEAP32[$358 >> 2] | 0) != ($$4$lcssa$i | 0)) _abort();\n     $361 = $353 + 8 | 0;\n     if ((HEAP32[$361 >> 2] | 0) == ($$4$lcssa$i | 0)) {\n      HEAP32[$358 >> 2] = $353;\n      HEAP32[$361 >> 2] = $356;\n      $$3371$i = $353;\n      break;\n     } else _abort();\n    } while (0);\n    L176 : do if (!$351) $469 = $247; else {\n     $379 = HEAP32[$$4$lcssa$i + 28 >> 2] | 0;\n     $380 = 17708 + ($379 << 2) | 0;\n     do if (($$4$lcssa$i | 0) == (HEAP32[$380 >> 2] | 0)) {\n      HEAP32[$380 >> 2] = $$3371$i;\n      if (!$$3371$i) {\n       $385 = $247 & ~(1 << $379);\n       HEAP32[4352] = $385;\n       $469 = $385;\n       break L176;\n      }\n     } else if ((HEAP32[4355] | 0) >>> 0 > $351 >>> 0) _abort(); else {\n      $388 = $351 + 16 | 0;\n      HEAP32[((HEAP32[$388 >> 2] | 0) == ($$4$lcssa$i | 0) ? $388 : $351 + 20 | 0) >> 2] = $$3371$i;\n      if (!$$3371$i) {\n       $469 = $247;\n       break L176;\n      } else break;\n     } while (0);\n     $393 = HEAP32[4355] | 0;\n     if ($393 >>> 0 > $$3371$i >>> 0) _abort();\n     HEAP32[$$3371$i + 24 >> 2] = $351;\n     $397 = HEAP32[$$4$lcssa$i + 16 >> 2] | 0;\n     do if ($397 | 0) if ($393 >>> 0 > $397 >>> 0) _abort(); else {\n      HEAP32[$$3371$i + 16 >> 2] = $397;\n      HEAP32[$397 + 24 >> 2] = $$3371$i;\n      break;\n     } while (0);\n     $403 = HEAP32[$$4$lcssa$i + 20 >> 2] | 0;\n     if (!$403) $469 = $247; else if ((HEAP32[4355] | 0) >>> 0 > $403 >>> 0) _abort(); else {\n      HEAP32[$$3371$i + 20 >> 2] = $403;\n      HEAP32[$403 + 24 >> 2] = $$3371$i;\n      $469 = $247;\n      break;\n     }\n    } while (0);\n    L200 : do if ($$4349$lcssa$i >>> 0 < 16) {\n     $410 = $$4349$lcssa$i + $246 | 0;\n     HEAP32[$$4$lcssa$i + 4 >> 2] = $410 | 3;\n     $414 = $$4$lcssa$i + $410 + 4 | 0;\n     HEAP32[$414 >> 2] = HEAP32[$414 >> 2] | 1;\n    } else {\n     HEAP32[$$4$lcssa$i + 4 >> 2] = $246 | 3;\n     HEAP32[$348 + 4 >> 2] = $$4349$lcssa$i | 1;\n     HEAP32[$348 + $$4349$lcssa$i >> 2] = $$4349$lcssa$i;\n     $422 = $$4349$lcssa$i >>> 3;\n     if ($$4349$lcssa$i >>> 0 < 256) {\n      $425 = 17444 + ($422 << 1 << 2) | 0;\n      $426 = HEAP32[4351] | 0;\n      $427 = 1 << $422;\n      if (!($426 & $427)) {\n       HEAP32[4351] = $426 | $427;\n       $$0367$i = $425;\n       $$pre$phi$i209Z2D = $425 + 8 | 0;\n      } else {\n       $431 = $425 + 8 | 0;\n       $432 = HEAP32[$431 >> 2] | 0;\n       if ((HEAP32[4355] | 0) >>> 0 > $432 >>> 0) _abort(); else {\n        $$0367$i = $432;\n        $$pre$phi$i209Z2D = $431;\n       }\n      }\n      HEAP32[$$pre$phi$i209Z2D >> 2] = $348;\n      HEAP32[$$0367$i + 12 >> 2] = $348;\n      HEAP32[$348 + 8 >> 2] = $$0367$i;\n      HEAP32[$348 + 12 >> 2] = $425;\n      break;\n     }\n     $438 = $$4349$lcssa$i >>> 8;\n     if (!$438) $$0360$i = 0; else if ($$4349$lcssa$i >>> 0 > 16777215) $$0360$i = 31; else {\n      $443 = ($438 + 1048320 | 0) >>> 16 & 8;\n      $444 = $438 << $443;\n      $447 = ($444 + 520192 | 0) >>> 16 & 4;\n      $449 = $444 << $447;\n      $452 = ($449 + 245760 | 0) >>> 16 & 2;\n      $457 = 14 - ($447 | $443 | $452) + ($449 << $452 >>> 15) | 0;\n      $$0360$i = $$4349$lcssa$i >>> ($457 + 7 | 0) & 1 | $457 << 1;\n     }\n     $463 = 17708 + ($$0360$i << 2) | 0;\n     HEAP32[$348 + 28 >> 2] = $$0360$i;\n     $465 = $348 + 16 | 0;\n     HEAP32[$465 + 4 >> 2] = 0;\n     HEAP32[$465 >> 2] = 0;\n     $467 = 1 << $$0360$i;\n     if (!($469 & $467)) {\n      HEAP32[4352] = $469 | $467;\n      HEAP32[$463 >> 2] = $348;\n      HEAP32[$348 + 24 >> 2] = $463;\n      HEAP32[$348 + 12 >> 2] = $348;\n      HEAP32[$348 + 8 >> 2] = $348;\n      break;\n     }\n     $475 = HEAP32[$463 >> 2] | 0;\n     L218 : do if ((HEAP32[$475 + 4 >> 2] & -8 | 0) == ($$4349$lcssa$i | 0)) $$0343$lcssa$i = $475; else {\n      $$034217$i = $$4349$lcssa$i << (($$0360$i | 0) == 31 ? 0 : 25 - ($$0360$i >>> 1) | 0);\n      $$034316$i = $475;\n      while (1) {\n       $492 = $$034316$i + 16 + ($$034217$i >>> 31 << 2) | 0;\n       $487 = HEAP32[$492 >> 2] | 0;\n       if (!$487) break;\n       if ((HEAP32[$487 + 4 >> 2] & -8 | 0) == ($$4349$lcssa$i | 0)) {\n        $$0343$lcssa$i = $487;\n        break L218;\n       } else {\n        $$034217$i = $$034217$i << 1;\n        $$034316$i = $487;\n       }\n      }\n      if ((HEAP32[4355] | 0) >>> 0 > $492 >>> 0) _abort(); else {\n       HEAP32[$492 >> 2] = $348;\n       HEAP32[$348 + 24 >> 2] = $$034316$i;\n       HEAP32[$348 + 12 >> 2] = $348;\n       HEAP32[$348 + 8 >> 2] = $348;\n       break L200;\n      }\n     } while (0);\n     $499 = $$0343$lcssa$i + 8 | 0;\n     $500 = HEAP32[$499 >> 2] | 0;\n     $501 = HEAP32[4355] | 0;\n     if ($501 >>> 0 <= $500 >>> 0 & $501 >>> 0 <= $$0343$lcssa$i >>> 0) {\n      HEAP32[$500 + 12 >> 2] = $348;\n      HEAP32[$499 >> 2] = $348;\n      HEAP32[$348 + 8 >> 2] = $500;\n      HEAP32[$348 + 12 >> 2] = $$0343$lcssa$i;\n      HEAP32[$348 + 24 >> 2] = 0;\n      break;\n     } else _abort();\n    } while (0);\n    $$0 = $$4$lcssa$i + 8 | 0;\n    STACKTOP = sp;\n    return $$0 | 0;\n   } else $$0197 = $246;\n  }\n } while (0);\n $510 = HEAP32[4353] | 0;\n if ($510 >>> 0 >= $$0197 >>> 0) {\n  $512 = $510 - $$0197 | 0;\n  $513 = HEAP32[4356] | 0;\n  if ($512 >>> 0 > 15) {\n   $515 = $513 + $$0197 | 0;\n   HEAP32[4356] = $515;\n   HEAP32[4353] = $512;\n   HEAP32[$515 + 4 >> 2] = $512 | 1;\n   HEAP32[$513 + $510 >> 2] = $512;\n   HEAP32[$513 + 4 >> 2] = $$0197 | 3;\n  } else {\n   HEAP32[4353] = 0;\n   HEAP32[4356] = 0;\n   HEAP32[$513 + 4 >> 2] = $510 | 3;\n   $524 = $513 + $510 + 4 | 0;\n   HEAP32[$524 >> 2] = HEAP32[$524 >> 2] | 1;\n  }\n  $$0 = $513 + 8 | 0;\n  STACKTOP = sp;\n  return $$0 | 0;\n }\n $528 = HEAP32[4354] | 0;\n if ($528 >>> 0 > $$0197 >>> 0) {\n  $530 = $528 - $$0197 | 0;\n  HEAP32[4354] = $530;\n  $531 = HEAP32[4357] | 0;\n  $532 = $531 + $$0197 | 0;\n  HEAP32[4357] = $532;\n  HEAP32[$532 + 4 >> 2] = $530 | 1;\n  HEAP32[$531 + 4 >> 2] = $$0197 | 3;\n  $$0 = $531 + 8 | 0;\n  STACKTOP = sp;\n  return $$0 | 0;\n }\n if (!(HEAP32[4469] | 0)) {\n  HEAP32[4471] = 4096;\n  HEAP32[4470] = 4096;\n  HEAP32[4472] = -1;\n  HEAP32[4473] = -1;\n  HEAP32[4474] = 0;\n  HEAP32[4462] = 0;\n  HEAP32[4469] = $1 & -16 ^ 1431655768;\n  $546 = 4096;\n } else $546 = HEAP32[4471] | 0;\n $543 = $$0197 + 48 | 0;\n $544 = $$0197 + 47 | 0;\n $545 = $546 + $544 | 0;\n $547 = 0 - $546 | 0;\n $548 = $545 & $547;\n if ($548 >>> 0 <= $$0197 >>> 0) {\n  $$0 = 0;\n  STACKTOP = sp;\n  return $$0 | 0;\n }\n $550 = HEAP32[4461] | 0;\n if ($550 | 0) {\n  $552 = HEAP32[4459] | 0;\n  $553 = $552 + $548 | 0;\n  if ($553 >>> 0 <= $552 >>> 0 | $553 >>> 0 > $550 >>> 0) {\n   $$0 = 0;\n   STACKTOP = sp;\n   return $$0 | 0;\n  }\n }\n L257 : do if (!(HEAP32[4462] & 4)) {\n  $559 = HEAP32[4357] | 0;\n  L259 : do if (!$559) label = 173; else {\n   $$0$i$i = 17852;\n   while (1) {\n    $561 = HEAP32[$$0$i$i >> 2] | 0;\n    if ($561 >>> 0 <= $559 >>> 0) if (($561 + (HEAP32[$$0$i$i + 4 >> 2] | 0) | 0) >>> 0 > $559 >>> 0) break;\n    $568 = HEAP32[$$0$i$i + 8 >> 2] | 0;\n    if (!$568) {\n     label = 173;\n     break L259;\n    } else $$0$i$i = $568;\n   }\n   $593 = $545 - $528 & $547;\n   if ($593 >>> 0 < 2147483647) {\n    $596 = _sbrk($593 | 0) | 0;\n    if (($596 | 0) == ((HEAP32[$$0$i$i >> 2] | 0) + (HEAP32[$$0$i$i + 4 >> 2] | 0) | 0)) if (($596 | 0) == (-1 | 0)) $$2234243136$i = $593; else {\n     $$723947$i = $593;\n     $$748$i = $596;\n     label = 190;\n     break L257;\n    } else {\n     $$2247$ph$i = $596;\n     $$2253$ph$i = $593;\n     label = 181;\n    }\n   } else $$2234243136$i = 0;\n  } while (0);\n  do if ((label | 0) == 173) {\n   $570 = _sbrk(0) | 0;\n   if (($570 | 0) == (-1 | 0)) $$2234243136$i = 0; else {\n    $572 = $570;\n    $573 = HEAP32[4470] | 0;\n    $574 = $573 + -1 | 0;\n    $spec$select49$i = (($574 & $572 | 0) == 0 ? 0 : ($574 + $572 & 0 - $573) - $572 | 0) + $548 | 0;\n    $582 = HEAP32[4459] | 0;\n    $583 = $spec$select49$i + $582 | 0;\n    if ($spec$select49$i >>> 0 > $$0197 >>> 0 & $spec$select49$i >>> 0 < 2147483647) {\n     $586 = HEAP32[4461] | 0;\n     if ($586 | 0) if ($583 >>> 0 <= $582 >>> 0 | $583 >>> 0 > $586 >>> 0) {\n      $$2234243136$i = 0;\n      break;\n     }\n     $590 = _sbrk($spec$select49$i | 0) | 0;\n     if (($590 | 0) == ($570 | 0)) {\n      $$723947$i = $spec$select49$i;\n      $$748$i = $570;\n      label = 190;\n      break L257;\n     } else {\n      $$2247$ph$i = $590;\n      $$2253$ph$i = $spec$select49$i;\n      label = 181;\n     }\n    } else $$2234243136$i = 0;\n   }\n  } while (0);\n  do if ((label | 0) == 181) {\n   $602 = 0 - $$2253$ph$i | 0;\n   if (!($543 >>> 0 > $$2253$ph$i >>> 0 & ($$2253$ph$i >>> 0 < 2147483647 & ($$2247$ph$i | 0) != (-1 | 0)))) if (($$2247$ph$i | 0) == (-1 | 0)) {\n    $$2234243136$i = 0;\n    break;\n   } else {\n    $$723947$i = $$2253$ph$i;\n    $$748$i = $$2247$ph$i;\n    label = 190;\n    break L257;\n   }\n   $606 = HEAP32[4471] | 0;\n   $610 = $544 - $$2253$ph$i + $606 & 0 - $606;\n   if ($610 >>> 0 >= 2147483647) {\n    $$723947$i = $$2253$ph$i;\n    $$748$i = $$2247$ph$i;\n    label = 190;\n    break L257;\n   }\n   if ((_sbrk($610 | 0) | 0) == (-1 | 0)) {\n    _sbrk($602 | 0) | 0;\n    $$2234243136$i = 0;\n    break;\n   } else {\n    $$723947$i = $610 + $$2253$ph$i | 0;\n    $$748$i = $$2247$ph$i;\n    label = 190;\n    break L257;\n   }\n  } while (0);\n  HEAP32[4462] = HEAP32[4462] | 4;\n  $$4236$i = $$2234243136$i;\n  label = 188;\n } else {\n  $$4236$i = 0;\n  label = 188;\n } while (0);\n if ((label | 0) == 188) if ($548 >>> 0 < 2147483647) {\n  $619 = _sbrk($548 | 0) | 0;\n  $620 = _sbrk(0) | 0;\n  $626 = $620 - $619 | 0;\n  $628 = $626 >>> 0 > ($$0197 + 40 | 0) >>> 0;\n  if (!(($619 | 0) == (-1 | 0) | $628 ^ 1 | $619 >>> 0 < $620 >>> 0 & (($619 | 0) != (-1 | 0) & ($620 | 0) != (-1 | 0)) ^ 1)) {\n   $$723947$i = $628 ? $626 : $$4236$i;\n   $$748$i = $619;\n   label = 190;\n  }\n }\n if ((label | 0) == 190) {\n  $632 = (HEAP32[4459] | 0) + $$723947$i | 0;\n  HEAP32[4459] = $632;\n  if ($632 >>> 0 > (HEAP32[4460] | 0) >>> 0) HEAP32[4460] = $632;\n  $635 = HEAP32[4357] | 0;\n  L294 : do if (!$635) {\n   $637 = HEAP32[4355] | 0;\n   if (($637 | 0) == 0 | $$748$i >>> 0 < $637 >>> 0) HEAP32[4355] = $$748$i;\n   HEAP32[4463] = $$748$i;\n   HEAP32[4464] = $$723947$i;\n   HEAP32[4466] = 0;\n   HEAP32[4360] = HEAP32[4469];\n   HEAP32[4359] = -1;\n   HEAP32[4364] = 17444;\n   HEAP32[4363] = 17444;\n   HEAP32[4366] = 17452;\n   HEAP32[4365] = 17452;\n   HEAP32[4368] = 17460;\n   HEAP32[4367] = 17460;\n   HEAP32[4370] = 17468;\n   HEAP32[4369] = 17468;\n   HEAP32[4372] = 17476;\n   HEAP32[4371] = 17476;\n   HEAP32[4374] = 17484;\n   HEAP32[4373] = 17484;\n   HEAP32[4376] = 17492;\n   HEAP32[4375] = 17492;\n   HEAP32[4378] = 17500;\n   HEAP32[4377] = 17500;\n   HEAP32[4380] = 17508;\n   HEAP32[4379] = 17508;\n   HEAP32[4382] = 17516;\n   HEAP32[4381] = 17516;\n   HEAP32[4384] = 17524;\n   HEAP32[4383] = 17524;\n   HEAP32[4386] = 17532;\n   HEAP32[4385] = 17532;\n   HEAP32[4388] = 17540;\n   HEAP32[4387] = 17540;\n   HEAP32[4390] = 17548;\n   HEAP32[4389] = 17548;\n   HEAP32[4392] = 17556;\n   HEAP32[4391] = 17556;\n   HEAP32[4394] = 17564;\n   HEAP32[4393] = 17564;\n   HEAP32[4396] = 17572;\n   HEAP32[4395] = 17572;\n   HEAP32[4398] = 17580;\n   HEAP32[4397] = 17580;\n   HEAP32[4400] = 17588;\n   HEAP32[4399] = 17588;\n   HEAP32[4402] = 17596;\n   HEAP32[4401] = 17596;\n   HEAP32[4404] = 17604;\n   HEAP32[4403] = 17604;\n   HEAP32[4406] = 17612;\n   HEAP32[4405] = 17612;\n   HEAP32[4408] = 17620;\n   HEAP32[4407] = 17620;\n   HEAP32[4410] = 17628;\n   HEAP32[4409] = 17628;\n   HEAP32[4412] = 17636;\n   HEAP32[4411] = 17636;\n   HEAP32[4414] = 17644;\n   HEAP32[4413] = 17644;\n   HEAP32[4416] = 17652;\n   HEAP32[4415] = 17652;\n   HEAP32[4418] = 17660;\n   HEAP32[4417] = 17660;\n   HEAP32[4420] = 17668;\n   HEAP32[4419] = 17668;\n   HEAP32[4422] = 17676;\n   HEAP32[4421] = 17676;\n   HEAP32[4424] = 17684;\n   HEAP32[4423] = 17684;\n   HEAP32[4426] = 17692;\n   HEAP32[4425] = 17692;\n   $641 = $$723947$i + -40 | 0;\n   $643 = $$748$i + 8 | 0;\n   $648 = ($643 & 7 | 0) == 0 ? 0 : 0 - $643 & 7;\n   $649 = $$748$i + $648 | 0;\n   $650 = $641 - $648 | 0;\n   HEAP32[4357] = $649;\n   HEAP32[4354] = $650;\n   HEAP32[$649 + 4 >> 2] = $650 | 1;\n   HEAP32[$$748$i + $641 + 4 >> 2] = 40;\n   HEAP32[4358] = HEAP32[4473];\n  } else {\n   $$024372$i = 17852;\n   while (1) {\n    $656 = HEAP32[$$024372$i >> 2] | 0;\n    $658 = HEAP32[$$024372$i + 4 >> 2] | 0;\n    if (($$748$i | 0) == ($656 + $658 | 0)) {\n     label = 199;\n     break;\n    }\n    $662 = HEAP32[$$024372$i + 8 >> 2] | 0;\n    if (!$662) break; else $$024372$i = $662;\n   }\n   if ((label | 0) == 199) {\n    $664 = $$024372$i + 4 | 0;\n    if (!(HEAP32[$$024372$i + 12 >> 2] & 8)) if ($$748$i >>> 0 > $635 >>> 0 & $656 >>> 0 <= $635 >>> 0) {\n     HEAP32[$664 >> 2] = $658 + $$723947$i;\n     $673 = (HEAP32[4354] | 0) + $$723947$i | 0;\n     $675 = $635 + 8 | 0;\n     $680 = ($675 & 7 | 0) == 0 ? 0 : 0 - $675 & 7;\n     $681 = $635 + $680 | 0;\n     $682 = $673 - $680 | 0;\n     HEAP32[4357] = $681;\n     HEAP32[4354] = $682;\n     HEAP32[$681 + 4 >> 2] = $682 | 1;\n     HEAP32[$635 + $673 + 4 >> 2] = 40;\n     HEAP32[4358] = HEAP32[4473];\n     break;\n    }\n   }\n   $688 = HEAP32[4355] | 0;\n   if ($$748$i >>> 0 < $688 >>> 0) {\n    HEAP32[4355] = $$748$i;\n    $753 = $$748$i;\n   } else $753 = $688;\n   $690 = $$748$i + $$723947$i | 0;\n   $$124471$i = 17852;\n   while (1) {\n    if ((HEAP32[$$124471$i >> 2] | 0) == ($690 | 0)) {\n     label = 207;\n     break;\n    }\n    $694 = HEAP32[$$124471$i + 8 >> 2] | 0;\n    if (!$694) break; else $$124471$i = $694;\n   }\n   if ((label | 0) == 207) if (!(HEAP32[$$124471$i + 12 >> 2] & 8)) {\n    HEAP32[$$124471$i >> 2] = $$748$i;\n    $700 = $$124471$i + 4 | 0;\n    HEAP32[$700 >> 2] = (HEAP32[$700 >> 2] | 0) + $$723947$i;\n    $704 = $$748$i + 8 | 0;\n    $710 = $$748$i + (($704 & 7 | 0) == 0 ? 0 : 0 - $704 & 7) | 0;\n    $712 = $690 + 8 | 0;\n    $718 = $690 + (($712 & 7 | 0) == 0 ? 0 : 0 - $712 & 7) | 0;\n    $722 = $710 + $$0197 | 0;\n    $723 = $718 - $710 - $$0197 | 0;\n    HEAP32[$710 + 4 >> 2] = $$0197 | 3;\n    L317 : do if (($635 | 0) == ($718 | 0)) {\n     $728 = (HEAP32[4354] | 0) + $723 | 0;\n     HEAP32[4354] = $728;\n     HEAP32[4357] = $722;\n     HEAP32[$722 + 4 >> 2] = $728 | 1;\n    } else {\n     if ((HEAP32[4356] | 0) == ($718 | 0)) {\n      $734 = (HEAP32[4353] | 0) + $723 | 0;\n      HEAP32[4353] = $734;\n      HEAP32[4356] = $722;\n      HEAP32[$722 + 4 >> 2] = $734 | 1;\n      HEAP32[$722 + $734 >> 2] = $734;\n      break;\n     }\n     $739 = HEAP32[$718 + 4 >> 2] | 0;\n     if (($739 & 3 | 0) == 1) {\n      $742 = $739 & -8;\n      $743 = $739 >>> 3;\n      L325 : do if ($739 >>> 0 < 256) {\n       $746 = HEAP32[$718 + 8 >> 2] | 0;\n       $748 = HEAP32[$718 + 12 >> 2] | 0;\n       $750 = 17444 + ($743 << 1 << 2) | 0;\n       do if (($746 | 0) != ($750 | 0)) {\n        if ($753 >>> 0 > $746 >>> 0) _abort();\n        if ((HEAP32[$746 + 12 >> 2] | 0) == ($718 | 0)) break;\n        _abort();\n       } while (0);\n       if (($748 | 0) == ($746 | 0)) {\n        HEAP32[4351] = HEAP32[4351] & ~(1 << $743);\n        break;\n       }\n       do if (($748 | 0) == ($750 | 0)) $$pre$phi17$i$iZ2D = $748 + 8 | 0; else {\n        if ($753 >>> 0 > $748 >>> 0) _abort();\n        $764 = $748 + 8 | 0;\n        if ((HEAP32[$764 >> 2] | 0) == ($718 | 0)) {\n         $$pre$phi17$i$iZ2D = $764;\n         break;\n        }\n        _abort();\n       } while (0);\n       HEAP32[$746 + 12 >> 2] = $748;\n       HEAP32[$$pre$phi17$i$iZ2D >> 2] = $746;\n      } else {\n       $769 = HEAP32[$718 + 24 >> 2] | 0;\n       $771 = HEAP32[$718 + 12 >> 2] | 0;\n       do if (($771 | 0) == ($718 | 0)) {\n        $782 = $718 + 16 | 0;\n        $783 = $782 + 4 | 0;\n        $784 = HEAP32[$783 >> 2] | 0;\n        if (!$784) {\n         $786 = HEAP32[$782 >> 2] | 0;\n         if (!$786) {\n          $$3$i$i = 0;\n          break;\n         } else {\n          $$1290$i$i$ph = $786;\n          $$1292$i$i$ph = $782;\n         }\n        } else {\n         $$1290$i$i$ph = $784;\n         $$1292$i$i$ph = $783;\n        }\n        $$1290$i$i = $$1290$i$i$ph;\n        $$1292$i$i = $$1292$i$i$ph;\n        while (1) {\n         $788 = $$1290$i$i + 20 | 0;\n         $789 = HEAP32[$788 >> 2] | 0;\n         if (!$789) {\n          $791 = $$1290$i$i + 16 | 0;\n          $792 = HEAP32[$791 >> 2] | 0;\n          if (!$792) break; else {\n           $$1290$i$i$be = $792;\n           $$1292$i$i$be = $791;\n          }\n         } else {\n          $$1290$i$i$be = $789;\n          $$1292$i$i$be = $788;\n         }\n         $$1290$i$i = $$1290$i$i$be;\n         $$1292$i$i = $$1292$i$i$be;\n        }\n        if ($753 >>> 0 > $$1292$i$i >>> 0) _abort(); else {\n         HEAP32[$$1292$i$i >> 2] = 0;\n         $$3$i$i = $$1290$i$i;\n         break;\n        }\n       } else {\n        $774 = HEAP32[$718 + 8 >> 2] | 0;\n        if ($753 >>> 0 > $774 >>> 0) _abort();\n        $776 = $774 + 12 | 0;\n        if ((HEAP32[$776 >> 2] | 0) != ($718 | 0)) _abort();\n        $779 = $771 + 8 | 0;\n        if ((HEAP32[$779 >> 2] | 0) == ($718 | 0)) {\n         HEAP32[$776 >> 2] = $771;\n         HEAP32[$779 >> 2] = $774;\n         $$3$i$i = $771;\n         break;\n        } else _abort();\n       } while (0);\n       if (!$769) break;\n       $797 = HEAP32[$718 + 28 >> 2] | 0;\n       $798 = 17708 + ($797 << 2) | 0;\n       do if ((HEAP32[$798 >> 2] | 0) == ($718 | 0)) {\n        HEAP32[$798 >> 2] = $$3$i$i;\n        if ($$3$i$i | 0) break;\n        HEAP32[4352] = HEAP32[4352] & ~(1 << $797);\n        break L325;\n       } else if ((HEAP32[4355] | 0) >>> 0 > $769 >>> 0) _abort(); else {\n        $807 = $769 + 16 | 0;\n        HEAP32[((HEAP32[$807 >> 2] | 0) == ($718 | 0) ? $807 : $769 + 20 | 0) >> 2] = $$3$i$i;\n        if (!$$3$i$i) break L325; else break;\n       } while (0);\n       $812 = HEAP32[4355] | 0;\n       if ($812 >>> 0 > $$3$i$i >>> 0) _abort();\n       HEAP32[$$3$i$i + 24 >> 2] = $769;\n       $815 = $718 + 16 | 0;\n       $816 = HEAP32[$815 >> 2] | 0;\n       do if ($816 | 0) if ($812 >>> 0 > $816 >>> 0) _abort(); else {\n        HEAP32[$$3$i$i + 16 >> 2] = $816;\n        HEAP32[$816 + 24 >> 2] = $$3$i$i;\n        break;\n       } while (0);\n       $822 = HEAP32[$815 + 4 >> 2] | 0;\n       if (!$822) break;\n       if ((HEAP32[4355] | 0) >>> 0 > $822 >>> 0) _abort(); else {\n        HEAP32[$$3$i$i + 20 >> 2] = $822;\n        HEAP32[$822 + 24 >> 2] = $$3$i$i;\n        break;\n       }\n      } while (0);\n      $$0$i16$i = $718 + $742 | 0;\n      $$0286$i$i = $742 + $723 | 0;\n     } else {\n      $$0$i16$i = $718;\n      $$0286$i$i = $723;\n     }\n     $830 = $$0$i16$i + 4 | 0;\n     HEAP32[$830 >> 2] = HEAP32[$830 >> 2] & -2;\n     HEAP32[$722 + 4 >> 2] = $$0286$i$i | 1;\n     HEAP32[$722 + $$0286$i$i >> 2] = $$0286$i$i;\n     $836 = $$0286$i$i >>> 3;\n     if ($$0286$i$i >>> 0 < 256) {\n      $839 = 17444 + ($836 << 1 << 2) | 0;\n      $840 = HEAP32[4351] | 0;\n      $841 = 1 << $836;\n      do if (!($840 & $841)) {\n       HEAP32[4351] = $840 | $841;\n       $$0294$i$i = $839;\n       $$pre$phi$i18$iZ2D = $839 + 8 | 0;\n      } else {\n       $845 = $839 + 8 | 0;\n       $846 = HEAP32[$845 >> 2] | 0;\n       if ((HEAP32[4355] | 0) >>> 0 <= $846 >>> 0) {\n        $$0294$i$i = $846;\n        $$pre$phi$i18$iZ2D = $845;\n        break;\n       }\n       _abort();\n      } while (0);\n      HEAP32[$$pre$phi$i18$iZ2D >> 2] = $722;\n      HEAP32[$$0294$i$i + 12 >> 2] = $722;\n      HEAP32[$722 + 8 >> 2] = $$0294$i$i;\n      HEAP32[$722 + 12 >> 2] = $839;\n      break;\n     }\n     $852 = $$0286$i$i >>> 8;\n     do if (!$852) $$0295$i$i = 0; else {\n      if ($$0286$i$i >>> 0 > 16777215) {\n       $$0295$i$i = 31;\n       break;\n      }\n      $857 = ($852 + 1048320 | 0) >>> 16 & 8;\n      $858 = $852 << $857;\n      $861 = ($858 + 520192 | 0) >>> 16 & 4;\n      $863 = $858 << $861;\n      $866 = ($863 + 245760 | 0) >>> 16 & 2;\n      $871 = 14 - ($861 | $857 | $866) + ($863 << $866 >>> 15) | 0;\n      $$0295$i$i = $$0286$i$i >>> ($871 + 7 | 0) & 1 | $871 << 1;\n     } while (0);\n     $877 = 17708 + ($$0295$i$i << 2) | 0;\n     HEAP32[$722 + 28 >> 2] = $$0295$i$i;\n     $879 = $722 + 16 | 0;\n     HEAP32[$879 + 4 >> 2] = 0;\n     HEAP32[$879 >> 2] = 0;\n     $881 = HEAP32[4352] | 0;\n     $882 = 1 << $$0295$i$i;\n     if (!($881 & $882)) {\n      HEAP32[4352] = $881 | $882;\n      HEAP32[$877 >> 2] = $722;\n      HEAP32[$722 + 24 >> 2] = $877;\n      HEAP32[$722 + 12 >> 2] = $722;\n      HEAP32[$722 + 8 >> 2] = $722;\n      break;\n     }\n     $889 = HEAP32[$877 >> 2] | 0;\n     L410 : do if ((HEAP32[$889 + 4 >> 2] & -8 | 0) == ($$0286$i$i | 0)) $$0288$lcssa$i$i = $889; else {\n      $$028711$i$i = $$0286$i$i << (($$0295$i$i | 0) == 31 ? 0 : 25 - ($$0295$i$i >>> 1) | 0);\n      $$028810$i$i = $889;\n      while (1) {\n       $906 = $$028810$i$i + 16 + ($$028711$i$i >>> 31 << 2) | 0;\n       $901 = HEAP32[$906 >> 2] | 0;\n       if (!$901) break;\n       if ((HEAP32[$901 + 4 >> 2] & -8 | 0) == ($$0286$i$i | 0)) {\n        $$0288$lcssa$i$i = $901;\n        break L410;\n       } else {\n        $$028711$i$i = $$028711$i$i << 1;\n        $$028810$i$i = $901;\n       }\n      }\n      if ((HEAP32[4355] | 0) >>> 0 > $906 >>> 0) _abort(); else {\n       HEAP32[$906 >> 2] = $722;\n       HEAP32[$722 + 24 >> 2] = $$028810$i$i;\n       HEAP32[$722 + 12 >> 2] = $722;\n       HEAP32[$722 + 8 >> 2] = $722;\n       break L317;\n      }\n     } while (0);\n     $913 = $$0288$lcssa$i$i + 8 | 0;\n     $914 = HEAP32[$913 >> 2] | 0;\n     $915 = HEAP32[4355] | 0;\n     if ($915 >>> 0 <= $914 >>> 0 & $915 >>> 0 <= $$0288$lcssa$i$i >>> 0) {\n      HEAP32[$914 + 12 >> 2] = $722;\n      HEAP32[$913 >> 2] = $722;\n      HEAP32[$722 + 8 >> 2] = $914;\n      HEAP32[$722 + 12 >> 2] = $$0288$lcssa$i$i;\n      HEAP32[$722 + 24 >> 2] = 0;\n      break;\n     } else _abort();\n    } while (0);\n    $$0 = $710 + 8 | 0;\n    STACKTOP = sp;\n    return $$0 | 0;\n   }\n   $$0$i$i$i = 17852;\n   while (1) {\n    $923 = HEAP32[$$0$i$i$i >> 2] | 0;\n    if ($923 >>> 0 <= $635 >>> 0) {\n     $927 = $923 + (HEAP32[$$0$i$i$i + 4 >> 2] | 0) | 0;\n     if ($927 >>> 0 > $635 >>> 0) break;\n    }\n    $$0$i$i$i = HEAP32[$$0$i$i$i + 8 >> 2] | 0;\n   }\n   $931 = $927 + -47 | 0;\n   $933 = $931 + 8 | 0;\n   $939 = $931 + (($933 & 7 | 0) == 0 ? 0 : 0 - $933 & 7) | 0;\n   $940 = $635 + 16 | 0;\n   $942 = $939 >>> 0 < $940 >>> 0 ? $635 : $939;\n   $943 = $942 + 8 | 0;\n   $945 = $$723947$i + -40 | 0;\n   $947 = $$748$i + 8 | 0;\n   $952 = ($947 & 7 | 0) == 0 ? 0 : 0 - $947 & 7;\n   $953 = $$748$i + $952 | 0;\n   $954 = $945 - $952 | 0;\n   HEAP32[4357] = $953;\n   HEAP32[4354] = $954;\n   HEAP32[$953 + 4 >> 2] = $954 | 1;\n   HEAP32[$$748$i + $945 + 4 >> 2] = 40;\n   HEAP32[4358] = HEAP32[4473];\n   $960 = $942 + 4 | 0;\n   HEAP32[$960 >> 2] = 27;\n   HEAP32[$943 >> 2] = HEAP32[4463];\n   HEAP32[$943 + 4 >> 2] = HEAP32[4464];\n   HEAP32[$943 + 8 >> 2] = HEAP32[4465];\n   HEAP32[$943 + 12 >> 2] = HEAP32[4466];\n   HEAP32[4463] = $$748$i;\n   HEAP32[4464] = $$723947$i;\n   HEAP32[4466] = 0;\n   HEAP32[4465] = $943;\n   $962 = $942 + 24 | 0;\n   do {\n    $962$looptemp = $962;\n    $962 = $962 + 4 | 0;\n    HEAP32[$962 >> 2] = 7;\n   } while (($962$looptemp + 8 | 0) >>> 0 < $927 >>> 0);\n   if (($942 | 0) != ($635 | 0)) {\n    $968 = $942 - $635 | 0;\n    HEAP32[$960 >> 2] = HEAP32[$960 >> 2] & -2;\n    HEAP32[$635 + 4 >> 2] = $968 | 1;\n    HEAP32[$942 >> 2] = $968;\n    $973 = $968 >>> 3;\n    if ($968 >>> 0 < 256) {\n     $976 = 17444 + ($973 << 1 << 2) | 0;\n     $977 = HEAP32[4351] | 0;\n     $978 = 1 << $973;\n     if (!($977 & $978)) {\n      HEAP32[4351] = $977 | $978;\n      $$0211$i$i = $976;\n      $$pre$phi$i$iZ2D = $976 + 8 | 0;\n     } else {\n      $982 = $976 + 8 | 0;\n      $983 = HEAP32[$982 >> 2] | 0;\n      if ((HEAP32[4355] | 0) >>> 0 > $983 >>> 0) _abort(); else {\n       $$0211$i$i = $983;\n       $$pre$phi$i$iZ2D = $982;\n      }\n     }\n     HEAP32[$$pre$phi$i$iZ2D >> 2] = $635;\n     HEAP32[$$0211$i$i + 12 >> 2] = $635;\n     HEAP32[$635 + 8 >> 2] = $$0211$i$i;\n     HEAP32[$635 + 12 >> 2] = $976;\n     break;\n    }\n    $989 = $968 >>> 8;\n    if (!$989) $$0212$i$i = 0; else if ($968 >>> 0 > 16777215) $$0212$i$i = 31; else {\n     $994 = ($989 + 1048320 | 0) >>> 16 & 8;\n     $995 = $989 << $994;\n     $998 = ($995 + 520192 | 0) >>> 16 & 4;\n     $1000 = $995 << $998;\n     $1003 = ($1000 + 245760 | 0) >>> 16 & 2;\n     $1008 = 14 - ($998 | $994 | $1003) + ($1000 << $1003 >>> 15) | 0;\n     $$0212$i$i = $968 >>> ($1008 + 7 | 0) & 1 | $1008 << 1;\n    }\n    $1014 = 17708 + ($$0212$i$i << 2) | 0;\n    HEAP32[$635 + 28 >> 2] = $$0212$i$i;\n    HEAP32[$635 + 20 >> 2] = 0;\n    HEAP32[$940 >> 2] = 0;\n    $1017 = HEAP32[4352] | 0;\n    $1018 = 1 << $$0212$i$i;\n    if (!($1017 & $1018)) {\n     HEAP32[4352] = $1017 | $1018;\n     HEAP32[$1014 >> 2] = $635;\n     HEAP32[$635 + 24 >> 2] = $1014;\n     HEAP32[$635 + 12 >> 2] = $635;\n     HEAP32[$635 + 8 >> 2] = $635;\n     break;\n    }\n    $1025 = HEAP32[$1014 >> 2] | 0;\n    L451 : do if ((HEAP32[$1025 + 4 >> 2] & -8 | 0) == ($968 | 0)) $$0207$lcssa$i$i = $1025; else {\n     $$02065$i$i = $968 << (($$0212$i$i | 0) == 31 ? 0 : 25 - ($$0212$i$i >>> 1) | 0);\n     $$02074$i$i = $1025;\n     while (1) {\n      $1042 = $$02074$i$i + 16 + ($$02065$i$i >>> 31 << 2) | 0;\n      $1037 = HEAP32[$1042 >> 2] | 0;\n      if (!$1037) break;\n      if ((HEAP32[$1037 + 4 >> 2] & -8 | 0) == ($968 | 0)) {\n       $$0207$lcssa$i$i = $1037;\n       break L451;\n      } else {\n       $$02065$i$i = $$02065$i$i << 1;\n       $$02074$i$i = $1037;\n      }\n     }\n     if ((HEAP32[4355] | 0) >>> 0 > $1042 >>> 0) _abort(); else {\n      HEAP32[$1042 >> 2] = $635;\n      HEAP32[$635 + 24 >> 2] = $$02074$i$i;\n      HEAP32[$635 + 12 >> 2] = $635;\n      HEAP32[$635 + 8 >> 2] = $635;\n      break L294;\n     }\n    } while (0);\n    $1049 = $$0207$lcssa$i$i + 8 | 0;\n    $1050 = HEAP32[$1049 >> 2] | 0;\n    $1051 = HEAP32[4355] | 0;\n    if ($1051 >>> 0 <= $1050 >>> 0 & $1051 >>> 0 <= $$0207$lcssa$i$i >>> 0) {\n     HEAP32[$1050 + 12 >> 2] = $635;\n     HEAP32[$1049 >> 2] = $635;\n     HEAP32[$635 + 8 >> 2] = $1050;\n     HEAP32[$635 + 12 >> 2] = $$0207$lcssa$i$i;\n     HEAP32[$635 + 24 >> 2] = 0;\n     break;\n    } else _abort();\n   }\n  } while (0);\n  $1060 = HEAP32[4354] | 0;\n  if ($1060 >>> 0 > $$0197 >>> 0) {\n   $1062 = $1060 - $$0197 | 0;\n   HEAP32[4354] = $1062;\n   $1063 = HEAP32[4357] | 0;\n   $1064 = $1063 + $$0197 | 0;\n   HEAP32[4357] = $1064;\n   HEAP32[$1064 + 4 >> 2] = $1062 | 1;\n   HEAP32[$1063 + 4 >> 2] = $$0197 | 3;\n   $$0 = $1063 + 8 | 0;\n   STACKTOP = sp;\n   return $$0 | 0;\n  }\n }\n $1070 = ___errno_location() | 0;\n HEAP32[$1070 >> 2] = 12;\n $$0 = 0;\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_119parse_operator_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$3 = 0, $102 = 0, $103 = 0, $110 = 0, $111 = 0, $118 = 0, $119 = 0, $129 = 0, $13 = 0, $130 = 0, $137 = 0, $138 = 0, $14 = 0, $145 = 0, $146 = 0, $156 = 0, $157 = 0, $164 = 0, $165 = 0, $175 = 0, $176 = 0, $186 = 0, $187 = 0, $194 = 0, $195 = 0, $199 = 0, $202 = 0, $203 = 0, $21 = 0, $210 = 0, $211 = 0, $218 = 0, $219 = 0, $22 = 0, $229 = 0, $230 = 0, $237 = 0, $238 = 0, $245 = 0, $246 = 0, $253 = 0, $254 = 0, $261 = 0, $262 = 0, $272 = 0, $273 = 0, $280 = 0, $281 = 0, $288 = 0, $289 = 0, $29 = 0, $296 = 0, $297 = 0, $3 = 0, $30 = 0, $304 = 0, $305 = 0, $315 = 0, $316 = 0, $323 = 0, $324 = 0, $331 = 0, $332 = 0, $342 = 0, $343 = 0, $350 = 0, $351 = 0, $358 = 0, $359 = 0, $366 = 0, $367 = 0, $37 = 0, $374 = 0, $375 = 0, $38 = 0, $382 = 0, $383 = 0, $393 = 0, $394 = 0, $404 = 0, $405 = 0, $412 = 0, $413 = 0, $420 = 0, $421 = 0, $428 = 0, $429 = 0, $439 = 0, $440 = 0, $444 = 0, $48 = 0, $49 = 0, $56 = 0, $57 = 0, $64 = 0, $65 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $79 = 0, $86 = 0, $87 = 0, $94 = 0, $95 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp;\n L1 : do if (($1 - $0 | 0) > 1) do switch (HEAP8[$0 >> 0] | 0) {\n case 97:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 97:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15419);\n     $13 = $2 + 4 | 0;\n     $14 = HEAP32[$13 >> 2] | 0;\n     if ($14 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($14, $3);\n      HEAP32[$13 >> 2] = (HEAP32[$13 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 110:\n   case 100:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15430);\n     $21 = $2 + 4 | 0;\n     $22 = HEAP32[$21 >> 2] | 0;\n     if ($22 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($22, $3);\n      HEAP32[$21 >> 2] = (HEAP32[$21 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 78:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15440);\n     $29 = $2 + 4 | 0;\n     $30 = HEAP32[$29 >> 2] | 0;\n     if ($30 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($30, $3);\n      HEAP32[$29 >> 2] = (HEAP32[$29 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 83:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15451);\n     $37 = $2 + 4 | 0;\n     $38 = HEAP32[$37 >> 2] | 0;\n     if ($38 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($38, $3);\n      HEAP32[$37 >> 2] = (HEAP32[$37 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 99:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 108:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15461);\n     $48 = $2 + 4 | 0;\n     $49 = HEAP32[$48 >> 2] | 0;\n     if ($49 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($49, $3);\n      HEAP32[$48 >> 2] = (HEAP32[$48 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 109:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15472);\n     $56 = $2 + 4 | 0;\n     $57 = HEAP32[$56 >> 2] | 0;\n     if ($57 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($57, $3);\n      HEAP32[$56 >> 2] = (HEAP32[$56 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 111:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15482);\n     $64 = $2 + 4 | 0;\n     $65 = HEAP32[$64 >> 2] | 0;\n     if ($65 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($65, $3);\n      HEAP32[$64 >> 2] = (HEAP32[$64 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 118:\n    {\n     $72 = $2 + 63 | 0;\n     $73 = HEAP8[$72 >> 0] | 0;\n     HEAP8[$72 >> 0] = 0;\n     $74 = $0 + 2 | 0;\n     $75 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($74, $1, $2) | 0;\n     HEAP8[$72 >> 0] = $73;\n     if (($75 | 0) == ($74 | 0)) {\n      $$3 = $0;\n      break L1;\n     }\n     $79 = HEAP32[$2 + 4 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($79 | 0)) {\n      $$3 = $0;\n      break L1;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($79 + -24 | 0, 0, 15492) | 0;\n     HEAP8[$2 + 60 >> 0] = 1;\n     $$3 = $75;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 100:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 97:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj18EEERAT__Kc($3, 15502);\n     $86 = $2 + 4 | 0;\n     $87 = HEAP32[$86 >> 2] | 0;\n     if ($87 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($87, $3);\n      HEAP32[$86 >> 2] = (HEAP32[$86 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 101:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15520);\n     $94 = $2 + 4 | 0;\n     $95 = HEAP32[$94 >> 2] | 0;\n     if ($95 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($95, $3);\n      HEAP32[$94 >> 2] = (HEAP32[$94 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 108:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj16EEERAT__Kc($3);\n     $102 = $2 + 4 | 0;\n     $103 = HEAP32[$102 >> 2] | 0;\n     if ($103 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($103, $3);\n      HEAP32[$102 >> 2] = (HEAP32[$102 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 118:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15530);\n     $110 = $2 + 4 | 0;\n     $111 = HEAP32[$110 >> 2] | 0;\n     if ($111 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($111, $3);\n      HEAP32[$110 >> 2] = (HEAP32[$110 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 86:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15540);\n     $118 = $2 + 4 | 0;\n     $119 = HEAP32[$118 >> 2] | 0;\n     if ($119 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($119, $3);\n      HEAP32[$118 >> 2] = (HEAP32[$118 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 101:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 111:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15551);\n     $129 = $2 + 4 | 0;\n     $130 = HEAP32[$129 >> 2] | 0;\n     if ($130 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($130, $3);\n      HEAP32[$129 >> 2] = (HEAP32[$129 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 79:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15561);\n     $137 = $2 + 4 | 0;\n     $138 = HEAP32[$137 >> 2] | 0;\n     if ($138 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($138, $3);\n      HEAP32[$137 >> 2] = (HEAP32[$137 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 113:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15572);\n     $145 = $2 + 4 | 0;\n     $146 = HEAP32[$145 >> 2] | 0;\n     if ($146 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($146, $3);\n      HEAP32[$145 >> 2] = (HEAP32[$145 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 103:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 101:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15583);\n     $156 = $2 + 4 | 0;\n     $157 = HEAP32[$156 >> 2] | 0;\n     if ($157 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($157, $3);\n      HEAP32[$156 >> 2] = (HEAP32[$156 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 116:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15594);\n     $164 = $2 + 4 | 0;\n     $165 = HEAP32[$164 >> 2] | 0;\n     if ($165 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($165, $3);\n      HEAP32[$164 >> 2] = (HEAP32[$164 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 105:\n  {\n   if ((HEAP8[$0 + 1 >> 0] | 0) != 120) {\n    $$3 = $0;\n    break L1;\n   }\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15604);\n   $175 = $2 + 4 | 0;\n   $176 = HEAP32[$175 >> 2] | 0;\n   if ($176 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($176, $3);\n    HEAP32[$175 >> 2] = (HEAP32[$175 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$3 = $0 + 2 | 0;\n   break L1;\n   break;\n  }\n case 108:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 101:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15615);\n     $186 = $2 + 4 | 0;\n     $187 = HEAP32[$186 >> 2] | 0;\n     if ($187 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($187, $3);\n      HEAP32[$186 >> 2] = (HEAP32[$186 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 105:\n    {\n     $194 = $0 + 2 | 0;\n     $195 = __ZN10__cxxabiv112_GLOBAL__N_117parse_source_nameINS0_2DbEEEPKcS4_S4_RT_($194, $1, $2) | 0;\n     if (($195 | 0) == ($194 | 0)) {\n      $$3 = $0;\n      break L1;\n     }\n     $199 = HEAP32[$2 + 4 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($199 | 0)) {\n      $$3 = $0;\n      break L1;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($199 + -24 | 0, 0, 15626) | 0;\n     $$3 = $195;\n     break L1;\n     break;\n    }\n   case 115:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15638);\n     $202 = $2 + 4 | 0;\n     $203 = HEAP32[$202 >> 2] | 0;\n     if ($203 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($203, $3);\n      HEAP32[$202 >> 2] = (HEAP32[$202 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 83:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj12EEERAT__Kc($3, 15649);\n     $210 = $2 + 4 | 0;\n     $211 = HEAP32[$210 >> 2] | 0;\n     if ($211 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($211, $3);\n      HEAP32[$210 >> 2] = (HEAP32[$210 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 116:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15661);\n     $218 = $2 + 4 | 0;\n     $219 = HEAP32[$218 >> 2] | 0;\n     if ($219 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($219, $3);\n      HEAP32[$218 >> 2] = (HEAP32[$218 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 109:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 105:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15671);\n     $229 = $2 + 4 | 0;\n     $230 = HEAP32[$229 >> 2] | 0;\n     if ($230 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($230, $3);\n      HEAP32[$229 >> 2] = (HEAP32[$229 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 73:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15681);\n     $237 = $2 + 4 | 0;\n     $238 = HEAP32[$237 >> 2] | 0;\n     if ($238 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($238, $3);\n      HEAP32[$237 >> 2] = (HEAP32[$237 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 108:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15520);\n     $245 = $2 + 4 | 0;\n     $246 = HEAP32[$245 >> 2] | 0;\n     if ($246 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($246, $3);\n      HEAP32[$245 >> 2] = (HEAP32[$245 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 76:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15692);\n     $253 = $2 + 4 | 0;\n     $254 = HEAP32[$253 >> 2] | 0;\n     if ($254 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($254, $3);\n      HEAP32[$253 >> 2] = (HEAP32[$253 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 109:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15703);\n     $261 = $2 + 4 | 0;\n     $262 = HEAP32[$261 >> 2] | 0;\n     if ($262 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($262, $3);\n      HEAP32[$261 >> 2] = (HEAP32[$261 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 110:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 97:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj15EEERAT__Kc($3, 15714);\n     $272 = $2 + 4 | 0;\n     $273 = HEAP32[$272 >> 2] | 0;\n     if ($273 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($273, $3);\n      HEAP32[$272 >> 2] = (HEAP32[$272 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 101:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15729);\n     $280 = $2 + 4 | 0;\n     $281 = HEAP32[$280 >> 2] | 0;\n     if ($281 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($281, $3);\n      HEAP32[$280 >> 2] = (HEAP32[$280 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 103:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15671);\n     $288 = $2 + 4 | 0;\n     $289 = HEAP32[$288 >> 2] | 0;\n     if ($289 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($289, $3);\n      HEAP32[$288 >> 2] = (HEAP32[$288 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 116:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15740);\n     $296 = $2 + 4 | 0;\n     $297 = HEAP32[$296 >> 2] | 0;\n     if ($297 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($297, $3);\n      HEAP32[$296 >> 2] = (HEAP32[$296 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 119:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj13EEERAT__Kc($3, 15750);\n     $304 = $2 + 4 | 0;\n     $305 = HEAP32[$304 >> 2] | 0;\n     if ($305 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($305, $3);\n      HEAP32[$304 >> 2] = (HEAP32[$304 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 111:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 111:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15763);\n     $315 = $2 + 4 | 0;\n     $316 = HEAP32[$315 >> 2] | 0;\n     if ($316 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($316, $3);\n      HEAP32[$315 >> 2] = (HEAP32[$315 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 114:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15774);\n     $323 = $2 + 4 | 0;\n     $324 = HEAP32[$323 >> 2] | 0;\n     if ($324 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($324, $3);\n      HEAP32[$323 >> 2] = (HEAP32[$323 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 82:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15784);\n     $331 = $2 + 4 | 0;\n     $332 = HEAP32[$331 >> 2] | 0;\n     if ($332 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($332, $3);\n      HEAP32[$331 >> 2] = (HEAP32[$331 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 112:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 109:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj12EEERAT__Kc($3, 15795);\n     $342 = $2 + 4 | 0;\n     $343 = HEAP32[$342 >> 2] | 0;\n     if ($343 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($343, $3);\n      HEAP32[$342 >> 2] = (HEAP32[$342 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 108:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15807);\n     $350 = $2 + 4 | 0;\n     $351 = HEAP32[$350 >> 2] | 0;\n     if ($351 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($351, $3);\n      HEAP32[$350 >> 2] = (HEAP32[$350 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 76:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15817);\n     $358 = $2 + 4 | 0;\n     $359 = HEAP32[$358 >> 2] | 0;\n     if ($359 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($359, $3);\n      HEAP32[$358 >> 2] = (HEAP32[$358 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 112:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15828);\n     $366 = $2 + 4 | 0;\n     $367 = HEAP32[$366 >> 2] | 0;\n     if ($367 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($367, $3);\n      HEAP32[$366 >> 2] = (HEAP32[$366 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 115:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15807);\n     $374 = $2 + 4 | 0;\n     $375 = HEAP32[$374 >> 2] | 0;\n     if ($375 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($375, $3);\n      HEAP32[$374 >> 2] = (HEAP32[$374 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 116:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15839);\n     $382 = $2 + 4 | 0;\n     $383 = HEAP32[$382 >> 2] | 0;\n     if ($383 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($383, $3);\n      HEAP32[$382 >> 2] = (HEAP32[$382 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 113:\n  {\n   if ((HEAP8[$0 + 1 >> 0] | 0) != 117) {\n    $$3 = $0;\n    break L1;\n   }\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15850);\n   $393 = $2 + 4 | 0;\n   $394 = HEAP32[$393 >> 2] | 0;\n   if ($394 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($394, $3);\n    HEAP32[$393 >> 2] = (HEAP32[$393 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$3 = $0 + 2 | 0;\n   break L1;\n   break;\n  }\n case 114:\n  {\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 109:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 15860);\n     $404 = $2 + 4 | 0;\n     $405 = HEAP32[$404 >> 2] | 0;\n     if ($405 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($405, $3);\n      HEAP32[$404 >> 2] = (HEAP32[$404 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 77:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15870);\n     $412 = $2 + 4 | 0;\n     $413 = HEAP32[$412 >> 2] | 0;\n     if ($413 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($413, $3);\n      HEAP32[$412 >> 2] = (HEAP32[$412 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 115:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 15881);\n     $420 = $2 + 4 | 0;\n     $421 = HEAP32[$420 >> 2] | 0;\n     if ($421 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($421, $3);\n      HEAP32[$420 >> 2] = (HEAP32[$420 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 83:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj12EEERAT__Kc($3, 15892);\n     $428 = $2 + 4 | 0;\n     $429 = HEAP32[$428 >> 2] | 0;\n     if ($429 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($429, $3);\n      HEAP32[$428 >> 2] = (HEAP32[$428 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$3 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$3 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n case 118:\n  {\n   if (((HEAP8[$0 + 1 >> 0] | 0) + -48 | 0) >>> 0 >= 10) {\n    $$3 = $0;\n    break L1;\n   }\n   $439 = $0 + 2 | 0;\n   $440 = __ZN10__cxxabiv112_GLOBAL__N_117parse_source_nameINS0_2DbEEEPKcS4_S4_RT_($439, $1, $2) | 0;\n   if (($440 | 0) == ($439 | 0)) {\n    $$3 = $0;\n    break L1;\n   }\n   $444 = HEAP32[$2 + 4 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($444 | 0)) {\n    $$3 = $0;\n    break L1;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($444 + -24 | 0, 0, 15492) | 0;\n   $$3 = $440;\n   break L1;\n   break;\n  }\n default:\n  {\n   $$3 = $0;\n   break L1;\n  }\n } while (0); else $$3 = $0; while (0);\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction __ZNSt3__212__next_primeEj($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$0328 = 0, $$0334 = 0, $$0337 = 0, $$1 = 0, $$2332 = 0, $$4 = 0, $$5 = 0, $$6 = 0, $$8 = 0, $$sink369 = 0, $1 = 0, $100 = 0, $104 = 0, $105 = 0, $109 = 0, $110 = 0, $114 = 0, $115 = 0, $119 = 0, $120 = 0, $124 = 0, $125 = 0, $129 = 0, $130 = 0, $134 = 0, $135 = 0, $139 = 0, $140 = 0, $144 = 0, $145 = 0, $149 = 0, $150 = 0, $154 = 0, $155 = 0, $159 = 0, $16 = 0, $160 = 0, $164 = 0, $165 = 0, $169 = 0, $170 = 0, $174 = 0, $175 = 0, $179 = 0, $180 = 0, $184 = 0, $185 = 0, $189 = 0, $19 = 0, $190 = 0, $194 = 0, $195 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $204 = 0, $205 = 0, $209 = 0, $210 = 0, $214 = 0, $215 = 0, $219 = 0, $220 = 0, $224 = 0, $225 = 0, $229 = 0, $230 = 0, $234 = 0, $235 = 0, $239 = 0, $240 = 0, $244 = 0, $245 = 0, $249 = 0, $25 = 0, $250 = 0, $254 = 0, $255 = 0, $259 = 0, $260 = 0, $261 = 0, $263 = 0, $266 = 0, $267 = 0, $29 = 0, $3 = 0, $30 = 0, $34 = 0, $35 = 0, $39 = 0, $40 = 0, $44 = 0, $45 = 0, $49 = 0, $5 = 0, $50 = 0, $54 = 0, $55 = 0, $59 = 0, $60 = 0, $64 = 0, $65 = 0, $69 = 0, $7 = 0, $70 = 0, $74 = 0, $75 = 0, $79 = 0, $8 = 0, $80 = 0, $84 = 0, $85 = 0, $89 = 0, $90 = 0, $94 = 0, $95 = 0, $99 = 0, $spec$select = 0, $spec$select339$sink = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = sp + 8 | 0;\n $3 = sp + 4 | 0;\n HEAP32[$2 >> 2] = $0;\n do if ($0 >>> 0 < 212) {\n  $5 = __ZNSt3__213__lower_boundIRNS_6__lessIjjEEPKjjEET0_S6_S6_RKT1_T_(2948, 3140, $2, $1) | 0;\n  $$8 = HEAP32[$5 >> 2] | 0;\n } else {\n  $7 = ($0 >>> 0) / 210 | 0;\n  $8 = $7 * 210 | 0;\n  HEAP32[$3 >> 2] = $0 - $8;\n  $$0328 = 0;\n  $$0337 = $7;\n  $$sink369 = $8;\n  $spec$select339$sink = (__ZNSt3__213__lower_boundIRNS_6__lessIjjEEPKjjEET0_S6_S6_RKT1_T_(3140, 3332, $3, $1) | 0) - 3140 >> 2;\n  L4 : while (1) {\n   $16 = (HEAP32[3140 + ($spec$select339$sink << 2) >> 2] | 0) + $$sink369 | 0;\n   $$0334 = 5;\n   while (1) {\n    if ($$0334 >>> 0 >= 47) {\n     label = 6;\n     break;\n    }\n    $19 = HEAP32[2948 + ($$0334 << 2) >> 2] | 0;\n    $20 = ($16 >>> 0) / ($19 >>> 0) | 0;\n    if ($20 >>> 0 < $19 >>> 0) {\n     label = 107;\n     break L4;\n    }\n    if (($16 | 0) == (Math_imul($20, $19) | 0)) {\n     $$6 = $$0328;\n     break;\n    } else $$0334 = $$0334 + 1 | 0;\n   }\n   L10 : do if ((label | 0) == 6) {\n    label = 0;\n    $$0 = 211;\n    $$4 = $$0328;\n    L12 : while (1) {\n     $25 = ($16 >>> 0) / ($$0 >>> 0) | 0;\n     do if ($25 >>> 0 < $$0 >>> 0) {\n      $$1 = $$0;\n      $$2332 = 1;\n      $$5 = $16;\n     } else if (($16 | 0) == (Math_imul($25, $$0) | 0)) {\n      $$1 = $$0;\n      $$2332 = 9;\n      $$5 = $$4;\n     } else {\n      $29 = $$0 + 10 | 0;\n      $30 = ($16 >>> 0) / ($29 >>> 0) | 0;\n      if ($30 >>> 0 < $29 >>> 0) {\n       $$1 = $29;\n       $$2332 = 1;\n       $$5 = $16;\n      } else if (($16 | 0) == (Math_imul($30, $29) | 0)) {\n       $$1 = $29;\n       $$2332 = 9;\n       $$5 = $$4;\n      } else {\n       $34 = $$0 + 12 | 0;\n       $35 = ($16 >>> 0) / ($34 >>> 0) | 0;\n       if ($35 >>> 0 < $34 >>> 0) {\n        $$1 = $34;\n        $$2332 = 1;\n        $$5 = $16;\n       } else if (($16 | 0) == (Math_imul($35, $34) | 0)) {\n        $$1 = $34;\n        $$2332 = 9;\n        $$5 = $$4;\n       } else {\n        $39 = $$0 + 16 | 0;\n        $40 = ($16 >>> 0) / ($39 >>> 0) | 0;\n        if ($40 >>> 0 < $39 >>> 0) {\n         $$1 = $39;\n         $$2332 = 1;\n         $$5 = $16;\n        } else if (($16 | 0) == (Math_imul($40, $39) | 0)) {\n         $$1 = $39;\n         $$2332 = 9;\n         $$5 = $$4;\n        } else {\n         $44 = $$0 + 18 | 0;\n         $45 = ($16 >>> 0) / ($44 >>> 0) | 0;\n         if ($45 >>> 0 < $44 >>> 0) {\n          $$1 = $44;\n          $$2332 = 1;\n          $$5 = $16;\n         } else if (($16 | 0) == (Math_imul($45, $44) | 0)) {\n          $$1 = $44;\n          $$2332 = 9;\n          $$5 = $$4;\n         } else {\n          $49 = $$0 + 22 | 0;\n          $50 = ($16 >>> 0) / ($49 >>> 0) | 0;\n          if ($50 >>> 0 < $49 >>> 0) {\n           $$1 = $49;\n           $$2332 = 1;\n           $$5 = $16;\n          } else if (($16 | 0) == (Math_imul($50, $49) | 0)) {\n           $$1 = $49;\n           $$2332 = 9;\n           $$5 = $$4;\n          } else {\n           $54 = $$0 + 28 | 0;\n           $55 = ($16 >>> 0) / ($54 >>> 0) | 0;\n           if ($55 >>> 0 < $54 >>> 0) {\n            $$1 = $54;\n            $$2332 = 1;\n            $$5 = $16;\n           } else if (($16 | 0) == (Math_imul($55, $54) | 0)) {\n            $$1 = $54;\n            $$2332 = 9;\n            $$5 = $$4;\n           } else {\n            $59 = $$0 + 30 | 0;\n            $60 = ($16 >>> 0) / ($59 >>> 0) | 0;\n            if ($60 >>> 0 < $59 >>> 0) {\n             $$1 = $59;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($60, $59) | 0)) {\n             $$1 = $59;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $64 = $$0 + 36 | 0;\n            $65 = ($16 >>> 0) / ($64 >>> 0) | 0;\n            if ($65 >>> 0 < $64 >>> 0) {\n             $$1 = $64;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($65, $64) | 0)) {\n             $$1 = $64;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $69 = $$0 + 40 | 0;\n            $70 = ($16 >>> 0) / ($69 >>> 0) | 0;\n            if ($70 >>> 0 < $69 >>> 0) {\n             $$1 = $69;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($70, $69) | 0)) {\n             $$1 = $69;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $74 = $$0 + 42 | 0;\n            $75 = ($16 >>> 0) / ($74 >>> 0) | 0;\n            if ($75 >>> 0 < $74 >>> 0) {\n             $$1 = $74;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($75, $74) | 0)) {\n             $$1 = $74;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $79 = $$0 + 46 | 0;\n            $80 = ($16 >>> 0) / ($79 >>> 0) | 0;\n            if ($80 >>> 0 < $79 >>> 0) {\n             $$1 = $79;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($80, $79) | 0)) {\n             $$1 = $79;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $84 = $$0 + 52 | 0;\n            $85 = ($16 >>> 0) / ($84 >>> 0) | 0;\n            if ($85 >>> 0 < $84 >>> 0) {\n             $$1 = $84;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($85, $84) | 0)) {\n             $$1 = $84;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $89 = $$0 + 58 | 0;\n            $90 = ($16 >>> 0) / ($89 >>> 0) | 0;\n            if ($90 >>> 0 < $89 >>> 0) {\n             $$1 = $89;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($90, $89) | 0)) {\n             $$1 = $89;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $94 = $$0 + 60 | 0;\n            $95 = ($16 >>> 0) / ($94 >>> 0) | 0;\n            if ($95 >>> 0 < $94 >>> 0) {\n             $$1 = $94;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($95, $94) | 0)) {\n             $$1 = $94;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $99 = $$0 + 66 | 0;\n            $100 = ($16 >>> 0) / ($99 >>> 0) | 0;\n            if ($100 >>> 0 < $99 >>> 0) {\n             $$1 = $99;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($100, $99) | 0)) {\n             $$1 = $99;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $104 = $$0 + 70 | 0;\n            $105 = ($16 >>> 0) / ($104 >>> 0) | 0;\n            if ($105 >>> 0 < $104 >>> 0) {\n             $$1 = $104;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($105, $104) | 0)) {\n             $$1 = $104;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $109 = $$0 + 72 | 0;\n            $110 = ($16 >>> 0) / ($109 >>> 0) | 0;\n            if ($110 >>> 0 < $109 >>> 0) {\n             $$1 = $109;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($110, $109) | 0)) {\n             $$1 = $109;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $114 = $$0 + 78 | 0;\n            $115 = ($16 >>> 0) / ($114 >>> 0) | 0;\n            if ($115 >>> 0 < $114 >>> 0) {\n             $$1 = $114;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($115, $114) | 0)) {\n             $$1 = $114;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $119 = $$0 + 82 | 0;\n            $120 = ($16 >>> 0) / ($119 >>> 0) | 0;\n            if ($120 >>> 0 < $119 >>> 0) {\n             $$1 = $119;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($120, $119) | 0)) {\n             $$1 = $119;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $124 = $$0 + 88 | 0;\n            $125 = ($16 >>> 0) / ($124 >>> 0) | 0;\n            if ($125 >>> 0 < $124 >>> 0) {\n             $$1 = $124;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($125, $124) | 0)) {\n             $$1 = $124;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $129 = $$0 + 96 | 0;\n            $130 = ($16 >>> 0) / ($129 >>> 0) | 0;\n            if ($130 >>> 0 < $129 >>> 0) {\n             $$1 = $129;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($130, $129) | 0)) {\n             $$1 = $129;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $134 = $$0 + 100 | 0;\n            $135 = ($16 >>> 0) / ($134 >>> 0) | 0;\n            if ($135 >>> 0 < $134 >>> 0) {\n             $$1 = $134;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($135, $134) | 0)) {\n             $$1 = $134;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $139 = $$0 + 102 | 0;\n            $140 = ($16 >>> 0) / ($139 >>> 0) | 0;\n            if ($140 >>> 0 < $139 >>> 0) {\n             $$1 = $139;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($140, $139) | 0)) {\n             $$1 = $139;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $144 = $$0 + 106 | 0;\n            $145 = ($16 >>> 0) / ($144 >>> 0) | 0;\n            if ($145 >>> 0 < $144 >>> 0) {\n             $$1 = $144;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($145, $144) | 0)) {\n             $$1 = $144;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $149 = $$0 + 108 | 0;\n            $150 = ($16 >>> 0) / ($149 >>> 0) | 0;\n            if ($150 >>> 0 < $149 >>> 0) {\n             $$1 = $149;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($150, $149) | 0)) {\n             $$1 = $149;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $154 = $$0 + 112 | 0;\n            $155 = ($16 >>> 0) / ($154 >>> 0) | 0;\n            if ($155 >>> 0 < $154 >>> 0) {\n             $$1 = $154;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($155, $154) | 0)) {\n             $$1 = $154;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $159 = $$0 + 120 | 0;\n            $160 = ($16 >>> 0) / ($159 >>> 0) | 0;\n            if ($160 >>> 0 < $159 >>> 0) {\n             $$1 = $159;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($160, $159) | 0)) {\n             $$1 = $159;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $164 = $$0 + 126 | 0;\n            $165 = ($16 >>> 0) / ($164 >>> 0) | 0;\n            if ($165 >>> 0 < $164 >>> 0) {\n             $$1 = $164;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($165, $164) | 0)) {\n             $$1 = $164;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $169 = $$0 + 130 | 0;\n            $170 = ($16 >>> 0) / ($169 >>> 0) | 0;\n            if ($170 >>> 0 < $169 >>> 0) {\n             $$1 = $169;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($170, $169) | 0)) {\n             $$1 = $169;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $174 = $$0 + 136 | 0;\n            $175 = ($16 >>> 0) / ($174 >>> 0) | 0;\n            if ($175 >>> 0 < $174 >>> 0) {\n             $$1 = $174;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($175, $174) | 0)) {\n             $$1 = $174;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $179 = $$0 + 138 | 0;\n            $180 = ($16 >>> 0) / ($179 >>> 0) | 0;\n            if ($180 >>> 0 < $179 >>> 0) {\n             $$1 = $179;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($180, $179) | 0)) {\n             $$1 = $179;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $184 = $$0 + 142 | 0;\n            $185 = ($16 >>> 0) / ($184 >>> 0) | 0;\n            if ($185 >>> 0 < $184 >>> 0) {\n             $$1 = $184;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($185, $184) | 0)) {\n             $$1 = $184;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $189 = $$0 + 148 | 0;\n            $190 = ($16 >>> 0) / ($189 >>> 0) | 0;\n            if ($190 >>> 0 < $189 >>> 0) {\n             $$1 = $189;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($190, $189) | 0)) {\n             $$1 = $189;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $194 = $$0 + 150 | 0;\n            $195 = ($16 >>> 0) / ($194 >>> 0) | 0;\n            if ($195 >>> 0 < $194 >>> 0) {\n             $$1 = $194;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($195, $194) | 0)) {\n             $$1 = $194;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $199 = $$0 + 156 | 0;\n            $200 = ($16 >>> 0) / ($199 >>> 0) | 0;\n            if ($200 >>> 0 < $199 >>> 0) {\n             $$1 = $199;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($200, $199) | 0)) {\n             $$1 = $199;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $204 = $$0 + 162 | 0;\n            $205 = ($16 >>> 0) / ($204 >>> 0) | 0;\n            if ($205 >>> 0 < $204 >>> 0) {\n             $$1 = $204;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($205, $204) | 0)) {\n             $$1 = $204;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $209 = $$0 + 166 | 0;\n            $210 = ($16 >>> 0) / ($209 >>> 0) | 0;\n            if ($210 >>> 0 < $209 >>> 0) {\n             $$1 = $209;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($210, $209) | 0)) {\n             $$1 = $209;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $214 = $$0 + 168 | 0;\n            $215 = ($16 >>> 0) / ($214 >>> 0) | 0;\n            if ($215 >>> 0 < $214 >>> 0) {\n             $$1 = $214;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($215, $214) | 0)) {\n             $$1 = $214;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $219 = $$0 + 172 | 0;\n            $220 = ($16 >>> 0) / ($219 >>> 0) | 0;\n            if ($220 >>> 0 < $219 >>> 0) {\n             $$1 = $219;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($220, $219) | 0)) {\n             $$1 = $219;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $224 = $$0 + 178 | 0;\n            $225 = ($16 >>> 0) / ($224 >>> 0) | 0;\n            if ($225 >>> 0 < $224 >>> 0) {\n             $$1 = $224;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($225, $224) | 0)) {\n             $$1 = $224;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $229 = $$0 + 180 | 0;\n            $230 = ($16 >>> 0) / ($229 >>> 0) | 0;\n            if ($230 >>> 0 < $229 >>> 0) {\n             $$1 = $229;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($230, $229) | 0)) {\n             $$1 = $229;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $234 = $$0 + 186 | 0;\n            $235 = ($16 >>> 0) / ($234 >>> 0) | 0;\n            if ($235 >>> 0 < $234 >>> 0) {\n             $$1 = $234;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($235, $234) | 0)) {\n             $$1 = $234;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $239 = $$0 + 190 | 0;\n            $240 = ($16 >>> 0) / ($239 >>> 0) | 0;\n            if ($240 >>> 0 < $239 >>> 0) {\n             $$1 = $239;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($240, $239) | 0)) {\n             $$1 = $239;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $244 = $$0 + 192 | 0;\n            $245 = ($16 >>> 0) / ($244 >>> 0) | 0;\n            if ($245 >>> 0 < $244 >>> 0) {\n             $$1 = $244;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($245, $244) | 0)) {\n             $$1 = $244;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $249 = $$0 + 196 | 0;\n            $250 = ($16 >>> 0) / ($249 >>> 0) | 0;\n            if ($250 >>> 0 < $249 >>> 0) {\n             $$1 = $249;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($250, $249) | 0)) {\n             $$1 = $249;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $254 = $$0 + 198 | 0;\n            $255 = ($16 >>> 0) / ($254 >>> 0) | 0;\n            if ($255 >>> 0 < $254 >>> 0) {\n             $$1 = $254;\n             $$2332 = 1;\n             $$5 = $16;\n             break;\n            }\n            if (($16 | 0) == (Math_imul($255, $254) | 0)) {\n             $$1 = $254;\n             $$2332 = 9;\n             $$5 = $$4;\n             break;\n            }\n            $259 = $$0 + 208 | 0;\n            $260 = ($16 >>> 0) / ($259 >>> 0) | 0;\n            $261 = $260 >>> 0 < $259 >>> 0;\n            $263 = ($16 | 0) == (Math_imul($260, $259) | 0);\n            $$1 = $261 | $263 ? $259 : $$0 + 210 | 0;\n            $$2332 = $261 ? 1 : $263 ? 9 : 0;\n            $$5 = $261 ? $16 : $$4;\n           }\n          }\n         }\n        }\n       }\n      }\n     } while (0);\n     switch ($$2332 & 15) {\n     case 9:\n      {\n       $$6 = $$5;\n       break L10;\n       break;\n      }\n     case 0:\n      {\n       $$0 = $$1;\n       $$4 = $$5;\n       break;\n      }\n     default:\n      break L12;\n     }\n    }\n    if (!$$2332) $$6 = $$5; else {\n     label = 108;\n     break L4;\n    }\n   } while (0);\n   $266 = $spec$select339$sink + 1 | 0;\n   $267 = ($266 | 0) == 48;\n   $spec$select = $$0337 + ($267 & 1) | 0;\n   $$0328 = $$6;\n   $$0337 = $spec$select;\n   $$sink369 = $spec$select * 210 | 0;\n   $spec$select339$sink = $267 ? 0 : $266;\n  }\n  if ((label | 0) == 107) {\n   HEAP32[$2 >> 2] = $16;\n   $$8 = $16;\n   break;\n  } else if ((label | 0) == 108) {\n   HEAP32[$2 >> 2] = $16;\n   $$8 = $$5;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$8 | 0;\n}\n\nfunction _vfscanf($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0266$lcssa = 0, $$0266409 = 0, $$0268 = 0, $$0270 = 0, $$0272 = 0, $$0273420 = 0, $$0276$ph$ph = 0, $$0280$ph = 0, $$0280$ph$ph = 0, $$0285419 = 0, $$0288411 = 0, $$0290416 = 0, $$0294 = 0, $$0295 = 0, $$0308414 = 0, $$10 = 0, $$10318 = 0, $$11 = 0, $$12 = 0, $$1267 = 0, $$1271 = 0, $$1274 = 0, $$1281 = 0, $$1286 = 0, $$1291 = 0, $$1309 = 0, $$2 = 0, $$2275 = 0, $$2278$ph = 0, $$2282 = 0, $$2282$ph = 0, $$2287 = 0, $$2292 = 0, $$2310$ph = 0, $$3$lcssa = 0, $$3283 = 0, $$3293 = 0, $$3408 = 0, $$4 = 0, $$4284 = 0, $$5 = 0, $$5313 = 0, $$6 = 0, $$6302 = 0, $$6314 = 0, $$7 = 0, $$7315 = 0, $$8 = 0, $$8316 = 0, $$9 = 0, $$9317 = 0, $$ph$ph = 0, $$pre$phi493Z2D = 0, $$pre$phiZ2D = 0, $$sroa$2$0$$sroa_idx13 = 0, $102 = 0, $103 = 0, $108 = 0, $11 = 0, $110 = 0, $113 = 0, $115 = 0, $118 = 0, $121 = 0, $123 = 0, $128 = 0, $13 = 0, $135 = 0, $14 = 0, $141 = 0, $147 = 0, $149 = 0, $15 = 0, $150 = 0, $156 = 0, $159 = 0, $16 = 0, $163 = 0, $165 = 0, $17 = 0, $170 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $178 = 0, $18 = 0, $183 = 0, $187 = 0, $19 = 0, $192 = 0, $193 = 0, $194 = 0, $196 = 0, $198 = 0, $199 = 0, $20 = 0, $207 = 0, $219 = 0, $22 = 0, $223 = 0, $225 = 0, $233 = 0, $242 = 0, $245 = 0, $25 = 0, $253 = 0, $260 = 0, $268 = 0, $275 = 0, $280 = 0, $281 = 0, $288 = 0, $298 = 0.0, $3 = 0, $30 = 0, $318 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $37 = 0, $4 = 0, $43 = 0, $49 = 0, $5 = 0, $52 = 0, $53 = 0, $54 = 0, $56 = 0, $57 = 0, $6 = 0, $67 = 0, $92 = 0, $93 = 0, $spec$select = 0, $spec$select319 = 0, $trunc = 0, label = 0, sp = 0, $$2282$looptemp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 288 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(288);\n $3 = sp + 8 | 0;\n $4 = sp + 17 | 0;\n $5 = sp;\n $6 = sp + 16 | 0;\n if ((HEAP32[$0 + 76 >> 2] | 0) > -1) $320 = ___lockfile($0) | 0; else $320 = 0;\n $11 = HEAP8[$1 >> 0] | 0;\n L4 : do if (!($11 << 24 >> 24)) $$3293 = 0; else {\n  $13 = $0 + 4 | 0;\n  $14 = $0 + 100 | 0;\n  $15 = $0 + 108 | 0;\n  $16 = $0 + 8 | 0;\n  $17 = $4 + 10 | 0;\n  $18 = $4 + 33 | 0;\n  $19 = $4 + 46 | 0;\n  $20 = $4 + 94 | 0;\n  $$sroa$2$0$$sroa_idx13 = $3 + 4 | 0;\n  $$0273420 = $1;\n  $$0285419 = 0;\n  $$0290416 = 0;\n  $$0308414 = 0;\n  $22 = $11;\n  $321 = 0;\n  L6 : while (1) {\n   L8 : do if (!(_isspace($22 & 255) | 0)) {\n    $52 = (HEAP8[$$0273420 >> 0] | 0) == 37;\n    L10 : do if ($52) {\n     $53 = $$0273420 + 1 | 0;\n     $54 = HEAP8[$53 >> 0] | 0;\n     L12 : do switch ($54 << 24 >> 24) {\n     case 37:\n      {\n       break L10;\n       break;\n      }\n     case 42:\n      {\n       $$0295 = 0;\n       $$2275 = $$0273420 + 2 | 0;\n       break;\n      }\n     default:\n      {\n       if (_isdigit($54 & 255) | 0) if ((HEAP8[$$0273420 + 2 >> 0] | 0) == 36) {\n        $$0295 = _arg_n_724($2, (HEAPU8[$53 >> 0] | 0) + -48 | 0) | 0;\n        $$2275 = $$0273420 + 3 | 0;\n        break L12;\n       }\n       $92 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n       $93 = HEAP32[$92 >> 2] | 0;\n       HEAP32[$2 >> 2] = $92 + 4;\n       $$0295 = $93;\n       $$2275 = $53;\n      }\n     } while (0);\n     if (!(_isdigit(HEAPU8[$$2275 >> 0] | 0) | 0)) {\n      $$0266$lcssa = 0;\n      $$3$lcssa = $$2275;\n     } else {\n      $$0266409 = 0;\n      $$3408 = $$2275;\n      while (1) {\n       $102 = ($$0266409 * 10 | 0) + -48 + (HEAPU8[$$3408 >> 0] | 0) | 0;\n       $103 = $$3408 + 1 | 0;\n       if (!(_isdigit(HEAPU8[$103 >> 0] | 0) | 0)) {\n        $$0266$lcssa = $102;\n        $$3$lcssa = $103;\n        break;\n       } else {\n        $$0266409 = $102;\n        $$3408 = $103;\n       }\n      }\n     }\n     $108 = HEAP8[$$3$lcssa >> 0] | 0;\n     $110 = $$3$lcssa + 1 | 0;\n     if ($108 << 24 >> 24 == 109) {\n      $$0270 = ($$0295 | 0) != 0 & 1;\n      $$1309 = 0;\n      $$4 = $110;\n      $$pre$phiZ2D = $$3$lcssa + 2 | 0;\n      $113 = HEAP8[$110 >> 0] | 0;\n      $324 = 0;\n     } else {\n      $$0270 = 0;\n      $$1309 = $$0308414;\n      $$4 = $$3$lcssa;\n      $$pre$phiZ2D = $110;\n      $113 = $108;\n      $324 = $321;\n     }\n     switch ($113 << 24 >> 24) {\n     case 104:\n      {\n       $115 = (HEAP8[$$pre$phiZ2D >> 0] | 0) == 104;\n       $$0268 = $115 ? -2 : -1;\n       $$5 = $115 ? $$4 + 2 | 0 : $$pre$phiZ2D;\n       break;\n      }\n     case 108:\n      {\n       $118 = (HEAP8[$$pre$phiZ2D >> 0] | 0) == 108;\n       $$0268 = $118 ? 3 : 1;\n       $$5 = $118 ? $$4 + 2 | 0 : $$pre$phiZ2D;\n       break;\n      }\n     case 106:\n      {\n       $$0268 = 3;\n       $$5 = $$pre$phiZ2D;\n       break;\n      }\n     case 116:\n     case 122:\n      {\n       $$0268 = 1;\n       $$5 = $$pre$phiZ2D;\n       break;\n      }\n     case 76:\n      {\n       $$0268 = 2;\n       $$5 = $$pre$phiZ2D;\n       break;\n      }\n     case 110:\n     case 112:\n     case 67:\n     case 83:\n     case 91:\n     case 99:\n     case 115:\n     case 88:\n     case 71:\n     case 70:\n     case 69:\n     case 65:\n     case 103:\n     case 102:\n     case 101:\n     case 97:\n     case 120:\n     case 117:\n     case 111:\n     case 105:\n     case 100:\n      {\n       $$0268 = 0;\n       $$5 = $$4;\n       break;\n      }\n     default:\n      {\n       $$8316 = $$1309;\n       $325 = $324;\n       label = 143;\n       break L6;\n      }\n     }\n     $121 = HEAPU8[$$5 >> 0] | 0;\n     $123 = ($121 & 47 | 0) == 3;\n     $spec$select = $123 ? $121 | 32 : $121;\n     $spec$select319 = $123 ? 1 : $$0268;\n     $trunc = $spec$select & 255;\n     switch ($trunc << 24 >> 24) {\n     case 99:\n      {\n       $$1267 = ($$0266$lcssa | 0) > 1 ? $$0266$lcssa : 1;\n       $$1286 = $$0285419;\n       break;\n      }\n     case 91:\n      {\n       $$1267 = $$0266$lcssa;\n       $$1286 = $$0285419;\n       break;\n      }\n     case 110:\n      {\n       _store_int_725($$0295, $spec$select319, $$0285419, (($$0285419 | 0) < 0) << 31 >> 31);\n       $$12 = $$5;\n       $$1291 = $$0290416;\n       $$2287 = $$0285419;\n       $$7315 = $$1309;\n       $322 = $324;\n       break L8;\n       break;\n      }\n     default:\n      {\n       ___shlim($0, 0);\n       do {\n        $128 = HEAP32[$13 >> 2] | 0;\n        if ($128 >>> 0 < (HEAP32[$14 >> 2] | 0) >>> 0) {\n         HEAP32[$13 >> 2] = $128 + 1;\n         $135 = HEAPU8[$128 >> 0] | 0;\n        } else $135 = ___shgetc($0) | 0;\n       } while ((_isspace($135) | 0) != 0);\n       if (!(HEAP32[$14 >> 2] | 0)) $147 = HEAP32[$13 >> 2] | 0; else {\n        $141 = (HEAP32[$13 >> 2] | 0) + -1 | 0;\n        HEAP32[$13 >> 2] = $141;\n        $147 = $141;\n       }\n       $$1267 = $$0266$lcssa;\n       $$1286 = (HEAP32[$15 >> 2] | 0) + $$0285419 + $147 - (HEAP32[$16 >> 2] | 0) | 0;\n      }\n     }\n     ___shlim($0, $$1267);\n     $149 = HEAP32[$13 >> 2] | 0;\n     $150 = HEAP32[$14 >> 2] | 0;\n     if ($149 >>> 0 < $150 >>> 0) {\n      HEAP32[$13 >> 2] = $149 + 1;\n      $156 = $150;\n     } else {\n      if ((___shgetc($0) | 0) < 0) {\n       $$8316 = $$1309;\n       $325 = $324;\n       label = 143;\n       break L6;\n      }\n      $156 = HEAP32[$14 >> 2] | 0;\n     }\n     if ($156 | 0) HEAP32[$13 >> 2] = (HEAP32[$13 >> 2] | 0) + -1;\n     L59 : do switch ($trunc << 24 >> 24) {\n     case 91:\n     case 99:\n     case 115:\n      {\n       $159 = ($spec$select | 0) == 99;\n       L61 : do if (($spec$select | 16 | 0) == 115) {\n        _memset($4 | 0, -1, 257) | 0;\n        HEAP8[$4 >> 0] = 0;\n        if (($spec$select | 0) == 115) {\n         HEAP8[$18 >> 0] = 0;\n         HEAP8[$17 >> 0] = 0;\n         HEAP8[$17 + 1 >> 0] = 0;\n         HEAP8[$17 + 2 >> 0] = 0;\n         HEAP8[$17 + 3 >> 0] = 0;\n         HEAP8[$17 + 4 >> 0] = 0;\n         $$10 = $$5;\n        } else $$10 = $$5;\n       } else {\n        $163 = $$5 + 1 | 0;\n        $165 = (HEAP8[$163 >> 0] | 0) == 94;\n        $$0294 = $165 & 1;\n        $$6 = $165 ? $$5 + 2 | 0 : $163;\n        _memset($4 | 0, $$0294 | 0, 257) | 0;\n        HEAP8[$4 >> 0] = 0;\n        switch (HEAP8[$$6 >> 0] | 0) {\n        case 45:\n         {\n          $170 = ($$0294 ^ 1) & 255;\n          HEAP8[$19 >> 0] = $170;\n          $$7 = $$6 + 1 | 0;\n          $$pre$phi493Z2D = $170;\n          break;\n         }\n        case 93:\n         {\n          $173 = ($$0294 ^ 1) & 255;\n          HEAP8[$20 >> 0] = $173;\n          $$7 = $$6 + 1 | 0;\n          $$pre$phi493Z2D = $173;\n          break;\n         }\n        default:\n         {\n          $$7 = $$6;\n          $$pre$phi493Z2D = ($$0294 ^ 1) & 255;\n         }\n        }\n        $$8 = $$7;\n        while (1) {\n         $174 = HEAP8[$$8 >> 0] | 0;\n         L72 : do switch ($174 << 24 >> 24) {\n         case 0:\n          {\n           $$8316 = $$1309;\n           $325 = $324;\n           label = 143;\n           break L6;\n           break;\n          }\n         case 93:\n          {\n           $$10 = $$8;\n           break L61;\n           break;\n          }\n         case 45:\n          {\n           $175 = $$8 + 1 | 0;\n           $176 = HEAP8[$175 >> 0] | 0;\n           switch ($176 << 24 >> 24) {\n           case 93:\n           case 0:\n            {\n             $$9 = $$8;\n             $187 = 45;\n             break L72;\n             break;\n            }\n           default:\n            {}\n           }\n           $178 = HEAP8[$$8 + -1 >> 0] | 0;\n           if (($178 & 255) < ($176 & 255)) {\n            $$0288411 = $178 & 255;\n            do {\n             $$0288411 = $$0288411 + 1 | 0;\n             HEAP8[$4 + $$0288411 >> 0] = $$pre$phi493Z2D;\n             $183 = HEAP8[$175 >> 0] | 0;\n            } while ($$0288411 >>> 0 < ($183 & 255) >>> 0);\n            $$9 = $175;\n            $187 = $183;\n           } else {\n            $$9 = $175;\n            $187 = $176;\n           }\n           break;\n          }\n         default:\n          {\n           $$9 = $$8;\n           $187 = $174;\n          }\n         } while (0);\n         HEAP8[$4 + (($187 & 255) + 1) >> 0] = $$pre$phi493Z2D;\n         $$8 = $$9 + 1 | 0;\n        }\n       } while (0);\n       $192 = $159 ? $$1267 + 1 | 0 : 31;\n       $193 = ($spec$select319 | 0) == 1;\n       $194 = ($$0270 | 0) != 0;\n       L80 : do if ($193) {\n        if ($194) {\n         $196 = _malloc($192 << 2) | 0;\n         if (!$196) {\n          $$8316 = 0;\n          $325 = 0;\n          label = 143;\n          break L6;\n         } else $327 = $196;\n        } else $327 = $$0295;\n        HEAP32[$3 >> 2] = 0;\n        HEAP32[$$sroa$2$0$$sroa_idx13 >> 2] = 0;\n        $$0276$ph$ph = $192;\n        $$0280$ph$ph = 0;\n        $$ph$ph = $327;\n        L85 : while (1) {\n         $198 = ($$ph$ph | 0) == 0;\n         $$0280$ph = $$0280$ph$ph;\n         while (1) {\n          L89 : while (1) {\n           $199 = HEAP32[$13 >> 2] | 0;\n           if ($199 >>> 0 < (HEAP32[$14 >> 2] | 0) >>> 0) {\n            HEAP32[$13 >> 2] = $199 + 1;\n            $207 = HEAPU8[$199 >> 0] | 0;\n           } else $207 = ___shgetc($0) | 0;\n           if (!(HEAP8[$4 + ($207 + 1) >> 0] | 0)) break L85;\n           HEAP8[$6 >> 0] = $207;\n           switch (_mbrtowc($5, $6, 1, $3) | 0) {\n           case -1:\n            {\n             $$8316 = 0;\n             $325 = $$ph$ph;\n             label = 143;\n             break L6;\n             break;\n            }\n           case -2:\n            break;\n           default:\n            break L89;\n           }\n          }\n          if ($198) $$1281 = $$0280$ph; else {\n           HEAP32[$$ph$ph + ($$0280$ph << 2) >> 2] = HEAP32[$5 >> 2];\n           $$1281 = $$0280$ph + 1 | 0;\n          }\n          if ($194 & ($$1281 | 0) == ($$0276$ph$ph | 0)) break; else $$0280$ph = $$1281;\n         }\n         $$0276$ph$ph = $$0276$ph$ph << 1 | 1;\n         $219 = _realloc($$ph$ph, $$0276$ph$ph << 2) | 0;\n         if (!$219) {\n          $$8316 = 0;\n          $325 = $$ph$ph;\n          label = 143;\n          break L6;\n         } else {\n          $$0280$ph$ph = $$1281;\n          $$ph$ph = $219;\n         }\n        }\n        if (!(_mbsinit($3) | 0)) {\n         $$8316 = 0;\n         $325 = $$ph$ph;\n         label = 143;\n         break L6;\n        } else {\n         $$4284 = $$0280$ph;\n         $$5313 = 0;\n         $$6302 = $$ph$ph;\n         $328 = $$ph$ph;\n        }\n       } else {\n        if ($194) {\n         $223 = _malloc($192) | 0;\n         if (!$223) {\n          $$8316 = 0;\n          $325 = 0;\n          label = 143;\n          break L6;\n         }\n         $$2278$ph = $192;\n         $$2282$ph = 0;\n         $$2310$ph = $223;\n         while (1) {\n          $$2282 = $$2282$ph;\n          do {\n           $225 = HEAP32[$13 >> 2] | 0;\n           if ($225 >>> 0 < (HEAP32[$14 >> 2] | 0) >>> 0) {\n            HEAP32[$13 >> 2] = $225 + 1;\n            $233 = HEAPU8[$225 >> 0] | 0;\n           } else $233 = ___shgetc($0) | 0;\n           if (!(HEAP8[$4 + ($233 + 1) >> 0] | 0)) {\n            $$4284 = $$2282;\n            $$5313 = $$2310$ph;\n            $$6302 = 0;\n            $328 = 0;\n            break L80;\n           }\n           $$2282$looptemp = $$2282;\n           $$2282 = $$2282 + 1 | 0;\n           HEAP8[$$2310$ph + $$2282$looptemp >> 0] = $233;\n          } while (($$2282 | 0) != ($$2278$ph | 0));\n          $$2278$ph = $$2278$ph << 1 | 1;\n          $242 = _realloc($$2310$ph, $$2278$ph) | 0;\n          if (!$242) {\n           $$8316 = $$2310$ph;\n           $325 = 0;\n           label = 143;\n           break L6;\n          } else {\n           $$2282$ph = $$2282;\n           $$2310$ph = $242;\n          }\n         }\n        }\n        if (!$$0295) while (1) {\n         $260 = HEAP32[$13 >> 2] | 0;\n         if ($260 >>> 0 < (HEAP32[$14 >> 2] | 0) >>> 0) {\n          HEAP32[$13 >> 2] = $260 + 1;\n          $268 = HEAPU8[$260 >> 0] | 0;\n         } else $268 = ___shgetc($0) | 0;\n         if (!(HEAP8[$4 + ($268 + 1) >> 0] | 0)) {\n          $$4284 = 0;\n          $$5313 = 0;\n          $$6302 = 0;\n          $328 = 0;\n          break L80;\n         }\n        }\n        $$3283 = 0;\n        while (1) {\n         $245 = HEAP32[$13 >> 2] | 0;\n         if ($245 >>> 0 < (HEAP32[$14 >> 2] | 0) >>> 0) {\n          HEAP32[$13 >> 2] = $245 + 1;\n          $253 = HEAPU8[$245 >> 0] | 0;\n         } else $253 = ___shgetc($0) | 0;\n         if (!(HEAP8[$4 + ($253 + 1) >> 0] | 0)) {\n          $$4284 = $$3283;\n          $$5313 = $$0295;\n          $$6302 = 0;\n          $328 = 0;\n          break L80;\n         }\n         HEAP8[$$0295 + $$3283 >> 0] = $253;\n         $$3283 = $$3283 + 1 | 0;\n        }\n       } while (0);\n       if (!(HEAP32[$14 >> 2] | 0)) $280 = HEAP32[$13 >> 2] | 0; else {\n        $275 = (HEAP32[$13 >> 2] | 0) + -1 | 0;\n        HEAP32[$13 >> 2] = $275;\n        $280 = $275;\n       }\n       $281 = $280 - (HEAP32[$16 >> 2] | 0) + (HEAP32[$15 >> 2] | 0) | 0;\n       if (!$281) {\n        $$10318 = $$5313;\n        $$2 = $$0270;\n        $$2292 = $$0290416;\n        $318 = $328;\n        break L6;\n       }\n       if (!(($281 | 0) == ($$1267 | 0) | $159 ^ 1)) {\n        $$10318 = $$5313;\n        $$2 = $$0270;\n        $$2292 = $$0290416;\n        $318 = $328;\n        break L6;\n       }\n       do if ($194) if ($193) {\n        HEAP32[$$0295 >> 2] = $$6302;\n        break;\n       } else {\n        HEAP32[$$0295 >> 2] = $$5313;\n        break;\n       } while (0);\n       if ($159) {\n        $$11 = $$10;\n        $$6314 = $$5313;\n        $326 = $328;\n       } else {\n        if ($$6302 | 0) HEAP32[$$6302 + ($$4284 << 2) >> 2] = 0;\n        if (!$$5313) {\n         $$11 = $$10;\n         $$6314 = 0;\n         $326 = $328;\n         break L59;\n        }\n        HEAP8[$$5313 + $$4284 >> 0] = 0;\n        $$11 = $$10;\n        $$6314 = $$5313;\n        $326 = $328;\n       }\n       break;\n      }\n     case 120:\n     case 88:\n     case 112:\n      {\n       $$0272 = 16;\n       label = 131;\n       break;\n      }\n     case 111:\n      {\n       $$0272 = 8;\n       label = 131;\n       break;\n      }\n     case 117:\n     case 100:\n      {\n       $$0272 = 10;\n       label = 131;\n       break;\n      }\n     case 105:\n      {\n       $$0272 = 0;\n       label = 131;\n       break;\n      }\n     case 71:\n     case 103:\n     case 70:\n     case 102:\n     case 69:\n     case 101:\n     case 65:\n     case 97:\n      {\n       $298 = +___floatscan($0, $spec$select319, 0);\n       if ((HEAP32[$15 >> 2] | 0) == ((HEAP32[$16 >> 2] | 0) - (HEAP32[$13 >> 2] | 0) | 0)) {\n        $$10318 = $$1309;\n        $$2 = $$0270;\n        $$2292 = $$0290416;\n        $318 = $324;\n        break L6;\n       }\n       if (!$$0295) {\n        $$11 = $$5;\n        $$6314 = $$1309;\n        $326 = $324;\n       } else switch ($spec$select319 | 0) {\n       case 0:\n        {\n         HEAPF32[$$0295 >> 2] = $298;\n         $$11 = $$5;\n         $$6314 = $$1309;\n         $326 = $324;\n         break L59;\n         break;\n        }\n       case 1:\n        {\n         HEAPF64[$$0295 >> 3] = $298;\n         $$11 = $$5;\n         $$6314 = $$1309;\n         $326 = $324;\n         break L59;\n         break;\n        }\n       case 2:\n        {\n         HEAPF64[$$0295 >> 3] = $298;\n         $$11 = $$5;\n         $$6314 = $$1309;\n         $326 = $324;\n         break L59;\n         break;\n        }\n       default:\n        {\n         $$11 = $$5;\n         $$6314 = $$1309;\n         $326 = $324;\n         break L59;\n        }\n       }\n       break;\n      }\n     default:\n      {\n       $$11 = $$5;\n       $$6314 = $$1309;\n       $326 = $324;\n      }\n     } while (0);\n     do if ((label | 0) == 131) {\n      label = 0;\n      $288 = ___intscan($0, $$0272, 0, -1, -1) | 0;\n      if ((HEAP32[$15 >> 2] | 0) == ((HEAP32[$16 >> 2] | 0) - (HEAP32[$13 >> 2] | 0) | 0)) {\n       $$10318 = $$1309;\n       $$2 = $$0270;\n       $$2292 = $$0290416;\n       $318 = $324;\n       break L6;\n      }\n      if (($$0295 | 0) != 0 & ($spec$select | 0) == 112) {\n       HEAP32[$$0295 >> 2] = $288;\n       $$11 = $$5;\n       $$6314 = $$1309;\n       $326 = $324;\n       break;\n      } else {\n       _store_int_725($$0295, $spec$select319, $288, tempRet0);\n       $$11 = $$5;\n       $$6314 = $$1309;\n       $326 = $324;\n       break;\n      }\n     } while (0);\n     $$12 = $$11;\n     $$1291 = $$0290416 + (($$0295 | 0) != 0 & 1) | 0;\n     $$2287 = (HEAP32[$15 >> 2] | 0) + $$1286 + (HEAP32[$13 >> 2] | 0) - (HEAP32[$16 >> 2] | 0) | 0;\n     $$7315 = $$6314;\n     $322 = $326;\n     break L8;\n    } while (0);\n    $56 = $$0273420 + ($52 & 1) | 0;\n    ___shlim($0, 0);\n    $57 = HEAP32[$13 >> 2] | 0;\n    if ($57 >>> 0 < (HEAP32[$14 >> 2] | 0) >>> 0) {\n     HEAP32[$13 >> 2] = $57 + 1;\n     $67 = HEAPU8[$57 >> 0] | 0;\n    } else $67 = ___shgetc($0) | 0;\n    if (($67 | 0) != (HEAPU8[$56 >> 0] | 0)) {\n     label = 23;\n     break L6;\n    }\n    $$12 = $56;\n    $$1291 = $$0290416;\n    $$2287 = $$0285419 + 1 | 0;\n    $$7315 = $$0308414;\n    $322 = $321;\n   } else {\n    $$1274 = $$0273420;\n    while (1) {\n     $25 = $$1274 + 1 | 0;\n     if (!(_isspace(HEAPU8[$25 >> 0] | 0) | 0)) break; else $$1274 = $25;\n    }\n    ___shlim($0, 0);\n    do {\n     $30 = HEAP32[$13 >> 2] | 0;\n     if ($30 >>> 0 < (HEAP32[$14 >> 2] | 0) >>> 0) {\n      HEAP32[$13 >> 2] = $30 + 1;\n      $37 = HEAPU8[$30 >> 0] | 0;\n     } else $37 = ___shgetc($0) | 0;\n    } while ((_isspace($37) | 0) != 0);\n    if (!(HEAP32[$14 >> 2] | 0)) $49 = HEAP32[$13 >> 2] | 0; else {\n     $43 = (HEAP32[$13 >> 2] | 0) + -1 | 0;\n     HEAP32[$13 >> 2] = $43;\n     $49 = $43;\n    }\n    $$12 = $$1274;\n    $$1291 = $$0290416;\n    $$2287 = (HEAP32[$15 >> 2] | 0) + $$0285419 + $49 - (HEAP32[$16 >> 2] | 0) | 0;\n    $$7315 = $$0308414;\n    $322 = $321;\n   } while (0);\n   $$0273420 = $$12 + 1 | 0;\n   $22 = HEAP8[$$0273420 >> 0] | 0;\n   if (!($22 << 24 >> 24)) {\n    $$3293 = $$1291;\n    break L4;\n   } else {\n    $$0285419 = $$2287;\n    $$0290416 = $$1291;\n    $$0308414 = $$7315;\n    $321 = $322;\n   }\n  }\n  if ((label | 0) == 23) {\n   if (HEAP32[$14 >> 2] | 0) HEAP32[$13 >> 2] = (HEAP32[$13 >> 2] | 0) + -1;\n   if (($$0290416 | 0) != 0 | ($67 | 0) > -1) {\n    $$3293 = $$0290416;\n    break;\n   } else {\n    $$1271 = 0;\n    $$9317 = $$0308414;\n    $323 = $321;\n    label = 144;\n   }\n  } else if ((label | 0) == 143) if (!$$0290416) {\n   $$1271 = $$0270;\n   $$9317 = $$8316;\n   $323 = $325;\n   label = 144;\n  } else {\n   $$10318 = $$8316;\n   $$2 = $$0270;\n   $$2292 = $$0290416;\n   $318 = $325;\n  }\n  if ((label | 0) == 144) {\n   $$10318 = $$9317;\n   $$2 = $$1271;\n   $$2292 = -1;\n   $318 = $323;\n  }\n  if (!$$2) $$3293 = $$2292; else {\n   _free($$10318);\n   _free($318);\n   $$3293 = $$2292;\n  }\n } while (0);\n if ($320 | 0) ___unlockfile($0);\n STACKTOP = sp;\n return $$3293 | 0;\n}\n\nfunction _fmt_fp($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = +$1;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $$0 = 0, $$0463$lcssa = 0, $$0463588 = 0, $$0464599 = 0, $$0471 = 0.0, $$0479 = 0, $$0487657 = 0, $$0488669 = 0, $$0488671 = 0, $$0497670 = 0, $$0498 = 0, $$0511586 = 0.0, $$0513 = 0, $$0516652 = 0, $$0522 = 0, $$0523 = 0, $$0525 = 0, $$0527 = 0, $$0529$in646 = 0, $$0532651 = 0, $$1465 = 0, $$1467 = 0.0, $$1469 = 0.0, $$1472 = 0.0, $$1480 = 0, $$1482$lcssa = 0, $$1482683 = 0, $$1489656 = 0, $$1499 = 0, $$1510587 = 0, $$1514$lcssa = 0, $$1514614 = 0, $$1517 = 0, $$1526 = 0, $$1530621 = 0, $$1533$lcssa = 0, $$1533645 = 0, $$1604 = 0, $$2 = 0, $$2473 = 0.0, $$2476 = 0, $$2483 = 0, $$2490$lcssa = 0, $$2490638 = 0, $$2500$lcssa = 0, $$2500682 = 0, $$2515 = 0, $$2518634 = 0, $$2531 = 0, $$2534633 = 0, $$3 = 0.0, $$3477 = 0, $$3484$lcssa = 0, $$3484663 = 0, $$3501$lcssa = 0, $$3501676 = 0, $$3535620 = 0, $$4 = 0.0, $$4478$lcssa = 0, $$4478594 = 0, $$4492 = 0, $$4502$lcssa = 0, $$4502662 = 0, $$4520 = 0, $$5$lcssa = 0, $$5486$lcssa = 0, $$5486639 = 0, $$5493603 = 0, $$5503 = 0, $$5521 = 0, $$5609 = 0, $$6 = 0, $$6494593 = 0, $$7495608 = 0, $$8 = 0, $$8506 = 0, $$9 = 0, $$9507$lcssa = 0, $$9507625 = 0, $$lcssa583 = 0, $$pn = 0, $$pr = 0, $$pr564 = 0, $$pre$phi713Z2D = 0, $$pre$phi714Z2D = 0, $$pre716 = 0, $$sink755 = 0, $10 = 0, $103 = 0, $104 = 0, $108 = 0, $109 = 0, $11 = 0, $113 = 0, $115 = 0, $116 = 0, $12 = 0, $123 = 0, $126 = 0, $13 = 0, $134 = 0, $135 = 0, $138 = 0, $140 = 0, $141 = 0, $144 = 0, $146 = 0, $15 = 0.0, $150 = 0, $153 = 0, $157 = 0, $16 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $167 = 0, $173 = 0, $174 = 0, $175 = 0, $187 = 0, $198 = 0, $202 = 0, $203 = 0, $206 = 0, $211 = 0, $212 = 0, $214 = 0, $222 = 0, $223 = 0, $225 = 0, $227 = 0, $229 = 0, $231 = 0, $232 = 0, $234 = 0, $237 = 0, $240 = 0, $245 = 0, $248 = 0, $25 = 0, $251 = 0, $253 = 0, $255 = 0, $257 = 0, $262 = 0, $263 = 0, $266 = 0, $268 = 0, $270 = 0, $273 = 0, $286 = 0, $291 = 0, $30 = 0, $300 = 0, $301 = 0, $305 = 0, $308 = 0, $310 = 0, $312 = 0, $316 = 0, $319 = 0, $320 = 0, $324 = 0, $334 = 0, $339 = 0, $34 = 0, $342 = 0, $343 = 0, $344 = 0, $346 = 0, $351 = 0, $364 = 0, $368 = 0, $373 = 0, $38 = 0.0, $382 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $389 = 0, $39 = 0, $393 = 0, $395 = 0, $398 = 0, $401 = 0, $412 = 0, $42 = 0, $44 = 0, $47 = 0, $49 = 0, $6 = 0, $63 = 0, $66 = 0, $69 = 0, $7 = 0, $71 = 0, $79 = 0, $8 = 0, $80 = 0, $82 = 0, $83 = 0, $89 = 0, $9 = 0, $spec$select = 0, $spec$select539 = 0, $spec$select540 = 0, $spec$select540721 = 0, $spec$select541 = 0, $spec$select544 = 0.0, $spec$select548 = 0, $spec$select549 = 0, $spec$select551 = 0, $spec$select554 = 0, $spec$select557 = 0, $spec$select567 = 0.0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 560 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(560);\n $6 = sp + 8 | 0;\n $7 = sp;\n $8 = sp + 524 | 0;\n $9 = $8;\n $10 = sp + 512 | 0;\n HEAP32[$7 >> 2] = 0;\n $11 = $10 + 12 | 0;\n $12 = ___DOUBLE_BITS_677($1) | 0;\n $13 = tempRet0;\n if (($13 | 0) < 0) {\n  $15 = -$1;\n  $16 = ___DOUBLE_BITS_677($15) | 0;\n  $$0471 = $15;\n  $$0522 = 1;\n  $$0523 = 12519;\n  $25 = tempRet0;\n  $412 = $16;\n } else {\n  $$0471 = $1;\n  $$0522 = ($4 & 2049 | 0) != 0 & 1;\n  $$0523 = ($4 & 2048 | 0) == 0 ? (($4 & 1 | 0) == 0 ? 12520 : 12525) : 12522;\n  $25 = $13;\n  $412 = $12;\n }\n do if (0 == 0 & ($25 & 2146435072 | 0) == 2146435072) {\n  $30 = ($5 & 32 | 0) != 0;\n  $34 = $$0522 + 3 | 0;\n  _pad_676($0, 32, $2, $34, $4 & -65537);\n  _out_670($0, $$0523, $$0522);\n  _out_670($0, $$0471 != $$0471 | 0.0 != 0.0 ? ($30 ? 12546 : 12550) : $30 ? 12538 : 12542, 3);\n  _pad_676($0, 32, $2, $34, $4 ^ 8192);\n  $$sink755 = $34;\n } else {\n  $38 = +_frexpl($$0471, $7) * 2.0;\n  $39 = $38 != 0.0;\n  if ($39) HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + -1;\n  $42 = $5 | 32;\n  if (($42 | 0) == 97) {\n   $44 = $5 & 32;\n   $spec$select = ($44 | 0) == 0 ? $$0523 : $$0523 + 9 | 0;\n   $47 = $$0522 | 2;\n   $49 = 12 - $3 | 0;\n   do if ($3 >>> 0 > 11 | ($49 | 0) == 0) $$1472 = $38; else {\n    $$0511586 = 8.0;\n    $$1510587 = $49;\n    do {\n     $$1510587 = $$1510587 + -1 | 0;\n     $$0511586 = $$0511586 * 16.0;\n    } while (($$1510587 | 0) != 0);\n    if ((HEAP8[$spec$select >> 0] | 0) == 45) {\n     $$1472 = -($$0511586 + (-$38 - $$0511586));\n     break;\n    } else {\n     $$1472 = $38 + $$0511586 - $$0511586;\n     break;\n    }\n   } while (0);\n   $63 = HEAP32[$7 >> 2] | 0;\n   $66 = ($63 | 0) < 0 ? 0 - $63 | 0 : $63;\n   $69 = _fmt_u($66, (($66 | 0) < 0) << 31 >> 31, $11) | 0;\n   if (($69 | 0) == ($11 | 0)) {\n    $71 = $10 + 11 | 0;\n    HEAP8[$71 >> 0] = 48;\n    $$0513 = $71;\n   } else $$0513 = $69;\n   HEAP8[$$0513 + -1 >> 0] = ($63 >> 31 & 2) + 43;\n   $79 = $$0513 + -2 | 0;\n   HEAP8[$79 >> 0] = $5 + 15;\n   $80 = ($3 | 0) < 1;\n   $82 = ($4 & 8 | 0) == 0;\n   $$0525 = $8;\n   $$2473 = $$1472;\n   while (1) {\n    $83 = ~~$$2473;\n    $89 = $$0525 + 1 | 0;\n    HEAP8[$$0525 >> 0] = $44 | HEAPU8[12554 + $83 >> 0];\n    $$2473 = ($$2473 - +($83 | 0)) * 16.0;\n    if (($89 - $9 | 0) == 1) if ($82 & ($80 & $$2473 == 0.0)) $$1526 = $89; else {\n     HEAP8[$89 >> 0] = 46;\n     $$1526 = $$0525 + 2 | 0;\n    } else $$1526 = $89;\n    if (!($$2473 != 0.0)) break; else $$0525 = $$1526;\n   }\n   $$pre716 = $$1526;\n   if (!$3) label = 25; else if ((-2 - $9 + $$pre716 | 0) < ($3 | 0)) {\n    $103 = $11;\n    $104 = $79;\n    $$0527 = $3 + 2 + $103 - $104 | 0;\n    $$pre$phi713Z2D = $103;\n    $$pre$phi714Z2D = $104;\n   } else label = 25;\n   if ((label | 0) == 25) {\n    $108 = $11;\n    $109 = $79;\n    $$0527 = $108 - $9 - $109 + $$pre716 | 0;\n    $$pre$phi713Z2D = $108;\n    $$pre$phi714Z2D = $109;\n   }\n   $113 = $$0527 + $47 | 0;\n   _pad_676($0, 32, $2, $113, $4);\n   _out_670($0, $spec$select, $47);\n   _pad_676($0, 48, $2, $113, $4 ^ 65536);\n   $115 = $$pre716 - $9 | 0;\n   _out_670($0, $8, $115);\n   $116 = $$pre$phi713Z2D - $$pre$phi714Z2D | 0;\n   _pad_676($0, 48, $$0527 - ($115 + $116) | 0, 0, 0);\n   _out_670($0, $79, $116);\n   _pad_676($0, 32, $2, $113, $4 ^ 8192);\n   $$sink755 = $113;\n   break;\n  }\n  $spec$select539 = ($3 | 0) < 0 ? 6 : $3;\n  if ($39) {\n   $123 = (HEAP32[$7 >> 2] | 0) + -28 | 0;\n   HEAP32[$7 >> 2] = $123;\n   $$3 = $38 * 268435456.0;\n   $$pr = $123;\n  } else {\n   $$3 = $38;\n   $$pr = HEAP32[$7 >> 2] | 0;\n  }\n  $$0498 = ($$pr | 0) < 0 ? $6 : $6 + 288 | 0;\n  $$1499 = $$0498;\n  $$4 = $$3;\n  do {\n   $126 = ~~$$4 >>> 0;\n   HEAP32[$$1499 >> 2] = $126;\n   $$1499 = $$1499 + 4 | 0;\n   $$4 = ($$4 - +($126 >>> 0)) * 1.0e9;\n  } while ($$4 != 0.0);\n  if (($$pr | 0) > 0) {\n   $$1482683 = $$0498;\n   $$2500682 = $$1499;\n   $134 = $$pr;\n   while (1) {\n    $135 = ($134 | 0) < 29 ? $134 : 29;\n    $$0488669 = $$2500682 + -4 | 0;\n    if ($$0488669 >>> 0 < $$1482683 >>> 0) $$2483 = $$1482683; else {\n     $$0488671 = $$0488669;\n     $$0497670 = 0;\n     do {\n      $138 = _bitshift64Shl(HEAP32[$$0488671 >> 2] | 0, 0, $135 | 0) | 0;\n      $140 = _i64Add($138 | 0, tempRet0 | 0, $$0497670 | 0, 0) | 0;\n      $141 = tempRet0;\n      $$0497670 = ___udivdi3($140 | 0, $141 | 0, 1e9, 0) | 0;\n      $144 = ___muldi3($$0497670 | 0, tempRet0 | 0, 1e9, 0) | 0;\n      $146 = _i64Subtract($140 | 0, $141 | 0, $144 | 0, tempRet0 | 0) | 0;\n      HEAP32[$$0488671 >> 2] = $146;\n      $$0488671 = $$0488671 + -4 | 0;\n     } while ($$0488671 >>> 0 >= $$1482683 >>> 0);\n     if (!$$0497670) $$2483 = $$1482683; else {\n      $150 = $$1482683 + -4 | 0;\n      HEAP32[$150 >> 2] = $$0497670;\n      $$2483 = $150;\n     }\n    }\n    L57 : do if ($$2500682 >>> 0 > $$2483 >>> 0) {\n     $$3501676 = $$2500682;\n     while (1) {\n      $153 = $$3501676 + -4 | 0;\n      if (HEAP32[$153 >> 2] | 0) {\n       $$3501$lcssa = $$3501676;\n       break L57;\n      }\n      if ($153 >>> 0 > $$2483 >>> 0) $$3501676 = $153; else {\n       $$3501$lcssa = $153;\n       break;\n      }\n     }\n    } else $$3501$lcssa = $$2500682; while (0);\n    $157 = (HEAP32[$7 >> 2] | 0) - $135 | 0;\n    HEAP32[$7 >> 2] = $157;\n    if (($157 | 0) > 0) {\n     $$1482683 = $$2483;\n     $$2500682 = $$3501$lcssa;\n     $134 = $157;\n    } else {\n     $$1482$lcssa = $$2483;\n     $$2500$lcssa = $$3501$lcssa;\n     $$pr564 = $157;\n     break;\n    }\n   }\n  } else {\n   $$1482$lcssa = $$0498;\n   $$2500$lcssa = $$1499;\n   $$pr564 = $$pr;\n  }\n  if (($$pr564 | 0) < 0) {\n   $162 = (($spec$select539 + 25 | 0) / 9 | 0) + 1 | 0;\n   $163 = ($42 | 0) == 102;\n   $$3484663 = $$1482$lcssa;\n   $$4502662 = $$2500$lcssa;\n   $165 = $$pr564;\n   while (1) {\n    $164 = 0 - $165 | 0;\n    $167 = ($164 | 0) < 9 ? $164 : 9;\n    if ($$3484663 >>> 0 < $$4502662 >>> 0) {\n     $173 = (1 << $167) + -1 | 0;\n     $174 = 1e9 >>> $167;\n     $$0487657 = 0;\n     $$1489656 = $$3484663;\n     do {\n      $175 = HEAP32[$$1489656 >> 2] | 0;\n      HEAP32[$$1489656 >> 2] = ($175 >>> $167) + $$0487657;\n      $$0487657 = Math_imul($175 & $173, $174) | 0;\n      $$1489656 = $$1489656 + 4 | 0;\n     } while ($$1489656 >>> 0 < $$4502662 >>> 0);\n     $spec$select540 = (HEAP32[$$3484663 >> 2] | 0) == 0 ? $$3484663 + 4 | 0 : $$3484663;\n     if (!$$0487657) {\n      $$5503 = $$4502662;\n      $spec$select540721 = $spec$select540;\n     } else {\n      HEAP32[$$4502662 >> 2] = $$0487657;\n      $$5503 = $$4502662 + 4 | 0;\n      $spec$select540721 = $spec$select540;\n     }\n    } else {\n     $$5503 = $$4502662;\n     $spec$select540721 = (HEAP32[$$3484663 >> 2] | 0) == 0 ? $$3484663 + 4 | 0 : $$3484663;\n    }\n    $187 = $163 ? $$0498 : $spec$select540721;\n    $spec$select541 = ($$5503 - $187 >> 2 | 0) > ($162 | 0) ? $187 + ($162 << 2) | 0 : $$5503;\n    $165 = (HEAP32[$7 >> 2] | 0) + $167 | 0;\n    HEAP32[$7 >> 2] = $165;\n    if (($165 | 0) >= 0) {\n     $$3484$lcssa = $spec$select540721;\n     $$4502$lcssa = $spec$select541;\n     break;\n    } else {\n     $$3484663 = $spec$select540721;\n     $$4502662 = $spec$select541;\n    }\n   }\n  } else {\n   $$3484$lcssa = $$1482$lcssa;\n   $$4502$lcssa = $$2500$lcssa;\n  }\n  $198 = $$0498;\n  if ($$3484$lcssa >>> 0 < $$4502$lcssa >>> 0) {\n   $202 = ($198 - $$3484$lcssa >> 2) * 9 | 0;\n   $203 = HEAP32[$$3484$lcssa >> 2] | 0;\n   if ($203 >>> 0 < 10) $$1517 = $202; else {\n    $$0516652 = $202;\n    $$0532651 = 10;\n    while (1) {\n     $$0532651 = $$0532651 * 10 | 0;\n     $206 = $$0516652 + 1 | 0;\n     if ($203 >>> 0 < $$0532651 >>> 0) {\n      $$1517 = $206;\n      break;\n     } else $$0516652 = $206;\n    }\n   }\n  } else $$1517 = 0;\n  $211 = ($42 | 0) == 103;\n  $212 = ($spec$select539 | 0) != 0;\n  $214 = $spec$select539 - (($42 | 0) == 102 ? 0 : $$1517) + (($212 & $211) << 31 >> 31) | 0;\n  if (($214 | 0) < ((($$4502$lcssa - $198 >> 2) * 9 | 0) + -9 | 0)) {\n   $222 = $214 + 9216 | 0;\n   $223 = ($222 | 0) / 9 | 0;\n   $225 = $$0498 + 4 + ($223 + -1024 << 2) | 0;\n   $227 = $222 - ($223 * 9 | 0) | 0;\n   if (($227 | 0) < 8) {\n    $$0529$in646 = $227;\n    $$1533645 = 10;\n    while (1) {\n     $229 = $$1533645 * 10 | 0;\n     if (($$0529$in646 | 0) < 7) {\n      $$0529$in646 = $$0529$in646 + 1 | 0;\n      $$1533645 = $229;\n     } else {\n      $$1533$lcssa = $229;\n      break;\n     }\n    }\n   } else $$1533$lcssa = 10;\n   $231 = HEAP32[$225 >> 2] | 0;\n   $232 = ($231 >>> 0) / ($$1533$lcssa >>> 0) | 0;\n   $234 = $231 - (Math_imul($232, $$1533$lcssa) | 0) | 0;\n   $237 = ($225 + 4 | 0) == ($$4502$lcssa | 0);\n   if ($237 & ($234 | 0) == 0) {\n    $$4492 = $225;\n    $$4520 = $$1517;\n    $$8 = $$3484$lcssa;\n   } else {\n    $spec$select544 = ($232 & 1 | 0) == 0 ? 9007199254740992.0 : 9007199254740994.0;\n    $240 = $$1533$lcssa >>> 1;\n    $spec$select567 = $234 >>> 0 < $240 >>> 0 ? .5 : $237 & ($234 | 0) == ($240 | 0) ? 1.0 : 1.5;\n    if (!$$0522) {\n     $$1467 = $spec$select567;\n     $$1469 = $spec$select544;\n    } else {\n     $245 = (HEAP8[$$0523 >> 0] | 0) == 45;\n     $$1467 = $245 ? -$spec$select567 : $spec$select567;\n     $$1469 = $245 ? -$spec$select544 : $spec$select544;\n    }\n    $248 = $231 - $234 | 0;\n    HEAP32[$225 >> 2] = $248;\n    if ($$1469 + $$1467 != $$1469) {\n     $251 = $248 + $$1533$lcssa | 0;\n     HEAP32[$225 >> 2] = $251;\n     if ($251 >>> 0 > 999999999) {\n      $$2490638 = $225;\n      $$5486639 = $$3484$lcssa;\n      while (1) {\n       $253 = $$2490638 + -4 | 0;\n       HEAP32[$$2490638 >> 2] = 0;\n       if ($253 >>> 0 < $$5486639 >>> 0) {\n        $255 = $$5486639 + -4 | 0;\n        HEAP32[$255 >> 2] = 0;\n        $$6 = $255;\n       } else $$6 = $$5486639;\n       $257 = (HEAP32[$253 >> 2] | 0) + 1 | 0;\n       HEAP32[$253 >> 2] = $257;\n       if ($257 >>> 0 > 999999999) {\n        $$2490638 = $253;\n        $$5486639 = $$6;\n       } else {\n        $$2490$lcssa = $253;\n        $$5486$lcssa = $$6;\n        break;\n       }\n      }\n     } else {\n      $$2490$lcssa = $225;\n      $$5486$lcssa = $$3484$lcssa;\n     }\n     $262 = ($198 - $$5486$lcssa >> 2) * 9 | 0;\n     $263 = HEAP32[$$5486$lcssa >> 2] | 0;\n     if ($263 >>> 0 < 10) {\n      $$4492 = $$2490$lcssa;\n      $$4520 = $262;\n      $$8 = $$5486$lcssa;\n     } else {\n      $$2518634 = $262;\n      $$2534633 = 10;\n      while (1) {\n       $$2534633 = $$2534633 * 10 | 0;\n       $266 = $$2518634 + 1 | 0;\n       if ($263 >>> 0 < $$2534633 >>> 0) {\n        $$4492 = $$2490$lcssa;\n        $$4520 = $266;\n        $$8 = $$5486$lcssa;\n        break;\n       } else $$2518634 = $266;\n      }\n     }\n    } else {\n     $$4492 = $225;\n     $$4520 = $$1517;\n     $$8 = $$3484$lcssa;\n    }\n   }\n   $268 = $$4492 + 4 | 0;\n   $$5521 = $$4520;\n   $$8506 = $$4502$lcssa >>> 0 > $268 >>> 0 ? $268 : $$4502$lcssa;\n   $$9 = $$8;\n  } else {\n   $$5521 = $$1517;\n   $$8506 = $$4502$lcssa;\n   $$9 = $$3484$lcssa;\n  }\n  $270 = 0 - $$5521 | 0;\n  L109 : do if ($$8506 >>> 0 > $$9 >>> 0) {\n   $$9507625 = $$8506;\n   while (1) {\n    $273 = $$9507625 + -4 | 0;\n    if (HEAP32[$273 >> 2] | 0) {\n     $$9507$lcssa = $$9507625;\n     $$lcssa583 = 1;\n     break L109;\n    }\n    if ($273 >>> 0 > $$9 >>> 0) $$9507625 = $273; else {\n     $$9507$lcssa = $273;\n     $$lcssa583 = 0;\n     break;\n    }\n   }\n  } else {\n   $$9507$lcssa = $$8506;\n   $$lcssa583 = 0;\n  } while (0);\n  do if ($211) {\n   $spec$select548 = $spec$select539 + (($212 ^ 1) & 1) | 0;\n   if (($spec$select548 | 0) > ($$5521 | 0) & ($$5521 | 0) > -5) {\n    $$0479 = $5 + -1 | 0;\n    $$2476 = $spec$select548 + -1 - $$5521 | 0;\n   } else {\n    $$0479 = $5 + -2 | 0;\n    $$2476 = $spec$select548 + -1 | 0;\n   }\n   if (!($4 & 8)) {\n    if ($$lcssa583) {\n     $286 = HEAP32[$$9507$lcssa + -4 >> 2] | 0;\n     if (!$286) $$2531 = 9; else if (!(($286 >>> 0) % 10 | 0)) {\n      $$1530621 = 0;\n      $$3535620 = 10;\n      while (1) {\n       $$3535620 = $$3535620 * 10 | 0;\n       $291 = $$1530621 + 1 | 0;\n       if (($286 >>> 0) % ($$3535620 >>> 0) | 0 | 0) {\n        $$2531 = $291;\n        break;\n       } else $$1530621 = $291;\n      }\n     } else $$2531 = 0;\n    } else $$2531 = 9;\n    $300 = (($$9507$lcssa - $198 >> 2) * 9 | 0) + -9 | 0;\n    if (($$0479 | 32 | 0) == 102) {\n     $301 = $300 - $$2531 | 0;\n     $spec$select549 = ($301 | 0) > 0 ? $301 : 0;\n     $$1480 = $$0479;\n     $$3477 = ($$2476 | 0) < ($spec$select549 | 0) ? $$2476 : $spec$select549;\n     break;\n    } else {\n     $305 = $300 + $$5521 - $$2531 | 0;\n     $spec$select551 = ($305 | 0) > 0 ? $305 : 0;\n     $$1480 = $$0479;\n     $$3477 = ($$2476 | 0) < ($spec$select551 | 0) ? $$2476 : $spec$select551;\n     break;\n    }\n   } else {\n    $$1480 = $$0479;\n    $$3477 = $$2476;\n   }\n  } else {\n   $$1480 = $5;\n   $$3477 = $spec$select539;\n  } while (0);\n  $308 = ($$3477 | 0) != 0;\n  $310 = $308 ? 1 : $4 >>> 3 & 1;\n  $312 = ($$1480 | 32 | 0) == 102;\n  if ($312) {\n   $$2515 = 0;\n   $$pn = ($$5521 | 0) > 0 ? $$5521 : 0;\n  } else {\n   $316 = ($$5521 | 0) < 0 ? $270 : $$5521;\n   $319 = _fmt_u($316, (($316 | 0) < 0) << 31 >> 31, $11) | 0;\n   $320 = $11;\n   if (($320 - $319 | 0) < 2) {\n    $$1514614 = $319;\n    while (1) {\n     $324 = $$1514614 + -1 | 0;\n     HEAP8[$324 >> 0] = 48;\n     if (($320 - $324 | 0) < 2) $$1514614 = $324; else {\n      $$1514$lcssa = $324;\n      break;\n     }\n    }\n   } else $$1514$lcssa = $319;\n   HEAP8[$$1514$lcssa + -1 >> 0] = ($$5521 >> 31 & 2) + 43;\n   $334 = $$1514$lcssa + -2 | 0;\n   HEAP8[$334 >> 0] = $$1480;\n   $$2515 = $334;\n   $$pn = $320 - $334 | 0;\n  }\n  $339 = $$0522 + 1 + $$3477 + $310 + $$pn | 0;\n  _pad_676($0, 32, $2, $339, $4);\n  _out_670($0, $$0523, $$0522);\n  _pad_676($0, 48, $2, $339, $4 ^ 65536);\n  if ($312) {\n   $spec$select554 = $$9 >>> 0 > $$0498 >>> 0 ? $$0498 : $$9;\n   $342 = $8 + 9 | 0;\n   $343 = $342;\n   $344 = $8 + 8 | 0;\n   $$5493603 = $spec$select554;\n   do {\n    $346 = _fmt_u(HEAP32[$$5493603 >> 2] | 0, 0, $342) | 0;\n    if (($$5493603 | 0) == ($spec$select554 | 0)) if (($346 | 0) == ($342 | 0)) {\n     HEAP8[$344 >> 0] = 48;\n     $$1465 = $344;\n    } else $$1465 = $346; else if ($346 >>> 0 > $8 >>> 0) {\n     _memset($8 | 0, 48, $346 - $9 | 0) | 0;\n     $$0464599 = $346;\n     while (1) {\n      $351 = $$0464599 + -1 | 0;\n      if ($351 >>> 0 > $8 >>> 0) $$0464599 = $351; else {\n       $$1465 = $351;\n       break;\n      }\n     }\n    } else $$1465 = $346;\n    _out_670($0, $$1465, $343 - $$1465 | 0);\n    $$5493603 = $$5493603 + 4 | 0;\n   } while ($$5493603 >>> 0 <= $$0498 >>> 0);\n   if (!(($4 & 8 | 0) == 0 & ($308 ^ 1))) _out_670($0, 15408, 1);\n   if ($$5493603 >>> 0 < $$9507$lcssa >>> 0 & ($$3477 | 0) > 0) {\n    $$4478594 = $$3477;\n    $$6494593 = $$5493603;\n    while (1) {\n     $364 = _fmt_u(HEAP32[$$6494593 >> 2] | 0, 0, $342) | 0;\n     if ($364 >>> 0 > $8 >>> 0) {\n      _memset($8 | 0, 48, $364 - $9 | 0) | 0;\n      $$0463588 = $364;\n      while (1) {\n       $368 = $$0463588 + -1 | 0;\n       if ($368 >>> 0 > $8 >>> 0) $$0463588 = $368; else {\n        $$0463$lcssa = $368;\n        break;\n       }\n      }\n     } else $$0463$lcssa = $364;\n     _out_670($0, $$0463$lcssa, ($$4478594 | 0) < 9 ? $$4478594 : 9);\n     $$6494593 = $$6494593 + 4 | 0;\n     $373 = $$4478594 + -9 | 0;\n     if (!($$6494593 >>> 0 < $$9507$lcssa >>> 0 & ($$4478594 | 0) > 9)) {\n      $$4478$lcssa = $373;\n      break;\n     } else $$4478594 = $373;\n    }\n   } else $$4478$lcssa = $$3477;\n   _pad_676($0, 48, $$4478$lcssa + 9 | 0, 9, 0);\n  } else {\n   $spec$select557 = $$lcssa583 ? $$9507$lcssa : $$9 + 4 | 0;\n   if ($$9 >>> 0 < $spec$select557 >>> 0 & ($$3477 | 0) > -1) {\n    $382 = $8 + 9 | 0;\n    $384 = ($4 & 8 | 0) == 0;\n    $385 = $382;\n    $386 = 0 - $9 | 0;\n    $387 = $8 + 8 | 0;\n    $$5609 = $$3477;\n    $$7495608 = $$9;\n    while (1) {\n     $389 = _fmt_u(HEAP32[$$7495608 >> 2] | 0, 0, $382) | 0;\n     if (($389 | 0) == ($382 | 0)) {\n      HEAP8[$387 >> 0] = 48;\n      $$0 = $387;\n     } else $$0 = $389;\n     do if (($$7495608 | 0) == ($$9 | 0)) {\n      $395 = $$0 + 1 | 0;\n      _out_670($0, $$0, 1);\n      if ($384 & ($$5609 | 0) < 1) {\n       $$2 = $395;\n       break;\n      }\n      _out_670($0, 15408, 1);\n      $$2 = $395;\n     } else {\n      if ($$0 >>> 0 <= $8 >>> 0) {\n       $$2 = $$0;\n       break;\n      }\n      _memset($8 | 0, 48, $$0 + $386 | 0) | 0;\n      $$1604 = $$0;\n      while (1) {\n       $393 = $$1604 + -1 | 0;\n       if ($393 >>> 0 > $8 >>> 0) $$1604 = $393; else {\n        $$2 = $393;\n        break;\n       }\n      }\n     } while (0);\n     $398 = $385 - $$2 | 0;\n     _out_670($0, $$2, ($$5609 | 0) > ($398 | 0) ? $398 : $$5609);\n     $401 = $$5609 - $398 | 0;\n     $$7495608 = $$7495608 + 4 | 0;\n     if (!($$7495608 >>> 0 < $spec$select557 >>> 0 & ($401 | 0) > -1)) {\n      $$5$lcssa = $401;\n      break;\n     } else $$5609 = $401;\n    }\n   } else $$5$lcssa = $$3477;\n   _pad_676($0, 48, $$5$lcssa + 18 | 0, 18, 0);\n   _out_670($0, $$2515, $11 - $$2515 | 0);\n  }\n  _pad_676($0, 32, $2, $339, $4 ^ 8192);\n  $$sink755 = $339;\n } while (0);\n STACKTOP = sp;\n return (($$sink755 | 0) < ($2 | 0) ? $2 : $$sink755) | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_117parse_nested_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$add$i184 = 0, $$0$i$i$add$i188 = 0, $$0$i$i$add$i199 = 0, $$0$i$i$add$i210 = 0, $$0$i$i$add$i220 = 0, $$0$i$i$add$i231 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i183 = 0, $$0$i$i$idx$i187 = 0, $$0$i$i$idx$i198 = 0, $$0$i$i$idx$i209 = 0, $$0$i$i$idx$i219 = 0, $$0$i$i$idx$i230 = 0, $$0151$off0$ph = 0, $$0157 = 0, $$1158 = 0, $$2159 = 0, $$2159$be = 0, $$2159$ph = 0, $$2159$ph$be = 0, $$4166 = 0, $$sink = 0, $$sroa$0$0$$sroa_idx$i215 = 0, $101 = 0, $102 = 0, $105 = 0, $106 = 0, $11 = 0, $114 = 0, $119 = 0, $122 = 0, $124 = 0, $13 = 0, $130 = 0, $133 = 0, $134 = 0, $141 = 0, $142 = 0, $145 = 0, $146 = 0, $154 = 0, $157 = 0, $16 = 0, $162 = 0, $165 = 0, $167 = 0, $17 = 0, $173 = 0, $176 = 0, $177 = 0, $184 = 0, $185 = 0, $188 = 0, $189 = 0, $197 = 0, $202 = 0, $206 = 0, $207 = 0, $214 = 0, $215 = 0, $218 = 0, $219 = 0, $227 = 0, $229 = 0, $234 = 0, $237 = 0, $239 = 0, $245 = 0, $248 = 0, $249 = 0, $256 = 0, $257 = 0, $260 = 0, $261 = 0, $269 = 0, $274 = 0, $3 = 0, $36 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $70 = 0, $74 = 0, $79 = 0, $82 = 0, $84 = 0, $90 = 0, $93 = 0, $94 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $3 = sp + 36 | 0;\n $4 = sp + 24 | 0;\n $5 = sp + 8 | 0;\n $6 = sp;\n L1 : do if (($0 | 0) == ($1 | 0)) $$4166 = $0; else if ((HEAP8[$0 >> 0] | 0) == 78) {\n  $11 = __ZN10__cxxabiv112_GLOBAL__N_119parse_cv_qualifiersEPKcS2_Rj($0 + 1 | 0, $1, $3) | 0;\n  L4 : do if (($11 | 0) != ($1 | 0)) {\n   $13 = $2 + 52 | 0;\n   HEAP32[$13 >> 2] = 0;\n   switch (HEAP8[$11 >> 0] | 0) {\n   case 82:\n    {\n     $$sink = 1;\n     label = 6;\n     break;\n    }\n   case 79:\n    {\n     $$sink = 2;\n     label = 6;\n     break;\n    }\n   default:\n    $$0157 = $11;\n   }\n   if ((label | 0) == 6) {\n    HEAP32[$13 >> 2] = $$sink;\n    $$0157 = $11 + 1 | 0;\n   }\n   $16 = $2 + 4 | 0;\n   $17 = HEAP32[$16 >> 2] | 0;\n   if ($17 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    HEAP32[$17 >> 2] = 0;\n    HEAP32[$17 + 4 >> 2] = 0;\n    HEAP32[$17 + 8 >> 2] = 0;\n    HEAP32[$17 + 12 >> 2] = 0;\n    HEAP32[$17 + 16 >> 2] = 0;\n    HEAP32[$17 + 20 >> 2] = 0;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2Ev($17);\n    HEAP32[$16 >> 2] = (HEAP32[$16 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE24__emplace_back_slow_pathIJEEEvDpOT_($2);\n   if (($1 - $$0157 | 0) > 1) if ((HEAP8[$$0157 >> 0] | 0) == 83) if ((HEAP8[$$0157 + 1 >> 0] | 0) == 116) {\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKc((HEAP32[$16 >> 2] | 0) + -24 | 0, 16495);\n    $$1158 = $$0157 + 2 | 0;\n   } else $$1158 = $$0157; else $$1158 = $$0157; else $$1158 = $$0157;\n   if (($$1158 | 0) == ($1 | 0)) {\n    $36 = HEAP32[$16 >> 2] | 0;\n    $$0$i$i$idx$i = 0;\n    while (1) {\n     if (($$0$i$i$idx$i | 0) == -1) break;\n     $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($36 + ($$0$i$i$add$i * 24 | 0) | 0);\n     $$0$i$i$idx$i = $$0$i$i$add$i;\n    }\n    HEAP32[$16 >> 2] = $36 + -24;\n    break;\n   }\n   $39 = $4 + 11 | 0;\n   $40 = $4 + 4 | 0;\n   $$sroa$0$0$$sroa_idx$i215 = $2 + 12 | 0;\n   $41 = $2 + 20 | 0;\n   $42 = $2 + 24 | 0;\n   $43 = $5 + 11 | 0;\n   $44 = $5 + 4 | 0;\n   $45 = $5 + 11 | 0;\n   $46 = $5 + 4 | 0;\n   $47 = $5 + 12 | 0;\n   $48 = $5 + 4 | 0;\n   $49 = $5 + 8 | 0;\n   $50 = $2 + 16 | 0;\n   $51 = $5 + 12 | 0;\n   $52 = $5 + 4 | 0;\n   $53 = $5 + 8 | 0;\n   $54 = $5 + 11 | 0;\n   $55 = $5 + 4 | 0;\n   $56 = $5 + 12 | 0;\n   $57 = $5 + 4 | 0;\n   $58 = $5 + 8 | 0;\n   $59 = $5 + 11 | 0;\n   $60 = $5 + 4 | 0;\n   $61 = $5 + 12 | 0;\n   $62 = $5 + 4 | 0;\n   $63 = $5 + 8 | 0;\n   $64 = $5 + 12 | 0;\n   $65 = $5 + 4 | 0;\n   $66 = $5 + 8 | 0;\n   $$0151$off0$ph = 0;\n   $$2159$ph = $$1158;\n   L27 : while (1) {\n    $$2159 = $$2159$ph;\n    L29 : while (1) {\n     $67 = HEAP8[$$2159 >> 0] | 0;\n     if ($67 << 24 >> 24 == 69) break L27;\n     switch ($67 << 24 >> 24 | 0) {\n     case 83:\n      {\n       label = 23;\n       break L29;\n       break;\n      }\n     case 84:\n      {\n       label = 39;\n       break L29;\n       break;\n      }\n     case 68:\n      {\n       label = 53;\n       break L29;\n       break;\n      }\n     case 73:\n      {\n       $197 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($$2159, $1, $2) | 0;\n       if (($197 | 0) == ($$2159 | 0) | ($197 | 0) == ($1 | 0)) break L4;\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, (HEAP32[$16 >> 2] | 0) + -24 | 0);\n       $202 = HEAP32[$16 >> 2] | 0;\n       $$0$i$i$idx$i209 = 0;\n       while (1) {\n        if (($$0$i$i$idx$i209 | 0) == -1) break;\n        $$0$i$i$add$i210 = $$0$i$i$idx$i209 + -1 | 0;\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($202 + ($$0$i$i$add$i210 * 24 | 0) | 0);\n        $$0$i$i$idx$i209 = $$0$i$i$add$i210;\n       }\n       HEAP32[$16 >> 2] = $202 + -24;\n       $206 = HEAP8[$39 >> 0] | 0;\n       $207 = $206 << 24 >> 24 < 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($202 + -48 | 0, $207 ? HEAP32[$4 >> 2] | 0 : $4, $207 ? HEAP32[$40 >> 2] | 0 : $206 & 255) | 0;\n       $214 = (HEAP32[$16 >> 2] | 0) + -24 | 0;\n       HEAP32[$6 >> 2] = HEAP32[$$sroa$0$0$$sroa_idx$i215 >> 2];\n       __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($5, $214, $6);\n       $215 = HEAP32[$41 >> 2] | 0;\n       if ($215 >>> 0 < (HEAP32[$42 >> 2] | 0) >>> 0) {\n        HEAP32[$215 >> 2] = 0;\n        $218 = $215 + 4 | 0;\n        HEAP32[$218 >> 2] = 0;\n        $219 = $215 + 8 | 0;\n        HEAP32[$219 >> 2] = 0;\n        HEAP32[$215 + 12 >> 2] = HEAP32[$47 >> 2];\n        HEAP32[$215 >> 2] = HEAP32[$5 >> 2];\n        HEAP32[$218 >> 2] = HEAP32[$48 >> 2];\n        HEAP32[$219 >> 2] = HEAP32[$49 >> 2];\n        HEAP32[$49 >> 2] = 0;\n        HEAP32[$48 >> 2] = 0;\n        HEAP32[$5 >> 2] = 0;\n        HEAP32[$41 >> 2] = (HEAP32[$41 >> 2] | 0) + 16;\n       } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($50, $5);\n       __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($5);\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n       $$2159$be = $197;\n       break;\n      }\n     case 76:\n      {\n       $227 = $$2159 + 1 | 0;\n       if (($227 | 0) == ($1 | 0)) break L4; else $$2159$be = $227;\n       break;\n      }\n     default:\n      {\n       label = 79;\n       break L29;\n      }\n     }\n     $$2159 = $$2159$be;\n    }\n    L45 : do if ((label | 0) == 23) {\n     label = 0;\n     $70 = $$2159 + 1 | 0;\n     if (($70 | 0) != ($1 | 0)) if ((HEAP8[$70 >> 0] | 0) == 116) {\n      label = 79;\n      break;\n     }\n     $74 = __ZN10__cxxabiv112_GLOBAL__N_118parse_substitutionINS0_2DbEEEPKcS4_S4_RT_($$2159, $1, $2) | 0;\n     if (($74 | 0) == ($$2159 | 0) | ($74 | 0) == ($1 | 0)) break L4;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, (HEAP32[$16 >> 2] | 0) + -24 | 0);\n     $79 = HEAP32[$16 >> 2] | 0;\n     $$0$i$i$idx$i183 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i183 | 0) == -1) break;\n      $$0$i$i$add$i184 = $$0$i$i$idx$i183 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($79 + ($$0$i$i$add$i184 * 24 | 0) | 0);\n      $$0$i$i$idx$i183 = $$0$i$i$add$i184;\n     }\n     HEAP32[$16 >> 2] = $79 + -24;\n     $82 = $79 + -48 | 0;\n     $84 = HEAP8[$82 + 11 >> 0] | 0;\n     if ($84 << 24 >> 24 < 0) $90 = HEAP32[$79 + -44 >> 2] | 0; else $90 = $84 & 255;\n     if (!$90) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEaSERKS7_($82, $4); else {\n      __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($5, 15191, $4);\n      $93 = HEAP8[$54 >> 0] | 0;\n      $94 = $93 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$16 >> 2] | 0) + -24 | 0, $94 ? HEAP32[$5 >> 2] | 0 : $5, $94 ? HEAP32[$55 >> 2] | 0 : $93 & 255) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n      $101 = (HEAP32[$16 >> 2] | 0) + -24 | 0;\n      HEAP32[$6 >> 2] = HEAP32[$$sroa$0$0$$sroa_idx$i215 >> 2];\n      __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($5, $101, $6);\n      $102 = HEAP32[$41 >> 2] | 0;\n      if ($102 >>> 0 < (HEAP32[$42 >> 2] | 0) >>> 0) {\n       HEAP32[$102 >> 2] = 0;\n       $105 = $102 + 4 | 0;\n       HEAP32[$105 >> 2] = 0;\n       $106 = $102 + 8 | 0;\n       HEAP32[$106 >> 2] = 0;\n       HEAP32[$102 + 12 >> 2] = HEAP32[$64 >> 2];\n       HEAP32[$102 >> 2] = HEAP32[$5 >> 2];\n       HEAP32[$105 >> 2] = HEAP32[$65 >> 2];\n       HEAP32[$106 >> 2] = HEAP32[$66 >> 2];\n       HEAP32[$66 >> 2] = 0;\n       HEAP32[$65 >> 2] = 0;\n       HEAP32[$5 >> 2] = 0;\n       HEAP32[$41 >> 2] = (HEAP32[$41 >> 2] | 0) + 16;\n      } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($50, $5);\n      __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($5);\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     $$2159$ph$be = $74;\n    } else if ((label | 0) == 39) {\n     label = 0;\n     $114 = __ZN10__cxxabiv112_GLOBAL__N_120parse_template_paramINS0_2DbEEEPKcS4_S4_RT_($$2159, $1, $2) | 0;\n     if (($114 | 0) == ($$2159 | 0) | ($114 | 0) == ($1 | 0)) break L4;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, (HEAP32[$16 >> 2] | 0) + -24 | 0);\n     $119 = HEAP32[$16 >> 2] | 0;\n     $$0$i$i$idx$i187 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i187 | 0) == -1) break;\n      $$0$i$i$add$i188 = $$0$i$i$idx$i187 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($119 + ($$0$i$i$add$i188 * 24 | 0) | 0);\n      $$0$i$i$idx$i187 = $$0$i$i$add$i188;\n     }\n     HEAP32[$16 >> 2] = $119 + -24;\n     $122 = $119 + -48 | 0;\n     $124 = HEAP8[$122 + 11 >> 0] | 0;\n     if ($124 << 24 >> 24 < 0) $130 = HEAP32[$119 + -44 >> 2] | 0; else $130 = $124 & 255;\n     if (!$130) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEaSERKS7_($122, $4); else {\n      __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($5, 15191, $4);\n      $133 = HEAP8[$45 >> 0] | 0;\n      $134 = $133 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$16 >> 2] | 0) + -24 | 0, $134 ? HEAP32[$5 >> 2] | 0 : $5, $134 ? HEAP32[$46 >> 2] | 0 : $133 & 255) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     }\n     $141 = (HEAP32[$16 >> 2] | 0) + -24 | 0;\n     HEAP32[$6 >> 2] = HEAP32[$$sroa$0$0$$sroa_idx$i215 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($5, $141, $6);\n     $142 = HEAP32[$41 >> 2] | 0;\n     if ($142 >>> 0 < (HEAP32[$42 >> 2] | 0) >>> 0) {\n      HEAP32[$142 >> 2] = 0;\n      $145 = $142 + 4 | 0;\n      HEAP32[$145 >> 2] = 0;\n      $146 = $142 + 8 | 0;\n      HEAP32[$146 >> 2] = 0;\n      HEAP32[$142 + 12 >> 2] = HEAP32[$56 >> 2];\n      HEAP32[$142 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$145 >> 2] = HEAP32[$57 >> 2];\n      HEAP32[$146 >> 2] = HEAP32[$58 >> 2];\n      HEAP32[$58 >> 2] = 0;\n      HEAP32[$57 >> 2] = 0;\n      HEAP32[$5 >> 2] = 0;\n      HEAP32[$41 >> 2] = (HEAP32[$41 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($50, $5);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($5);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     $$2159$ph$be = $114;\n    } else if ((label | 0) == 53) {\n     label = 0;\n     $154 = $$2159 + 1 | 0;\n     if (($154 | 0) != ($1 | 0)) switch (HEAP8[$154 >> 0] | 0) {\n     case 84:\n     case 116:\n      break;\n     default:\n      {\n       label = 79;\n       break L45;\n      }\n     }\n     $157 = __ZN10__cxxabiv112_GLOBAL__N_114parse_decltypeINS0_2DbEEEPKcS4_S4_RT_($$2159, $1, $2) | 0;\n     if (($157 | 0) == ($$2159 | 0) | ($157 | 0) == ($1 | 0)) break L4;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, (HEAP32[$16 >> 2] | 0) + -24 | 0);\n     $162 = HEAP32[$16 >> 2] | 0;\n     $$0$i$i$idx$i198 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i198 | 0) == -1) break;\n      $$0$i$i$add$i199 = $$0$i$i$idx$i198 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($162 + ($$0$i$i$add$i199 * 24 | 0) | 0);\n      $$0$i$i$idx$i198 = $$0$i$i$add$i199;\n     }\n     HEAP32[$16 >> 2] = $162 + -24;\n     $165 = $162 + -48 | 0;\n     $167 = HEAP8[$165 + 11 >> 0] | 0;\n     if ($167 << 24 >> 24 < 0) $173 = HEAP32[$162 + -44 >> 2] | 0; else $173 = $167 & 255;\n     if (!$173) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEaSERKS7_($165, $4); else {\n      __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($5, 15191, $4);\n      $176 = HEAP8[$59 >> 0] | 0;\n      $177 = $176 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$16 >> 2] | 0) + -24 | 0, $177 ? HEAP32[$5 >> 2] | 0 : $5, $177 ? HEAP32[$60 >> 2] | 0 : $176 & 255) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     }\n     $184 = (HEAP32[$16 >> 2] | 0) + -24 | 0;\n     HEAP32[$6 >> 2] = HEAP32[$$sroa$0$0$$sroa_idx$i215 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($5, $184, $6);\n     $185 = HEAP32[$41 >> 2] | 0;\n     if ($185 >>> 0 < (HEAP32[$42 >> 2] | 0) >>> 0) {\n      HEAP32[$185 >> 2] = 0;\n      $188 = $185 + 4 | 0;\n      HEAP32[$188 >> 2] = 0;\n      $189 = $185 + 8 | 0;\n      HEAP32[$189 >> 2] = 0;\n      HEAP32[$185 + 12 >> 2] = HEAP32[$61 >> 2];\n      HEAP32[$185 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$188 >> 2] = HEAP32[$62 >> 2];\n      HEAP32[$189 >> 2] = HEAP32[$63 >> 2];\n      HEAP32[$63 >> 2] = 0;\n      HEAP32[$62 >> 2] = 0;\n      HEAP32[$5 >> 2] = 0;\n      HEAP32[$41 >> 2] = (HEAP32[$41 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($50, $5);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($5);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     $$2159$ph$be = $157;\n    } while (0);\n    if ((label | 0) == 79) {\n     label = 0;\n     $229 = __ZN10__cxxabiv112_GLOBAL__N_122parse_unqualified_nameINS0_2DbEEEPKcS4_S4_RT_($$2159, $1, $2) | 0;\n     if (($229 | 0) == ($$2159 | 0) | ($229 | 0) == ($1 | 0)) break L4;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, (HEAP32[$16 >> 2] | 0) + -24 | 0);\n     $234 = HEAP32[$16 >> 2] | 0;\n     $$0$i$i$idx$i219 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i219 | 0) == -1) break;\n      $$0$i$i$add$i220 = $$0$i$i$idx$i219 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($234 + ($$0$i$i$add$i220 * 24 | 0) | 0);\n      $$0$i$i$idx$i219 = $$0$i$i$add$i220;\n     }\n     HEAP32[$16 >> 2] = $234 + -24;\n     $237 = $234 + -48 | 0;\n     $239 = HEAP8[$237 + 11 >> 0] | 0;\n     if ($239 << 24 >> 24 < 0) $245 = HEAP32[$234 + -44 >> 2] | 0; else $245 = $239 & 255;\n     if (!$245) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEaSERKS7_($237, $4); else {\n      __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($5, 15191, $4);\n      $248 = HEAP8[$43 >> 0] | 0;\n      $249 = $248 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$16 >> 2] | 0) + -24 | 0, $249 ? HEAP32[$5 >> 2] | 0 : $5, $249 ? HEAP32[$44 >> 2] | 0 : $248 & 255) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     }\n     $256 = (HEAP32[$16 >> 2] | 0) + -24 | 0;\n     HEAP32[$6 >> 2] = HEAP32[$$sroa$0$0$$sroa_idx$i215 >> 2];\n     __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($5, $256, $6);\n     $257 = HEAP32[$41 >> 2] | 0;\n     if ($257 >>> 0 < (HEAP32[$42 >> 2] | 0) >>> 0) {\n      HEAP32[$257 >> 2] = 0;\n      $260 = $257 + 4 | 0;\n      HEAP32[$260 >> 2] = 0;\n      $261 = $257 + 8 | 0;\n      HEAP32[$261 >> 2] = 0;\n      HEAP32[$257 + 12 >> 2] = HEAP32[$51 >> 2];\n      HEAP32[$257 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$260 >> 2] = HEAP32[$52 >> 2];\n      HEAP32[$261 >> 2] = HEAP32[$53 >> 2];\n      HEAP32[$53 >> 2] = 0;\n      HEAP32[$52 >> 2] = 0;\n      HEAP32[$5 >> 2] = 0;\n      HEAP32[$41 >> 2] = (HEAP32[$41 >> 2] | 0) + 16;\n     } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($50, $5);\n     __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($5);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     $$2159$ph$be = $229;\n    }\n    $$0151$off0$ph = 1;\n    $$2159$ph = $$2159$ph$be;\n   }\n   $269 = $$2159 + 1 | 0;\n   HEAP32[$2 + 48 >> 2] = HEAP32[$3 >> 2];\n   if ($$0151$off0$ph) {\n    $274 = HEAP32[$41 >> 2] | 0;\n    if ((HEAP32[$2 + 16 >> 2] | 0) != ($274 | 0)) {\n     $$0$i$i$idx$i230 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i230 | 0) == -1) break;\n      $$0$i$i$add$i231 = $$0$i$i$idx$i230 + -1 | 0;\n      __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($274 + ($$0$i$i$add$i231 << 4) | 0);\n      $$0$i$i$idx$i230 = $$0$i$i$add$i231;\n     }\n     HEAP32[$41 >> 2] = $274 + -16;\n    }\n   }\n   $$4166 = $269;\n   break L1;\n  } while (0);\n  $$4166 = $0;\n } else $$4166 = $0; while (0);\n STACKTOP = sp;\n return $$4166 | 0;\n}\n\nfunction _decfloat($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $$0324 = 0, $$0324$be = 0, $$0327480 = 0, $$0328 = 0, $$0329 = 0, $$0331476 = 0, $$0335486 = 0, $$0336$lcssa = 0, $$0336453 = 0, $$0336454 = 0, $$0336455 = 0, $$0336503 = 0, $$0340$lcssa = 0, $$0340457 = 0, $$0340458 = 0, $$0340459 = 0, $$0340502 = 0, $$0345$lcssa540 = 0, $$0345484 = 0, $$0355 = 0.0, $$0356 = 0.0, $$0360474 = 0.0, $$0367 = 0, $$0376 = 0, $$0376$ph = 0, $$0381$lcssa539 = 0, $$0381483 = 0, $$0390 = 0, $$0393 = 0, $$0398$lcssa = 0, $$0398463 = 0, $$0398464 = 0, $$0398465 = 0, $$0398499 = 0, $$1 = 0.0, $$10473 = 0, $$11 = 0, $$1330 = 0, $$1357 = 0.0, $$1361 = 0.0, $$1377 = 0, $$1377$ph = 0, $$1377$ph$ph = 0, $$1391$lcssa = 0, $$1391501 = 0, $$2 = 0, $$2338 = 0, $$2342 = 0, $$2362 = 0.0, $$2369 = 0, $$2369$ph = 0, $$2369$ph579 = 0, $$2392 = 0, $$2395 = 0, $$2400 = 0, $$3$lcssa = 0, $$3339493 = 0, $$3343 = 0, $$3348$ph = 0, $$3348$ph580 = 0, $$3359 = 0.0, $$3363 = 0.0, $$3370 = 0, $$3379 = 0, $$3384$ph = 0, $$3384$ph578 = 0, $$3396$lcssa = 0, $$3396500 = 0, $$3504 = 0, $$4344485 = 0, $$4380 = 0, $$4397 = 0, $$4475 = 0, $$5 = 0, $$5$in = 0, $$5350 = 0, $$5350$ph = 0, $$5350$ph$ph = 0, $$5372 = 0, $$5386$ph = 0, $$5386$ph576 = 0, $$5386$ph576$ph = 0, $$6351478 = 0, $$6387477 = 0, $$6479 = 0, $$7374$ph$ph = 0, $$pre = 0, $$sink$off0 = 0, $10 = 0, $104 = 0, $105 = 0, $11 = 0, $110 = 0, $111 = 0, $113 = 0, $114 = 0, $127 = 0, $129 = 0, $135 = 0, $139 = 0, $141 = 0, $147 = 0, $153 = 0, $155 = 0, $177 = 0, $18 = 0, $189 = 0, $193 = 0, $196 = 0, $198 = 0, $199 = 0, $200 = 0, $201 = 0, $203 = 0, $204 = 0, $218 = 0, $219 = 0, $220 = 0, $224 = 0, $226 = 0, $228 = 0, $229 = 0, $235 = 0, $237 = 0, $239 = 0, $244 = 0, $247 = 0, $251 = 0, $254 = 0, $257 = 0, $26 = 0, $264 = 0, $267 = 0, $269 = 0, $27 = 0, $274 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $283 = 0, $29 = 0, $294 = 0, $297 = 0, $30 = 0, $302 = 0, $306 = 0, $309 = 0, $31 = 0, $318 = 0.0, $319 = 0.0, $320 = 0, $321 = 0, $322 = 0, $327 = 0.0, $330 = 0.0, $334 = 0, $337 = 0, $361 = 0.0, $366 = 0, $373 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $40 = 0, $42 = 0, $44 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $53 = 0, $58 = 0, $59 = 0, $6 = 0, $63 = 0, $7 = 0, $71 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $85 = 0, $86 = 0, $9 = 0, $95 = 0, $96 = 0, $97 = 0, $or$cond417 = 0, $or$cond421 = 0, $spec$select420 = 0, $spec$select441 = 0, $storemerge446 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 512 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(512);\n $6 = sp;\n $7 = $3 + $2 | 0;\n $8 = 0 - $7 | 0;\n $9 = $0 + 4 | 0;\n $10 = $0 + 100 | 0;\n $$0324 = $1;\n $$0393 = 0;\n L1 : while (1) {\n  switch ($$0324 | 0) {\n  case 46:\n   {\n    label = 7;\n    break L1;\n    break;\n   }\n  case 48:\n   break;\n  default:\n   {\n    $$0390 = 0;\n    $$2 = $$0324;\n    $$2395 = $$0393;\n    $375 = 0;\n    $376 = 0;\n    break L1;\n   }\n  }\n  $11 = HEAP32[$9 >> 2] | 0;\n  if ($11 >>> 0 < (HEAP32[$10 >> 2] | 0) >>> 0) {\n   HEAP32[$9 >> 2] = $11 + 1;\n   $$0324$be = HEAPU8[$11 >> 0] | 0;\n  } else $$0324$be = ___shgetc($0) | 0;\n  $$0324 = $$0324$be;\n  $$0393 = 1;\n }\n if ((label | 0) == 7) {\n  $18 = HEAP32[$9 >> 2] | 0;\n  if ($18 >>> 0 < (HEAP32[$10 >> 2] | 0) >>> 0) {\n   HEAP32[$9 >> 2] = $18 + 1;\n   $26 = HEAPU8[$18 >> 0] | 0;\n  } else $26 = ___shgetc($0) | 0;\n  if (($26 | 0) == 48) {\n   $27 = 0;\n   $28 = 0;\n   while (1) {\n    $29 = _i64Add($27 | 0, $28 | 0, -1, -1) | 0;\n    $30 = tempRet0;\n    $31 = HEAP32[$9 >> 2] | 0;\n    if ($31 >>> 0 < (HEAP32[$10 >> 2] | 0) >>> 0) {\n     HEAP32[$9 >> 2] = $31 + 1;\n     $39 = HEAPU8[$31 >> 0] | 0;\n    } else $39 = ___shgetc($0) | 0;\n    if (($39 | 0) == 48) {\n     $27 = $29;\n     $28 = $30;\n    } else {\n     $$0390 = 1;\n     $$2 = $39;\n     $$2395 = 1;\n     $375 = $29;\n     $376 = $30;\n     break;\n    }\n   }\n  } else {\n   $$0390 = 1;\n   $$2 = $26;\n   $$2395 = $$0393;\n   $375 = 0;\n   $376 = 0;\n  }\n }\n HEAP32[$6 >> 2] = 0;\n $40 = $$2 + -48 | 0;\n $42 = ($$2 | 0) == 46;\n L22 : do if ($42 | $40 >>> 0 < 10) {\n  $44 = $6 + 496 | 0;\n  $$0336503 = 0;\n  $$0340502 = 0;\n  $$0398499 = 0;\n  $$1391501 = $$0390;\n  $$3396500 = $$2395;\n  $$3504 = $$2;\n  $377 = $42;\n  $378 = $40;\n  $379 = $375;\n  $380 = $376;\n  $47 = 0;\n  $48 = 0;\n  L24 : while (1) {\n   do if ($377) if (!$$1391501) {\n    $$2338 = $$0336503;\n    $$2342 = $$0340502;\n    $$2392 = 1;\n    $$2400 = $$0398499;\n    $$4397 = $$3396500;\n    $381 = $47;\n    $382 = $48;\n    $383 = $47;\n    $384 = $48;\n   } else break L24; else {\n    $49 = _i64Add($47 | 0, $48 | 0, 1, 0) | 0;\n    $50 = tempRet0;\n    $51 = ($$3504 | 0) != 48;\n    if (($$0340502 | 0) >= 125) {\n     if (!$51) {\n      $$2338 = $$0336503;\n      $$2342 = $$0340502;\n      $$2392 = $$1391501;\n      $$2400 = $$0398499;\n      $$4397 = $$3396500;\n      $381 = $379;\n      $382 = $380;\n      $383 = $49;\n      $384 = $50;\n      break;\n     }\n     HEAP32[$44 >> 2] = HEAP32[$44 >> 2] | 1;\n     $$2338 = $$0336503;\n     $$2342 = $$0340502;\n     $$2392 = $$1391501;\n     $$2400 = $$0398499;\n     $$4397 = $$3396500;\n     $381 = $379;\n     $382 = $380;\n     $383 = $49;\n     $384 = $50;\n     break;\n    }\n    $53 = $6 + ($$0340502 << 2) | 0;\n    if (!$$0336503) $storemerge446 = $378; else $storemerge446 = $$3504 + -48 + ((HEAP32[$53 >> 2] | 0) * 10 | 0) | 0;\n    HEAP32[$53 >> 2] = $storemerge446;\n    $58 = $$0336503 + 1 | 0;\n    $59 = ($58 | 0) == 9;\n    $$2338 = $59 ? 0 : $58;\n    $$2342 = $$0340502 + ($59 & 1) | 0;\n    $$2392 = $$1391501;\n    $$2400 = $51 ? $49 : $$0398499;\n    $$4397 = 1;\n    $381 = $379;\n    $382 = $380;\n    $383 = $49;\n    $384 = $50;\n   } while (0);\n   $63 = HEAP32[$9 >> 2] | 0;\n   if ($63 >>> 0 < (HEAP32[$10 >> 2] | 0) >>> 0) {\n    HEAP32[$9 >> 2] = $63 + 1;\n    $71 = HEAPU8[$63 >> 0] | 0;\n   } else $71 = ___shgetc($0) | 0;\n   $378 = $71 + -48 | 0;\n   $377 = ($71 | 0) == 46;\n   if (!($377 | $378 >>> 0 < 10)) {\n    $$0336$lcssa = $$2338;\n    $$0340$lcssa = $$2342;\n    $$0398$lcssa = $$2400;\n    $$1391$lcssa = $$2392;\n    $$3$lcssa = $71;\n    $$3396$lcssa = $$4397;\n    $77 = $383;\n    $78 = $381;\n    $80 = $384;\n    $81 = $382;\n    label = 31;\n    break L22;\n   } else {\n    $$0336503 = $$2338;\n    $$0340502 = $$2342;\n    $$0398499 = $$2400;\n    $$1391501 = $$2392;\n    $$3396500 = $$4397;\n    $$3504 = $71;\n    $379 = $381;\n    $380 = $382;\n    $47 = $383;\n    $48 = $384;\n   }\n  }\n  $$0336455 = $$0336503;\n  $$0340459 = $$0340502;\n  $$0398465 = $$0398499;\n  $385 = $47;\n  $386 = $48;\n  $387 = $379;\n  $388 = $380;\n  $389 = ($$3396500 | 0) != 0;\n  label = 39;\n } else {\n  $$0336$lcssa = 0;\n  $$0340$lcssa = 0;\n  $$0398$lcssa = 0;\n  $$1391$lcssa = $$0390;\n  $$3$lcssa = $$2;\n  $$3396$lcssa = $$2395;\n  $77 = 0;\n  $78 = $375;\n  $80 = 0;\n  $81 = $376;\n  label = 31;\n } while (0);\n do if ((label | 0) == 31) {\n  $75 = ($$1391$lcssa | 0) == 0;\n  $76 = $75 ? $77 : $78;\n  $79 = $75 ? $80 : $81;\n  $82 = ($$3396$lcssa | 0) != 0;\n  if (!($82 & ($$3$lcssa | 32 | 0) == 101)) if (($$3$lcssa | 0) > -1) {\n   $$0336455 = $$0336$lcssa;\n   $$0340459 = $$0340$lcssa;\n   $$0398465 = $$0398$lcssa;\n   $385 = $77;\n   $386 = $80;\n   $387 = $76;\n   $388 = $79;\n   $389 = $82;\n   label = 39;\n   break;\n  } else {\n   $$0336454 = $$0336$lcssa;\n   $$0340458 = $$0340$lcssa;\n   $$0398464 = $$0398$lcssa;\n   $390 = $77;\n   $391 = $80;\n   $392 = $82;\n   $393 = $76;\n   $394 = $79;\n   label = 41;\n   break;\n  }\n  $85 = _scanexp($0, $5) | 0;\n  $86 = tempRet0;\n  if (($85 | 0) == 0 & ($86 | 0) == -2147483648) {\n   if (!$5) {\n    ___shlim($0, 0);\n    $$1 = 0.0;\n    break;\n   }\n   if (!(HEAP32[$10 >> 2] | 0)) {\n    $95 = 0;\n    $96 = 0;\n   } else {\n    HEAP32[$9 >> 2] = (HEAP32[$9 >> 2] | 0) + -1;\n    $95 = 0;\n    $96 = 0;\n   }\n  } else {\n   $95 = $85;\n   $96 = $86;\n  }\n  $97 = _i64Add($95 | 0, $96 | 0, $76 | 0, $79 | 0) | 0;\n  $$0336453 = $$0336$lcssa;\n  $$0340457 = $$0340$lcssa;\n  $$0398463 = $$0398$lcssa;\n  $110 = $97;\n  $111 = $77;\n  $113 = tempRet0;\n  $114 = $80;\n  label = 43;\n } while (0);\n if ((label | 0) == 39) if (!(HEAP32[$10 >> 2] | 0)) {\n  $$0336454 = $$0336455;\n  $$0340458 = $$0340459;\n  $$0398464 = $$0398465;\n  $390 = $385;\n  $391 = $386;\n  $392 = $389;\n  $393 = $387;\n  $394 = $388;\n  label = 41;\n } else {\n  HEAP32[$9 >> 2] = (HEAP32[$9 >> 2] | 0) + -1;\n  if ($389) {\n   $$0336453 = $$0336455;\n   $$0340457 = $$0340459;\n   $$0398463 = $$0398465;\n   $110 = $387;\n   $111 = $385;\n   $113 = $388;\n   $114 = $386;\n   label = 43;\n  } else label = 42;\n }\n if ((label | 0) == 41) if ($392) {\n  $$0336453 = $$0336454;\n  $$0340457 = $$0340458;\n  $$0398463 = $$0398464;\n  $110 = $393;\n  $111 = $390;\n  $113 = $394;\n  $114 = $391;\n  label = 43;\n } else label = 42;\n do if ((label | 0) == 42) {\n  $104 = ___errno_location() | 0;\n  HEAP32[$104 >> 2] = 22;\n  ___shlim($0, 0);\n  $$1 = 0.0;\n } else if ((label | 0) == 43) {\n  $105 = HEAP32[$6 >> 2] | 0;\n  if (!$105) {\n   $$1 = +($4 | 0) * 0.0;\n   break;\n  }\n  if ((($114 | 0) < 0 | ($114 | 0) == 0 & $111 >>> 0 < 10) & (($110 | 0) == ($111 | 0) & ($113 | 0) == ($114 | 0))) if (($2 | 0) > 30 | ($105 >>> $2 | 0) == 0) {\n   $$1 = +($4 | 0) * +($105 >>> 0);\n   break;\n  }\n  $127 = ($3 | 0) / -2 | 0;\n  $129 = (($127 | 0) < 0) << 31 >> 31;\n  if (($113 | 0) > ($129 | 0) | ($113 | 0) == ($129 | 0) & $110 >>> 0 > $127 >>> 0) {\n   $135 = ___errno_location() | 0;\n   HEAP32[$135 >> 2] = 34;\n   $$1 = +($4 | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284;\n   break;\n  }\n  $139 = $3 + -106 | 0;\n  $141 = (($139 | 0) < 0) << 31 >> 31;\n  if (($113 | 0) < ($141 | 0) | ($113 | 0) == ($141 | 0) & $110 >>> 0 < $139 >>> 0) {\n   $147 = ___errno_location() | 0;\n   HEAP32[$147 >> 2] = 34;\n   $$1 = +($4 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308;\n   break;\n  }\n  if (!$$0336453) $$3343 = $$0340457; else {\n   if (($$0336453 | 0) < 9) {\n    $153 = $6 + ($$0340457 << 2) | 0;\n    $$3339493 = $$0336453;\n    $155 = HEAP32[$153 >> 2] | 0;\n    while (1) {\n     $155 = $155 * 10 | 0;\n     if (($$3339493 | 0) >= 8) break; else $$3339493 = $$3339493 + 1 | 0;\n    }\n    HEAP32[$153 >> 2] = $155;\n   }\n   $$3343 = $$0340457 + 1 | 0;\n  }\n  if (($$0398463 | 0) < 9) if (($$0398463 | 0) <= ($110 | 0) & ($110 | 0) < 18) {\n   if (($110 | 0) == 9) {\n    $$1 = +($4 | 0) * +((HEAP32[$6 >> 2] | 0) >>> 0);\n    break;\n   }\n   if (($110 | 0) < 9) {\n    $$1 = +($4 | 0) * +((HEAP32[$6 >> 2] | 0) >>> 0) / +(HEAP32[2784 + (8 - $110 << 2) >> 2] | 0);\n    break;\n   }\n   $177 = $2 + 27 + (Math_imul($110, -3) | 0) | 0;\n   $$pre = HEAP32[$6 >> 2] | 0;\n   if (($177 | 0) > 30 | ($$pre >>> $177 | 0) == 0) {\n    $$1 = +($4 | 0) * +($$pre >>> 0) * +(HEAP32[2784 + ($110 + -10 << 2) >> 2] | 0);\n    break;\n   }\n  }\n  $189 = ($110 | 0) % 9 | 0;\n  if (!$189) {\n   $$2369$ph = $$3343;\n   $$3348$ph = 0;\n   $$3384$ph = $110;\n  } else {\n   $193 = ($110 | 0) > -1 ? $189 : $189 + 9 | 0;\n   $196 = HEAP32[2784 + (8 - $193 << 2) >> 2] | 0;\n   if (!$$3343) {\n    $$0345$lcssa540 = 0;\n    $$0367 = 0;\n    $$0381$lcssa539 = $110;\n   } else {\n    $198 = 1e9 / ($196 | 0) | 0;\n    $$0335486 = 0;\n    $$0345484 = 0;\n    $$0381483 = $110;\n    $$4344485 = 0;\n    do {\n     $199 = $6 + ($$4344485 << 2) | 0;\n     $200 = HEAP32[$199 >> 2] | 0;\n     $201 = ($200 >>> 0) / ($196 >>> 0) | 0;\n     $203 = $200 - (Math_imul($201, $196) | 0) | 0;\n     $204 = $201 + $$0335486 | 0;\n     HEAP32[$199 >> 2] = $204;\n     $$0335486 = Math_imul($198, $203) | 0;\n     $or$cond417 = ($$4344485 | 0) == ($$0345484 | 0) & ($204 | 0) == 0;\n     $$0381483 = $or$cond417 ? $$0381483 + -9 | 0 : $$0381483;\n     $$0345484 = $or$cond417 ? $$0345484 + 1 & 127 : $$0345484;\n     $$4344485 = $$4344485 + 1 | 0;\n    } while (($$4344485 | 0) != ($$3343 | 0));\n    if (!$$0335486) {\n     $$0345$lcssa540 = $$0345484;\n     $$0367 = $$3343;\n     $$0381$lcssa539 = $$0381483;\n    } else {\n     HEAP32[$6 + ($$3343 << 2) >> 2] = $$0335486;\n     $$0345$lcssa540 = $$0345484;\n     $$0367 = $$3343 + 1 | 0;\n     $$0381$lcssa539 = $$0381483;\n    }\n   }\n   $$2369$ph = $$0367;\n   $$3348$ph = $$0345$lcssa540;\n   $$3384$ph = 9 - $193 + $$0381$lcssa539 | 0;\n  }\n  $$0376$ph = 0;\n  $$2369$ph579 = $$2369$ph;\n  $$3348$ph580 = $$3348$ph;\n  $$3384$ph578 = $$3384$ph;\n  L104 : while (1) {\n   $218 = ($$3384$ph578 | 0) < 18;\n   $219 = ($$3384$ph578 | 0) == 18;\n   $220 = $6 + ($$3348$ph580 << 2) | 0;\n   $$0376 = $$0376$ph;\n   $$2369 = $$2369$ph579;\n   while (1) {\n    if (!$218) {\n     if (!$219) {\n      $$5386$ph = $$3384$ph578;\n      break L104;\n     }\n     if ((HEAP32[$220 >> 2] | 0) >>> 0 >= 9007199) {\n      $$5386$ph = 18;\n      break L104;\n     }\n    }\n    $$0329 = 0;\n    $$3370 = $$2369;\n    $$5$in = $$2369 + 127 | 0;\n    while (1) {\n     $$5 = $$5$in & 127;\n     $224 = $6 + ($$5 << 2) | 0;\n     $226 = _bitshift64Shl(HEAP32[$224 >> 2] | 0, 0, 29) | 0;\n     $228 = _i64Add($226 | 0, tempRet0 | 0, $$0329 | 0, 0) | 0;\n     $229 = tempRet0;\n     if ($229 >>> 0 > 0 | ($229 | 0) == 0 & $228 >>> 0 > 1e9) {\n      $235 = ___udivdi3($228 | 0, $229 | 0, 1e9, 0) | 0;\n      $237 = ___muldi3($235 | 0, tempRet0 | 0, 1e9, 0) | 0;\n      $239 = _i64Subtract($228 | 0, $229 | 0, $237 | 0, tempRet0 | 0) | 0;\n      $$1330 = $235;\n      $$sink$off0 = $239;\n     } else {\n      $$1330 = 0;\n      $$sink$off0 = $228;\n     }\n     HEAP32[$224 >> 2] = $$sink$off0;\n     $244 = ($$5 | 0) == ($$3348$ph580 | 0);\n     $spec$select441 = ($$5 | 0) != ($$3370 + 127 & 127 | 0) | $244 ? $$3370 : ($$sink$off0 | 0) == 0 ? $$5 : $$3370;\n     if ($244) break; else {\n      $$0329 = $$1330;\n      $$3370 = $spec$select441;\n      $$5$in = $$5 + -1 | 0;\n     }\n    }\n    $247 = $$0376 + -29 | 0;\n    if (!$$1330) {\n     $$0376 = $247;\n     $$2369 = $$3370;\n    } else break;\n   }\n   $251 = $$3348$ph580 + 127 & 127;\n   $254 = $spec$select441 + 127 & 127;\n   $257 = $6 + (($spec$select441 + 126 & 127) << 2) | 0;\n   if (($251 | 0) == ($spec$select441 | 0)) {\n    HEAP32[$257 >> 2] = HEAP32[$257 >> 2] | HEAP32[$6 + ($254 << 2) >> 2];\n    $$5372 = $254;\n   } else $$5372 = $$3370;\n   HEAP32[$6 + ($251 << 2) >> 2] = $$1330;\n   $$0376$ph = $247;\n   $$2369$ph579 = $$5372;\n   $$3348$ph580 = $251;\n   $$3384$ph578 = $$3384$ph578 + 9 | 0;\n  }\n  $$1377$ph$ph = $$0376;\n  $$5350$ph$ph = $$3348$ph580;\n  $$5386$ph576$ph = $$5386$ph;\n  $$7374$ph$ph = $$2369;\n  L123 : while (1) {\n   $297 = $$7374$ph$ph + 1 & 127;\n   $302 = $6 + (($$7374$ph$ph + 127 & 127) << 2) | 0;\n   $$1377$ph = $$1377$ph$ph;\n   $$5350$ph = $$5350$ph$ph;\n   $$5386$ph576 = $$5386$ph576$ph;\n   while (1) {\n    $294 = ($$5386$ph576 | 0) == 18;\n    $spec$select420 = ($$5386$ph576 | 0) > 27 ? 9 : 1;\n    $$1377 = $$1377$ph;\n    $$5350 = $$5350$ph;\n    while (1) {\n     $$0331476 = 0;\n     while (1) {\n      $264 = $$0331476 + $$5350 & 127;\n      if (($264 | 0) == ($$7374$ph$ph | 0)) {\n       label = 92;\n       break;\n      }\n      $267 = HEAP32[$6 + ($264 << 2) >> 2] | 0;\n      $269 = HEAP32[2816 + ($$0331476 << 2) >> 2] | 0;\n      if ($267 >>> 0 < $269 >>> 0) {\n       label = 92;\n       break;\n      }\n      if ($267 >>> 0 > $269 >>> 0) break;\n      if (($$0331476 + 1 | 0) >>> 0 < 2) $$0331476 = 1; else {\n       label = 92;\n       break;\n      }\n     }\n     if ((label | 0) == 92) {\n      label = 0;\n      if ($294) break L123;\n     }\n     $274 = $spec$select420 + $$1377 | 0;\n     if (($$5350 | 0) == ($$7374$ph$ph | 0)) {\n      $$1377 = $274;\n      $$5350 = $$7374$ph$ph;\n     } else break;\n    }\n    $277 = (1 << $spec$select420) + -1 | 0;\n    $278 = 1e9 >>> $spec$select420;\n    $$0327480 = 0;\n    $$6351478 = $$5350;\n    $$6387477 = $$5386$ph576;\n    $$6479 = $$5350;\n    do {\n     $279 = $6 + ($$6479 << 2) | 0;\n     $280 = HEAP32[$279 >> 2] | 0;\n     $283 = ($280 >>> $spec$select420) + $$0327480 | 0;\n     HEAP32[$279 >> 2] = $283;\n     $$0327480 = Math_imul($280 & $277, $278) | 0;\n     $or$cond421 = ($$6479 | 0) == ($$6351478 | 0) & ($283 | 0) == 0;\n     $$6387477 = $or$cond421 ? $$6387477 + -9 | 0 : $$6387477;\n     $$6351478 = $or$cond421 ? $$6351478 + 1 & 127 : $$6351478;\n     $$6479 = $$6479 + 1 & 127;\n    } while (($$6479 | 0) != ($$7374$ph$ph | 0));\n    if ($$0327480 | 0) {\n     if (($297 | 0) != ($$6351478 | 0)) break;\n     HEAP32[$302 >> 2] = HEAP32[$302 >> 2] | 1;\n    }\n    $$1377$ph = $274;\n    $$5350$ph = $$6351478;\n    $$5386$ph576 = $$6387477;\n   }\n   HEAP32[$6 + ($$7374$ph$ph << 2) >> 2] = $$0327480;\n   $$1377$ph$ph = $274;\n   $$5350$ph$ph = $$6351478;\n   $$5386$ph576$ph = $$6387477;\n   $$7374$ph$ph = $297;\n  }\n  $$0360474 = 0.0;\n  $$10473 = $$7374$ph$ph;\n  $$4475 = 0;\n  while (1) {\n   $306 = $$4475 + $$5350 & 127;\n   $309 = $$10473 + 1 & 127;\n   if (($306 | 0) == ($$10473 | 0)) {\n    HEAP32[$6 + ($309 + -1 << 2) >> 2] = 0;\n    $$11 = $309;\n   } else $$11 = $$10473;\n   $$0360474 = $$0360474 * 1.0e9 + +((HEAP32[$6 + ($306 << 2) >> 2] | 0) >>> 0);\n   $$4475 = $$4475 + 1 | 0;\n   if (($$4475 | 0) == 2) break; else $$10473 = $$11;\n  }\n  $318 = +($4 | 0);\n  $319 = $$0360474 * $318;\n  $320 = $$1377 + 53 | 0;\n  $321 = $320 - $3 | 0;\n  $322 = ($321 | 0) < ($2 | 0);\n  $$0328 = $322 ? (($321 | 0) > 0 ? $321 : 0) : $2;\n  if (($$0328 | 0) < 53) {\n   $327 = +_copysignl(+_scalbn(1.0, 105 - $$0328 | 0), $319);\n   $330 = +_fmodl($319, +_scalbn(1.0, 53 - $$0328 | 0));\n   $$0355 = $327;\n   $$0356 = $330;\n   $$1361 = $327 + ($319 - $330);\n  } else {\n   $$0355 = 0.0;\n   $$0356 = 0.0;\n   $$1361 = $319;\n  }\n  $334 = $$5350 + 2 & 127;\n  if (($334 | 0) == ($$11 | 0)) $$3359 = $$0356; else {\n   $337 = HEAP32[$6 + ($334 << 2) >> 2] | 0;\n   do if ($337 >>> 0 < 5e8) {\n    if (!$337) if (($$5350 + 3 & 127 | 0) == ($$11 | 0)) {\n     $$1357 = $$0356;\n     break;\n    }\n    $$1357 = $318 * .25 + $$0356;\n   } else {\n    if (($337 | 0) != 5e8) {\n     $$1357 = $318 * .75 + $$0356;\n     break;\n    }\n    if (($$5350 + 3 & 127 | 0) == ($$11 | 0)) {\n     $$1357 = $318 * .5 + $$0356;\n     break;\n    } else {\n     $$1357 = $318 * .75 + $$0356;\n     break;\n    }\n   } while (0);\n   if ((53 - $$0328 | 0) > 1) if (+_fmodl($$1357, 1.0) != 0.0) $$3359 = $$1357; else $$3359 = $$1357 + 1.0; else $$3359 = $$1357;\n  }\n  $361 = $$1361 + $$3359 - $$0355;\n  do if (($320 & 2147483647 | 0) > (-2 - $7 | 0)) {\n   $366 = !(+Math_abs(+$361) >= 9007199254740992.0);\n   $$3379 = $$1377 + (($366 ^ 1) & 1) | 0;\n   $$2362 = $366 ? $361 : $361 * .5;\n   if (($$3379 + 50 | 0) <= ($8 | 0)) if (!($$3359 != 0.0 & ($322 & (($$0328 | 0) != ($321 | 0) | $366)))) {\n    $$3363 = $$2362;\n    $$4380 = $$3379;\n    break;\n   }\n   $373 = ___errno_location() | 0;\n   HEAP32[$373 >> 2] = 34;\n   $$3363 = $$2362;\n   $$4380 = $$3379;\n  } else {\n   $$3363 = $361;\n   $$4380 = $$1377;\n  } while (0);\n  $$1 = +_scalbnl($$3363, $$4380);\n } while (0);\n STACKTOP = sp;\n return +$$1;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_118parse_builtin_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$1 = 0, $103 = 0, $104 = 0, $111 = 0, $112 = 0, $119 = 0, $120 = 0, $127 = 0, $128 = 0, $135 = 0, $136 = 0, $143 = 0, $144 = 0, $15 = 0, $151 = 0, $152 = 0, $159 = 0, $16 = 0, $160 = 0, $167 = 0, $168 = 0, $175 = 0, $176 = 0, $178 = 0, $182 = 0, $183 = 0, $190 = 0, $191 = 0, $198 = 0, $199 = 0, $206 = 0, $207 = 0, $214 = 0, $215 = 0, $222 = 0, $223 = 0, $23 = 0, $230 = 0, $231 = 0, $238 = 0, $239 = 0, $24 = 0, $3 = 0, $31 = 0, $32 = 0, $39 = 0, $40 = 0, $47 = 0, $48 = 0, $55 = 0, $56 = 0, $63 = 0, $64 = 0, $7 = 0, $71 = 0, $72 = 0, $79 = 0, $8 = 0, $80 = 0, $87 = 0, $88 = 0, $95 = 0, $96 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp;\n L1 : do if (($0 | 0) == ($1 | 0)) $$1 = $0; else do switch (HEAP8[$0 >> 0] | 0) {\n case 118:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj5EEERAT__Kc($3, 16556);\n   $7 = $2 + 4 | 0;\n   $8 = HEAP32[$7 >> 2] | 0;\n   if ($8 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($8, $3);\n    HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 119:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj8EEERAT__Kc($3);\n   $15 = $2 + 4 | 0;\n   $16 = HEAP32[$15 >> 2] | 0;\n   if ($16 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($16, $3);\n    HEAP32[$15 >> 2] = (HEAP32[$15 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 98:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj5EEERAT__Kc($3, 16561);\n   $23 = $2 + 4 | 0;\n   $24 = HEAP32[$23 >> 2] | 0;\n   if ($24 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($24, $3);\n    HEAP32[$23 >> 2] = (HEAP32[$23 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 99:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj5EEERAT__Kc($3, 16330);\n   $31 = $2 + 4 | 0;\n   $32 = HEAP32[$31 >> 2] | 0;\n   if ($32 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($32, $3);\n    HEAP32[$31 >> 2] = (HEAP32[$31 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 97:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj12EEERAT__Kc($3, 16335);\n   $39 = $2 + 4 | 0;\n   $40 = HEAP32[$39 >> 2] | 0;\n   if ($40 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($40, $3);\n    HEAP32[$39 >> 2] = (HEAP32[$39 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 104:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj14EEERAT__Kc($3, 16347);\n   $47 = $2 + 4 | 0;\n   $48 = HEAP32[$47 >> 2] | 0;\n   if ($48 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($48, $3);\n    HEAP32[$47 >> 2] = (HEAP32[$47 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 115:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj6EEERAT__Kc($3, 16361);\n   $55 = $2 + 4 | 0;\n   $56 = HEAP32[$55 >> 2] | 0;\n   if ($56 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($56, $3);\n    HEAP32[$55 >> 2] = (HEAP32[$55 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 116:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj15EEERAT__Kc($3, 16367);\n   $63 = $2 + 4 | 0;\n   $64 = HEAP32[$63 >> 2] | 0;\n   if ($64 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($64, $3);\n    HEAP32[$63 >> 2] = (HEAP32[$63 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 105:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj4EEERAT__Kc($3, 16566);\n   $71 = $2 + 4 | 0;\n   $72 = HEAP32[$71 >> 2] | 0;\n   if ($72 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($72, $3);\n    HEAP32[$71 >> 2] = (HEAP32[$71 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 106:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj13EEERAT__Kc($3, 16570);\n   $79 = $2 + 4 | 0;\n   $80 = HEAP32[$79 >> 2] | 0;\n   if ($80 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($80, $3);\n    HEAP32[$79 >> 2] = (HEAP32[$79 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 108:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj5EEERAT__Kc($3, 16583);\n   $87 = $2 + 4 | 0;\n   $88 = HEAP32[$87 >> 2] | 0;\n   if ($88 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($88, $3);\n    HEAP32[$87 >> 2] = (HEAP32[$87 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 109:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj14EEERAT__Kc($3, 16588);\n   $95 = $2 + 4 | 0;\n   $96 = HEAP32[$95 >> 2] | 0;\n   if ($96 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($96, $3);\n    HEAP32[$95 >> 2] = (HEAP32[$95 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 120:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 16602);\n   $103 = $2 + 4 | 0;\n   $104 = HEAP32[$103 >> 2] | 0;\n   if ($104 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($104, $3);\n    HEAP32[$103 >> 2] = (HEAP32[$103 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 121:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj19EEERAT__Kc($3);\n   $111 = $2 + 4 | 0;\n   $112 = HEAP32[$111 >> 2] | 0;\n   if ($112 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($112, $3);\n    HEAP32[$111 >> 2] = (HEAP32[$111 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 110:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj9EEERAT__Kc($3, 16396);\n   $119 = $2 + 4 | 0;\n   $120 = HEAP32[$119 >> 2] | 0;\n   if ($120 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($120, $3);\n    HEAP32[$119 >> 2] = (HEAP32[$119 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 111:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj18EEERAT__Kc($3, 16405);\n   $127 = $2 + 4 | 0;\n   $128 = HEAP32[$127 >> 2] | 0;\n   if ($128 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($128, $3);\n    HEAP32[$127 >> 2] = (HEAP32[$127 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 102:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj6EEERAT__Kc($3, 16612);\n   $135 = $2 + 4 | 0;\n   $136 = HEAP32[$135 >> 2] | 0;\n   if ($136 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($136, $3);\n    HEAP32[$135 >> 2] = (HEAP32[$135 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 100:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj7EEERAT__Kc($3);\n   $143 = $2 + 4 | 0;\n   $144 = HEAP32[$143 >> 2] | 0;\n   if ($144 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($144, $3);\n    HEAP32[$143 >> 2] = (HEAP32[$143 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 101:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj12EEERAT__Kc($3, 16618);\n   $151 = $2 + 4 | 0;\n   $152 = HEAP32[$151 >> 2] | 0;\n   if ($152 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($152, $3);\n    HEAP32[$151 >> 2] = (HEAP32[$151 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 103:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 16630);\n   $159 = $2 + 4 | 0;\n   $160 = HEAP32[$159 >> 2] | 0;\n   if ($160 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($160, $3);\n    HEAP32[$159 >> 2] = (HEAP32[$159 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 122:\n  {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj4EEERAT__Kc($3, 16641);\n   $167 = $2 + 4 | 0;\n   $168 = HEAP32[$167 >> 2] | 0;\n   if ($168 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($168, $3);\n    HEAP32[$167 >> 2] = (HEAP32[$167 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   $$1 = $0 + 1 | 0;\n   break L1;\n   break;\n  }\n case 117:\n  {\n   $175 = $0 + 1 | 0;\n   $176 = __ZN10__cxxabiv112_GLOBAL__N_117parse_source_nameINS0_2DbEEEPKcS4_S4_RT_($175, $1, $2) | 0;\n   $$1 = ($176 | 0) == ($175 | 0) ? $0 : $176;\n   break L1;\n   break;\n  }\n case 68:\n  {\n   $178 = $0 + 1 | 0;\n   if (($178 | 0) == ($1 | 0)) {\n    $$1 = $0;\n    break L1;\n   }\n   switch (HEAP8[$178 >> 0] | 0) {\n   case 100:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 16645);\n     $182 = $2 + 4 | 0;\n     $183 = HEAP32[$182 >> 2] | 0;\n     if ($183 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($183, $3);\n      HEAP32[$182 >> 2] = (HEAP32[$182 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$1 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 101:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($3, 16655);\n     $190 = $2 + 4 | 0;\n     $191 = HEAP32[$190 >> 2] | 0;\n     if ($191 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($191, $3);\n      HEAP32[$190 >> 2] = (HEAP32[$190 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$1 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 102:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 16666);\n     $198 = $2 + 4 | 0;\n     $199 = HEAP32[$198 >> 2] | 0;\n     if ($199 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($199, $3);\n      HEAP32[$198 >> 2] = (HEAP32[$198 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$1 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 104:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($3, 16676);\n     $206 = $2 + 4 | 0;\n     $207 = HEAP32[$206 >> 2] | 0;\n     if ($207 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($207, $3);\n      HEAP32[$206 >> 2] = (HEAP32[$206 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$1 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 105:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj9EEERAT__Kc($3, 16686);\n     $214 = $2 + 4 | 0;\n     $215 = HEAP32[$214 >> 2] | 0;\n     if ($215 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($215, $3);\n      HEAP32[$214 >> 2] = (HEAP32[$214 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$1 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 115:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj9EEERAT__Kc($3, 16695);\n     $222 = $2 + 4 | 0;\n     $223 = HEAP32[$222 >> 2] | 0;\n     if ($223 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($223, $3);\n      HEAP32[$222 >> 2] = (HEAP32[$222 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$1 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 97:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj5EEERAT__Kc($3, 16704);\n     $230 = $2 + 4 | 0;\n     $231 = HEAP32[$230 >> 2] | 0;\n     if ($231 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($231, $3);\n      HEAP32[$230 >> 2] = (HEAP32[$230 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$1 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 110:\n    {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj15EEERAT__Kc($3, 16709);\n     $238 = $2 + 4 | 0;\n     $239 = HEAP32[$238 >> 2] | 0;\n     if ($239 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($239, $3);\n      HEAP32[$238 >> 2] = (HEAP32[$238 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     $$1 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$1 = $0;\n     break L1;\n    }\n   }\n   break;\n  }\n default:\n  {\n   $$1 = $0;\n   break L1;\n  }\n } while (0); while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$add$i199 = 0, $$0$i$i$add$i203 = 0, $$0$i$i$add$i209 = 0, $$0$i$i$add$i213 = 0, $$0$i$i$add$i223 = 0, $$0$i$i$add$i229 = 0, $$0$i$i$add$i233 = 0, $$0$i$i$add$i243 = 0, $$0$i$i$add$i253 = 0, $$0$i$i$add$i257 = 0, $$0$i$i$i = 0, $$0$i$i$i216 = 0, $$0$i$i$i236 = 0, $$0$i$i$i246 = 0, $$0$i$i$i260 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i198 = 0, $$0$i$i$idx$i202 = 0, $$0$i$i$idx$i208 = 0, $$0$i$i$idx$i212 = 0, $$0$i$i$idx$i222 = 0, $$0$i$i$idx$i228 = 0, $$0$i$i$idx$i232 = 0, $$0$i$i$idx$i242 = 0, $$0$i$i$idx$i252 = 0, $$0$i$i$idx$i256 = 0, $$0182$off0 = 0, $$0183 = 0, $$1184 = 0, $$2185 = 0, $$3186 = 0, $$4187 = 0, $$6181 = 0, $$pre = 0, $$pre$phi298Z2D = 0, $$pre$phi300Z2D = 0, $100 = 0, $107 = 0, $116 = 0, $117 = 0, $124 = 0, $126 = 0, $128 = 0, $129 = 0, $13 = 0, $136 = 0, $141 = 0, $142 = 0, $149 = 0, $15 = 0, $152 = 0, $153 = 0, $157 = 0, $158 = 0, $165 = 0, $174 = 0, $175 = 0, $182 = 0, $186 = 0, $187 = 0, $19 = 0, $190 = 0, $191 = 0, $194 = 0, $197 = 0, $204 = 0, $212 = 0, $213 = 0, $219 = 0, $220 = 0, $223 = 0, $227 = 0, $234 = 0, $243 = 0, $244 = 0, $3 = 0, $30 = 0, $33 = 0, $34 = 0, $37 = 0, $39 = 0, $4 = 0, $46 = 0, $5 = 0, $51 = 0, $52 = 0, $60 = 0, $63 = 0, $64 = 0, $67 = 0, $70 = 0, $77 = 0, $85 = 0, $86 = 0, $92 = 0, $93 = 0, $96 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp + 12 | 0;\n $4 = sp;\n $5 = $1;\n L1 : do if (($5 - $0 | 0) > 2) {\n  if ((HEAP8[$0 >> 0] | 0) == 103) {\n   $13 = (HEAP8[$0 + 1 >> 0] | 0) == 115;\n   $$0182$off0 = $13;\n   $$0183 = $13 ? $0 + 2 | 0 : $0;\n  } else {\n   $$0182$off0 = 0;\n   $$0183 = $0;\n  }\n  $15 = __ZN10__cxxabiv112_GLOBAL__N_126parse_base_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($$0183, $1, $2) | 0;\n  if (($15 | 0) != ($$0183 | 0)) {\n   if (!$$0182$off0) {\n    $$6181 = $15;\n    break;\n   }\n   $19 = HEAP32[$2 + 4 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($19 | 0)) {\n    $$6181 = $0;\n    break;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($19 + -24 | 0, 0, 15191) | 0;\n   $$6181 = $15;\n   break;\n  }\n  if (($5 - $$0183 | 0) > 2) if ((HEAP8[$$0183 >> 0] | 0) == 115) if ((HEAP8[$$0183 + 1 >> 0] | 0) == 114) {\n   $30 = $$0183 + 2 | 0;\n   if ((HEAP8[$30 >> 0] | 0) == 78) {\n    $33 = $$0183 + 3 | 0;\n    $34 = __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_typeINS0_2DbEEEPKcS4_S4_RT_($33, $1, $2) | 0;\n    if (($34 | 0) == ($33 | 0) | ($34 | 0) == ($1 | 0)) {\n     $$6181 = $0;\n     break;\n    }\n    $37 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($34, $1, $2) | 0;\n    $$pre = $2 + 4 | 0;\n    do if (($37 | 0) == ($34 | 0)) {\n     $$1184 = $34;\n     $$pre$phi298Z2D = $2;\n    } else {\n     $39 = HEAP32[$$pre >> 2] | 0;\n     if ((($39 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$6181 = $0;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $39 + -24 | 0);\n     $46 = HEAP32[$$pre >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($46 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$$pre >> 2] = $46 + -24;\n     $51 = HEAP8[$3 + 11 >> 0] | 0;\n     $52 = $51 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($46 + -48 | 0, $52 ? HEAP32[$3 >> 2] | 0 : $3, $52 ? HEAP32[$3 + 4 >> 2] | 0 : $51 & 255) | 0;\n     if (($37 | 0) != ($1 | 0)) {\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$1184 = $37;\n      $$pre$phi298Z2D = $2;\n      break;\n     }\n     $60 = HEAP32[$$pre >> 2] | 0;\n     $$0$i$i$idx$i198 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i198 | 0) == -1) break;\n      $$0$i$i$add$i199 = $$0$i$i$idx$i198 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($60 + ($$0$i$i$add$i199 * 24 | 0) | 0);\n      $$0$i$i$idx$i198 = $$0$i$i$add$i199;\n     }\n     HEAP32[$$pre >> 2] = $60 + -24;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$6181 = $0;\n     break L1;\n    } while (0);\n    $63 = $4 + 11 | 0;\n    $64 = $4 + 4 | 0;\n    $$2185 = $$1184;\n    while (1) {\n     if ((HEAP8[$$2185 >> 0] | 0) == 69) break;\n     $67 = __ZN10__cxxabiv112_GLOBAL__N_132parse_unresolved_qualifier_levelINS0_2DbEEEPKcS4_S4_RT_($$2185, $1, $2) | 0;\n     if (($67 | 0) == ($$2185 | 0) | ($67 | 0) == ($1 | 0)) {\n      $$6181 = $0;\n      break L1;\n     }\n     $70 = HEAP32[$$pre >> 2] | 0;\n     if ((($70 - (HEAP32[$$pre$phi298Z2D >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$6181 = $0;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $70 + -24 | 0);\n     $77 = HEAP32[$$pre >> 2] | 0;\n     $$0$i$i$idx$i202 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i202 | 0) == -1) break;\n      $$0$i$i$add$i203 = $$0$i$i$idx$i202 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($77 + ($$0$i$i$add$i203 * 24 | 0) | 0);\n      $$0$i$i$idx$i202 = $$0$i$i$add$i203;\n     }\n     HEAP32[$$pre >> 2] = $77 + -24;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($3, 0, 15191) | 0;\n     HEAP32[$4 >> 2] = HEAP32[$3 >> 2];\n     HEAP32[$4 + 4 >> 2] = HEAP32[$3 + 4 >> 2];\n     HEAP32[$4 + 8 >> 2] = HEAP32[$3 + 8 >> 2];\n     $$0$i$i$i = 0;\n     while (1) {\n      if (($$0$i$i$i | 0) == 3) break;\n      HEAP32[$3 + ($$0$i$i$i << 2) >> 2] = 0;\n      $$0$i$i$i = $$0$i$i$i + 1 | 0;\n     }\n     $85 = HEAP8[$63 >> 0] | 0;\n     $86 = $85 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$$pre >> 2] | 0) + -24 | 0, $86 ? HEAP32[$4 >> 2] | 0 : $4, $86 ? HEAP32[$64 >> 2] | 0 : $85 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$2185 = $67;\n    }\n    $92 = $$2185 + 1 | 0;\n    $93 = __ZN10__cxxabiv112_GLOBAL__N_126parse_base_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($92, $1, $2) | 0;\n    if (($93 | 0) == ($92 | 0)) {\n     $96 = HEAP32[$$pre >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($96 | 0)) {\n      $$6181 = $0;\n      break;\n     }\n     $$0$i$i$idx$i208 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i208 | 0) == -1) break;\n      $$0$i$i$add$i209 = $$0$i$i$idx$i208 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($96 + ($$0$i$i$add$i209 * 24 | 0) | 0);\n      $$0$i$i$idx$i208 = $$0$i$i$add$i209;\n     }\n     HEAP32[$$pre >> 2] = $96 + -24;\n     $$6181 = $0;\n     break;\n    }\n    $100 = HEAP32[$$pre >> 2] | 0;\n    if ((($100 - (HEAP32[$$pre$phi298Z2D >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n     $$6181 = $0;\n     break;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $100 + -24 | 0);\n    $107 = HEAP32[$$pre >> 2] | 0;\n    $$0$i$i$idx$i212 = 0;\n    while (1) {\n     if (($$0$i$i$idx$i212 | 0) == -1) break;\n     $$0$i$i$add$i213 = $$0$i$i$idx$i212 + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($107 + ($$0$i$i$add$i213 * 24 | 0) | 0);\n     $$0$i$i$idx$i212 = $$0$i$i$add$i213;\n    }\n    HEAP32[$$pre >> 2] = $107 + -24;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($3, 0, 15191) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$3 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$3 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$3 + 8 >> 2];\n    $$0$i$i$i216 = 0;\n    while (1) {\n     if (($$0$i$i$i216 | 0) == 3) break;\n     HEAP32[$3 + ($$0$i$i$i216 << 2) >> 2] = 0;\n     $$0$i$i$i216 = $$0$i$i$i216 + 1 | 0;\n    }\n    $116 = HEAP8[$4 + 11 >> 0] | 0;\n    $117 = $116 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$$pre >> 2] | 0) + -24 | 0, $117 ? HEAP32[$4 >> 2] | 0 : $4, $117 ? HEAP32[$4 + 4 >> 2] | 0 : $116 & 255) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$6181 = $93;\n    break;\n   }\n   $124 = __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_typeINS0_2DbEEEPKcS4_S4_RT_($30, $1, $2) | 0;\n   if (($124 | 0) != ($30 | 0)) {\n    $126 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($124, $1, $2) | 0;\n    if (($126 | 0) == ($124 | 0)) $$3186 = $124; else {\n     $128 = $2 + 4 | 0;\n     $129 = HEAP32[$128 >> 2] | 0;\n     if ((($129 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$6181 = $0;\n      break;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $129 + -24 | 0);\n     $136 = HEAP32[$128 >> 2] | 0;\n     $$0$i$i$idx$i222 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i222 | 0) == -1) break;\n      $$0$i$i$add$i223 = $$0$i$i$idx$i222 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($136 + ($$0$i$i$add$i223 * 24 | 0) | 0);\n      $$0$i$i$idx$i222 = $$0$i$i$add$i223;\n     }\n     HEAP32[$128 >> 2] = $136 + -24;\n     $141 = HEAP8[$3 + 11 >> 0] | 0;\n     $142 = $141 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($136 + -48 | 0, $142 ? HEAP32[$3 >> 2] | 0 : $3, $142 ? HEAP32[$3 + 4 >> 2] | 0 : $141 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$3186 = $126;\n    }\n    $149 = __ZN10__cxxabiv112_GLOBAL__N_126parse_base_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($$3186, $1, $2) | 0;\n    if (($149 | 0) == ($$3186 | 0)) {\n     $152 = $2 + 4 | 0;\n     $153 = HEAP32[$152 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($153 | 0)) {\n      $$6181 = $0;\n      break;\n     }\n     $$0$i$i$idx$i228 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i228 | 0) == -1) break;\n      $$0$i$i$add$i229 = $$0$i$i$idx$i228 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($153 + ($$0$i$i$add$i229 * 24 | 0) | 0);\n      $$0$i$i$idx$i228 = $$0$i$i$add$i229;\n     }\n     HEAP32[$152 >> 2] = $153 + -24;\n     $$6181 = $0;\n     break;\n    }\n    $157 = $2 + 4 | 0;\n    $158 = HEAP32[$157 >> 2] | 0;\n    if ((($158 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n     $$6181 = $0;\n     break;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $158 + -24 | 0);\n    $165 = HEAP32[$157 >> 2] | 0;\n    $$0$i$i$idx$i232 = 0;\n    while (1) {\n     if (($$0$i$i$idx$i232 | 0) == -1) break;\n     $$0$i$i$add$i233 = $$0$i$i$idx$i232 + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($165 + ($$0$i$i$add$i233 * 24 | 0) | 0);\n     $$0$i$i$idx$i232 = $$0$i$i$add$i233;\n    }\n    HEAP32[$157 >> 2] = $165 + -24;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($3, 0, 15191) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$3 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$3 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$3 + 8 >> 2];\n    $$0$i$i$i236 = 0;\n    while (1) {\n     if (($$0$i$i$i236 | 0) == 3) break;\n     HEAP32[$3 + ($$0$i$i$i236 << 2) >> 2] = 0;\n     $$0$i$i$i236 = $$0$i$i$i236 + 1 | 0;\n    }\n    $174 = HEAP8[$4 + 11 >> 0] | 0;\n    $175 = $174 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$157 >> 2] | 0) + -24 | 0, $175 ? HEAP32[$4 >> 2] | 0 : $4, $175 ? HEAP32[$4 + 4 >> 2] | 0 : $174 & 255) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$6181 = $149;\n    break;\n   }\n   $182 = __ZN10__cxxabiv112_GLOBAL__N_132parse_unresolved_qualifier_levelINS0_2DbEEEPKcS4_S4_RT_($30, $1, $2) | 0;\n   if (($182 | 0) == ($30 | 0) | ($182 | 0) == ($1 | 0)) $$6181 = $0; else {\n    if ($$0182$off0) {\n     $186 = $2 + 4 | 0;\n     $187 = HEAP32[$186 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($187 | 0)) {\n      $$6181 = $0;\n      break;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($187 + -24 | 0, 0, 15191) | 0;\n     $$pre$phi300Z2D = $186;\n    } else $$pre$phi300Z2D = $2 + 4 | 0;\n    $190 = $4 + 11 | 0;\n    $191 = $4 + 4 | 0;\n    $$4187 = $182;\n    while (1) {\n     if ((HEAP8[$$4187 >> 0] | 0) == 69) break;\n     $194 = __ZN10__cxxabiv112_GLOBAL__N_132parse_unresolved_qualifier_levelINS0_2DbEEEPKcS4_S4_RT_($$4187, $1, $2) | 0;\n     if (($194 | 0) == ($$4187 | 0) | ($194 | 0) == ($1 | 0)) {\n      $$6181 = $0;\n      break L1;\n     }\n     $197 = HEAP32[$$pre$phi300Z2D >> 2] | 0;\n     if ((($197 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$6181 = $0;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $197 + -24 | 0);\n     $204 = HEAP32[$$pre$phi300Z2D >> 2] | 0;\n     $$0$i$i$idx$i242 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i242 | 0) == -1) break;\n      $$0$i$i$add$i243 = $$0$i$i$idx$i242 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($204 + ($$0$i$i$add$i243 * 24 | 0) | 0);\n      $$0$i$i$idx$i242 = $$0$i$i$add$i243;\n     }\n     HEAP32[$$pre$phi300Z2D >> 2] = $204 + -24;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($3, 0, 15191) | 0;\n     HEAP32[$4 >> 2] = HEAP32[$3 >> 2];\n     HEAP32[$4 + 4 >> 2] = HEAP32[$3 + 4 >> 2];\n     HEAP32[$4 + 8 >> 2] = HEAP32[$3 + 8 >> 2];\n     $$0$i$i$i246 = 0;\n     while (1) {\n      if (($$0$i$i$i246 | 0) == 3) break;\n      HEAP32[$3 + ($$0$i$i$i246 << 2) >> 2] = 0;\n      $$0$i$i$i246 = $$0$i$i$i246 + 1 | 0;\n     }\n     $212 = HEAP8[$190 >> 0] | 0;\n     $213 = $212 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$$pre$phi300Z2D >> 2] | 0) + -24 | 0, $213 ? HEAP32[$4 >> 2] | 0 : $4, $213 ? HEAP32[$191 >> 2] | 0 : $212 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$4187 = $194;\n    }\n    $219 = $$4187 + 1 | 0;\n    $220 = __ZN10__cxxabiv112_GLOBAL__N_126parse_base_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($219, $1, $2) | 0;\n    if (($220 | 0) == ($219 | 0)) {\n     $223 = HEAP32[$$pre$phi300Z2D >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($223 | 0)) {\n      $$6181 = $0;\n      break;\n     }\n     $$0$i$i$idx$i252 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i252 | 0) == -1) break;\n      $$0$i$i$add$i253 = $$0$i$i$idx$i252 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($223 + ($$0$i$i$add$i253 * 24 | 0) | 0);\n      $$0$i$i$idx$i252 = $$0$i$i$add$i253;\n     }\n     HEAP32[$$pre$phi300Z2D >> 2] = $223 + -24;\n     $$6181 = $0;\n     break;\n    }\n    $227 = HEAP32[$$pre$phi300Z2D >> 2] | 0;\n    if ((($227 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$6181 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $227 + -24 | 0);\n     $234 = HEAP32[$$pre$phi300Z2D >> 2] | 0;\n     $$0$i$i$idx$i256 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i256 | 0) == -1) break;\n      $$0$i$i$add$i257 = $$0$i$i$idx$i256 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($234 + ($$0$i$i$add$i257 * 24 | 0) | 0);\n      $$0$i$i$idx$i256 = $$0$i$i$add$i257;\n     }\n     HEAP32[$$pre$phi300Z2D >> 2] = $234 + -24;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($3, 0, 15191) | 0;\n     HEAP32[$4 >> 2] = HEAP32[$3 >> 2];\n     HEAP32[$4 + 4 >> 2] = HEAP32[$3 + 4 >> 2];\n     HEAP32[$4 + 8 >> 2] = HEAP32[$3 + 8 >> 2];\n     $$0$i$i$i260 = 0;\n     while (1) {\n      if (($$0$i$i$i260 | 0) == 3) break;\n      HEAP32[$3 + ($$0$i$i$i260 << 2) >> 2] = 0;\n      $$0$i$i$i260 = $$0$i$i$i260 + 1 | 0;\n     }\n     $243 = HEAP8[$4 + 11 >> 0] | 0;\n     $244 = $243 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$$pre$phi300Z2D >> 2] | 0) + -24 | 0, $244 ? HEAP32[$4 >> 2] | 0 : $4, $244 ? HEAP32[$4 + 4 >> 2] | 0 : $243 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$6181 = $220;\n    }\n   }\n  } else $$6181 = $0; else $$6181 = $0; else $$6181 = $0;\n } else $$6181 = $0; while (0);\n STACKTOP = sp;\n return $$6181 | 0;\n}\n\nfunction _arDetectMarker($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$0440 = 0, $$0442 = 0, $$0447 = 0, $$0452 = 0, $$0456 = 0, $$0458 = 0.0, $$0462 = 0.0, $$0464 = 0.0, $$1441 = 0, $$1443 = 0, $$1448 = 0, $$1453 = 0, $$1457 = 0, $$1459 = 0.0, $$1463 = 0.0, $$1465 = 0.0, $$2444 = 0, $$2449 = 0, $$2454 = 0, $$2460 = 0.0, $$3445 = 0, $$3450 = 0, $$3455 = 0, $$4 = 0, $$4446 = 0, $$4451 = 0, $$5 = 0, $$6 = 0, $$pre$phi495Z2D = 0, $$pre$phi501Z2D = 0, $$pre$phi503Z2D = 0, $$pre$phi505Z2D = 0, $$pre$phiZ2D = 0, $$pre486 = 0, $$pre487 = 0, $$pre488 = 0, $10 = 0, $100 = 0, $11 = 0, $111 = 0, $112 = 0, $114 = 0, $116 = 0, $119 = 0, $127 = 0, $129 = 0, $131 = 0, $132 = 0, $137 = 0, $139 = 0, $14 = 0, $145 = 0, $148 = 0, $15 = 0, $159 = 0, $16 = 0, $161 = 0, $168 = 0, $170 = 0, $176 = 0, $177 = 0, $18 = 0, $2 = 0, $20 = 0, $201 = 0, $204 = 0, $205 = 0, $206 = 0, $208 = 0, $209 = 0, $210 = 0, $211 = 0, $217 = 0.0, $218 = 0.0, $22 = 0, $224 = 0.0, $229 = 0.0, $232 = 0.0, $236 = 0, $237 = 0, $240 = 0.0, $243 = 0, $245 = 0, $249 = 0, $252 = 0.0, $258 = 0.0, $26 = 0, $27 = 0, $276 = 0, $279 = 0.0, $28 = 0, $281 = 0, $284 = 0.0, $289 = 0.0, $29 = 0, $296 = 0, $299 = 0.0, $3 = 0, $30 = 0, $305 = 0.0, $31 = 0, $310 = 0, $314 = 0, $32 = 0, $326 = 0, $327 = 0, $33 = 0, $336 = 0, $338 = 0, $34 = 0, $341 = 0, $348 = 0, $35 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $36 = 0, $360 = 0, $365 = 0.0, $366 = 0.0, $37 = 0, $372 = 0.0, $377 = 0.0, $38 = 0, $386 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $40 = 0, $6 = 0, $7 = 0, $77 = 0, $79 = 0, $8 = 0, $80 = 0, $82 = 0, $83 = 0, $85 = 0, $86 = 0, $88 = 0, $91 = 0, $94 = 0, $97 = 0, $99 = 0, $spec$select = 0, $storemerge = 0, $storemerge466 = 0, $vararg_buffer = 0, $vararg_buffer6 = 0, $vararg_buffer9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $vararg_buffer9 = sp + 32 | 0;\n $vararg_buffer6 = sp + 24 | 0;\n $vararg_buffer = sp;\n $2 = sp + 52 | 0;\n $3 = sp + 40 | 0;\n L1 : do if (($0 | 0) != 0 & ($1 | 0) != 0) {\n  $6 = $0 + 44 | 0;\n  HEAP32[$6 >> 2] = 0;\n  $7 = $0 + 7062388 | 0;\n  $8 = HEAP32[$7 >> 2] | 0;\n  L3 : do if (($8 | 0) == 4) {\n   $10 = $0 + 7062396 | 0;\n   $11 = HEAP32[$10 >> 2] | 0;\n   do if (($11 | 0) > 0) HEAP32[$10 >> 2] = $11 + -1; else {\n    $14 = $0 + 16 | 0;\n    $15 = HEAP32[$14 >> 2] | 0;\n    $16 = $0 + 7062400 | 0;\n    $18 = (HEAP32[$16 >> 2] | 0) + $15 | 0;\n    $spec$select = ($18 | 0) < 255 ? $18 : 255;\n    HEAP32[$2 >> 2] = $spec$select;\n    $20 = $0 + 7062404 | 0;\n    $22 = $15 - (HEAP32[$20 >> 2] | 0) | 0;\n    $storemerge466 = ($22 | 0) > 0 ? $22 : 0;\n    HEAP32[$2 + 4 >> 2] = $storemerge466;\n    HEAP32[$2 + 8 >> 2] = $15;\n    $26 = $1 + 12 | 0;\n    $27 = $0 + 36 | 0;\n    $28 = $0 + 40 | 0;\n    $29 = $0 + 12 | 0;\n    $30 = $0 + 20 | 0;\n    $31 = $0 + 4834144 | 0;\n    $32 = $0 + 15416 | 0;\n    $33 = $0 + 15408 | 0;\n    $34 = $0 + 4 | 0;\n    $35 = $0 + 7062384 | 0;\n    $36 = $0 + 24 | 0;\n    $37 = $0 + 32 | 0;\n    $38 = $0 + 7062416 | 0;\n    $39 = $0 + 48 | 0;\n    $40 = $0 + 7062424 | 0;\n    $$0447 = 0;\n    while (1) {\n     if ($$0447 >>> 0 >= 3) break;\n     if ((_arLabeling(HEAP32[$26 >> 2] | 0, HEAP32[$27 >> 2] | 0, HEAP32[$28 >> 2] | 0, HEAP32[$0 >> 2] | 0, HEAP32[$29 >> 2] | 0, HEAP32[$2 + ($$0447 << 2) >> 2] | 0, HEAP32[$30 >> 2] | 0, $31, 0) | 0) < 0) {\n      label = 29;\n      break;\n     }\n     if ((_arDetectMarker2(HEAP32[$27 >> 2] | 0, HEAP32[$28 >> 2] | 0, $31, HEAP32[$30 >> 2] | 0, 1e6, 70, 1.0, $32, $33) | 0) < 0) {\n      label = 29;\n      break;\n     }\n     if ((_arGetMarkerInfo(HEAP32[$1 >> 2] | 0, HEAP32[$27 >> 2] | 0, HEAP32[$28 >> 2] | 0, HEAP32[$34 >> 2] | 0, $32, HEAP32[$33 >> 2] | 0, HEAP32[$35 >> 2] | 0, HEAP32[$30 >> 2] | 0, HEAP32[$36 >> 2] | 0, (HEAP32[$37 >> 2] | 0) + 184 | 0, +HEAPF64[$38 >> 3], $39, $6, HEAP32[$40 >> 2] | 0) | 0) < 0) {\n      label = 29;\n      break;\n     }\n     HEAP32[$3 + ($$0447 << 2) >> 2] = HEAP32[$6 >> 2];\n     $$0447 = $$0447 + 1 | 0;\n    }\n    if ((label | 0) == 29) {\n     $$4 = -1;\n     break L1;\n    }\n    if ((HEAP32[$0 >> 2] | 0) == 1) {\n     $77 = HEAP32[$3 + 4 >> 2] | 0;\n     $79 = HEAP32[$3 + 8 >> 2] | 0;\n     $80 = HEAP32[$3 >> 2] | 0;\n     HEAP32[$vararg_buffer >> 2] = $storemerge466;\n     HEAP32[$vararg_buffer + 4 >> 2] = $77;\n     HEAP32[$vararg_buffer + 8 >> 2] = $15;\n     HEAP32[$vararg_buffer + 12 >> 2] = $79;\n     HEAP32[$vararg_buffer + 16 >> 2] = $spec$select;\n     HEAP32[$vararg_buffer + 20 >> 2] = $80;\n     _arLog(0, 3, 3774, $vararg_buffer);\n     $82 = $80;\n     $83 = $79;\n    } else {\n     $82 = HEAP32[$3 >> 2] | 0;\n     $83 = HEAP32[$3 + 8 >> 2] | 0;\n    }\n    $$pre486 = HEAP32[$3 + 4 >> 2] | 0;\n    if (($82 | 0) > ($83 | 0) | ($$pre486 | 0) > ($83 | 0)) {\n     $99 = ($82 | 0) < ($$pre486 | 0) ? $storemerge466 : $spec$select;\n     HEAP32[$14 >> 2] = $99;\n     $100 = $99 - $15 | 0;\n     if (($100 | 0) > 0) {\n      HEAP32[$16 >> 2] = $100;\n      $storemerge = 1;\n     } else {\n      HEAP32[$16 >> 2] = 1;\n      $storemerge = 0 - $100 | 0;\n     }\n     HEAP32[$20 >> 2] = $storemerge;\n     if ((HEAP32[$0 >> 2] | 0) == 1) {\n      HEAP32[$vararg_buffer6 >> 2] = $99;\n      _arLog(0, 3, 3850, $vararg_buffer6);\n      HEAP32[$10 >> 2] = HEAP32[$0 + 7062392 >> 2];\n      break;\n     } else {\n      HEAP32[$10 >> 2] = HEAP32[$0 + 7062392 >> 2];\n      break;\n     }\n    }\n    $85 = HEAP32[$16 >> 2] | 0;\n    $86 = HEAP32[$20 >> 2] | 0;\n    do if (($85 | 0) < ($86 | 0)) {\n     $88 = $85 + 1 | 0;\n     HEAP32[$16 >> 2] = $88;\n     $94 = $88;\n    } else if (($85 | 0) > ($86 | 0)) {\n     HEAP32[$20 >> 2] = $86 + 1;\n     $94 = $85;\n     break;\n    } else {\n     $91 = $85 + 1 | 0;\n     HEAP32[$16 >> 2] = $91;\n     HEAP32[$20 >> 2] = $86 + 1;\n     $94 = $91;\n     break;\n    } while (0);\n    if (($94 + $15 | 0) > 254) {\n     HEAP32[$16 >> 2] = 1;\n     $97 = 1;\n    } else $97 = $94;\n    if (($15 | 0) <= ($97 | 0)) HEAP32[$20 >> 2] = 1;\n    HEAP32[$10 >> 2] = HEAP32[$0 + 7062392 >> 2];\n    break L3;\n   } while (0);\n   $111 = HEAP32[$7 >> 2] | 0;\n   label = 33;\n  } else {\n   $111 = $8;\n   label = 33;\n  } while (0);\n  if ((label | 0) == 33) {\n   L47 : do switch ($111 | 0) {\n   case 3:\n    {\n     $112 = $0 + 7062408 | 0;\n     $114 = $1 + 12 | 0;\n     $116 = _arImageProcLumaHistAndBoxFilterWithBias(HEAP32[$112 >> 2] | 0, HEAP32[$114 >> 2] | 0, 9, -7) | 0;\n     if (($116 | 0) < 0) {\n      $$4 = $116;\n      break L1;\n     }\n     $119 = HEAP32[$112 >> 2] | 0;\n     $127 = $0 + 4834144 | 0;\n     $129 = _arLabeling(HEAP32[$114 >> 2] | 0, HEAP32[$119 + 4 >> 2] | 0, HEAP32[$119 + 8 >> 2] | 0, HEAP32[$0 >> 2] | 0, HEAP32[$0 + 12 >> 2] | 0, 0, 0, $127, HEAP32[$119 >> 2] | 0) | 0;\n     if (($129 | 0) < 0) {\n      $$4 = $129;\n      break L1;\n     }\n     $$pre$phi501Z2D = $0 + 36 | 0;\n     $$pre$phi503Z2D = $0 + 40 | 0;\n     $$pre$phi505Z2D = $0 + 20 | 0;\n     $$pre$phiZ2D = $127;\n     break;\n    }\n   case 2:\n   case 1:\n    {\n     $131 = $0 + 7062396 | 0;\n     $132 = HEAP32[$131 >> 2] | 0;\n     if (($132 | 0) > 0) {\n      HEAP32[$131 >> 2] = $132 + -1;\n      label = 48;\n      break L47;\n     }\n     $137 = HEAP32[$0 + 7062408 >> 2] | 0;\n     $139 = HEAP32[$1 + 12 >> 2] | 0;\n     if (($111 | 0) == 1) $$0 = _arImageProcLumaHistAndCDFAndMedian($137, $139, $2) | 0; else $$0 = _arImageProcLumaHistAndOtsu($137, $139, $2) | 0;\n     if (($$0 | 0) < 0) {\n      $$4 = $$0;\n      break L1;\n     }\n     $145 = $0 + 16 | 0;\n     if ((HEAP32[$0 >> 2] | 0) == 1) {\n      $148 = HEAPU8[$2 >> 0] | 0;\n      if ((HEAP32[$145 >> 2] | 0) != ($148 | 0)) {\n       HEAP32[$vararg_buffer9 >> 2] = (HEAP32[$7 >> 2] | 0) == 1 ? 3902 : 3909;\n       HEAP32[$vararg_buffer9 + 4 >> 2] = $148;\n       _arLog(0, 3, 3914, $vararg_buffer9);\n      }\n     }\n     HEAP32[$145 >> 2] = HEAPU8[$2 >> 0];\n     HEAP32[$131 >> 2] = HEAP32[$0 + 7062392 >> 2];\n     label = 48;\n     break;\n    }\n   default:\n    label = 48;\n   } while (0);\n   if ((label | 0) == 48) {\n    $159 = $0 + 36 | 0;\n    $161 = $0 + 40 | 0;\n    $168 = $0 + 20 | 0;\n    $170 = $0 + 4834144 | 0;\n    if ((_arLabeling(HEAP32[$1 + 12 >> 2] | 0, HEAP32[$159 >> 2] | 0, HEAP32[$161 >> 2] | 0, HEAP32[$0 >> 2] | 0, HEAP32[$0 + 12 >> 2] | 0, HEAP32[$0 + 16 >> 2] | 0, HEAP32[$168 >> 2] | 0, $170, 0) | 0) < 0) {\n     $$4 = -1;\n     break;\n    } else {\n     $$pre$phi501Z2D = $159;\n     $$pre$phi503Z2D = $161;\n     $$pre$phi505Z2D = $168;\n     $$pre$phiZ2D = $170;\n    }\n   }\n   $176 = $0 + 15416 | 0;\n   $177 = $0 + 15408 | 0;\n   if ((_arDetectMarker2(HEAP32[$$pre$phi501Z2D >> 2] | 0, HEAP32[$$pre$phi503Z2D >> 2] | 0, $$pre$phiZ2D, HEAP32[$$pre$phi505Z2D >> 2] | 0, 1e6, 70, 1.0, $176, $177) | 0) < 0) {\n    $$4 = -1;\n    break;\n   }\n   if ((_arGetMarkerInfo(HEAP32[$1 >> 2] | 0, HEAP32[$$pre$phi501Z2D >> 2] | 0, HEAP32[$$pre$phi503Z2D >> 2] | 0, HEAP32[$0 + 4 >> 2] | 0, $176, HEAP32[$177 >> 2] | 0, HEAP32[$0 + 7062384 >> 2] | 0, HEAP32[$$pre$phi505Z2D >> 2] | 0, HEAP32[$0 + 24 >> 2] | 0, (HEAP32[$0 + 32 >> 2] | 0) + 184 | 0, +HEAPF64[$0 + 7062416 >> 3], $0 + 48 | 0, $6, HEAP32[$0 + 7062424 >> 2] | 0) | 0) < 0) {\n    $$4 = -1;\n    break;\n   }\n  }\n  $201 = $0 + 28 | 0;\n  if ((HEAP32[$201 >> 2] | 0) == 1) {\n   _confidenceCutoff($0);\n   $$4 = 0;\n   break;\n  }\n  $204 = $0 + 4818296 | 0;\n  $205 = HEAP32[$204 >> 2] | 0;\n  $206 = $0 + 24 | 0;\n  $$1448 = 0;\n  while (1) {\n   if (($$1448 | 0) >= ($205 | 0)) break;\n   $208 = HEAP32[$6 >> 2] | 0;\n   $209 = $0 + 4818304 + ($$1448 * 264 | 0) | 0;\n   $210 = $0 + 4818304 + ($$1448 * 264 | 0) + 56 | 0;\n   $211 = $0 + 4818304 + ($$1448 * 264 | 0) + 64 | 0;\n   $$0442 = 0;\n   $$0456 = -1;\n   $$0464 = .5;\n   while (1) {\n    if (($$0442 | 0) >= ($208 | 0)) break;\n    $217 = +(HEAP32[$0 + 48 + ($$0442 << 8) >> 2] | 0);\n    $218 = +(HEAP32[$209 >> 2] | 0) / $217;\n    if ($218 < .7 | $218 > 1.43) {\n     $$1457 = $$0456;\n     $$1465 = $$0464;\n    } else {\n     $224 = +HEAPF64[$0 + 48 + ($$0442 << 8) + 56 >> 3] - +HEAPF64[$210 >> 3];\n     $229 = +HEAPF64[$0 + 48 + ($$0442 << 8) + 64 >> 3] - +HEAPF64[$211 >> 3];\n     $232 = ($224 * $224 + $229 * $229) / $217;\n     if ($232 < $$0464) {\n      $$1457 = $$0442;\n      $$1465 = $232;\n     } else {\n      $$1457 = $$0456;\n      $$1465 = $$0464;\n     }\n    }\n    $$0442 = $$0442 + 1 | 0;\n    $$0456 = $$1457;\n    $$0464 = $$1465;\n   }\n   L85 : do if (($$0456 | 0) > -1) {\n    $236 = HEAP32[$206 >> 2] | 0;\n    switch ($236 | 0) {\n    case 2:\n    case 1:\n    case 0:\n     break;\n    case 4:\n    case 3:\n     {\n      $276 = $0 + 48 + ($$0456 << 8) + 40 | 0;\n      $279 = +HEAPF64[$0 + 4818304 + ($$1448 * 264 | 0) + 40 >> 3];\n      if (+HEAPF64[$276 >> 3] < $279) {\n       $$pre$phi495Z2D = $0 + 48 + ($$0456 << 8) + 48 | 0;\n       $289 = +HEAPF64[$0 + 4818304 + ($$1448 * 264 | 0) + 48 >> 3];\n      } else {\n       $281 = $0 + 48 + ($$0456 << 8) + 48 | 0;\n       $284 = +HEAPF64[$0 + 4818304 + ($$1448 * 264 | 0) + 48 >> 3];\n       if (+HEAPF64[$281 >> 3] < $284) {\n        $$pre$phi495Z2D = $281;\n        $289 = $284;\n       } else break L85;\n      }\n      HEAPF64[$276 >> 3] = $279;\n      HEAP32[$0 + 48 + ($$0456 << 8) + 8 >> 2] = HEAP32[$0 + 4818304 + ($$1448 * 264 | 0) + 8 >> 2];\n      HEAPF64[$$pre$phi495Z2D >> 3] = $289;\n      HEAP32[$0 + 48 + ($$0456 << 8) + 12 >> 2] = HEAP32[$0 + 4818304 + ($$1448 * 264 | 0) + 12 >> 2];\n      $$2444 = 0;\n      $$2454 = -1;\n      $$2460 = 1.0e8;\n      while (1) {\n       if (($$2444 | 0) == 4) break;\n       $$1441 = 0;\n       $$1463 = 0.0;\n       while (1) {\n        if (($$1441 | 0) == 4) break;\n        $296 = $$1441 + $$2444 & 3;\n        $299 = +HEAPF64[$0 + 4818304 + ($$1448 * 264 | 0) + 168 + ($$1441 << 4) >> 3] - +HEAPF64[$0 + 48 + ($$0456 << 8) + 168 + ($296 << 4) >> 3];\n        $305 = +HEAPF64[$0 + 4818304 + ($$1448 * 264 | 0) + 168 + ($$1441 << 4) + 8 >> 3] - +HEAPF64[$0 + 48 + ($$0456 << 8) + 168 + ($296 << 4) + 8 >> 3];\n        $$1441 = $$1441 + 1 | 0;\n        $$1463 = $$1463 + ($299 * $299 + $305 * $305);\n       }\n       $310 = $$1463 < $$2460;\n       $$3455 = $310 ? $$2444 : $$2454;\n       $$2444 = $$2444 + 1 | 0;\n       $$2454 = $$3455;\n       $$2460 = $310 ? $$1463 : $$2460;\n      }\n      $314 = 4 - $$2454 | 0;\n      HEAP32[$0 + 48 + ($$0456 << 8) + 20 >> 2] = ($314 + (HEAP32[$0 + 4818304 + ($$1448 * 264 | 0) + 20 >> 2] | 0) | 0) % 4 | 0;\n      HEAP32[$0 + 48 + ($$0456 << 8) + 24 >> 2] = ($314 + (HEAP32[$0 + 4818304 + ($$1448 * 264 | 0) + 24 >> 2] | 0) | 0) % 4 | 0;\n      break L85;\n      break;\n     }\n    default:\n     {\n      $$4 = -1;\n      break L1;\n     }\n    }\n    $237 = $0 + 48 + ($$0456 << 8) + 32 | 0;\n    $240 = +HEAPF64[$0 + 4818304 + ($$1448 * 264 | 0) + 32 >> 3];\n    if (+HEAPF64[$237 >> 3] < $240) {\n     HEAPF64[$237 >> 3] = $240;\n     $243 = HEAP32[$0 + 4818304 + ($$1448 * 264 | 0) + 4 >> 2] | 0;\n     HEAP32[$0 + 48 + ($$0456 << 8) + 4 >> 2] = $243;\n     $245 = $0 + 4818304 + ($$1448 * 264 | 0) + 16 | 0;\n     $$0452 = -1;\n     $$0458 = 1.0e8;\n     $$1443 = 0;\n     while (1) {\n      if (($$1443 | 0) == 4) break;\n      $$0440 = 0;\n      $$0462 = 0.0;\n      while (1) {\n       if (($$0440 | 0) == 4) break;\n       $249 = $$0440 + $$1443 & 3;\n       $252 = +HEAPF64[$0 + 4818304 + ($$1448 * 264 | 0) + 168 + ($$0440 << 4) >> 3] - +HEAPF64[$0 + 48 + ($$0456 << 8) + 168 + ($249 << 4) >> 3];\n       $258 = +HEAPF64[$0 + 4818304 + ($$1448 * 264 | 0) + 168 + ($$0440 << 4) + 8 >> 3] - +HEAPF64[$0 + 48 + ($$0456 << 8) + 168 + ($249 << 4) + 8 >> 3];\n       $$0440 = $$0440 + 1 | 0;\n       $$0462 = $$0462 + ($252 * $252 + $258 * $258);\n      }\n      if ($$0462 < $$0458) {\n       $$1453 = (4 - $$1443 + (HEAP32[$245 >> 2] | 0) | 0) % 4 | 0;\n       $$1459 = $$0462;\n      } else {\n       $$1453 = $$0452;\n       $$1459 = $$0458;\n      }\n      $$0452 = $$1453;\n      $$0458 = $$1459;\n      $$1443 = $$1443 + 1 | 0;\n     }\n     HEAP32[$0 + 48 + ($$0456 << 8) + 16 >> 2] = $$0452;\n     if ($236 >>> 0 < 2) {\n      HEAP32[$0 + 48 + ($$0456 << 8) + 8 >> 2] = $243;\n      HEAPF64[$0 + 48 + ($$0456 << 8) + 40 >> 3] = $240;\n      HEAP32[$0 + 48 + ($$0456 << 8) + 20 >> 2] = $$0452;\n      break;\n     } else {\n      HEAP32[$0 + 48 + ($$0456 << 8) + 12 >> 2] = $243;\n      HEAPF64[$0 + 48 + ($$0456 << 8) + 48 >> 3] = $240;\n      HEAP32[$0 + 48 + ($$0456 << 8) + 24 >> 2] = $$0452;\n      break;\n     }\n    }\n   } while (0);\n   $$1448 = $$1448 + 1 | 0;\n  }\n  _confidenceCutoff($0);\n  $$2449 = 0;\n  $$3445 = 0;\n  while (1) {\n   if (($$2449 | 0) >= (HEAP32[$204 >> 2] | 0)) break;\n   $326 = $0 + 4818304 + ($$2449 * 264 | 0) + 256 | 0;\n   $327 = HEAP32[$326 >> 2] | 0;\n   HEAP32[$326 >> 2] = $327 + 1;\n   if (($327 | 0) < 3) {\n    if (($$2449 | 0) != ($$3445 | 0)) _memcpy($0 + 4818304 + ($$3445 * 264 | 0) | 0, $0 + 4818304 + ($$2449 * 264 | 0) | 0, 264) | 0;\n    $$4446 = $$3445 + 1 | 0;\n   } else $$4446 = $$3445;\n   $$2449 = $$2449 + 1 | 0;\n   $$3445 = $$4446;\n  }\n  HEAP32[$204 >> 2] = $$3445;\n  $$pre487 = HEAP32[$6 >> 2] | 0;\n  $$3450 = 0;\n  $341 = $$3445;\n  while (1) {\n   if (($$3450 | 0) >= ($$pre487 | 0)) break;\n   $336 = $0 + 48 + ($$3450 << 8) | 0;\n   $338 = HEAP32[$0 + 48 + ($$3450 << 8) + 4 >> 2] | 0;\n   if (($338 | 0) < 0) $388 = $341; else {\n    $$5 = 0;\n    while (1) {\n     if (($$5 | 0) >= ($341 | 0)) break;\n     if ((HEAP32[$0 + 4818304 + ($$5 * 264 | 0) + 4 >> 2] | 0) == ($338 | 0)) break;\n     $$5 = $$5 + 1 | 0;\n    }\n    if (($$5 | 0) == ($341 | 0)) {\n     if (($341 | 0) == 60) break;\n     $348 = $341 + 1 | 0;\n     HEAP32[$204 >> 2] = $348;\n     $389 = $348;\n    } else $389 = $341;\n    _memcpy($0 + 4818304 + ($$5 * 264 | 0) | 0, $336 | 0, 256) | 0;\n    HEAP32[$0 + 4818304 + ($$5 * 264 | 0) + 256 >> 2] = 1;\n    $388 = $389;\n   }\n   $$3450 = $$3450 + 1 | 0;\n   $341 = $388;\n  }\n  if ((HEAP32[$201 >> 2] | 0) == 2) $$4 = 0; else {\n   $$4451 = 0;\n   $355 = $341;\n   $360 = $$pre487;\n   while (1) {\n    if (($$4451 | 0) >= ($355 | 0)) {\n     $$4 = 0;\n     break L1;\n    }\n    $356 = $0 + 4818304 + ($$4451 * 264 | 0) | 0;\n    $357 = $0 + 4818304 + ($$4451 * 264 | 0) + 56 | 0;\n    $358 = $0 + 4818304 + ($$4451 * 264 | 0) + 64 | 0;\n    $$6 = 0;\n    while (1) {\n     if (($$6 | 0) >= ($360 | 0)) break;\n     $365 = +(HEAP32[$0 + 48 + ($$6 << 8) >> 2] | 0);\n     $366 = +(HEAP32[$356 >> 2] | 0) / $365;\n     if (!($366 < .7 | $366 > 1.43)) {\n      $372 = +HEAPF64[$0 + 48 + ($$6 << 8) + 56 >> 3] - +HEAPF64[$357 >> 3];\n      $377 = +HEAPF64[$0 + 48 + ($$6 << 8) + 64 >> 3] - +HEAPF64[$358 >> 3];\n      if (($372 * $372 + $377 * $377) / $365 < .5) break;\n     }\n     $$6 = $$6 + 1 | 0;\n    }\n    if (($$6 | 0) == ($360 | 0)) {\n     _memcpy($0 + 48 + ($360 << 8) | 0, $0 + 4818304 + ($$4451 * 264 | 0) | 0, 256) | 0;\n     $386 = $360 + 1 | 0;\n     HEAP32[$6 >> 2] = $386;\n     $$pre488 = HEAP32[$204 >> 2] | 0;\n     $390 = $386;\n    } else {\n     $$pre488 = $355;\n     $390 = $360;\n    }\n    $$4451 = $$4451 + 1 | 0;\n    $355 = $$pre488;\n    $360 = $390;\n   }\n  }\n } else $$4 = -1; while (0);\n STACKTOP = sp;\n return $$4 | 0;\n}\n\nfunction _printf_core($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0228 = 0, $$0229334 = 0, $$0232 = 0, $$0235 = 0, $$0237 = 0, $$0240313 = 0, $$0240313371 = 0, $$0240333 = 0, $$0243 = 0, $$0243$ph = 0, $$0243$ph$be = 0, $$0247 = 0, $$0247$ph = 0, $$0249$lcssa = 0, $$0249321 = 0, $$0252 = 0, $$0253 = 0, $$0254 = 0, $$0259 = 0, $$0262$lcssa = 0, $$0262328 = 0, $$0269$ph = 0, $$1 = 0, $$1230340 = 0, $$1233 = 0, $$1236 = 0, $$1238 = 0, $$1241339 = 0, $$1248 = 0, $$1255 = 0, $$1260 = 0, $$1263 = 0, $$1270 = 0, $$2 = 0, $$2234 = 0, $$2239 = 0, $$2242320 = 0, $$2256 = 0, $$2261 = 0, $$2271 = 0, $$3265 = 0, $$3272 = 0, $$3317 = 0, $$4258370 = 0, $$4266 = 0, $$5 = 0, $$6268 = 0, $$lcssa308 = 0, $$pre$phiZ2D = 0, $$pre360 = 0, $$pre363 = 0, $$sink = 0, $10 = 0, $102 = 0, $103 = 0, $106 = 0, $109 = 0, $11 = 0, $112 = 0, $114 = 0, $12 = 0, $122 = 0, $126 = 0, $13 = 0, $137 = 0, $14 = 0, $141 = 0, $148 = 0, $149 = 0, $151 = 0, $152 = 0, $154 = 0, $163 = 0, $164 = 0, $169 = 0, $172 = 0, $177 = 0, $178 = 0, $18 = 0, $183 = 0, $185 = 0, $192 = 0, $193 = 0, $20 = 0, $204 = 0, $21 = 0, $216 = 0, $223 = 0, $225 = 0, $228 = 0, $23 = 0, $230 = 0, $238 = 0, $24 = 0, $240 = 0, $243 = 0, $244 = 0, $248 = 0, $25 = 0, $252 = 0, $254 = 0, $257 = 0, $259 = 0, $260 = 0, $261 = 0, $27 = 0, $271 = 0, $272 = 0, $277 = 0, $279 = 0, $280 = 0, $286 = 0, $295 = 0, $298 = 0, $30 = 0, $301 = 0, $302 = 0, $315 = 0, $317 = 0, $318 = 0, $322 = 0, $326 = 0, $328 = 0, $339 = 0, $341 = 0, $348 = 0, $351 = 0, $358 = 0, $359 = 0, $43 = 0, $5 = 0, $51 = 0, $52 = 0, $54 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $7 = 0, $76 = 0, $8 = 0, $80 = 0, $9 = 0, $or$cond = 0, $or$cond278 = 0, $spec$select = 0, $spec$select284 = 0, $storemerge273$lcssa = 0, $storemerge273327 = 0, $storemerge274 = 0, label = 0, sp = 0, $154$looptemp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $5 = sp + 16 | 0;\n $6 = sp;\n $7 = sp + 24 | 0;\n $8 = sp + 8 | 0;\n $9 = sp + 20 | 0;\n HEAP32[$5 >> 2] = $1;\n $10 = ($0 | 0) != 0;\n $11 = $7 + 40 | 0;\n $12 = $11;\n $13 = $7 + 39 | 0;\n $14 = $8 + 4 | 0;\n $$0243$ph = 0;\n $$0247$ph = 0;\n $$0269$ph = 0;\n L1 : while (1) {\n  $$0243 = $$0243$ph;\n  $$0247 = $$0247$ph;\n  while (1) {\n   do if (($$0247 | 0) > -1) if (($$0243 | 0) > (2147483647 - $$0247 | 0)) {\n    $18 = ___errno_location() | 0;\n    HEAP32[$18 >> 2] = 75;\n    $$1248 = -1;\n    break;\n   } else {\n    $$1248 = $$0243 + $$0247 | 0;\n    break;\n   } else $$1248 = $$0247; while (0);\n   $20 = HEAP32[$5 >> 2] | 0;\n   $21 = HEAP8[$20 >> 0] | 0;\n   if (!($21 << 24 >> 24)) {\n    label = 94;\n    break L1;\n   }\n   $23 = $21;\n   $25 = $20;\n   L12 : while (1) {\n    switch ($23 << 24 >> 24) {\n    case 37:\n     {\n      label = 10;\n      break L12;\n      break;\n     }\n    case 0:\n     {\n      $$0249$lcssa = $25;\n      break L12;\n      break;\n     }\n    default:\n     {}\n    }\n    $24 = $25 + 1 | 0;\n    HEAP32[$5 >> 2] = $24;\n    $23 = HEAP8[$24 >> 0] | 0;\n    $25 = $24;\n   }\n   L15 : do if ((label | 0) == 10) {\n    label = 0;\n    $$0249321 = $25;\n    $27 = $25;\n    while (1) {\n     if ((HEAP8[$27 + 1 >> 0] | 0) != 37) {\n      $$0249$lcssa = $$0249321;\n      break L15;\n     }\n     $30 = $$0249321 + 1 | 0;\n     $27 = $27 + 2 | 0;\n     HEAP32[$5 >> 2] = $27;\n     if ((HEAP8[$27 >> 0] | 0) != 37) {\n      $$0249$lcssa = $30;\n      break;\n     } else $$0249321 = $30;\n    }\n   } while (0);\n   $$0243 = $$0249$lcssa - $20 | 0;\n   if ($10) _out_670($0, $20, $$0243);\n   if (!$$0243) break; else $$0247 = $$1248;\n  }\n  $43 = (_isdigit(HEAP8[(HEAP32[$5 >> 2] | 0) + 1 >> 0] | 0) | 0) == 0;\n  $$pre360 = HEAP32[$5 >> 2] | 0;\n  if ($43) {\n   $$0253 = -1;\n   $$1270 = $$0269$ph;\n   $$sink = 1;\n  } else if ((HEAP8[$$pre360 + 2 >> 0] | 0) == 36) {\n   $$0253 = (HEAP8[$$pre360 + 1 >> 0] | 0) + -48 | 0;\n   $$1270 = 1;\n   $$sink = 3;\n  } else {\n   $$0253 = -1;\n   $$1270 = $$0269$ph;\n   $$sink = 1;\n  }\n  $51 = $$pre360 + $$sink | 0;\n  HEAP32[$5 >> 2] = $51;\n  $52 = HEAP8[$51 >> 0] | 0;\n  $54 = ($52 << 24 >> 24) + -32 | 0;\n  if ($54 >>> 0 > 31 | (1 << $54 & 75913 | 0) == 0) {\n   $$0262$lcssa = 0;\n   $$lcssa308 = $52;\n   $storemerge273$lcssa = $51;\n  } else {\n   $$0262328 = 0;\n   $60 = $54;\n   $storemerge273327 = $51;\n   while (1) {\n    $61 = 1 << $60 | $$0262328;\n    $62 = $storemerge273327 + 1 | 0;\n    HEAP32[$5 >> 2] = $62;\n    $63 = HEAP8[$62 >> 0] | 0;\n    $60 = ($63 << 24 >> 24) + -32 | 0;\n    if ($60 >>> 0 > 31 | (1 << $60 & 75913 | 0) == 0) {\n     $$0262$lcssa = $61;\n     $$lcssa308 = $63;\n     $storemerge273$lcssa = $62;\n     break;\n    } else {\n     $$0262328 = $61;\n     $storemerge273327 = $62;\n    }\n   }\n  }\n  if ($$lcssa308 << 24 >> 24 == 42) {\n   if (!(_isdigit(HEAP8[$storemerge273$lcssa + 1 >> 0] | 0) | 0)) label = 27; else {\n    $76 = HEAP32[$5 >> 2] | 0;\n    if ((HEAP8[$76 + 2 >> 0] | 0) == 36) {\n     $80 = $76 + 1 | 0;\n     HEAP32[$4 + ((HEAP8[$80 >> 0] | 0) + -48 << 2) >> 2] = 10;\n     $$0259 = HEAP32[$3 + ((HEAP8[$80 >> 0] | 0) + -48 << 3) >> 2] | 0;\n     $$2271 = 1;\n     $storemerge274 = $76 + 3 | 0;\n    } else label = 27;\n   }\n   if ((label | 0) == 27) {\n    label = 0;\n    if ($$1270 | 0) {\n     $$0 = -1;\n     break;\n    }\n    if ($10) {\n     $102 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n     $103 = HEAP32[$102 >> 2] | 0;\n     HEAP32[$2 >> 2] = $102 + 4;\n     $358 = $103;\n    } else $358 = 0;\n    $$0259 = $358;\n    $$2271 = 0;\n    $storemerge274 = (HEAP32[$5 >> 2] | 0) + 1 | 0;\n   }\n   HEAP32[$5 >> 2] = $storemerge274;\n   $106 = ($$0259 | 0) < 0;\n   $$1260 = $106 ? 0 - $$0259 | 0 : $$0259;\n   $$1263 = $106 ? $$0262$lcssa | 8192 : $$0262$lcssa;\n   $$3272 = $$2271;\n   $112 = $storemerge274;\n  } else {\n   $109 = _getint_671($5) | 0;\n   if (($109 | 0) < 0) {\n    $$0 = -1;\n    break;\n   }\n   $$1260 = $109;\n   $$1263 = $$0262$lcssa;\n   $$3272 = $$1270;\n   $112 = HEAP32[$5 >> 2] | 0;\n  }\n  do if ((HEAP8[$112 >> 0] | 0) == 46) {\n   $114 = $112 + 1 | 0;\n   if ((HEAP8[$114 >> 0] | 0) != 42) {\n    HEAP32[$5 >> 2] = $114;\n    $152 = _getint_671($5) | 0;\n    $$0254 = $152;\n    $$pre363 = HEAP32[$5 >> 2] | 0;\n    break;\n   }\n   if (_isdigit(HEAP8[$112 + 2 >> 0] | 0) | 0) {\n    $122 = HEAP32[$5 >> 2] | 0;\n    if ((HEAP8[$122 + 3 >> 0] | 0) == 36) {\n     $126 = $122 + 2 | 0;\n     HEAP32[$4 + ((HEAP8[$126 >> 0] | 0) + -48 << 2) >> 2] = 10;\n     $137 = HEAP32[$3 + ((HEAP8[$126 >> 0] | 0) + -48 << 3) >> 2] | 0;\n     $141 = $122 + 4 | 0;\n     HEAP32[$5 >> 2] = $141;\n     $$0254 = $137;\n     $$pre363 = $141;\n     break;\n    }\n   }\n   if ($$3272 | 0) {\n    $$0 = -1;\n    break L1;\n   }\n   if ($10) {\n    $148 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n    $149 = HEAP32[$148 >> 2] | 0;\n    HEAP32[$2 >> 2] = $148 + 4;\n    $359 = $149;\n   } else $359 = 0;\n   $151 = (HEAP32[$5 >> 2] | 0) + 2 | 0;\n   HEAP32[$5 >> 2] = $151;\n   $$0254 = $359;\n   $$pre363 = $151;\n  } else {\n   $$0254 = -1;\n   $$pre363 = $112;\n  } while (0);\n  $$0252 = 0;\n  $154 = $$pre363;\n  while (1) {\n   if (((HEAP8[$154 >> 0] | 0) + -65 | 0) >>> 0 > 57) {\n    $$0 = -1;\n    break L1;\n   }\n   $154$looptemp = $154;\n   $154 = $154 + 1 | 0;\n   HEAP32[$5 >> 2] = $154;\n   $163 = HEAP8[(HEAP8[$154$looptemp >> 0] | 0) + -65 + (12038 + ($$0252 * 58 | 0)) >> 0] | 0;\n   $164 = $163 & 255;\n   if (($164 + -1 | 0) >>> 0 >= 8) break; else $$0252 = $164;\n  }\n  if (!($163 << 24 >> 24)) {\n   $$0 = -1;\n   break;\n  }\n  $169 = ($$0253 | 0) > -1;\n  do if ($163 << 24 >> 24 == 19) if ($169) {\n   $$0 = -1;\n   break L1;\n  } else label = 54; else {\n   if ($169) {\n    HEAP32[$4 + ($$0253 << 2) >> 2] = $164;\n    $172 = $3 + ($$0253 << 3) | 0;\n    $177 = HEAP32[$172 + 4 >> 2] | 0;\n    $178 = $6;\n    HEAP32[$178 >> 2] = HEAP32[$172 >> 2];\n    HEAP32[$178 + 4 >> 2] = $177;\n    label = 54;\n    break;\n   }\n   if (!$10) {\n    $$0 = 0;\n    break L1;\n   }\n   _pop_arg_673($6, $164, $2);\n   $183 = HEAP32[$5 >> 2] | 0;\n   label = 55;\n  } while (0);\n  if ((label | 0) == 54) {\n   label = 0;\n   if ($10) {\n    $183 = $154;\n    label = 55;\n   } else $$0243$ph$be = 0;\n  }\n  L77 : do if ((label | 0) == 55) {\n   label = 0;\n   $185 = HEAP8[$183 + -1 >> 0] | 0;\n   $$0235 = ($$0252 | 0) != 0 & ($185 & 15 | 0) == 3 ? $185 & -33 : $185;\n   $192 = $$1263 & -65537;\n   $spec$select = ($$1263 & 8192 | 0) == 0 ? $$1263 : $192;\n   L79 : do switch ($$0235 | 0) {\n   case 110:\n    {\n     switch (($$0252 & 255) << 24 >> 24) {\n     case 0:\n      {\n       HEAP32[HEAP32[$6 >> 2] >> 2] = $$1248;\n       $$0243$ph$be = 0;\n       break L77;\n       break;\n      }\n     case 1:\n      {\n       HEAP32[HEAP32[$6 >> 2] >> 2] = $$1248;\n       $$0243$ph$be = 0;\n       break L77;\n       break;\n      }\n     case 2:\n      {\n       $204 = HEAP32[$6 >> 2] | 0;\n       HEAP32[$204 >> 2] = $$1248;\n       HEAP32[$204 + 4 >> 2] = (($$1248 | 0) < 0) << 31 >> 31;\n       $$0243$ph$be = 0;\n       break L77;\n       break;\n      }\n     case 3:\n      {\n       HEAP16[HEAP32[$6 >> 2] >> 1] = $$1248;\n       $$0243$ph$be = 0;\n       break L77;\n       break;\n      }\n     case 4:\n      {\n       HEAP8[HEAP32[$6 >> 2] >> 0] = $$1248;\n       $$0243$ph$be = 0;\n       break L77;\n       break;\n      }\n     case 6:\n      {\n       HEAP32[HEAP32[$6 >> 2] >> 2] = $$1248;\n       $$0243$ph$be = 0;\n       break L77;\n       break;\n      }\n     case 7:\n      {\n       $216 = HEAP32[$6 >> 2] | 0;\n       HEAP32[$216 >> 2] = $$1248;\n       HEAP32[$216 + 4 >> 2] = (($$1248 | 0) < 0) << 31 >> 31;\n       $$0243$ph$be = 0;\n       break L77;\n       break;\n      }\n     default:\n      {\n       $$0243$ph$be = 0;\n       break L77;\n      }\n     }\n     break;\n    }\n   case 112:\n    {\n     $$1236 = 120;\n     $$1255 = $$0254 >>> 0 > 8 ? $$0254 : 8;\n     $$3265 = $spec$select | 8;\n     label = 67;\n     break;\n    }\n   case 88:\n   case 120:\n    {\n     $$1236 = $$0235;\n     $$1255 = $$0254;\n     $$3265 = $spec$select;\n     label = 67;\n     break;\n    }\n   case 111:\n    {\n     $238 = $6;\n     $240 = HEAP32[$238 >> 2] | 0;\n     $243 = HEAP32[$238 + 4 >> 2] | 0;\n     $244 = _fmt_o($240, $243, $11) | 0;\n     $248 = $12 - $244 | 0;\n     $$0228 = $244;\n     $$1233 = 0;\n     $$1238 = 12502;\n     $$2256 = ($spec$select & 8 | 0) == 0 | ($$0254 | 0) > ($248 | 0) ? $$0254 : $248 + 1 | 0;\n     $$4266 = $spec$select;\n     $277 = $240;\n     $279 = $243;\n     label = 73;\n     break;\n    }\n   case 105:\n   case 100:\n    {\n     $252 = $6;\n     $254 = HEAP32[$252 >> 2] | 0;\n     $257 = HEAP32[$252 + 4 >> 2] | 0;\n     if (($257 | 0) < 0) {\n      $259 = _i64Subtract(0, 0, $254 | 0, $257 | 0) | 0;\n      $260 = tempRet0;\n      $261 = $6;\n      HEAP32[$261 >> 2] = $259;\n      HEAP32[$261 + 4 >> 2] = $260;\n      $$0232 = 1;\n      $$0237 = 12502;\n      $271 = $259;\n      $272 = $260;\n      label = 72;\n      break L79;\n     } else {\n      $$0232 = ($spec$select & 2049 | 0) != 0 & 1;\n      $$0237 = ($spec$select & 2048 | 0) == 0 ? (($spec$select & 1 | 0) == 0 ? 12502 : 12504) : 12503;\n      $271 = $254;\n      $272 = $257;\n      label = 72;\n      break L79;\n     }\n     break;\n    }\n   case 117:\n    {\n     $193 = $6;\n     $$0232 = 0;\n     $$0237 = 12502;\n     $271 = HEAP32[$193 >> 2] | 0;\n     $272 = HEAP32[$193 + 4 >> 2] | 0;\n     label = 72;\n     break;\n    }\n   case 99:\n    {\n     HEAP8[$13 >> 0] = HEAP32[$6 >> 2];\n     $$2 = $13;\n     $$2234 = 0;\n     $$2239 = 12502;\n     $$5 = 1;\n     $$6268 = $192;\n     $$pre$phiZ2D = $12;\n     break;\n    }\n   case 109:\n    {\n     $295 = ___errno_location() | 0;\n     $$1 = _strerror(HEAP32[$295 >> 2] | 0) | 0;\n     label = 77;\n     break;\n    }\n   case 115:\n    {\n     $298 = HEAP32[$6 >> 2] | 0;\n     $$1 = ($298 | 0) == 0 ? 12512 : $298;\n     label = 77;\n     break;\n    }\n   case 67:\n    {\n     HEAP32[$8 >> 2] = HEAP32[$6 >> 2];\n     HEAP32[$14 >> 2] = 0;\n     HEAP32[$6 >> 2] = $8;\n     $$4258370 = -1;\n     label = 81;\n     break;\n    }\n   case 83:\n    {\n     if (!$$0254) {\n      _pad_676($0, 32, $$1260, 0, $spec$select);\n      $$0240313371 = 0;\n      label = 91;\n     } else {\n      $$4258370 = $$0254;\n      label = 81;\n     }\n     break;\n    }\n   case 65:\n   case 71:\n   case 70:\n   case 69:\n   case 97:\n   case 103:\n   case 102:\n   case 101:\n    {\n     $$0243$ph$be = _fmt_fp($0, +HEAPF64[$6 >> 3], $$1260, $$0254, $spec$select, $$0235) | 0;\n     break L77;\n     break;\n    }\n   default:\n    {\n     $$2 = $20;\n     $$2234 = 0;\n     $$2239 = 12502;\n     $$5 = $$0254;\n     $$6268 = $spec$select;\n     $$pre$phiZ2D = $12;\n    }\n   } while (0);\n   L103 : do if ((label | 0) == 67) {\n    label = 0;\n    $223 = $6;\n    $225 = HEAP32[$223 >> 2] | 0;\n    $228 = HEAP32[$223 + 4 >> 2] | 0;\n    $230 = _fmt_x($225, $228, $11, $$1236 & 32) | 0;\n    $or$cond278 = ($$3265 & 8 | 0) == 0 | ($225 | 0) == 0 & ($228 | 0) == 0;\n    $$0228 = $230;\n    $$1233 = $or$cond278 ? 0 : 2;\n    $$1238 = $or$cond278 ? 12502 : 12502 + ($$1236 >>> 4) | 0;\n    $$2256 = $$1255;\n    $$4266 = $$3265;\n    $277 = $225;\n    $279 = $228;\n    label = 73;\n   } else if ((label | 0) == 72) {\n    label = 0;\n    $$0228 = _fmt_u($271, $272, $11) | 0;\n    $$1233 = $$0232;\n    $$1238 = $$0237;\n    $$2256 = $$0254;\n    $$4266 = $spec$select;\n    $277 = $271;\n    $279 = $272;\n    label = 73;\n   } else if ((label | 0) == 77) {\n    label = 0;\n    $301 = _memchr($$1, 0, $$0254) | 0;\n    $302 = ($301 | 0) == 0;\n    $$2 = $$1;\n    $$2234 = 0;\n    $$2239 = 12502;\n    $$5 = $302 ? $$0254 : $301 - $$1 | 0;\n    $$6268 = $192;\n    $$pre$phiZ2D = $302 ? $$1 + $$0254 | 0 : $301;\n   } else if ((label | 0) == 81) {\n    label = 0;\n    $$0229334 = HEAP32[$6 >> 2] | 0;\n    $$0240333 = 0;\n    while (1) {\n     $315 = HEAP32[$$0229334 >> 2] | 0;\n     if (!$315) {\n      $$0240313 = $$0240333;\n      break;\n     }\n     $317 = _wctomb($9, $315) | 0;\n     $318 = ($317 | 0) < 0;\n     if ($318 | $317 >>> 0 > ($$4258370 - $$0240333 | 0) >>> 0) {\n      label = 85;\n      break;\n     }\n     $322 = $317 + $$0240333 | 0;\n     if ($$4258370 >>> 0 > $322 >>> 0) {\n      $$0229334 = $$0229334 + 4 | 0;\n      $$0240333 = $322;\n     } else {\n      $$0240313 = $322;\n      break;\n     }\n    }\n    if ((label | 0) == 85) {\n     label = 0;\n     if ($318) {\n      $$0 = -1;\n      break L1;\n     } else $$0240313 = $$0240333;\n    }\n    _pad_676($0, 32, $$1260, $$0240313, $spec$select);\n    if (!$$0240313) {\n     $$0240313371 = 0;\n     label = 91;\n    } else {\n     $$1230340 = HEAP32[$6 >> 2] | 0;\n     $$1241339 = 0;\n     while (1) {\n      $326 = HEAP32[$$1230340 >> 2] | 0;\n      if (!$326) {\n       $$0240313371 = $$0240313;\n       label = 91;\n       break L103;\n      }\n      $328 = _wctomb($9, $326) | 0;\n      $$1241339 = $328 + $$1241339 | 0;\n      if (($$1241339 | 0) > ($$0240313 | 0)) {\n       $$0240313371 = $$0240313;\n       label = 91;\n       break L103;\n      }\n      _out_670($0, $9, $328);\n      if ($$1241339 >>> 0 >= $$0240313 >>> 0) {\n       $$0240313371 = $$0240313;\n       label = 91;\n       break;\n      } else $$1230340 = $$1230340 + 4 | 0;\n     }\n    }\n   } while (0);\n   if ((label | 0) == 73) {\n    label = 0;\n    $280 = ($277 | 0) != 0 | ($279 | 0) != 0;\n    $or$cond = ($$2256 | 0) != 0 | $280;\n    $286 = $12 - $$0228 + (($280 ^ 1) & 1) | 0;\n    $$2 = $or$cond ? $$0228 : $11;\n    $$2234 = $$1233;\n    $$2239 = $$1238;\n    $$5 = $or$cond ? (($$2256 | 0) > ($286 | 0) ? $$2256 : $286) : 0;\n    $$6268 = ($$2256 | 0) > -1 ? $$4266 & -65537 : $$4266;\n    $$pre$phiZ2D = $12;\n   } else if ((label | 0) == 91) {\n    label = 0;\n    _pad_676($0, 32, $$1260, $$0240313371, $spec$select ^ 8192);\n    $$0243$ph$be = ($$1260 | 0) > ($$0240313371 | 0) ? $$1260 : $$0240313371;\n    break;\n   }\n   $339 = $$pre$phiZ2D - $$2 | 0;\n   $spec$select284 = ($$5 | 0) < ($339 | 0) ? $339 : $$5;\n   $341 = $spec$select284 + $$2234 | 0;\n   $$2261 = ($$1260 | 0) < ($341 | 0) ? $341 : $$1260;\n   _pad_676($0, 32, $$2261, $341, $$6268);\n   _out_670($0, $$2239, $$2234);\n   _pad_676($0, 48, $$2261, $341, $$6268 ^ 65536);\n   _pad_676($0, 48, $spec$select284, $339, 0);\n   _out_670($0, $$2, $339);\n   _pad_676($0, 32, $$2261, $341, $$6268 ^ 8192);\n   $$0243$ph$be = $$2261;\n  } while (0);\n  $$0243$ph = $$0243$ph$be;\n  $$0247$ph = $$1248;\n  $$0269$ph = $$3272;\n }\n L125 : do if ((label | 0) == 94) if (!$0) if (!$$0269$ph) $$0 = 0; else {\n  $$2242320 = 1;\n  while (1) {\n   $348 = HEAP32[$4 + ($$2242320 << 2) >> 2] | 0;\n   if (!$348) break;\n   _pop_arg_673($3 + ($$2242320 << 3) | 0, $348, $2);\n   $351 = $$2242320 + 1 | 0;\n   if ($351 >>> 0 < 10) $$2242320 = $351; else {\n    $$0 = 1;\n    break L125;\n   }\n  }\n  $$3317 = $$2242320;\n  while (1) {\n   if (HEAP32[$4 + ($$3317 << 2) >> 2] | 0) {\n    $$0 = -1;\n    break L125;\n   }\n   $$3317 = $$3317 + 1 | 0;\n   if ($$3317 >>> 0 >= 10) {\n    $$0 = 1;\n    break;\n   }\n  }\n } else $$0 = $$1248; while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_118parse_expr_primaryINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i246 = 0, $$0$i$i$i250 = 0, $$0208 = 0, $$3 = 0, $100 = 0, $102 = 0, $103 = 0, $108 = 0, $109 = 0, $115 = 0, $121 = 0, $127 = 0, $128 = 0, $138 = 0, $139 = 0, $15 = 0, $18 = 0, $20 = 0, $28 = 0, $29 = 0, $3 = 0, $36 = 0, $37 = 0, $4 = 0, $44 = 0, $46 = 0, $48 = 0, $5 = 0, $50 = 0, $52 = 0, $54 = 0, $56 = 0, $58 = 0, $6 = 0, $60 = 0, $62 = 0, $64 = 0, $66 = 0, $68 = 0, $7 = 0, $70 = 0, $72 = 0, $74 = 0, $76 = 0, $78 = 0, $8 = 0, $80 = 0, $82 = 0, $84 = 0, $86 = 0, $88 = 0, $90 = 0, $92 = 0, $94 = 0, $96 = 0, $97 = 0, $99 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 96 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96);\n $3 = sp + 64 | 0;\n $4 = sp + 48 | 0;\n $5 = sp + 36 | 0;\n $6 = sp + 24 | 0;\n $7 = sp + 12 | 0;\n $8 = sp;\n L1 : do if (($1 - $0 | 0) > 3) if ((HEAP8[$0 >> 0] | 0) == 76) {\n  $15 = $0 + 1 | 0;\n  do switch (HEAP8[$15 >> 0] | 0) {\n  case 84:\n   {\n    $$3 = $0;\n    break L1;\n    break;\n   }\n  case 119:\n   {\n    $18 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16311, __ZNSt3__211char_traitsIcE6lengthEPKc(16311) | 0);\n    $20 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($18, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($20 | 0) == ($18 | 0) ? $0 : $20;\n    break L1;\n    break;\n   }\n  case 98:\n   {\n    if ((HEAP8[$0 + 3 >> 0] | 0) != 69) {\n     $$3 = $0;\n     break L1;\n    }\n    switch (HEAP8[$0 + 2 >> 0] | 0) {\n    case 48:\n     {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj6EEERAT__Kc($3, 16319);\n      $28 = $2 + 4 | 0;\n      $29 = HEAP32[$28 >> 2] | 0;\n      if ($29 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($29, $3);\n       HEAP32[$28 >> 2] = (HEAP32[$28 >> 2] | 0) + 24;\n      } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n      $$3 = $0 + 4 | 0;\n      break L1;\n      break;\n     }\n    case 49:\n     {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj5EEERAT__Kc($3, 16325);\n      $36 = $2 + 4 | 0;\n      $37 = HEAP32[$36 >> 2] | 0;\n      if ($37 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($37, $3);\n       HEAP32[$36 >> 2] = (HEAP32[$36 >> 2] | 0) + 24;\n      } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n      $$3 = $0 + 4 | 0;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$3 = $0;\n      break L1;\n     }\n    }\n    break;\n   }\n  case 99:\n   {\n    $44 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16330, __ZNSt3__211char_traitsIcE6lengthEPKc(16330) | 0);\n    $46 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($44, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($46 | 0) == ($44 | 0) ? $0 : $46;\n    break L1;\n    break;\n   }\n  case 97:\n   {\n    $48 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16335, __ZNSt3__211char_traitsIcE6lengthEPKc(16335) | 0);\n    $50 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($48, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($50 | 0) == ($48 | 0) ? $0 : $50;\n    break L1;\n    break;\n   }\n  case 104:\n   {\n    $52 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16347, __ZNSt3__211char_traitsIcE6lengthEPKc(16347) | 0);\n    $54 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($52, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($54 | 0) == ($52 | 0) ? $0 : $54;\n    break L1;\n    break;\n   }\n  case 115:\n   {\n    $56 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16361, __ZNSt3__211char_traitsIcE6lengthEPKc(16361) | 0);\n    $58 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($56, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($58 | 0) == ($56 | 0) ? $0 : $58;\n    break L1;\n    break;\n   }\n  case 116:\n   {\n    $60 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16367, __ZNSt3__211char_traitsIcE6lengthEPKc(16367) | 0);\n    $62 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($60, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($62 | 0) == ($60 | 0) ? $0 : $62;\n    break L1;\n    break;\n   }\n  case 105:\n   {\n    $64 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 19061, __ZNSt3__211char_traitsIcE6lengthEPKc(19061) | 0);\n    $66 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($64, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($66 | 0) == ($64 | 0) ? $0 : $66;\n    break L1;\n    break;\n   }\n  case 106:\n   {\n    $68 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16382, __ZNSt3__211char_traitsIcE6lengthEPKc(16382) | 0);\n    $70 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($68, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($70 | 0) == ($68 | 0) ? $0 : $70;\n    break L1;\n    break;\n   }\n  case 108:\n   {\n    $72 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16384, __ZNSt3__211char_traitsIcE6lengthEPKc(16384) | 0);\n    $74 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($72, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($74 | 0) == ($72 | 0) ? $0 : $74;\n    break L1;\n    break;\n   }\n  case 109:\n   {\n    $76 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16386, __ZNSt3__211char_traitsIcE6lengthEPKc(16386) | 0);\n    $78 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($76, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($78 | 0) == ($76 | 0) ? $0 : $78;\n    break L1;\n    break;\n   }\n  case 120:\n   {\n    $80 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16389, __ZNSt3__211char_traitsIcE6lengthEPKc(16389) | 0);\n    $82 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($80, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($82 | 0) == ($80 | 0) ? $0 : $82;\n    break L1;\n    break;\n   }\n  case 121:\n   {\n    $84 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16392, __ZNSt3__211char_traitsIcE6lengthEPKc(16392) | 0);\n    $86 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($84, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($86 | 0) == ($84 | 0) ? $0 : $86;\n    break L1;\n    break;\n   }\n  case 110:\n   {\n    $88 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16396, __ZNSt3__211char_traitsIcE6lengthEPKc(16396) | 0);\n    $90 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($88, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($90 | 0) == ($88 | 0) ? $0 : $90;\n    break L1;\n    break;\n   }\n  case 111:\n   {\n    $92 = $0 + 2 | 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 16405, __ZNSt3__211char_traitsIcE6lengthEPKc(16405) | 0);\n    $94 = __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($92, $1, $3, $2) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = ($94 | 0) == ($92 | 0) ? $0 : $94;\n    break L1;\n    break;\n   }\n  case 102:\n   {\n    $96 = $0 + 2 | 0;\n    $97 = __ZN10__cxxabiv112_GLOBAL__N_121parse_floating_numberIfNS0_2DbEEEPKcS4_S4_RT0_($96, $1, $2) | 0;\n    $$3 = ($97 | 0) == ($96 | 0) ? $0 : $97;\n    break L1;\n    break;\n   }\n  case 100:\n   {\n    $99 = $0 + 2 | 0;\n    $100 = __ZN10__cxxabiv112_GLOBAL__N_121parse_floating_numberIdNS0_2DbEEEPKcS4_S4_RT0_($99, $1, $2) | 0;\n    $$3 = ($100 | 0) == ($99 | 0) ? $0 : $100;\n    break L1;\n    break;\n   }\n  case 101:\n   {\n    $102 = $0 + 2 | 0;\n    $103 = __ZN10__cxxabiv112_GLOBAL__N_121parse_floating_numberIeNS0_2DbEEEPKcS4_S4_RT0_($102, $1, $2) | 0;\n    $$3 = ($103 | 0) == ($102 | 0) ? $0 : $103;\n    break L1;\n    break;\n   }\n  case 95:\n   {\n    if ((HEAP8[$0 + 2 >> 0] | 0) != 90) {\n     $$3 = $0;\n     break L1;\n    }\n    $108 = $0 + 3 | 0;\n    $109 = __ZN10__cxxabiv112_GLOBAL__N_114parse_encodingINS0_2DbEEEPKcS4_S4_RT_($108, $1, $2) | 0;\n    if (($109 | 0) == ($108 | 0) | ($109 | 0) == ($1 | 0)) {\n     $$3 = $0;\n     break L1;\n    }\n    $$3 = (HEAP8[$109 >> 0] | 0) == 69 ? $109 + 1 | 0 : $0;\n    break L1;\n    break;\n   }\n  default:\n   {\n    $115 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($15, $1, $2) | 0;\n    if (($115 | 0) == ($15 | 0) | ($115 | 0) == ($1 | 0)) {\n     $$3 = $0;\n     break L1;\n    }\n    if ((HEAP8[$115 >> 0] | 0) == 69) {\n     $$3 = $115 + 1 | 0;\n     break L1;\n    }\n    $$0208 = $115;\n    while (1) {\n     if (($$0208 | 0) == ($1 | 0)) {\n      $$3 = $0;\n      break L1;\n     }\n     $121 = HEAP8[$$0208 >> 0] | 0;\n     if ((($121 << 24 >> 24) + -48 | 0) >>> 0 >= 10) break;\n     $$0208 = $$0208 + 1 | 0;\n    }\n    if (!(($$0208 | 0) != ($115 | 0) & $121 << 24 >> 24 == 69)) {\n     $$3 = $0;\n     break L1;\n    }\n    $127 = $2 + 4 | 0;\n    $128 = HEAP32[$127 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($128 | 0)) {\n     $$3 = $0;\n     break L1;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($7, $128 + -24 | 0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($7, 0, 15119) | 0;\n    HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n    HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n    HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$7 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15117) | 0;\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i246 = 0;\n    while (1) {\n     if (($$0$i$i$i246 | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i246 << 2) >> 2] = 0;\n     $$0$i$i$i246 = $$0$i$i$i246 + 1 | 0;\n    }\n    HEAP32[$8 >> 2] = 0;\n    HEAP32[$8 + 4 >> 2] = 0;\n    HEAP32[$8 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($8, $115, $$0208);\n    $138 = HEAP8[$8 + 11 >> 0] | 0;\n    $139 = $138 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($5, $139 ? HEAP32[$8 >> 2] | 0 : $8, $139 ? HEAP32[$8 + 4 >> 2] | 0 : $138 & 255) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i250 = 0;\n    while (1) {\n     if (($$0$i$i$i250 | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i250 << 2) >> 2] = 0;\n     $$0$i$i$i250 = $$0$i$i$i250 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $4);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$127 >> 2] | 0) + -24 | 0, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n    $$3 = $$0208 + 1 | 0;\n    break L1;\n   }\n  } while (0);\n } else $$3 = $0; else $$3 = $0; while (0);\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_114parse_encodingINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0$i$i = 0, $$0$i$i$add$i = 0, $$0$i$i$add$i188 = 0, $$0$i$i$i$i = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i187 = 0, $$0$i$i193 = 0, $$0$i$i198 = 0, $$0132 = 0, $$0141$off0$ph = 0, $$0168 = 0, $$11 = 0, $$1135 = 0, $$1169 = 0, $$1169$ph = 0, $$2136 = 0, $$3144$off0$ph = 0, $$3171 = 0, $$4158 = 0, $$5139 = 0, $$6140 = 0, $$6160 = 0, $$in = 0, $$in210 = 0, $$pre$phi248Z2D = 0, $$pre$phiZ2D = 0, $$pre242 = 0, $10 = 0, $104 = 0, $105 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $128 = 0, $13 = 0, $134 = 0, $142 = 0, $143 = 0, $151 = 0, $153 = 0, $154 = 0, $157 = 0, $162 = 0, $166 = 0, $167 = 0, $168 = 0, $172 = 0, $176 = 0, $177 = 0, $19 = 0, $198 = 0, $199 = 0, $21 = 0, $23 = 0, $3 = 0, $30 = 0, $31 = 0, $33 = 0, $35 = 0, $36 = 0, $4 = 0, $41 = 0, $5 = 0, $50 = 0, $51 = 0, $6 = 0, $61 = 0, $7 = 0, $70 = 0, $73 = 0, $75 = 0, $8 = 0, $80 = 0, $81 = 0, $84 = 0, $85 = 0, $88 = 0, $92 = 0, $99 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 48 | 0;\n $4 = sp + 40 | 0;\n $5 = sp + 32 | 0;\n $6 = sp + 24 | 0;\n $7 = sp + 12 | 0;\n $8 = sp;\n if (($0 | 0) == ($1 | 0)) {\n  $$6140 = $0;\n  label = 90;\n } else {\n  $10 = $2 + 56 | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_110save_valueIjEC2ERj($4, $10);\n  HEAP32[$10 >> 2] = (HEAP32[$10 >> 2] | 0) + 1;\n  $13 = $2 + 61 | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_110save_valueIbEC2ERb($5, $13);\n  if ((HEAP32[$10 >> 2] | 0) >>> 0 > 1) HEAP8[$13 >> 0] = 1;\n  L6 : do switch (HEAP8[$0 >> 0] | 0) {\n  case 84:\n  case 71:\n   {\n    $$5139 = __ZN10__cxxabiv112_GLOBAL__N_118parse_special_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n    $$6160 = 1;\n    break;\n   }\n  default:\n   {\n    $19 = __ZN10__cxxabiv112_GLOBAL__N_110parse_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n    $21 = HEAP32[$2 + 48 >> 2] | 0;\n    $23 = HEAP32[$2 + 52 >> 2] | 0;\n    L8 : do if (($19 | 0) == ($0 | 0)) $$2136 = $0; else if (($19 | 0) == ($1 | 0)) $$2136 = $1; else {\n     switch (HEAP8[$19 >> 0] | 0) {\n     case 46:\n     case 69:\n      {\n       $$2136 = $19;\n       break L8;\n       break;\n      }\n     default:\n      {}\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_110save_valueIbEC2ERb($6, $13);\n     HEAP8[$13 >> 0] = 0;\n     HEAP32[$7 >> 2] = 0;\n     HEAP32[$7 + 4 >> 2] = 0;\n     HEAP32[$7 + 8 >> 2] = 0;\n     $$0$i$i198 = 0;\n     while (1) {\n      if (($$0$i$i198 | 0) == 3) break;\n      HEAP32[$7 + ($$0$i$i198 << 2) >> 2] = 0;\n      $$0$i$i198 = $$0$i$i198 + 1 | 0;\n     }\n     $30 = $2 + 4 | 0;\n     $31 = HEAP32[$30 >> 2] | 0;\n     L16 : do if ((HEAP32[$2 >> 2] | 0) == ($31 | 0)) {\n      $$1135 = $0;\n      $$4158 = 0;\n     } else {\n      $33 = $31 + -24 | 0;\n      $35 = HEAP8[$33 + 11 >> 0] | 0;\n      $36 = $35 << 24 >> 24 < 0;\n      if ($36) $41 = HEAP32[$31 + -20 >> 2] | 0; else $41 = $35 & 255;\n      if (!$41) {\n       $$1135 = $0;\n       $$4158 = 0;\n      } else {\n       if (!(HEAP8[$2 + 60 >> 0] | 0)) {\n        if ($36) {\n         $50 = HEAP32[$33 >> 2] | 0;\n         $51 = HEAP32[$31 + -20 >> 2] | 0;\n        } else {\n         $50 = $33;\n         $51 = $35 & 255;\n        }\n        if ((HEAP8[$50 + $51 + -1 >> 0] | 0) == 62) {\n         if ($36) {\n          $$in = HEAP32[$31 + -20 >> 2] | 0;\n          $61 = HEAP32[$33 >> 2] | 0;\n         } else {\n          $$in = $35 & 255;\n          $61 = $33;\n         }\n         if ((HEAP8[$61 + ($$in + -2) >> 0] | 0) == 45) {\n          $$0168 = $19;\n          $$pre$phiZ2D = $33;\n         } else {\n          if ($36) {\n           $$in210 = HEAP32[$31 + -20 >> 2] | 0;\n           $70 = HEAP32[$33 >> 2] | 0;\n          } else {\n           $$in210 = $35 & 255;\n           $70 = $33;\n          }\n          if ((HEAP8[$70 + ($$in210 + -2) >> 0] | 0) == 62) {\n           $$0168 = $19;\n           $$pre$phiZ2D = $33;\n          } else {\n           $73 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($19, $1, $2) | 0;\n           if (($73 | 0) == ($19 | 0)) {\n            $$1135 = $0;\n            $$4158 = 0;\n            break;\n           }\n           $75 = HEAP32[$30 >> 2] | 0;\n           $80 = $75;\n           if ((($75 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n            $$1135 = $0;\n            $$4158 = 0;\n            break;\n           }\n           $81 = $80 + -24 | 0;\n           HEAP32[$8 >> 2] = HEAP32[$81 >> 2];\n           HEAP32[$8 + 4 >> 2] = HEAP32[$81 + 4 >> 2];\n           HEAP32[$8 + 8 >> 2] = HEAP32[$81 + 8 >> 2];\n           $$0$i$i193 = 0;\n           while (1) {\n            if (($$0$i$i193 | 0) == 3) break;\n            HEAP32[$81 + ($$0$i$i193 << 2) >> 2] = 0;\n            $$0$i$i193 = $$0$i$i193 + 1 | 0;\n           }\n           $84 = $80 + -12 | 0;\n           $85 = $7 + 11 | 0;\n           if ((HEAP8[$85 >> 0] | 0) < 0) {\n            $88 = HEAP32[$7 >> 2] | 0;\n            HEAP8[$3 >> 0] = 0;\n            __ZNSt3__211char_traitsIcE6assignERcRKc($88, $3);\n            HEAP32[$7 + 4 >> 2] = 0;\n           } else {\n            HEAP8[$3 >> 0] = 0;\n            __ZNSt3__211char_traitsIcE6assignERcRKc($7, $3);\n            HEAP8[$85 >> 0] = 0;\n           }\n           __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($7);\n           HEAP32[$7 >> 2] = HEAP32[$84 >> 2];\n           HEAP32[$7 + 4 >> 2] = HEAP32[$84 + 4 >> 2];\n           HEAP32[$7 + 8 >> 2] = HEAP32[$84 + 8 >> 2];\n           $$0$i$i$i$i = 0;\n           while (1) {\n            if (($$0$i$i$i$i | 0) == 3) break;\n            HEAP32[$84 + ($$0$i$i$i$i << 2) >> 2] = 0;\n            $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n           }\n           $92 = HEAP8[$85 >> 0] | 0;\n           if (!(($92 << 24 >> 24 < 0 ? HEAP32[$7 + 4 >> 2] | 0 : $92 & 255) | 0)) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9push_backEc($8, 32);\n           $99 = HEAP32[$30 >> 2] | 0;\n           $$0$i$i$idx$i187 = 0;\n           while (1) {\n            if (($$0$i$i$idx$i187 | 0) == -1) break;\n            $$0$i$i$add$i188 = $$0$i$i$idx$i187 + -1 | 0;\n            __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($99 + ($$0$i$i$add$i188 * 24 | 0) | 0);\n            $$0$i$i$idx$i187 = $$0$i$i$add$i188;\n           }\n           HEAP32[$30 >> 2] = $99 + -24;\n           $104 = HEAP8[$8 + 11 >> 0] | 0;\n           $105 = $104 << 24 >> 24 < 0;\n           __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKcj($99 + -48 | 0, 0, $105 ? HEAP32[$8 >> 2] | 0 : $8, $105 ? HEAP32[$8 + 4 >> 2] | 0 : $104 & 255) | 0;\n           __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n           $$0168 = $73;\n           $$pre$phiZ2D = (HEAP32[$30 >> 2] | 0) + -24 | 0;\n          }\n         }\n        } else {\n         $$0168 = $19;\n         $$pre$phiZ2D = $33;\n        }\n       } else {\n        $$0168 = $19;\n        $$pre$phiZ2D = $33;\n       }\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9push_backEc($$pre$phiZ2D, 40);\n       if (($$0168 | 0) == ($1 | 0)) label = 50; else if ((HEAP8[$$0168 >> 0] | 0) == 118) {\n        $$3171 = $$0168 + 1 | 0;\n        $176 = HEAP32[$2 >> 2] | 0;\n        $177 = HEAP32[$30 >> 2] | 0;\n       } else label = 50;\n       do if ((label | 0) == 50) {\n        $116 = $3 + 11 | 0;\n        $117 = $3 + 4 | 0;\n        $118 = $8 + 11 | 0;\n        $119 = $8 + 4 | 0;\n        $$0141$off0$ph = 1;\n        $$1169$ph = $$0168;\n        L67 : while (1) {\n         $$1169 = $$1169$ph;\n         while (1) {\n          $123 = ((HEAP32[$30 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n          $124 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($$1169, $1, $2) | 0;\n          $125 = HEAP32[$30 >> 2] | 0;\n          $126 = HEAP32[$2 >> 2] | 0;\n          $128 = ($125 - $126 | 0) / 24 | 0;\n          if (($124 | 0) == ($$1169 | 0)) {\n           label = 74;\n           break L67;\n          }\n          if ($128 >>> 0 > $123 >>> 0) break; else $$1169 = $124;\n         }\n         HEAP32[$3 >> 2] = 0;\n         HEAP32[$3 + 4 >> 2] = 0;\n         HEAP32[$3 + 8 >> 2] = 0;\n         $$0$i$i = 0;\n         while (1) {\n          if (($$0$i$i | 0) == 3) break;\n          HEAP32[$3 + ($$0$i$i << 2) >> 2] = 0;\n          $$0$i$i = $$0$i$i + 1 | 0;\n         }\n         $$0132 = $123;\n         while (1) {\n          if ($$0132 >>> 0 >= $128 >>> 0) break;\n          $134 = HEAP8[$116 >> 0] | 0;\n          if (($134 << 24 >> 24 < 0 ? HEAP32[$117 >> 2] | 0 : $134 & 255) | 0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($3, 15341) | 0;\n          __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($8, (HEAP32[$2 >> 2] | 0) + ($$0132 * 24 | 0) | 0);\n          $142 = HEAP8[$118 >> 0] | 0;\n          $143 = $142 << 24 >> 24 < 0;\n          __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($3, $143 ? HEAP32[$8 >> 2] | 0 : $8, $143 ? HEAP32[$119 >> 2] | 0 : $142 & 255) | 0;\n          __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n          $$0132 = $$0132 + 1 | 0;\n         }\n         $$0 = $123;\n         while (1) {\n          if ($$0 >>> 0 >= $128 >>> 0) break;\n          $157 = HEAP32[$30 >> 2] | 0;\n          $$0$i$i$idx$i = 0;\n          while (1) {\n           if (($$0$i$i$idx$i | 0) == -1) break;\n           $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n           __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($157 + ($$0$i$i$add$i * 24 | 0) | 0);\n           $$0$i$i$idx$i = $$0$i$i$add$i;\n          }\n          HEAP32[$30 >> 2] = $157 + -24;\n          $$0 = $$0 + 1 | 0;\n         }\n         $151 = HEAP8[$116 >> 0] | 0;\n         $153 = HEAP32[$117 >> 2] | 0;\n         $154 = $151 & 255;\n         if (!(($151 << 24 >> 24 < 0 ? $153 : $154) | 0)) $$3144$off0$ph = $$0141$off0$ph; else {\n          $162 = HEAP32[$30 >> 2] | 0;\n          if ((HEAP32[$2 >> 2] | 0) == ($162 | 0)) {\n           label = 86;\n           break;\n          }\n          if ($$0141$off0$ph) {\n           $$pre$phi248Z2D = $154;\n           $166 = $162;\n           $168 = $151;\n           $172 = $153;\n          } else {\n           __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($162 + -24 | 0, 15341) | 0;\n           $$pre242 = HEAP8[$116 >> 0] | 0;\n           $$pre$phi248Z2D = $$pre242 & 255;\n           $166 = HEAP32[$30 >> 2] | 0;\n           $168 = $$pre242;\n           $172 = HEAP32[$117 >> 2] | 0;\n          }\n          $167 = $168 << 24 >> 24 < 0;\n          __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($166 + -24 | 0, $167 ? HEAP32[$3 >> 2] | 0 : $3, $167 ? $172 : $$pre$phi248Z2D) | 0;\n          $$3144$off0$ph = 0;\n         }\n         __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n         $$0141$off0$ph = $$3144$off0$ph;\n         $$1169$ph = $124;\n        }\n        if ((label | 0) == 74) {\n         $$3171 = $$1169;\n         $176 = $126;\n         $177 = $125;\n         break;\n        } else if ((label | 0) == 86) {\n         __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n         $$1135 = $0;\n         $$4158 = 0;\n         break L16;\n        }\n       } while (0);\n       if (($176 | 0) == ($177 | 0)) {\n        $$1135 = $0;\n        $$4158 = 0;\n       } else {\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9push_backEc($177 + -24 | 0, 41);\n        if ($21 & 1 | 0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$30 >> 2] | 0) + -24 | 0, 15064) | 0;\n        if ($21 & 2 | 0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$30 >> 2] | 0) + -24 | 0, 15071) | 0;\n        if ($21 & 4 | 0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$30 >> 2] | 0) + -24 | 0, 15081) | 0;\n        switch ($23 | 0) {\n        case 1:\n         {\n          __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$30 >> 2] | 0) + -24 | 0, 16545) | 0;\n          break;\n         }\n        case 2:\n         {\n          __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$30 >> 2] | 0) + -24 | 0, 16548) | 0;\n          break;\n         }\n        default:\n         {}\n        }\n        $198 = HEAP8[$7 + 11 >> 0] | 0;\n        $199 = $198 << 24 >> 24 < 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$30 >> 2] | 0) + -24 | 0, $199 ? HEAP32[$7 >> 2] | 0 : $7, $199 ? HEAP32[$7 + 4 >> 2] | 0 : $198 & 255) | 0;\n        $$1135 = $$3171;\n        $$4158 = 1;\n       }\n      }\n     } while (0);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n     __ZN10__cxxabiv112_GLOBAL__N_110save_valueIbED2Ev($6);\n     if ($$4158) $$2136 = $$1135; else {\n      $$5139 = $$1135;\n      $$6160 = 0;\n      break L6;\n     }\n    } while (0);\n    $$5139 = $$2136;\n    $$6160 = 1;\n   }\n  } while (0);\n  __ZN10__cxxabiv112_GLOBAL__N_110save_valueIbED2Ev($5);\n  __ZN10__cxxabiv112_GLOBAL__N_110save_valueIjED2Ev($4);\n  if ($$6160) {\n   $$6140 = $$5139;\n   label = 90;\n  } else $$11 = $0;\n }\n if ((label | 0) == 90) $$11 = $$6140;\n STACKTOP = sp;\n return $$11 | 0;\n}\n\nfunction _arGetTransMatMultiSquare2($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0389 = 0, $$0394 = 0, $$0404 = 0.0, $$0405 = 0, $$0407 = 0, $$0410 = 0, $$0413 = 0.0, $$1 = 0, $$10 = 0, $$1390 = 0, $$1395 = 0, $$1406 = 0, $$1408 = 0, $$1411 = 0, $$1414 = 0.0, $$2 = 0, $$2391 = 0, $$2396 = 0, $$2409 = 0, $$2412 = 0, $$2415 = 0.0, $$3 = 0, $$3392 = 0, $$3397 = 0, $$3416 = 0.0, $$4 = 0, $$4393 = 0, $$4398 = 0, $$4417 = 0.0, $$5 = 0, $$5399 = 0, $$5418 = 0.0, $$6 = 0, $$6400 = 0, $$6419 = 0.0, $$7 = 0, $$7401 = 0, $$8 = 0, $$8402 = 0, $$9 = 0, $$9403 = 0, $$pre441 = 0, $10 = 0, $109 = 0, $111 = 0, $114 = 0, $116 = 0, $118 = 0, $12 = 0, $120 = 0, $123 = 0, $125 = 0, $128 = 0, $135 = 0, $145 = 0, $155 = 0, $16 = 0, $166 = 0, $214 = 0, $217 = 0, $218 = 0, $219 = 0.0, $222 = 0.0, $225 = 0.0, $228 = 0.0, $23 = 0.0, $232 = 0.0, $233 = 0, $234 = 0.0, $235 = 0, $243 = 0.0, $244 = 0.0, $253 = 0.0, $254 = 0.0, $263 = 0.0, $264 = 0.0, $273 = 0.0, $274 = 0.0, $287 = 0, $291 = 0, $293 = 0, $36 = 0, $39 = 0, $42 = 0, $44 = 0, $47 = 0, $5 = 0, $51 = 0, $6 = 0, $63 = 0.0, $7 = 0, $78 = 0, $79 = 0, $8 = 0, $81 = 0, $83 = 0, $9 = 0, $90 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 208 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(208);\n $vararg_buffer1 = sp + 200 | 0;\n $vararg_buffer = sp + 192 | 0;\n $5 = sp + 96 | 0;\n $6 = sp;\n $7 = $3 + 4 | 0;\n $8 = HEAP32[$7 >> 2] | 0;\n $9 = $3 + 112 | 0;\n $10 = $3 + 120 | 0;\n $$0394 = 0;\n while (1) {\n  if (($$0394 | 0) >= ($8 | 0)) break;\n  $12 = HEAP32[$3 >> 2] | 0;\n  $16 = $12 + ($$0394 * 320 | 0) | 0;\n  if (!(HEAP32[$12 + ($$0394 * 320 | 0) + 4 >> 2] | 0)) {\n   $$0 = -1;\n   $$0389 = 0;\n   while (1) {\n    if (($$0389 | 0) >= ($2 | 0)) break;\n    if ((HEAP32[$1 + ($$0389 << 8) + 8 >> 2] | 0) == (HEAP32[$16 >> 2] | 0)) {\n     $23 = +HEAPF64[$1 + ($$0389 << 8) + 40 >> 3];\n     if ($23 < +HEAPF64[$9 >> 3]) $$1 = $$0; else if (($$0 | 0) == -1) $$1 = $$0389; else if (+HEAPF64[$1 + ($$0 << 8) + 40 >> 3] < $23) $$1 = $$0389; else $$1 = $$0;\n    } else $$1 = $$0;\n    $$0 = $$1;\n    $$0389 = $$0389 + 1 | 0;\n   }\n   HEAP32[$12 + ($$0394 * 320 | 0) + 304 >> 2] = $$0;\n   if (($$0 | 0) > -1) HEAP32[$1 + ($$0 << 8) + 16 >> 2] = HEAP32[$1 + ($$0 << 8) + 20 >> 2];\n  } else {\n   $36 = $12 + ($$0394 * 320 | 0) + 312 | 0;\n   $$1390 = 0;\n   $$2 = -1;\n   while (1) {\n    if (($$1390 | 0) >= ($2 | 0)) break;\n    $39 = HEAP32[$1 + ($$1390 << 8) + 12 >> 2] | 0;\n    if (!$39) {\n     $42 = $1 + ($$1390 << 8) + 248 | 0;\n     $44 = HEAP32[$42 >> 2] | 0;\n     $47 = HEAP32[$42 + 4 >> 2] | 0;\n     if (($44 | 0) == 0 & ($47 | 0) == 0) label = 19; else {\n      $51 = $36;\n      if (($44 | 0) == (HEAP32[$51 >> 2] | 0) ? ($47 | 0) == (HEAP32[$51 + 4 >> 2] | 0) : 0) label = 20; else $$3 = $$2;\n     }\n    } else label = 19;\n    if ((label | 0) == 19) {\n     label = 0;\n     if (($39 | 0) == (HEAP32[$16 >> 2] | 0)) label = 20; else $$3 = $$2;\n    }\n    if ((label | 0) == 20) {\n     label = 0;\n     $63 = +HEAPF64[$1 + ($$1390 << 8) + 48 >> 3];\n     if ($63 < +HEAPF64[$10 >> 3]) $$3 = $$2; else if (($$2 | 0) == -1) $$3 = $$1390; else if (+HEAPF64[$1 + ($$2 << 8) + 48 >> 3] < $63) $$3 = $$1390; else $$3 = $$2;\n    }\n    $$1390 = $$1390 + 1 | 0;\n    $$2 = $$3;\n   }\n   HEAP32[$12 + ($$0394 * 320 | 0) + 304 >> 2] = $$2;\n   if (($$2 | 0) > -1) HEAP32[$1 + ($$2 << 8) + 16 >> 2] = HEAP32[$1 + ($$2 << 8) + 24 >> 2];\n  }\n  $$0394 = $$0394 + 1 | 0;\n }\n $$0405 = 0;\n $$0407 = 0;\n $$0410 = 0;\n $$1395 = 0;\n $78 = $8;\n while (1) {\n  if (($$1395 | 0) >= ($78 | 0)) break;\n  $79 = HEAP32[$3 >> 2] | 0;\n  $81 = HEAP32[$79 + ($$1395 * 320 | 0) + 304 >> 2] | 0;\n  do if (($81 | 0) < 0) {\n   $$1406 = $$0405;\n   $$2409 = $$0407;\n   $$2412 = $$0410;\n  } else {\n   $83 = $1 + ($81 << 8) | 0;\n   if (+_arGetTransMatSquare($0, $83, +HEAPF64[$79 + ($$1395 * 320 | 0) + 8 >> 3], $6) > 4.0) {\n    HEAP32[(HEAP32[$3 >> 2] | 0) + ($$1395 * 320 | 0) + 304 >> 2] = -1;\n    $90 = $1 + ($81 << 8) + 236 | 0;\n    if (HEAP32[$90 >> 2] | 0) {\n     $$1406 = $$0405;\n     $$2409 = $$0407;\n     $$2412 = $$0410;\n     break;\n    }\n    HEAP32[$90 >> 2] = 7;\n    $$1406 = $$0405;\n    $$2409 = $$0407;\n    $$2412 = $$0410;\n    break;\n   }\n   $$pre441 = HEAP32[$83 >> 2] | 0;\n   L45 : do if (($$0405 | 0) == 0 | ($$0407 | 0) < ($$pre441 | 0)) {\n    $$2391 = 0;\n    while (1) {\n     if (($$2391 | 0) == 3) {\n      $$1408 = $$pre441;\n      $$1411 = $$1395;\n      break L45;\n     }\n     $$4 = 0;\n     while (1) {\n      if (($$4 | 0) == 4) break;\n      HEAPF64[$5 + ($$2391 << 5) + ($$4 << 3) >> 3] = +HEAPF64[$6 + ($$2391 << 5) + ($$4 << 3) >> 3];\n      $$4 = $$4 + 1 | 0;\n     }\n     $$2391 = $$2391 + 1 | 0;\n    }\n   } else {\n    $$1408 = $$0407;\n    $$1411 = $$0410;\n   } while (0);\n   $$1406 = $$0405 + 1 | 0;\n   $$2409 = $$1408;\n   $$2412 = $$1411;\n  } while (0);\n  $$0405 = $$1406;\n  $$0407 = $$2409;\n  $$0410 = $$2412;\n  $$1395 = $$1395 + 1 | 0;\n  $78 = HEAP32[$7 >> 2] | 0;\n }\n L57 : do if (!$$0405) label = 45; else if (($$0405 | 0) < (HEAP32[$3 + 128 >> 2] | 0)) label = 45; else {\n  _arUtilMatMul($5, (HEAP32[$3 >> 2] | 0) + ($$0410 * 320 | 0) + 112 | 0, $6) | 0;\n  $109 = $$0405 << 2;\n  $111 = _malloc($$0405 << 6) | 0;\n  if (!$111) {\n   _arLog(0, 3, 5051, $vararg_buffer);\n   _exit(1);\n  }\n  $114 = _malloc($$0405 * 96 | 0) | 0;\n  if (!$114) {\n   _arLog(0, 3, 5051, $vararg_buffer1);\n   _exit(1);\n  }\n  $116 = HEAP32[$7 >> 2] | 0;\n  $$2396 = 0;\n  $$3392 = 0;\n  while (1) {\n   if (($$2396 | 0) >= ($116 | 0)) break;\n   $118 = HEAP32[$3 >> 2] | 0;\n   $120 = HEAP32[$118 + ($$2396 * 320 | 0) + 304 >> 2] | 0;\n   if (($120 | 0) < 0) $$4393 = $$3392; else {\n    $123 = HEAP32[$1 + ($120 << 8) + 16 >> 2] | 0;\n    $125 = (4 - $123 | 0) % 4 | 0;\n    $128 = $$3392 << 3;\n    HEAPF64[$111 + ($128 << 3) >> 3] = +HEAPF64[$1 + ($120 << 8) + 168 + ($125 << 4) >> 3];\n    HEAPF64[$111 + (($128 | 1) << 3) >> 3] = +HEAPF64[$1 + ($120 << 8) + 168 + ($125 << 4) + 8 >> 3];\n    $135 = (5 - $123 | 0) % 4 | 0;\n    HEAPF64[$111 + (($128 | 2) << 3) >> 3] = +HEAPF64[$1 + ($120 << 8) + 168 + ($135 << 4) >> 3];\n    HEAPF64[$111 + (($128 | 3) << 3) >> 3] = +HEAPF64[$1 + ($120 << 8) + 168 + ($135 << 4) + 8 >> 3];\n    $145 = (6 - $123 | 0) % 4 | 0;\n    HEAPF64[$111 + (($128 | 4) << 3) >> 3] = +HEAPF64[$1 + ($120 << 8) + 168 + ($145 << 4) >> 3];\n    HEAPF64[$111 + (($128 | 5) << 3) >> 3] = +HEAPF64[$1 + ($120 << 8) + 168 + ($145 << 4) + 8 >> 3];\n    $155 = (7 - $123 | 0) % 4 | 0;\n    HEAPF64[$111 + (($128 | 6) << 3) >> 3] = +HEAPF64[$1 + ($120 << 8) + 168 + ($155 << 4) >> 3];\n    HEAPF64[$111 + (($128 | 7) << 3) >> 3] = +HEAPF64[$1 + ($120 << 8) + 168 + ($155 << 4) + 8 >> 3];\n    $166 = $$3392 * 12 | 0;\n    HEAPF64[$114 + ($166 << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 208 >> 3];\n    HEAPF64[$114 + (($166 | 1) << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 216 >> 3];\n    HEAPF64[$114 + (($166 | 2) << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 224 >> 3];\n    HEAPF64[$114 + (($166 | 3) << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 232 >> 3];\n    HEAPF64[$114 + ($166 + 4 << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 240 >> 3];\n    HEAPF64[$114 + ($166 + 5 << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 248 >> 3];\n    HEAPF64[$114 + ($166 + 6 << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 256 >> 3];\n    HEAPF64[$114 + ($166 + 7 << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 264 >> 3];\n    HEAPF64[$114 + ($166 + 8 << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 272 >> 3];\n    HEAPF64[$114 + ($166 + 9 << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 280 >> 3];\n    HEAPF64[$114 + ($166 + 10 << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 288 >> 3];\n    HEAPF64[$114 + ($166 + 11 << 3) >> 3] = +HEAPF64[$118 + ($$2396 * 320 | 0) + 296 >> 3];\n    $$4393 = $$3392 + 1 | 0;\n   }\n   $$2396 = $$2396 + 1 | 0;\n   $$3392 = $$4393;\n  }\n  $214 = $3 + 104 | 0;\n  $217 = ($4 | 0) != 0;\n  if (!(HEAP32[$214 >> 2] | 0)) {\n   $218 = $3 + 8 | 0;\n   $219 = +_arGetTransMat($0, $6, $111, $114, $109, $218);\n   if ($217 & $219 >= 20.0) {\n    _icpSetInlierProbability(HEAP32[$0 >> 2] | 0, .8) | 0;\n    $222 = +_arGetTransMatRobust($0, $6, $111, $114, $109, $218);\n    if (!($222 >= 20.0)) $$0413 = $222; else {\n     _icpSetInlierProbability(HEAP32[$0 >> 2] | 0, .6) | 0;\n     $225 = +_arGetTransMatRobust($0, $6, $111, $114, $109, $218);\n     if (!($225 >= 20.0)) $$0413 = $225; else {\n      _icpSetInlierProbability(HEAP32[$0 >> 2] | 0, .4) | 0;\n      $228 = +_arGetTransMatRobust($0, $6, $111, $114, $109, $218);\n      if (!($228 >= 20.0)) $$0413 = $228; else {\n       _icpSetInlierProbability(HEAP32[$0 >> 2] | 0, 0.0) | 0;\n       $$0413 = +_arGetTransMatRobust($0, $6, $111, $114, $109, $218);\n      }\n     }\n    }\n   } else $$0413 = $219;\n   _free($114);\n   _free($111);\n   $$6419 = $$0413;\n  } else {\n   $232 = +_arGetTransMat($0, $6, $111, $114, $109, $5);\n   $233 = $3 + 8 | 0;\n   $234 = +_arGetTransMat($0, $233, $111, $114, $109, $233);\n   $235 = $232 < $234;\n   L82 : do if ($217) {\n    L84 : do if ($235) {\n     $$5 = 0;\n     while (1) {\n      if (($$5 | 0) == 3) {\n       $$1414 = $232;\n       break L84;\n      }\n      $$3397 = 0;\n      while (1) {\n       if (($$3397 | 0) == 4) break;\n       HEAPF64[$3 + 8 + ($$5 << 5) + ($$3397 << 3) >> 3] = +HEAPF64[$5 + ($$5 << 5) + ($$3397 << 3) >> 3];\n       $$3397 = $$3397 + 1 | 0;\n      }\n      $$5 = $$5 + 1 | 0;\n     }\n    } else $$1414 = $234; while (0);\n    if (!($$1414 >= 20.0)) $$5418 = $$1414; else {\n     _icpSetInlierProbability(HEAP32[$0 >> 2] | 0, .8) | 0;\n     $243 = +_arGetTransMatRobust($0, $6, $111, $114, $109, $5);\n     $244 = +_arGetTransMatRobust($0, $233, $111, $114, $109, $233);\n     L95 : do if ($243 < $244) {\n      $$6 = 0;\n      while (1) {\n       if (($$6 | 0) == 3) {\n        $$2415 = $243;\n        break L95;\n       }\n       $$4398 = 0;\n       while (1) {\n        if (($$4398 | 0) == 4) break;\n        HEAPF64[$3 + 8 + ($$6 << 5) + ($$4398 << 3) >> 3] = +HEAPF64[$5 + ($$6 << 5) + ($$4398 << 3) >> 3];\n        $$4398 = $$4398 + 1 | 0;\n       }\n       $$6 = $$6 + 1 | 0;\n      }\n     } else $$2415 = $244; while (0);\n     if (!($$2415 >= 20.0)) $$5418 = $$2415; else {\n      _icpSetInlierProbability(HEAP32[$0 >> 2] | 0, .6) | 0;\n      $253 = +_arGetTransMatRobust($0, $6, $111, $114, $109, $5);\n      $254 = +_arGetTransMatRobust($0, $233, $111, $114, $109, $233);\n      L106 : do if ($253 < $254) {\n       $$7 = 0;\n       while (1) {\n        if (($$7 | 0) == 3) {\n         $$3416 = $253;\n         break L106;\n        }\n        $$5399 = 0;\n        while (1) {\n         if (($$5399 | 0) == 4) break;\n         HEAPF64[$3 + 8 + ($$7 << 5) + ($$5399 << 3) >> 3] = +HEAPF64[$5 + ($$7 << 5) + ($$5399 << 3) >> 3];\n         $$5399 = $$5399 + 1 | 0;\n        }\n        $$7 = $$7 + 1 | 0;\n       }\n      } else $$3416 = $254; while (0);\n      if (!($$3416 >= 20.0)) $$5418 = $$3416; else {\n       _icpSetInlierProbability(HEAP32[$0 >> 2] | 0, .4) | 0;\n       $263 = +_arGetTransMatRobust($0, $6, $111, $114, $109, $5);\n       $264 = +_arGetTransMatRobust($0, $233, $111, $114, $109, $233);\n       L117 : do if ($263 < $264) {\n        $$8 = 0;\n        while (1) {\n         if (($$8 | 0) == 3) {\n          $$4417 = $263;\n          break L117;\n         }\n         $$6400 = 0;\n         while (1) {\n          if (($$6400 | 0) == 4) break;\n          HEAPF64[$3 + 8 + ($$8 << 5) + ($$6400 << 3) >> 3] = +HEAPF64[$5 + ($$8 << 5) + ($$6400 << 3) >> 3];\n          $$6400 = $$6400 + 1 | 0;\n         }\n         $$8 = $$8 + 1 | 0;\n        }\n       } else $$4417 = $264; while (0);\n       if (!($$4417 >= 20.0)) $$5418 = $$4417; else {\n        _icpSetInlierProbability(HEAP32[$0 >> 2] | 0, 0.0) | 0;\n        $273 = +_arGetTransMatRobust($0, $6, $111, $114, $109, $5);\n        $274 = +_arGetTransMatRobust($0, $233, $111, $114, $109, $233);\n        if ($273 < $274) {\n         $$9 = 0;\n         while (1) {\n          if (($$9 | 0) == 3) {\n           $$5418 = $273;\n           break L82;\n          }\n          $$7401 = 0;\n          while (1) {\n           if (($$7401 | 0) == 4) break;\n           HEAPF64[$3 + 8 + ($$9 << 5) + ($$7401 << 3) >> 3] = +HEAPF64[$5 + ($$9 << 5) + ($$7401 << 3) >> 3];\n           $$7401 = $$7401 + 1 | 0;\n          }\n          $$9 = $$9 + 1 | 0;\n         }\n        } else $$5418 = $274;\n       }\n      }\n     }\n    }\n   } else if ($235) {\n    $$10 = 0;\n    while (1) {\n     if (($$10 | 0) == 3) {\n      $$5418 = $232;\n      break L82;\n     }\n     $$8402 = 0;\n     while (1) {\n      if (($$8402 | 0) == 4) break;\n      HEAPF64[$3 + 8 + ($$10 << 5) + ($$8402 << 3) >> 3] = +HEAPF64[$5 + ($$10 << 5) + ($$8402 << 3) >> 3];\n      $$8402 = $$8402 + 1 | 0;\n     }\n     $$10 = $$10 + 1 | 0;\n    }\n   } else $$5418 = $234; while (0);\n   _free($114);\n   _free($111);\n   $$6419 = $$5418;\n  }\n  if ($$6419 < 20.0) {\n   HEAP32[$214 >> 2] = 1;\n   $$0404 = $$6419;\n   break;\n  }\n  HEAP32[$214 >> 2] = 0;\n  $287 = HEAP32[$7 >> 2] | 0;\n  $$9403 = 0;\n  while (1) {\n   if (($$9403 | 0) >= ($287 | 0)) {\n    $$0404 = $$6419;\n    break L57;\n   }\n   $291 = HEAP32[(HEAP32[$3 >> 2] | 0) + ($$9403 * 320 | 0) + 304 >> 2] | 0;\n   if (($291 | 0) >= 0) {\n    $293 = $1 + ($291 << 8) + 236 | 0;\n    if (!(HEAP32[$293 >> 2] | 0)) HEAP32[$293 >> 2] = 8;\n   }\n   $$9403 = $$9403 + 1 | 0;\n  }\n } while (0);\n if ((label | 0) == 45) {\n  HEAP32[$3 + 104 >> 2] = 0;\n  $$0404 = -1.0;\n }\n STACKTOP = sp;\n return +$$0404;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_114parse_new_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i = 0, $$0$i$i$add$i = 0, $$0$i$i$add$i174 = 0, $$0$i$i$add$i186 = 0, $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i$i182 = 0, $$0$i$i$i196 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i173 = 0, $$0$i$i$idx$i185 = 0, $$0$i$i177 = 0, $$0$i$i189 = 0, $$0$i$i202 = 0, $$0$off0207 = 0, $$0138$off0 = 0, $$0150 = 0, $$0159$off0 = 0, $$0160 = 0, $$1151 = 0, $$1161 = 0, $$16 = 0, $$3143 = 0, $$3163 = 0, $$4144 = 0, $$4164206 = 0, $$phi$trans$insert = 0, $$pre$phi225Z2D = 0, $$pre$phiZ2D = 0, $10 = 0, $105 = 0, $106 = 0, $117 = 0, $118 = 0, $127 = 0, $14 = 0, $18 = 0, $21 = 0, $23 = 0, $24 = 0, $25 = 0, $29 = 0, $3 = 0, $32 = 0, $33 = 0, $39 = 0, $4 = 0, $5 = 0, $54 = 0, $55 = 0, $58 = 0, $6 = 0, $61 = 0, $65 = 0, $67 = 0, $7 = 0, $70 = 0, $72 = 0, $74 = 0, $8 = 0, $80 = 0, $83 = 0, $87 = 0, $9 = 0, $96 = 0, $97 = 0, $spec$select = 0, label = 0, sp = 0, $$3163$looptemp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 112 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112);\n $3 = sp + 88 | 0;\n $4 = sp + 76 | 0;\n $5 = sp + 64 | 0;\n $6 = sp + 40 | 0;\n $7 = sp + 16 | 0;\n $8 = sp;\n $9 = sp + 52 | 0;\n $10 = $1;\n L1 : do if (($10 - $0 | 0) > 3) {\n  $14 = HEAP8[$0 >> 0] | 0;\n  if ($14 << 24 >> 24 == 103) {\n   $18 = (HEAP8[$0 + 1 >> 0] | 0) == 115;\n   $spec$select = $18 ? $0 + 2 | 0 : $0;\n   $$0159$off0 = $18;\n   $$0160 = $spec$select;\n   $21 = HEAP8[$spec$select >> 0] | 0;\n  } else {\n   $$0159$off0 = 0;\n   $$0160 = $0;\n   $21 = $14;\n  }\n  if ($21 << 24 >> 24 == 110) {\n   $23 = HEAP8[$$0160 + 1 >> 0] | 0;\n   switch ($23 << 24 >> 24) {\n   case 97:\n   case 119:\n    break;\n   default:\n    {\n     $$16 = $0;\n     break L1;\n    }\n   }\n   $24 = $23 << 24 >> 24 == 97;\n   $25 = $$0160 + 2 | 0;\n   L8 : do if (($25 | 0) != ($1 | 0)) {\n    $$0138$off0 = 0;\n    $$1161 = $25;\n    while (1) {\n     if ((HEAP8[$$1161 >> 0] | 0) == 95) break;\n     $29 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($$1161, $1, $2) | 0;\n     if (($29 | 0) == ($$1161 | 0) | ($29 | 0) == ($1 | 0)) break L8; else {\n      $$0138$off0 = 1;\n      $$1161 = $29;\n     }\n    }\n    $32 = $$1161 + 1 | 0;\n    $33 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($32, $1, $2) | 0;\n    if (!(($33 | 0) == ($32 | 0) | ($33 | 0) == ($1 | 0))) {\n     $39 = HEAP8[$33 >> 0] | 0;\n     L15 : do if (($10 - $33 | 0) > 2 & $39 << 24 >> 24 == 112) {\n      if ((HEAP8[$33 + 1 >> 0] | 0) != 105) break L8;\n      $$3163 = $33 + 2 | 0;\n      while (1) {\n       if ((HEAP8[$$3163 >> 0] | 0) == 69) {\n        $$0$off0207 = 1;\n        $$4164206 = $$3163;\n        break L15;\n       }\n       $$3163$looptemp = $$3163;\n       $$3163 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($$3163, $1, $2) | 0;\n       if (($$3163 | 0) == ($$3163$looptemp | 0) | ($$3163 | 0) == ($1 | 0)) break L8;\n      }\n     } else if ($39 << 24 >> 24 == 69) {\n      $$0$off0207 = 0;\n      $$4164206 = $33;\n     } else break L8; while (0);\n     HEAP32[$4 >> 2] = 0;\n     HEAP32[$4 + 4 >> 2] = 0;\n     HEAP32[$4 + 8 >> 2] = 0;\n     $$0$i$i = 0;\n     while (1) {\n      if (($$0$i$i | 0) == 3) break;\n      HEAP32[$4 + ($$0$i$i << 2) >> 2] = 0;\n      $$0$i$i = $$0$i$i + 1 | 0;\n     }\n     if ($$0$off0207) {\n      $54 = $2 + 4 | 0;\n      $55 = HEAP32[$54 >> 2] | 0;\n      if ((HEAP32[$2 >> 2] | 0) == ($55 | 0)) {\n       $$1151 = $0;\n       $$4144 = 1;\n      } else {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, $55 + -24 | 0);\n       $58 = $4 + 11 | 0;\n       if ((HEAP8[$58 >> 0] | 0) < 0) {\n        $61 = HEAP32[$4 >> 2] | 0;\n        HEAP8[$3 >> 0] = 0;\n        __ZNSt3__211char_traitsIcE6assignERcRKc($61, $3);\n        HEAP32[$4 + 4 >> 2] = 0;\n       } else {\n        HEAP8[$3 >> 0] = 0;\n        __ZNSt3__211char_traitsIcE6assignERcRKc($4, $3);\n        HEAP8[$58 >> 0] = 0;\n       }\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($4);\n       HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n       HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n       HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n       $$0$i$i$i$i = 0;\n       while (1) {\n        if (($$0$i$i$i$i | 0) == 3) break;\n        HEAP32[$5 + ($$0$i$i$i$i << 2) >> 2] = 0;\n        $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n       }\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n       $65 = HEAP32[$54 >> 2] | 0;\n       $$0$i$i$idx$i = 0;\n       while (1) {\n        if (($$0$i$i$idx$i | 0) == -1) break;\n        $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($65 + ($$0$i$i$add$i * 24 | 0) | 0);\n        $$0$i$i$idx$i = $$0$i$i$add$i;\n       }\n       $67 = $65 + -24 | 0;\n       HEAP32[$54 >> 2] = $67;\n       $$pre$phi225Z2D = $54;\n       $$pre$phiZ2D = $2;\n       $70 = $67;\n       label = 33;\n      }\n     } else {\n      $$phi$trans$insert = $2 + 4 | 0;\n      $$pre$phi225Z2D = $$phi$trans$insert;\n      $$pre$phiZ2D = $2;\n      $70 = HEAP32[$$phi$trans$insert >> 2] | 0;\n      label = 33;\n     }\n     if ((label | 0) == 33) if ((HEAP32[$$pre$phiZ2D >> 2] | 0) == ($70 | 0)) {\n      $$1151 = $0;\n      $$4144 = 1;\n     } else {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, $70 + -24 | 0);\n      $72 = HEAP32[$$pre$phi225Z2D >> 2] | 0;\n      $$0$i$i$idx$i173 = 0;\n      while (1) {\n       if (($$0$i$i$idx$i173 | 0) == -1) break;\n       $$0$i$i$add$i174 = $$0$i$i$idx$i173 + -1 | 0;\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($72 + ($$0$i$i$add$i174 * 24 | 0) | 0);\n       $$0$i$i$idx$i173 = $$0$i$i$add$i174;\n      }\n      $74 = $72 + -24 | 0;\n      HEAP32[$$pre$phi225Z2D >> 2] = $74;\n      HEAP32[$6 >> 2] = 0;\n      HEAP32[$6 + 4 >> 2] = 0;\n      HEAP32[$6 + 8 >> 2] = 0;\n      $$0$i$i177 = 0;\n      while (1) {\n       if (($$0$i$i177 | 0) == 3) break;\n       HEAP32[$6 + ($$0$i$i177 << 2) >> 2] = 0;\n       $$0$i$i177 = $$0$i$i177 + 1 | 0;\n      }\n      if ($$0138$off0) if ((HEAP32[$$pre$phiZ2D >> 2] | 0) == ($74 | 0)) {\n       $$0150 = $0;\n       $$3143 = 1;\n      } else {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($7, $72 + -48 | 0);\n       $80 = $6 + 11 | 0;\n       if ((HEAP8[$80 >> 0] | 0) < 0) {\n        $83 = HEAP32[$6 >> 2] | 0;\n        HEAP8[$3 >> 0] = 0;\n        __ZNSt3__211char_traitsIcE6assignERcRKc($83, $3);\n        HEAP32[$6 + 4 >> 2] = 0;\n       } else {\n        HEAP8[$3 >> 0] = 0;\n        __ZNSt3__211char_traitsIcE6assignERcRKc($6, $3);\n        HEAP8[$80 >> 0] = 0;\n       }\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($6);\n       HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n       HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n       HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n       $$0$i$i$i$i182 = 0;\n       while (1) {\n        if (($$0$i$i$i$i182 | 0) == 3) break;\n        HEAP32[$7 + ($$0$i$i$i$i182 << 2) >> 2] = 0;\n        $$0$i$i$i$i182 = $$0$i$i$i$i182 + 1 | 0;\n       }\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n       $87 = HEAP32[$$pre$phi225Z2D >> 2] | 0;\n       $$0$i$i$idx$i185 = 0;\n       while (1) {\n        if (($$0$i$i$idx$i185 | 0) == -1) break;\n        $$0$i$i$add$i186 = $$0$i$i$idx$i185 + -1 | 0;\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($87 + ($$0$i$i$add$i186 * 24 | 0) | 0);\n        $$0$i$i$idx$i185 = $$0$i$i$add$i186;\n       }\n       HEAP32[$$pre$phi225Z2D >> 2] = $87 + -24;\n       label = 52;\n      } else label = 52;\n      if ((label | 0) == 52) {\n       HEAP32[$3 >> 2] = 0;\n       HEAP32[$3 + 4 >> 2] = 0;\n       HEAP32[$3 + 8 >> 2] = 0;\n       $$0$i$i189 = 0;\n       while (1) {\n        if (($$0$i$i189 | 0) == 3) break;\n        HEAP32[$3 + ($$0$i$i189 << 2) >> 2] = 0;\n        $$0$i$i189 = $$0$i$i189 + 1 | 0;\n       }\n       if ($$0159$off0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKc($3, 15191);\n       if ($24) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($3, 15401) | 0; else __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($3, 15151) | 0;\n       if ($$0138$off0) {\n        __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($8, 15119, $6);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($8, 15405) | 0;\n        HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n        HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n        HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n        $$0$i$i$i = 0;\n        while (1) {\n         if (($$0$i$i$i | 0) == 3) break;\n         HEAP32[$8 + ($$0$i$i$i << 2) >> 2] = 0;\n         $$0$i$i$i = $$0$i$i$i + 1 | 0;\n        }\n        $96 = HEAP8[$7 + 11 >> 0] | 0;\n        $97 = $96 << 24 >> 24 < 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($3, $97 ? HEAP32[$7 >> 2] | 0 : $7, $97 ? HEAP32[$7 + 4 >> 2] | 0 : $96 & 255) | 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n       }\n       $105 = HEAP8[$5 + 11 >> 0] | 0;\n       $106 = $105 << 24 >> 24 < 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($3, $106 ? HEAP32[$5 >> 2] | 0 : $5, $106 ? HEAP32[$5 + 4 >> 2] | 0 : $105 & 255) | 0;\n       if ($$0$off0207) {\n        __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($8, 15114, $4);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($8, 15117) | 0;\n        HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n        HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n        HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n        $$0$i$i$i196 = 0;\n        while (1) {\n         if (($$0$i$i$i196 | 0) == 3) break;\n         HEAP32[$8 + ($$0$i$i$i196 << 2) >> 2] = 0;\n         $$0$i$i$i196 = $$0$i$i$i196 + 1 | 0;\n        }\n        $117 = HEAP8[$7 + 11 >> 0] | 0;\n        $118 = $117 << 24 >> 24 < 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($3, $118 ? HEAP32[$7 >> 2] | 0 : $7, $118 ? HEAP32[$7 + 4 >> 2] | 0 : $117 & 255) | 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n       };\n       HEAP32[$9 >> 2] = HEAP32[$3 >> 2];\n       HEAP32[$9 + 4 >> 2] = HEAP32[$3 + 4 >> 2];\n       HEAP32[$9 + 8 >> 2] = HEAP32[$3 + 8 >> 2];\n       $$0$i$i202 = 0;\n       while (1) {\n        if (($$0$i$i202 | 0) == 3) break;\n        HEAP32[$3 + ($$0$i$i202 << 2) >> 2] = 0;\n        $$0$i$i202 = $$0$i$i202 + 1 | 0;\n       }\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($7, $9);\n       $127 = HEAP32[$$pre$phi225Z2D >> 2] | 0;\n       if ($127 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($127, $7);\n        HEAP32[$$pre$phi225Z2D >> 2] = (HEAP32[$$pre$phi225Z2D >> 2] | 0) + 24;\n       } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $7);\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($7);\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n       $$0150 = $$4164206 + 1 | 0;\n       $$3143 = 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n      $$1151 = $$0150;\n      $$4144 = $$3143;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     if (!$$4144) {\n      $$16 = $$1151;\n      break L1;\n     }\n    }\n   } while (0);\n   $$16 = $0;\n  } else $$16 = $0;\n } else $$16 = $0; while (0);\n STACKTOP = sp;\n return $$16 | 0;\n}\n\nfunction _free($0) {\n $0 = $0 | 0;\n var $$0211$i = 0, $$0211$in$i = 0, $$0381438 = 0, $$0382$lcssa = 0, $$0382437 = 0, $$0394 = 0, $$0401 = 0, $$1 = 0, $$1380 = 0, $$1385 = 0, $$1385$be = 0, $$1385$ph = 0, $$1388 = 0, $$1388$be = 0, $$1388$ph = 0, $$1396 = 0, $$1396$be = 0, $$1396$ph = 0, $$1400 = 0, $$1400$be = 0, $$1400$ph = 0, $$2 = 0, $$3 = 0, $$3398 = 0, $$pre$phi444Z2D = 0, $$pre$phi446Z2D = 0, $$pre$phiZ2D = 0, $10 = 0, $105 = 0, $106 = 0, $114 = 0, $115 = 0, $116 = 0, $124 = 0, $13 = 0, $132 = 0, $137 = 0, $138 = 0, $141 = 0, $143 = 0, $145 = 0, $16 = 0, $160 = 0, $165 = 0, $167 = 0, $17 = 0, $170 = 0, $173 = 0, $176 = 0, $179 = 0, $180 = 0, $181 = 0, $183 = 0, $185 = 0, $186 = 0, $188 = 0, $189 = 0, $195 = 0, $196 = 0, $2 = 0, $205 = 0, $21 = 0, $210 = 0, $213 = 0, $214 = 0, $220 = 0, $235 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $244 = 0, $245 = 0, $251 = 0, $256 = 0, $257 = 0, $26 = 0, $260 = 0, $262 = 0, $265 = 0, $270 = 0, $276 = 0, $28 = 0, $280 = 0, $281 = 0, $288 = 0, $3 = 0, $300 = 0, $305 = 0, $312 = 0, $313 = 0, $314 = 0, $323 = 0, $41 = 0, $46 = 0, $48 = 0, $51 = 0, $53 = 0, $56 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $63 = 0, $65 = 0, $66 = 0, $68 = 0, $69 = 0, $7 = 0, $74 = 0, $75 = 0, $84 = 0, $89 = 0, $9 = 0, $92 = 0, $93 = 0, $99 = 0;\n if (!$0) return;\n $2 = $0 + -8 | 0;\n $3 = HEAP32[4355] | 0;\n if ($2 >>> 0 < $3 >>> 0) _abort();\n $6 = HEAP32[$0 + -4 >> 2] | 0;\n $7 = $6 & 3;\n if (($7 | 0) == 1) _abort();\n $9 = $6 & -8;\n $10 = $2 + $9 | 0;\n L10 : do if (!($6 & 1)) {\n  $13 = HEAP32[$2 >> 2] | 0;\n  if (!$7) return;\n  $16 = $2 + (0 - $13) | 0;\n  $17 = $13 + $9 | 0;\n  if ($16 >>> 0 < $3 >>> 0) _abort();\n  if ((HEAP32[4356] | 0) == ($16 | 0)) {\n   $105 = $10 + 4 | 0;\n   $106 = HEAP32[$105 >> 2] | 0;\n   if (($106 & 3 | 0) != 3) {\n    $$1 = $16;\n    $$1380 = $17;\n    $114 = $16;\n    break;\n   }\n   HEAP32[4353] = $17;\n   HEAP32[$105 >> 2] = $106 & -2;\n   HEAP32[$16 + 4 >> 2] = $17 | 1;\n   HEAP32[$16 + $17 >> 2] = $17;\n   return;\n  }\n  $21 = $13 >>> 3;\n  if ($13 >>> 0 < 256) {\n   $24 = HEAP32[$16 + 8 >> 2] | 0;\n   $26 = HEAP32[$16 + 12 >> 2] | 0;\n   $28 = 17444 + ($21 << 1 << 2) | 0;\n   if (($24 | 0) != ($28 | 0)) {\n    if ($3 >>> 0 > $24 >>> 0) _abort();\n    if ((HEAP32[$24 + 12 >> 2] | 0) != ($16 | 0)) _abort();\n   }\n   if (($26 | 0) == ($24 | 0)) {\n    HEAP32[4351] = HEAP32[4351] & ~(1 << $21);\n    $$1 = $16;\n    $$1380 = $17;\n    $114 = $16;\n    break;\n   }\n   if (($26 | 0) == ($28 | 0)) $$pre$phi446Z2D = $26 + 8 | 0; else {\n    if ($3 >>> 0 > $26 >>> 0) _abort();\n    $41 = $26 + 8 | 0;\n    if ((HEAP32[$41 >> 2] | 0) == ($16 | 0)) $$pre$phi446Z2D = $41; else _abort();\n   }\n   HEAP32[$24 + 12 >> 2] = $26;\n   HEAP32[$$pre$phi446Z2D >> 2] = $24;\n   $$1 = $16;\n   $$1380 = $17;\n   $114 = $16;\n   break;\n  }\n  $46 = HEAP32[$16 + 24 >> 2] | 0;\n  $48 = HEAP32[$16 + 12 >> 2] | 0;\n  do if (($48 | 0) == ($16 | 0)) {\n   $59 = $16 + 16 | 0;\n   $60 = $59 + 4 | 0;\n   $61 = HEAP32[$60 >> 2] | 0;\n   if (!$61) {\n    $63 = HEAP32[$59 >> 2] | 0;\n    if (!$63) {\n     $$3 = 0;\n     break;\n    } else {\n     $$1385$ph = $63;\n     $$1388$ph = $59;\n    }\n   } else {\n    $$1385$ph = $61;\n    $$1388$ph = $60;\n   }\n   $$1385 = $$1385$ph;\n   $$1388 = $$1388$ph;\n   while (1) {\n    $65 = $$1385 + 20 | 0;\n    $66 = HEAP32[$65 >> 2] | 0;\n    if (!$66) {\n     $68 = $$1385 + 16 | 0;\n     $69 = HEAP32[$68 >> 2] | 0;\n     if (!$69) break; else {\n      $$1385$be = $69;\n      $$1388$be = $68;\n     }\n    } else {\n     $$1385$be = $66;\n     $$1388$be = $65;\n    }\n    $$1385 = $$1385$be;\n    $$1388 = $$1388$be;\n   }\n   if ($3 >>> 0 > $$1388 >>> 0) _abort(); else {\n    HEAP32[$$1388 >> 2] = 0;\n    $$3 = $$1385;\n    break;\n   }\n  } else {\n   $51 = HEAP32[$16 + 8 >> 2] | 0;\n   if ($3 >>> 0 > $51 >>> 0) _abort();\n   $53 = $51 + 12 | 0;\n   if ((HEAP32[$53 >> 2] | 0) != ($16 | 0)) _abort();\n   $56 = $48 + 8 | 0;\n   if ((HEAP32[$56 >> 2] | 0) == ($16 | 0)) {\n    HEAP32[$53 >> 2] = $48;\n    HEAP32[$56 >> 2] = $51;\n    $$3 = $48;\n    break;\n   } else _abort();\n  } while (0);\n  if (!$46) {\n   $$1 = $16;\n   $$1380 = $17;\n   $114 = $16;\n  } else {\n   $74 = HEAP32[$16 + 28 >> 2] | 0;\n   $75 = 17708 + ($74 << 2) | 0;\n   do if ((HEAP32[$75 >> 2] | 0) == ($16 | 0)) {\n    HEAP32[$75 >> 2] = $$3;\n    if (!$$3) {\n     HEAP32[4352] = HEAP32[4352] & ~(1 << $74);\n     $$1 = $16;\n     $$1380 = $17;\n     $114 = $16;\n     break L10;\n    }\n   } else if ((HEAP32[4355] | 0) >>> 0 > $46 >>> 0) _abort(); else {\n    $84 = $46 + 16 | 0;\n    HEAP32[((HEAP32[$84 >> 2] | 0) == ($16 | 0) ? $84 : $46 + 20 | 0) >> 2] = $$3;\n    if (!$$3) {\n     $$1 = $16;\n     $$1380 = $17;\n     $114 = $16;\n     break L10;\n    } else break;\n   } while (0);\n   $89 = HEAP32[4355] | 0;\n   if ($89 >>> 0 > $$3 >>> 0) _abort();\n   HEAP32[$$3 + 24 >> 2] = $46;\n   $92 = $16 + 16 | 0;\n   $93 = HEAP32[$92 >> 2] | 0;\n   do if ($93 | 0) if ($89 >>> 0 > $93 >>> 0) _abort(); else {\n    HEAP32[$$3 + 16 >> 2] = $93;\n    HEAP32[$93 + 24 >> 2] = $$3;\n    break;\n   } while (0);\n   $99 = HEAP32[$92 + 4 >> 2] | 0;\n   if (!$99) {\n    $$1 = $16;\n    $$1380 = $17;\n    $114 = $16;\n   } else if ((HEAP32[4355] | 0) >>> 0 > $99 >>> 0) _abort(); else {\n    HEAP32[$$3 + 20 >> 2] = $99;\n    HEAP32[$99 + 24 >> 2] = $$3;\n    $$1 = $16;\n    $$1380 = $17;\n    $114 = $16;\n    break;\n   }\n  }\n } else {\n  $$1 = $2;\n  $$1380 = $9;\n  $114 = $2;\n } while (0);\n if ($114 >>> 0 >= $10 >>> 0) _abort();\n $115 = $10 + 4 | 0;\n $116 = HEAP32[$115 >> 2] | 0;\n if (!($116 & 1)) _abort();\n if (!($116 & 2)) {\n  if ((HEAP32[4357] | 0) == ($10 | 0)) {\n   $124 = (HEAP32[4354] | 0) + $$1380 | 0;\n   HEAP32[4354] = $124;\n   HEAP32[4357] = $$1;\n   HEAP32[$$1 + 4 >> 2] = $124 | 1;\n   if (($$1 | 0) != (HEAP32[4356] | 0)) return;\n   HEAP32[4356] = 0;\n   HEAP32[4353] = 0;\n   return;\n  }\n  if ((HEAP32[4356] | 0) == ($10 | 0)) {\n   $132 = (HEAP32[4353] | 0) + $$1380 | 0;\n   HEAP32[4353] = $132;\n   HEAP32[4356] = $114;\n   HEAP32[$$1 + 4 >> 2] = $132 | 1;\n   HEAP32[$114 + $132 >> 2] = $132;\n   return;\n  }\n  $137 = ($116 & -8) + $$1380 | 0;\n  $138 = $116 >>> 3;\n  L111 : do if ($116 >>> 0 < 256) {\n   $141 = HEAP32[$10 + 8 >> 2] | 0;\n   $143 = HEAP32[$10 + 12 >> 2] | 0;\n   $145 = 17444 + ($138 << 1 << 2) | 0;\n   if (($141 | 0) != ($145 | 0)) {\n    if ((HEAP32[4355] | 0) >>> 0 > $141 >>> 0) _abort();\n    if ((HEAP32[$141 + 12 >> 2] | 0) != ($10 | 0)) _abort();\n   }\n   if (($143 | 0) == ($141 | 0)) {\n    HEAP32[4351] = HEAP32[4351] & ~(1 << $138);\n    break;\n   }\n   if (($143 | 0) == ($145 | 0)) $$pre$phi444Z2D = $143 + 8 | 0; else {\n    if ((HEAP32[4355] | 0) >>> 0 > $143 >>> 0) _abort();\n    $160 = $143 + 8 | 0;\n    if ((HEAP32[$160 >> 2] | 0) == ($10 | 0)) $$pre$phi444Z2D = $160; else _abort();\n   }\n   HEAP32[$141 + 12 >> 2] = $143;\n   HEAP32[$$pre$phi444Z2D >> 2] = $141;\n  } else {\n   $165 = HEAP32[$10 + 24 >> 2] | 0;\n   $167 = HEAP32[$10 + 12 >> 2] | 0;\n   do if (($167 | 0) == ($10 | 0)) {\n    $179 = $10 + 16 | 0;\n    $180 = $179 + 4 | 0;\n    $181 = HEAP32[$180 >> 2] | 0;\n    if (!$181) {\n     $183 = HEAP32[$179 >> 2] | 0;\n     if (!$183) {\n      $$3398 = 0;\n      break;\n     } else {\n      $$1396$ph = $183;\n      $$1400$ph = $179;\n     }\n    } else {\n     $$1396$ph = $181;\n     $$1400$ph = $180;\n    }\n    $$1396 = $$1396$ph;\n    $$1400 = $$1400$ph;\n    while (1) {\n     $185 = $$1396 + 20 | 0;\n     $186 = HEAP32[$185 >> 2] | 0;\n     if (!$186) {\n      $188 = $$1396 + 16 | 0;\n      $189 = HEAP32[$188 >> 2] | 0;\n      if (!$189) break; else {\n       $$1396$be = $189;\n       $$1400$be = $188;\n      }\n     } else {\n      $$1396$be = $186;\n      $$1400$be = $185;\n     }\n     $$1396 = $$1396$be;\n     $$1400 = $$1400$be;\n    }\n    if ((HEAP32[4355] | 0) >>> 0 > $$1400 >>> 0) _abort(); else {\n     HEAP32[$$1400 >> 2] = 0;\n     $$3398 = $$1396;\n     break;\n    }\n   } else {\n    $170 = HEAP32[$10 + 8 >> 2] | 0;\n    if ((HEAP32[4355] | 0) >>> 0 > $170 >>> 0) _abort();\n    $173 = $170 + 12 | 0;\n    if ((HEAP32[$173 >> 2] | 0) != ($10 | 0)) _abort();\n    $176 = $167 + 8 | 0;\n    if ((HEAP32[$176 >> 2] | 0) == ($10 | 0)) {\n     HEAP32[$173 >> 2] = $167;\n     HEAP32[$176 >> 2] = $170;\n     $$3398 = $167;\n     break;\n    } else _abort();\n   } while (0);\n   if ($165 | 0) {\n    $195 = HEAP32[$10 + 28 >> 2] | 0;\n    $196 = 17708 + ($195 << 2) | 0;\n    do if ((HEAP32[$196 >> 2] | 0) == ($10 | 0)) {\n     HEAP32[$196 >> 2] = $$3398;\n     if (!$$3398) {\n      HEAP32[4352] = HEAP32[4352] & ~(1 << $195);\n      break L111;\n     }\n    } else if ((HEAP32[4355] | 0) >>> 0 > $165 >>> 0) _abort(); else {\n     $205 = $165 + 16 | 0;\n     HEAP32[((HEAP32[$205 >> 2] | 0) == ($10 | 0) ? $205 : $165 + 20 | 0) >> 2] = $$3398;\n     if (!$$3398) break L111; else break;\n    } while (0);\n    $210 = HEAP32[4355] | 0;\n    if ($210 >>> 0 > $$3398 >>> 0) _abort();\n    HEAP32[$$3398 + 24 >> 2] = $165;\n    $213 = $10 + 16 | 0;\n    $214 = HEAP32[$213 >> 2] | 0;\n    do if ($214 | 0) if ($210 >>> 0 > $214 >>> 0) _abort(); else {\n     HEAP32[$$3398 + 16 >> 2] = $214;\n     HEAP32[$214 + 24 >> 2] = $$3398;\n     break;\n    } while (0);\n    $220 = HEAP32[$213 + 4 >> 2] | 0;\n    if ($220 | 0) if ((HEAP32[4355] | 0) >>> 0 > $220 >>> 0) _abort(); else {\n     HEAP32[$$3398 + 20 >> 2] = $220;\n     HEAP32[$220 + 24 >> 2] = $$3398;\n     break;\n    }\n   }\n  } while (0);\n  HEAP32[$$1 + 4 >> 2] = $137 | 1;\n  HEAP32[$114 + $137 >> 2] = $137;\n  if (($$1 | 0) == (HEAP32[4356] | 0)) {\n   HEAP32[4353] = $137;\n   return;\n  } else $$2 = $137;\n } else {\n  HEAP32[$115 >> 2] = $116 & -2;\n  HEAP32[$$1 + 4 >> 2] = $$1380 | 1;\n  HEAP32[$114 + $$1380 >> 2] = $$1380;\n  $$2 = $$1380;\n }\n $235 = $$2 >>> 3;\n if ($$2 >>> 0 < 256) {\n  $238 = 17444 + ($235 << 1 << 2) | 0;\n  $239 = HEAP32[4351] | 0;\n  $240 = 1 << $235;\n  if (!($239 & $240)) {\n   HEAP32[4351] = $239 | $240;\n   $$0401 = $238;\n   $$pre$phiZ2D = $238 + 8 | 0;\n  } else {\n   $244 = $238 + 8 | 0;\n   $245 = HEAP32[$244 >> 2] | 0;\n   if ((HEAP32[4355] | 0) >>> 0 > $245 >>> 0) _abort(); else {\n    $$0401 = $245;\n    $$pre$phiZ2D = $244;\n   }\n  }\n  HEAP32[$$pre$phiZ2D >> 2] = $$1;\n  HEAP32[$$0401 + 12 >> 2] = $$1;\n  HEAP32[$$1 + 8 >> 2] = $$0401;\n  HEAP32[$$1 + 12 >> 2] = $238;\n  return;\n }\n $251 = $$2 >>> 8;\n if (!$251) $$0394 = 0; else if ($$2 >>> 0 > 16777215) $$0394 = 31; else {\n  $256 = ($251 + 1048320 | 0) >>> 16 & 8;\n  $257 = $251 << $256;\n  $260 = ($257 + 520192 | 0) >>> 16 & 4;\n  $262 = $257 << $260;\n  $265 = ($262 + 245760 | 0) >>> 16 & 2;\n  $270 = 14 - ($260 | $256 | $265) + ($262 << $265 >>> 15) | 0;\n  $$0394 = $$2 >>> ($270 + 7 | 0) & 1 | $270 << 1;\n }\n $276 = 17708 + ($$0394 << 2) | 0;\n HEAP32[$$1 + 28 >> 2] = $$0394;\n HEAP32[$$1 + 20 >> 2] = 0;\n HEAP32[$$1 + 16 >> 2] = 0;\n $280 = HEAP32[4352] | 0;\n $281 = 1 << $$0394;\n L197 : do if (!($280 & $281)) {\n  HEAP32[4352] = $280 | $281;\n  HEAP32[$276 >> 2] = $$1;\n  HEAP32[$$1 + 24 >> 2] = $276;\n  HEAP32[$$1 + 12 >> 2] = $$1;\n  HEAP32[$$1 + 8 >> 2] = $$1;\n } else {\n  $288 = HEAP32[$276 >> 2] | 0;\n  L200 : do if ((HEAP32[$288 + 4 >> 2] & -8 | 0) == ($$2 | 0)) $$0382$lcssa = $288; else {\n   $$0381438 = $$2 << (($$0394 | 0) == 31 ? 0 : 25 - ($$0394 >>> 1) | 0);\n   $$0382437 = $288;\n   while (1) {\n    $305 = $$0382437 + 16 + ($$0381438 >>> 31 << 2) | 0;\n    $300 = HEAP32[$305 >> 2] | 0;\n    if (!$300) break;\n    if ((HEAP32[$300 + 4 >> 2] & -8 | 0) == ($$2 | 0)) {\n     $$0382$lcssa = $300;\n     break L200;\n    } else {\n     $$0381438 = $$0381438 << 1;\n     $$0382437 = $300;\n    }\n   }\n   if ((HEAP32[4355] | 0) >>> 0 > $305 >>> 0) _abort(); else {\n    HEAP32[$305 >> 2] = $$1;\n    HEAP32[$$1 + 24 >> 2] = $$0382437;\n    HEAP32[$$1 + 12 >> 2] = $$1;\n    HEAP32[$$1 + 8 >> 2] = $$1;\n    break L197;\n   }\n  } while (0);\n  $312 = $$0382$lcssa + 8 | 0;\n  $313 = HEAP32[$312 >> 2] | 0;\n  $314 = HEAP32[4355] | 0;\n  if ($314 >>> 0 <= $313 >>> 0 & $314 >>> 0 <= $$0382$lcssa >>> 0) {\n   HEAP32[$313 + 12 >> 2] = $$1;\n   HEAP32[$312 >> 2] = $$1;\n   HEAP32[$$1 + 8 >> 2] = $313;\n   HEAP32[$$1 + 12 >> 2] = $$0382$lcssa;\n   HEAP32[$$1 + 24 >> 2] = 0;\n   break;\n  } else _abort();\n } while (0);\n $323 = (HEAP32[4359] | 0) + -1 | 0;\n HEAP32[4359] = $323;\n if ($323 | 0) return;\n $$0211$in$i = 17860;\n while (1) {\n  $$0211$i = HEAP32[$$0211$in$i >> 2] | 0;\n  if (!$$0211$i) break; else $$0211$in$i = $$0211$i + 8 | 0;\n }\n HEAP32[4359] = -1;\n return;\n}\n\nfunction _arLabelingSubEWZ($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0373 = 0, $$0374 = 0, $$0376 = 0, $$0378 = 0, $$0380 = 0, $$0384 = 0, $$0387 = 0, $$0392 = 0, $$0395 = 0, $$0399 = 0, $$1 = 0, $$1375 = 0, $$1377 = 0, $$1379 = 0, $$1381 = 0, $$1385 = 0, $$1388 = 0, $$1393 = 0, $$1396 = 0, $$1400 = 0, $$2 = 0, $$2382 = 0, $$2386 = 0, $$2389 = 0, $$2394 = 0, $$2397 = 0, $$3 = 0, $$3383 = 0, $$3390 = 0, $$3398 = 0, $$4 = 0, $$4391 = 0, $$5 = 0, $$6 = 0, $103 = 0, $106 = 0, $121 = 0, $123 = 0, $125 = 0, $129 = 0, $13 = 0, $133 = 0, $136 = 0, $138 = 0, $142 = 0, $146 = 0, $150 = 0, $155 = 0, $157 = 0, $161 = 0, $165 = 0, $169 = 0, $175 = 0, $178 = 0, $180 = 0, $184 = 0, $188 = 0, $19 = 0, $192 = 0, $195 = 0, $20 = 0, $200 = 0, $224 = 0, $226 = 0, $232 = 0, $235 = 0, $236 = 0, $242 = 0, $254 = 0, $255 = 0, $258 = 0, $265 = 0, $266 = 0, $27 = 0, $274 = 0, $277 = 0, $278 = 0, $282 = 0, $285 = 0, $289 = 0, $292 = 0, $296 = 0, $299 = 0, $303 = 0, $306 = 0, $310 = 0.0, $311 = 0, $312 = 0, $316 = 0, $33 = 0, $34 = 0, $37 = 0, $39 = 0, $43 = 0, $47 = 0, $5 = 0, $53 = 0, $54 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $62 = 0, $65 = 0, $80 = 0, $82 = 0, $84 = 0, $88 = 0, $92 = 0, $98 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = HEAP32[$4 >> 2] | 0;\n $6 = $2 + -1 | 0;\n $$0376 = $5;\n $$0387 = 0;\n $$0395 = $5 + ((Math_imul($6, $1) | 0) << 1) | 0;\n while (1) {\n  if (($$0387 | 0) >= ($1 | 0)) break;\n  HEAP16[$$0395 >> 1] = 0;\n  HEAP16[$$0376 >> 1] = 0;\n  $$0376 = $$0376 + 2 | 0;\n  $$0387 = $$0387 + 1 | 0;\n  $$0395 = $$0395 + 2 | 0;\n }\n $13 = $1 + -1 | 0;\n $$1377 = $5;\n $$1388 = 0;\n $$1396 = $5 + ($13 << 1) | 0;\n while (1) {\n  if (($$1388 | 0) >= ($2 | 0)) break;\n  HEAP16[$$1396 >> 1] = 0;\n  HEAP16[$$1377 >> 1] = 0;\n  $$1377 = $$1377 + ($1 << 1) | 0;\n  $$1388 = $$1388 + 1 | 0;\n  $$1396 = $$1396 + ($1 << 1) | 0;\n }\n $19 = $4 + 1179664 | 0;\n $20 = $1 + 1 | 0;\n $27 = 0 - $1 | 0;\n $$0373 = $0 + $20 | 0;\n $$0374 = $3 + $20 | 0;\n $$0384 = 1;\n $$0392 = 0;\n $$0399 = (HEAP32[$4 + 4 >> 2] | 0) + $20 | 0;\n $$2397 = $5 + ($20 << 1) | 0;\n L9 : while (1) {\n  if (($$0384 | 0) >= ($6 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0373;\n  $$1375 = $$0374;\n  $$1393 = $$0392;\n  $$1400 = $$0399;\n  $$2389 = 1;\n  $$3398 = $$2397;\n  while (1) {\n   if (($$2389 | 0) >= ($13 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0) > (HEAPU8[$$1375 >> 0] | 0)) {\n    HEAP8[$$1400 >> 0] = -1;\n    $33 = $$3398 + ($27 << 1) | 0;\n    $34 = HEAP16[$33 >> 1] | 0;\n    if ($34 << 16 >> 16 > 0) {\n     HEAP16[$$3398 >> 1] = $34;\n     $37 = ($34 << 16 >> 16) * 7 | 0;\n     $39 = $4 + 1310736 + ($37 + -7 << 2) | 0;\n     HEAP32[$39 >> 2] = (HEAP32[$39 >> 2] | 0) + 1;\n     $43 = $4 + 1310736 + ($37 + -6 << 2) | 0;\n     HEAP32[$43 >> 2] = (HEAP32[$43 >> 2] | 0) + $$2389;\n     $47 = $4 + 1310736 + ($37 + -5 << 2) | 0;\n     HEAP32[$47 >> 2] = (HEAP32[$47 >> 2] | 0) + $$0384;\n     HEAP32[$4 + 1310736 + ($37 + -1 << 2) >> 2] = $$0384;\n     $$2394 = $$1393;\n     break;\n    }\n    $53 = HEAP16[$33 + 2 >> 1] | 0;\n    $54 = $53 << 16 >> 16;\n    $57 = HEAP16[$33 + -2 >> 1] | 0;\n    $58 = $57 << 16 >> 16;\n    $59 = $57 << 16 >> 16 > 0;\n    if ($53 << 16 >> 16 <= 0) {\n     if ($59) {\n      HEAP16[$$3398 >> 1] = $57;\n      $155 = $58 * 7 | 0;\n      $157 = $4 + 1310736 + ($155 + -7 << 2) | 0;\n      HEAP32[$157 >> 2] = (HEAP32[$157 >> 2] | 0) + 1;\n      $161 = $4 + 1310736 + ($155 + -6 << 2) | 0;\n      HEAP32[$161 >> 2] = (HEAP32[$161 >> 2] | 0) + $$2389;\n      $165 = $4 + 1310736 + ($155 + -5 << 2) | 0;\n      HEAP32[$165 >> 2] = (HEAP32[$165 >> 2] | 0) + $$0384;\n      $169 = $4 + 1310736 + ($155 + -3 << 2) | 0;\n      if ((HEAP32[$169 >> 2] | 0) < ($$2389 | 0)) HEAP32[$169 >> 2] = $$2389;\n      HEAP32[$4 + 1310736 + ($155 + -1 << 2) >> 2] = $$0384;\n      $$2394 = $$1393;\n      break;\n     }\n     $175 = HEAP16[$$3398 + -2 >> 1] | 0;\n     if ($175 << 16 >> 16 > 0) {\n      HEAP16[$$3398 >> 1] = $175;\n      $178 = ($175 << 16 >> 16) * 7 | 0;\n      $180 = $4 + 1310736 + ($178 + -7 << 2) | 0;\n      HEAP32[$180 >> 2] = (HEAP32[$180 >> 2] | 0) + 1;\n      $184 = $4 + 1310736 + ($178 + -6 << 2) | 0;\n      HEAP32[$184 >> 2] = (HEAP32[$184 >> 2] | 0) + $$2389;\n      $188 = $4 + 1310736 + ($178 + -5 << 2) | 0;\n      HEAP32[$188 >> 2] = (HEAP32[$188 >> 2] | 0) + $$0384;\n      $192 = $4 + 1310736 + ($178 + -3 << 2) | 0;\n      if ((HEAP32[$192 >> 2] | 0) >= ($$2389 | 0)) {\n       $$2394 = $$1393;\n       break;\n      }\n      HEAP32[$192 >> 2] = $$2389;\n      $$2394 = $$1393;\n      break;\n     } else {\n      $195 = $$1393 + 1 | 0;\n      if (($$1393 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3398 >> 1] = $195;\n      HEAP32[$4 + 1179664 + ($$1393 << 2) >> 2] = $195 << 16 >> 16;\n      $200 = $$1393 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($200 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($200 + 1 << 2) >> 2] = $$2389;\n      HEAP32[$4 + 1310736 + ($200 + 2 << 2) >> 2] = $$0384;\n      HEAP32[$4 + 1310736 + ($200 + 3 << 2) >> 2] = $$2389;\n      HEAP32[$4 + 1310736 + ($200 + 4 << 2) >> 2] = $$2389;\n      HEAP32[$4 + 1310736 + ($200 + 5 << 2) >> 2] = $$0384;\n      HEAP32[$4 + 1310736 + ($200 + 6 << 2) >> 2] = $$0384;\n      $$2394 = $195;\n      break;\n     }\n    }\n    if ($59) {\n     $62 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n     $65 = HEAP32[$4 + 1179664 + ($58 + -1 << 2) >> 2] | 0;\n     L36 : do if (($62 | 0) > ($65 | 0)) {\n      HEAP16[$$3398 >> 1] = $65;\n      $$0378 = $19;\n      $$0380 = 0;\n      while (1) {\n       if (($$0380 | 0) >= ($$1393 | 0)) {\n        $80 = $65;\n        break L36;\n       }\n       if ((HEAP32[$$0378 >> 2] | 0) == ($62 | 0)) HEAP32[$$0378 >> 2] = $65;\n       $$0378 = $$0378 + 4 | 0;\n       $$0380 = $$0380 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3398 >> 1] = $62;\n      if (($62 | 0) < ($65 | 0)) {\n       $$1379 = $19;\n       $$1381 = 0;\n       while (1) {\n        if (($$1381 | 0) >= ($$1393 | 0)) {\n         $80 = $62;\n         break L36;\n        }\n        if ((HEAP32[$$1379 >> 2] | 0) == ($65 | 0)) HEAP32[$$1379 >> 2] = $62;\n        $$1379 = $$1379 + 4 | 0;\n        $$1381 = $$1381 + 1 | 0;\n       }\n      } else $80 = $62;\n     } while (0);\n     $82 = ($80 << 16 >> 16) * 7 | 0;\n     $84 = $4 + 1310736 + ($82 + -7 << 2) | 0;\n     HEAP32[$84 >> 2] = (HEAP32[$84 >> 2] | 0) + 1;\n     $88 = $4 + 1310736 + ($82 + -6 << 2) | 0;\n     HEAP32[$88 >> 2] = (HEAP32[$88 >> 2] | 0) + $$2389;\n     $92 = $4 + 1310736 + ($82 + -5 << 2) | 0;\n     HEAP32[$92 >> 2] = (HEAP32[$92 >> 2] | 0) + $$0384;\n     HEAP32[$4 + 1310736 + ($82 + -1 << 2) >> 2] = $$0384;\n     $$2394 = $$1393;\n     break;\n    }\n    $98 = HEAP16[$$3398 + -2 >> 1] | 0;\n    if ($98 << 16 >> 16 <= 0) {\n     HEAP16[$$3398 >> 1] = $53;\n     $136 = $54 * 7 | 0;\n     $138 = $4 + 1310736 + ($136 + -7 << 2) | 0;\n     HEAP32[$138 >> 2] = (HEAP32[$138 >> 2] | 0) + 1;\n     $142 = $4 + 1310736 + ($136 + -6 << 2) | 0;\n     HEAP32[$142 >> 2] = (HEAP32[$142 >> 2] | 0) + $$2389;\n     $146 = $4 + 1310736 + ($136 + -5 << 2) | 0;\n     HEAP32[$146 >> 2] = (HEAP32[$146 >> 2] | 0) + $$0384;\n     $150 = $4 + 1310736 + ($136 + -4 << 2) | 0;\n     if ((HEAP32[$150 >> 2] | 0) > ($$2389 | 0)) HEAP32[$150 >> 2] = $$2389;\n     HEAP32[$4 + 1310736 + ($136 + -1 << 2) >> 2] = $$0384;\n     $$2394 = $$1393;\n     break;\n    }\n    $103 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n    $106 = HEAP32[$4 + 1179664 + (($98 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L60 : do if (($103 | 0) > ($106 | 0)) {\n     HEAP16[$$3398 >> 1] = $106;\n     $$2 = $19;\n     $$2382 = 0;\n     while (1) {\n      if (($$2382 | 0) >= ($$1393 | 0)) {\n       $121 = $106;\n       break L60;\n      }\n      if ((HEAP32[$$2 >> 2] | 0) == ($103 | 0)) HEAP32[$$2 >> 2] = $106;\n      $$2 = $$2 + 4 | 0;\n      $$2382 = $$2382 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3398 >> 1] = $103;\n     if (($103 | 0) < ($106 | 0)) {\n      $$3 = $19;\n      $$3383 = 0;\n      while (1) {\n       if (($$3383 | 0) >= ($$1393 | 0)) {\n        $121 = $103;\n        break L60;\n       }\n       if ((HEAP32[$$3 >> 2] | 0) == ($106 | 0)) HEAP32[$$3 >> 2] = $103;\n       $$3 = $$3 + 4 | 0;\n       $$3383 = $$3383 + 1 | 0;\n      }\n     } else $121 = $103;\n    } while (0);\n    $123 = ($121 << 16 >> 16) * 7 | 0;\n    $125 = $4 + 1310736 + ($123 + -7 << 2) | 0;\n    HEAP32[$125 >> 2] = (HEAP32[$125 >> 2] | 0) + 1;\n    $129 = $4 + 1310736 + ($123 + -6 << 2) | 0;\n    HEAP32[$129 >> 2] = (HEAP32[$129 >> 2] | 0) + $$2389;\n    $133 = $4 + 1310736 + ($123 + -5 << 2) | 0;\n    HEAP32[$133 >> 2] = (HEAP32[$133 >> 2] | 0) + $$0384;\n    $$2394 = $$1393;\n   } else {\n    HEAP16[$$3398 >> 1] = 0;\n    HEAP8[$$1400 >> 0] = 0;\n    $$2394 = $$1393;\n   } while (0);\n   $$1 = $$1 + 1 | 0;\n   $$1375 = $$1375 + 1 | 0;\n   $$1393 = $$2394;\n   $$1400 = $$1400 + 1 | 0;\n   $$2389 = $$2389 + 1 | 0;\n   $$3398 = $$3398 + 2 | 0;\n  }\n  $$0373 = $$1 + 2 | 0;\n  $$0374 = $$1375 + 2 | 0;\n  $$0384 = $$0384 + 1 | 0;\n  $$0392 = $$1393;\n  $$0399 = $$1400 + 2 | 0;\n  $$2397 = $$3398 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $224 = $4 + 12 | 0;\n  $$1385 = 1;\n  $$3390 = 1;\n  $$4 = $19;\n  while (1) {\n   if (($$3390 | 0) > ($$0392 | 0)) break;\n   $226 = HEAP32[$$4 >> 2] | 0;\n   if (($226 | 0) == ($$3390 | 0)) {\n    $$2386 = $$1385 + 1 | 0;\n    $232 = $$1385;\n   } else {\n    $$2386 = $$1385;\n    $232 = HEAP32[$4 + 1179664 + ($226 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $232;\n   $$1385 = $$2386;\n   $$3390 = $$3390 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $235 = $4 + 8 | 0;\n  $236 = $$1385 + -1 | 0;\n  HEAP32[$235 >> 2] = $236;\n  if (!$236) $$0 = 0; else {\n   _memset($224 | 0, 0, $236 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $236 << 4 | 0) | 0;\n   $$4391 = 0;\n   while (1) {\n    if (($$4391 | 0) >= ($236 | 0)) break;\n    $242 = $$4391 << 2;\n    HEAP32[$4 + 131084 + ($242 << 2) >> 2] = $1;\n    HEAP32[$4 + 131084 + (($242 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($242 | 2) << 2) >> 2] = $2;\n    HEAP32[$4 + 131084 + (($242 | 3) << 2) >> 2] = 0;\n    $$4391 = $$4391 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0392 | 0)) break;\n    $254 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $255 = $$5 * 7 | 0;\n    $258 = $4 + 12 + ($254 << 2) | 0;\n    HEAP32[$258 >> 2] = (HEAP32[$258 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($255 << 2) >> 2] | 0);\n    $265 = $254 << 1;\n    $266 = $4 + 655376 + ($265 << 3) | 0;\n    HEAPF64[$266 >> 3] = +HEAPF64[$266 >> 3] + +(HEAP32[$4 + 1310736 + ($255 + 1 << 2) >> 2] | 0);\n    $274 = $4 + 655376 + (($265 | 1) << 3) | 0;\n    HEAPF64[$274 >> 3] = +HEAPF64[$274 >> 3] + +(HEAP32[$4 + 1310736 + ($255 + 2 << 2) >> 2] | 0);\n    $277 = $254 << 2;\n    $278 = $4 + 131084 + ($277 << 2) | 0;\n    $282 = HEAP32[$4 + 1310736 + ($255 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$278 >> 2] | 0) > ($282 | 0)) HEAP32[$278 >> 2] = $282;\n    $285 = $4 + 131084 + (($277 | 1) << 2) | 0;\n    $289 = HEAP32[$4 + 1310736 + ($255 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$285 >> 2] | 0) < ($289 | 0)) HEAP32[$285 >> 2] = $289;\n    $292 = $4 + 131084 + (($277 | 2) << 2) | 0;\n    $296 = HEAP32[$4 + 1310736 + ($255 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$292 >> 2] | 0) > ($296 | 0)) HEAP32[$292 >> 2] = $296;\n    $299 = $4 + 131084 + (($277 | 3) << 2) | 0;\n    $303 = HEAP32[$4 + 1310736 + ($255 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$299 >> 2] | 0) < ($303 | 0)) HEAP32[$299 >> 2] = $303;\n    $$5 = $$5 + 1 | 0;\n   }\n   $306 = HEAP32[$235 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($306 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $310 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $311 = $$6 << 1;\n    $312 = $4 + 655376 + ($311 << 3) | 0;\n    HEAPF64[$312 >> 3] = +HEAPF64[$312 >> 3] / $310;\n    $316 = $4 + 655376 + (($311 | 1) << 3) | 0;\n    HEAPF64[$316 >> 3] = +HEAPF64[$316 >> 3] / $310;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubEBZ($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0373 = 0, $$0374 = 0, $$0376 = 0, $$0378 = 0, $$0380 = 0, $$0384 = 0, $$0387 = 0, $$0392 = 0, $$0395 = 0, $$0399 = 0, $$1 = 0, $$1375 = 0, $$1377 = 0, $$1379 = 0, $$1381 = 0, $$1385 = 0, $$1388 = 0, $$1393 = 0, $$1396 = 0, $$1400 = 0, $$2 = 0, $$2382 = 0, $$2386 = 0, $$2389 = 0, $$2394 = 0, $$2397 = 0, $$3 = 0, $$3383 = 0, $$3390 = 0, $$3398 = 0, $$4 = 0, $$4391 = 0, $$5 = 0, $$6 = 0, $103 = 0, $106 = 0, $121 = 0, $123 = 0, $125 = 0, $129 = 0, $13 = 0, $133 = 0, $136 = 0, $138 = 0, $142 = 0, $146 = 0, $150 = 0, $155 = 0, $157 = 0, $161 = 0, $165 = 0, $169 = 0, $175 = 0, $178 = 0, $180 = 0, $184 = 0, $188 = 0, $19 = 0, $192 = 0, $195 = 0, $20 = 0, $200 = 0, $224 = 0, $226 = 0, $232 = 0, $235 = 0, $236 = 0, $242 = 0, $254 = 0, $255 = 0, $258 = 0, $265 = 0, $266 = 0, $27 = 0, $274 = 0, $277 = 0, $278 = 0, $282 = 0, $285 = 0, $289 = 0, $292 = 0, $296 = 0, $299 = 0, $303 = 0, $306 = 0, $310 = 0.0, $311 = 0, $312 = 0, $316 = 0, $33 = 0, $34 = 0, $37 = 0, $39 = 0, $43 = 0, $47 = 0, $5 = 0, $53 = 0, $54 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $62 = 0, $65 = 0, $80 = 0, $82 = 0, $84 = 0, $88 = 0, $92 = 0, $98 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = HEAP32[$4 >> 2] | 0;\n $6 = $2 + -1 | 0;\n $$0376 = $5;\n $$0387 = 0;\n $$0395 = $5 + ((Math_imul($6, $1) | 0) << 1) | 0;\n while (1) {\n  if (($$0387 | 0) >= ($1 | 0)) break;\n  HEAP16[$$0395 >> 1] = 0;\n  HEAP16[$$0376 >> 1] = 0;\n  $$0376 = $$0376 + 2 | 0;\n  $$0387 = $$0387 + 1 | 0;\n  $$0395 = $$0395 + 2 | 0;\n }\n $13 = $1 + -1 | 0;\n $$1377 = $5;\n $$1388 = 0;\n $$1396 = $5 + ($13 << 1) | 0;\n while (1) {\n  if (($$1388 | 0) >= ($2 | 0)) break;\n  HEAP16[$$1396 >> 1] = 0;\n  HEAP16[$$1377 >> 1] = 0;\n  $$1377 = $$1377 + ($1 << 1) | 0;\n  $$1388 = $$1388 + 1 | 0;\n  $$1396 = $$1396 + ($1 << 1) | 0;\n }\n $19 = $4 + 1179664 | 0;\n $20 = $1 + 1 | 0;\n $27 = 0 - $1 | 0;\n $$0373 = $0 + $20 | 0;\n $$0374 = $3 + $20 | 0;\n $$0384 = 1;\n $$0392 = 0;\n $$0399 = (HEAP32[$4 + 4 >> 2] | 0) + $20 | 0;\n $$2397 = $5 + ($20 << 1) | 0;\n L9 : while (1) {\n  if (($$0384 | 0) >= ($6 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0373;\n  $$1375 = $$0374;\n  $$1393 = $$0392;\n  $$1400 = $$0399;\n  $$2389 = 1;\n  $$3398 = $$2397;\n  while (1) {\n   if (($$2389 | 0) >= ($13 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0) > (HEAPU8[$$1375 >> 0] | 0)) {\n    HEAP16[$$3398 >> 1] = 0;\n    HEAP8[$$1400 >> 0] = 0;\n    $$2394 = $$1393;\n   } else {\n    HEAP8[$$1400 >> 0] = -1;\n    $33 = $$3398 + ($27 << 1) | 0;\n    $34 = HEAP16[$33 >> 1] | 0;\n    if ($34 << 16 >> 16 > 0) {\n     HEAP16[$$3398 >> 1] = $34;\n     $37 = ($34 << 16 >> 16) * 7 | 0;\n     $39 = $4 + 1310736 + ($37 + -7 << 2) | 0;\n     HEAP32[$39 >> 2] = (HEAP32[$39 >> 2] | 0) + 1;\n     $43 = $4 + 1310736 + ($37 + -6 << 2) | 0;\n     HEAP32[$43 >> 2] = (HEAP32[$43 >> 2] | 0) + $$2389;\n     $47 = $4 + 1310736 + ($37 + -5 << 2) | 0;\n     HEAP32[$47 >> 2] = (HEAP32[$47 >> 2] | 0) + $$0384;\n     HEAP32[$4 + 1310736 + ($37 + -1 << 2) >> 2] = $$0384;\n     $$2394 = $$1393;\n     break;\n    }\n    $53 = HEAP16[$33 + 2 >> 1] | 0;\n    $54 = $53 << 16 >> 16;\n    $57 = HEAP16[$33 + -2 >> 1] | 0;\n    $58 = $57 << 16 >> 16;\n    $59 = $57 << 16 >> 16 > 0;\n    if ($53 << 16 >> 16 <= 0) {\n     if ($59) {\n      HEAP16[$$3398 >> 1] = $57;\n      $155 = $58 * 7 | 0;\n      $157 = $4 + 1310736 + ($155 + -7 << 2) | 0;\n      HEAP32[$157 >> 2] = (HEAP32[$157 >> 2] | 0) + 1;\n      $161 = $4 + 1310736 + ($155 + -6 << 2) | 0;\n      HEAP32[$161 >> 2] = (HEAP32[$161 >> 2] | 0) + $$2389;\n      $165 = $4 + 1310736 + ($155 + -5 << 2) | 0;\n      HEAP32[$165 >> 2] = (HEAP32[$165 >> 2] | 0) + $$0384;\n      $169 = $4 + 1310736 + ($155 + -3 << 2) | 0;\n      if ((HEAP32[$169 >> 2] | 0) < ($$2389 | 0)) HEAP32[$169 >> 2] = $$2389;\n      HEAP32[$4 + 1310736 + ($155 + -1 << 2) >> 2] = $$0384;\n      $$2394 = $$1393;\n      break;\n     }\n     $175 = HEAP16[$$3398 + -2 >> 1] | 0;\n     if ($175 << 16 >> 16 > 0) {\n      HEAP16[$$3398 >> 1] = $175;\n      $178 = ($175 << 16 >> 16) * 7 | 0;\n      $180 = $4 + 1310736 + ($178 + -7 << 2) | 0;\n      HEAP32[$180 >> 2] = (HEAP32[$180 >> 2] | 0) + 1;\n      $184 = $4 + 1310736 + ($178 + -6 << 2) | 0;\n      HEAP32[$184 >> 2] = (HEAP32[$184 >> 2] | 0) + $$2389;\n      $188 = $4 + 1310736 + ($178 + -5 << 2) | 0;\n      HEAP32[$188 >> 2] = (HEAP32[$188 >> 2] | 0) + $$0384;\n      $192 = $4 + 1310736 + ($178 + -3 << 2) | 0;\n      if ((HEAP32[$192 >> 2] | 0) >= ($$2389 | 0)) {\n       $$2394 = $$1393;\n       break;\n      }\n      HEAP32[$192 >> 2] = $$2389;\n      $$2394 = $$1393;\n      break;\n     } else {\n      $195 = $$1393 + 1 | 0;\n      if (($$1393 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3398 >> 1] = $195;\n      HEAP32[$4 + 1179664 + ($$1393 << 2) >> 2] = $195 << 16 >> 16;\n      $200 = $$1393 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($200 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($200 + 1 << 2) >> 2] = $$2389;\n      HEAP32[$4 + 1310736 + ($200 + 2 << 2) >> 2] = $$0384;\n      HEAP32[$4 + 1310736 + ($200 + 3 << 2) >> 2] = $$2389;\n      HEAP32[$4 + 1310736 + ($200 + 4 << 2) >> 2] = $$2389;\n      HEAP32[$4 + 1310736 + ($200 + 5 << 2) >> 2] = $$0384;\n      HEAP32[$4 + 1310736 + ($200 + 6 << 2) >> 2] = $$0384;\n      $$2394 = $195;\n      break;\n     }\n    }\n    if ($59) {\n     $62 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n     $65 = HEAP32[$4 + 1179664 + ($58 + -1 << 2) >> 2] | 0;\n     L37 : do if (($62 | 0) > ($65 | 0)) {\n      HEAP16[$$3398 >> 1] = $65;\n      $$0378 = $19;\n      $$0380 = 0;\n      while (1) {\n       if (($$0380 | 0) >= ($$1393 | 0)) {\n        $80 = $65;\n        break L37;\n       }\n       if ((HEAP32[$$0378 >> 2] | 0) == ($62 | 0)) HEAP32[$$0378 >> 2] = $65;\n       $$0378 = $$0378 + 4 | 0;\n       $$0380 = $$0380 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3398 >> 1] = $62;\n      if (($62 | 0) < ($65 | 0)) {\n       $$1379 = $19;\n       $$1381 = 0;\n       while (1) {\n        if (($$1381 | 0) >= ($$1393 | 0)) {\n         $80 = $62;\n         break L37;\n        }\n        if ((HEAP32[$$1379 >> 2] | 0) == ($65 | 0)) HEAP32[$$1379 >> 2] = $62;\n        $$1379 = $$1379 + 4 | 0;\n        $$1381 = $$1381 + 1 | 0;\n       }\n      } else $80 = $62;\n     } while (0);\n     $82 = ($80 << 16 >> 16) * 7 | 0;\n     $84 = $4 + 1310736 + ($82 + -7 << 2) | 0;\n     HEAP32[$84 >> 2] = (HEAP32[$84 >> 2] | 0) + 1;\n     $88 = $4 + 1310736 + ($82 + -6 << 2) | 0;\n     HEAP32[$88 >> 2] = (HEAP32[$88 >> 2] | 0) + $$2389;\n     $92 = $4 + 1310736 + ($82 + -5 << 2) | 0;\n     HEAP32[$92 >> 2] = (HEAP32[$92 >> 2] | 0) + $$0384;\n     HEAP32[$4 + 1310736 + ($82 + -1 << 2) >> 2] = $$0384;\n     $$2394 = $$1393;\n     break;\n    }\n    $98 = HEAP16[$$3398 + -2 >> 1] | 0;\n    if ($98 << 16 >> 16 <= 0) {\n     HEAP16[$$3398 >> 1] = $53;\n     $136 = $54 * 7 | 0;\n     $138 = $4 + 1310736 + ($136 + -7 << 2) | 0;\n     HEAP32[$138 >> 2] = (HEAP32[$138 >> 2] | 0) + 1;\n     $142 = $4 + 1310736 + ($136 + -6 << 2) | 0;\n     HEAP32[$142 >> 2] = (HEAP32[$142 >> 2] | 0) + $$2389;\n     $146 = $4 + 1310736 + ($136 + -5 << 2) | 0;\n     HEAP32[$146 >> 2] = (HEAP32[$146 >> 2] | 0) + $$0384;\n     $150 = $4 + 1310736 + ($136 + -4 << 2) | 0;\n     if ((HEAP32[$150 >> 2] | 0) > ($$2389 | 0)) HEAP32[$150 >> 2] = $$2389;\n     HEAP32[$4 + 1310736 + ($136 + -1 << 2) >> 2] = $$0384;\n     $$2394 = $$1393;\n     break;\n    }\n    $103 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n    $106 = HEAP32[$4 + 1179664 + (($98 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L61 : do if (($103 | 0) > ($106 | 0)) {\n     HEAP16[$$3398 >> 1] = $106;\n     $$2 = $19;\n     $$2382 = 0;\n     while (1) {\n      if (($$2382 | 0) >= ($$1393 | 0)) {\n       $121 = $106;\n       break L61;\n      }\n      if ((HEAP32[$$2 >> 2] | 0) == ($103 | 0)) HEAP32[$$2 >> 2] = $106;\n      $$2 = $$2 + 4 | 0;\n      $$2382 = $$2382 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3398 >> 1] = $103;\n     if (($103 | 0) < ($106 | 0)) {\n      $$3 = $19;\n      $$3383 = 0;\n      while (1) {\n       if (($$3383 | 0) >= ($$1393 | 0)) {\n        $121 = $103;\n        break L61;\n       }\n       if ((HEAP32[$$3 >> 2] | 0) == ($106 | 0)) HEAP32[$$3 >> 2] = $103;\n       $$3 = $$3 + 4 | 0;\n       $$3383 = $$3383 + 1 | 0;\n      }\n     } else $121 = $103;\n    } while (0);\n    $123 = ($121 << 16 >> 16) * 7 | 0;\n    $125 = $4 + 1310736 + ($123 + -7 << 2) | 0;\n    HEAP32[$125 >> 2] = (HEAP32[$125 >> 2] | 0) + 1;\n    $129 = $4 + 1310736 + ($123 + -6 << 2) | 0;\n    HEAP32[$129 >> 2] = (HEAP32[$129 >> 2] | 0) + $$2389;\n    $133 = $4 + 1310736 + ($123 + -5 << 2) | 0;\n    HEAP32[$133 >> 2] = (HEAP32[$133 >> 2] | 0) + $$0384;\n    $$2394 = $$1393;\n   } while (0);\n   $$1 = $$1 + 1 | 0;\n   $$1375 = $$1375 + 1 | 0;\n   $$1393 = $$2394;\n   $$1400 = $$1400 + 1 | 0;\n   $$2389 = $$2389 + 1 | 0;\n   $$3398 = $$3398 + 2 | 0;\n  }\n  $$0373 = $$1 + 2 | 0;\n  $$0374 = $$1375 + 2 | 0;\n  $$0384 = $$0384 + 1 | 0;\n  $$0392 = $$1393;\n  $$0399 = $$1400 + 2 | 0;\n  $$2397 = $$3398 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $224 = $4 + 12 | 0;\n  $$1385 = 1;\n  $$3390 = 1;\n  $$4 = $19;\n  while (1) {\n   if (($$3390 | 0) > ($$0392 | 0)) break;\n   $226 = HEAP32[$$4 >> 2] | 0;\n   if (($226 | 0) == ($$3390 | 0)) {\n    $$2386 = $$1385 + 1 | 0;\n    $232 = $$1385;\n   } else {\n    $$2386 = $$1385;\n    $232 = HEAP32[$4 + 1179664 + ($226 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $232;\n   $$1385 = $$2386;\n   $$3390 = $$3390 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $235 = $4 + 8 | 0;\n  $236 = $$1385 + -1 | 0;\n  HEAP32[$235 >> 2] = $236;\n  if (!$236) $$0 = 0; else {\n   _memset($224 | 0, 0, $236 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $236 << 4 | 0) | 0;\n   $$4391 = 0;\n   while (1) {\n    if (($$4391 | 0) >= ($236 | 0)) break;\n    $242 = $$4391 << 2;\n    HEAP32[$4 + 131084 + ($242 << 2) >> 2] = $1;\n    HEAP32[$4 + 131084 + (($242 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($242 | 2) << 2) >> 2] = $2;\n    HEAP32[$4 + 131084 + (($242 | 3) << 2) >> 2] = 0;\n    $$4391 = $$4391 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0392 | 0)) break;\n    $254 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $255 = $$5 * 7 | 0;\n    $258 = $4 + 12 + ($254 << 2) | 0;\n    HEAP32[$258 >> 2] = (HEAP32[$258 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($255 << 2) >> 2] | 0);\n    $265 = $254 << 1;\n    $266 = $4 + 655376 + ($265 << 3) | 0;\n    HEAPF64[$266 >> 3] = +HEAPF64[$266 >> 3] + +(HEAP32[$4 + 1310736 + ($255 + 1 << 2) >> 2] | 0);\n    $274 = $4 + 655376 + (($265 | 1) << 3) | 0;\n    HEAPF64[$274 >> 3] = +HEAPF64[$274 >> 3] + +(HEAP32[$4 + 1310736 + ($255 + 2 << 2) >> 2] | 0);\n    $277 = $254 << 2;\n    $278 = $4 + 131084 + ($277 << 2) | 0;\n    $282 = HEAP32[$4 + 1310736 + ($255 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$278 >> 2] | 0) > ($282 | 0)) HEAP32[$278 >> 2] = $282;\n    $285 = $4 + 131084 + (($277 | 1) << 2) | 0;\n    $289 = HEAP32[$4 + 1310736 + ($255 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$285 >> 2] | 0) < ($289 | 0)) HEAP32[$285 >> 2] = $289;\n    $292 = $4 + 131084 + (($277 | 2) << 2) | 0;\n    $296 = HEAP32[$4 + 1310736 + ($255 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$292 >> 2] | 0) > ($296 | 0)) HEAP32[$292 >> 2] = $296;\n    $299 = $4 + 131084 + (($277 | 3) << 2) | 0;\n    $303 = HEAP32[$4 + 1310736 + ($255 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$299 >> 2] | 0) < ($303 | 0)) HEAP32[$299 >> 2] = $303;\n    $$5 = $$5 + 1 | 0;\n   }\n   $306 = HEAP32[$235 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($306 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $310 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $311 = $$6 << 1;\n    $312 = $4 + 655376 + ($311 << 3) | 0;\n    HEAPF64[$312 >> 3] = +HEAPF64[$312 >> 3] / $310;\n    $316 = $4 + 655376 + (($311 | 1) << 3) | 0;\n    HEAPF64[$316 >> 3] = +HEAPF64[$316 >> 3] / $310;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubEWIC($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0369 = 0, $$0370 = 0, $$0372 = 0, $$0374 = 0, $$0378 = 0, $$0382 = 0, $$0385 = 0, $$0390 = 0, $$0393 = 0, $$1 = 0, $$1371 = 0, $$1373 = 0, $$1375 = 0, $$1379 = 0, $$1383 = 0, $$1386 = 0, $$1391 = 0, $$1394 = 0, $$2 = 0, $$2376 = 0, $$2380 = 0, $$2384 = 0, $$2387 = 0, $$2392 = 0, $$3 = 0, $$3377 = 0, $$3381 = 0, $$3388 = 0, $$4 = 0, $$4389 = 0, $$5 = 0, $$6 = 0, $101 = 0, $106 = 0, $109 = 0, $124 = 0, $126 = 0, $128 = 0, $132 = 0, $136 = 0, $139 = 0, $141 = 0, $145 = 0, $149 = 0, $15 = 0, $153 = 0, $158 = 0, $160 = 0, $164 = 0, $168 = 0, $172 = 0, $178 = 0, $181 = 0, $183 = 0, $187 = 0, $191 = 0, $195 = 0, $198 = 0, $203 = 0, $21 = 0, $22 = 0, $226 = 0, $228 = 0, $234 = 0, $237 = 0, $238 = 0, $244 = 0, $256 = 0, $257 = 0, $260 = 0, $267 = 0, $268 = 0, $276 = 0, $279 = 0, $280 = 0, $284 = 0, $287 = 0, $291 = 0, $294 = 0, $298 = 0, $30 = 0, $301 = 0, $305 = 0, $308 = 0, $312 = 0.0, $313 = 0, $314 = 0, $318 = 0, $36 = 0, $37 = 0, $40 = 0, $42 = 0, $46 = 0, $5 = 0, $50 = 0, $56 = 0, $57 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $65 = 0, $68 = 0, $7 = 0, $8 = 0, $83 = 0, $85 = 0, $87 = 0, $91 = 0, $95 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = ($1 | 0) / 2 | 0;\n $6 = ($2 | 0) / 2 | 0;\n $7 = HEAP32[$4 >> 2] | 0;\n $8 = $6 + -1 | 0;\n $$0370 = $7;\n $$0372 = $7 + ((Math_imul($8, $5) | 0) << 1) | 0;\n $$0385 = 0;\n while (1) {\n  if (($$0385 | 0) >= ($5 | 0)) break;\n  HEAP16[$$0372 >> 1] = 0;\n  HEAP16[$$0370 >> 1] = 0;\n  $$0370 = $$0370 + 2 | 0;\n  $$0372 = $$0372 + 2 | 0;\n  $$0385 = $$0385 + 1 | 0;\n }\n $15 = $5 + -1 | 0;\n $$1371 = $7;\n $$1373 = $7 + ($15 << 1) | 0;\n $$1386 = 0;\n while (1) {\n  if (($$1386 | 0) >= ($6 | 0)) break;\n  HEAP16[$$1373 >> 1] = 0;\n  HEAP16[$$1371 >> 1] = 0;\n  $$1371 = $$1371 + ($5 << 1) | 0;\n  $$1373 = $$1373 + ($5 << 1) | 0;\n  $$1386 = $$1386 + 1 | 0;\n }\n $21 = $4 + 1179664 | 0;\n $22 = $5 + 1 | 0;\n $30 = 0 - $5 | 0;\n $$0369 = $0 + (($1 << 1) + 2) | 0;\n $$0382 = 1;\n $$0390 = 0;\n $$0393 = (HEAP32[$4 + 4 >> 2] | 0) + $22 | 0;\n $$2 = $7 + ($22 << 1) | 0;\n L9 : while (1) {\n  if (($$0382 | 0) >= ($8 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0369;\n  $$1391 = $$0390;\n  $$1394 = $$0393;\n  $$2387 = 1;\n  $$3 = $$2;\n  while (1) {\n   if (($$2387 | 0) >= ($15 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0 | 0) > ($3 | 0)) {\n    HEAP8[$$1394 >> 0] = -1;\n    $36 = $$3 + ($30 << 1) | 0;\n    $37 = HEAP16[$36 >> 1] | 0;\n    if ($37 << 16 >> 16 > 0) {\n     HEAP16[$$3 >> 1] = $37;\n     $40 = ($37 << 16 >> 16) * 7 | 0;\n     $42 = $4 + 1310736 + ($40 + -7 << 2) | 0;\n     HEAP32[$42 >> 2] = (HEAP32[$42 >> 2] | 0) + 1;\n     $46 = $4 + 1310736 + ($40 + -6 << 2) | 0;\n     HEAP32[$46 >> 2] = (HEAP32[$46 >> 2] | 0) + $$2387;\n     $50 = $4 + 1310736 + ($40 + -5 << 2) | 0;\n     HEAP32[$50 >> 2] = (HEAP32[$50 >> 2] | 0) + $$0382;\n     HEAP32[$4 + 1310736 + ($40 + -1 << 2) >> 2] = $$0382;\n     $$2392 = $$1391;\n     break;\n    }\n    $56 = HEAP16[$36 + 2 >> 1] | 0;\n    $57 = $56 << 16 >> 16;\n    $60 = HEAP16[$36 + -2 >> 1] | 0;\n    $61 = $60 << 16 >> 16;\n    $62 = $60 << 16 >> 16 > 0;\n    if ($56 << 16 >> 16 <= 0) {\n     if ($62) {\n      HEAP16[$$3 >> 1] = $60;\n      $158 = $61 * 7 | 0;\n      $160 = $4 + 1310736 + ($158 + -7 << 2) | 0;\n      HEAP32[$160 >> 2] = (HEAP32[$160 >> 2] | 0) + 1;\n      $164 = $4 + 1310736 + ($158 + -6 << 2) | 0;\n      HEAP32[$164 >> 2] = (HEAP32[$164 >> 2] | 0) + $$2387;\n      $168 = $4 + 1310736 + ($158 + -5 << 2) | 0;\n      HEAP32[$168 >> 2] = (HEAP32[$168 >> 2] | 0) + $$0382;\n      $172 = $4 + 1310736 + ($158 + -3 << 2) | 0;\n      if ((HEAP32[$172 >> 2] | 0) < ($$2387 | 0)) HEAP32[$172 >> 2] = $$2387;\n      HEAP32[$4 + 1310736 + ($158 + -1 << 2) >> 2] = $$0382;\n      $$2392 = $$1391;\n      break;\n     }\n     $178 = HEAP16[$$3 + -2 >> 1] | 0;\n     if ($178 << 16 >> 16 > 0) {\n      HEAP16[$$3 >> 1] = $178;\n      $181 = ($178 << 16 >> 16) * 7 | 0;\n      $183 = $4 + 1310736 + ($181 + -7 << 2) | 0;\n      HEAP32[$183 >> 2] = (HEAP32[$183 >> 2] | 0) + 1;\n      $187 = $4 + 1310736 + ($181 + -6 << 2) | 0;\n      HEAP32[$187 >> 2] = (HEAP32[$187 >> 2] | 0) + $$2387;\n      $191 = $4 + 1310736 + ($181 + -5 << 2) | 0;\n      HEAP32[$191 >> 2] = (HEAP32[$191 >> 2] | 0) + $$0382;\n      $195 = $4 + 1310736 + ($181 + -3 << 2) | 0;\n      if ((HEAP32[$195 >> 2] | 0) >= ($$2387 | 0)) {\n       $$2392 = $$1391;\n       break;\n      }\n      HEAP32[$195 >> 2] = $$2387;\n      $$2392 = $$1391;\n      break;\n     } else {\n      $198 = $$1391 + 1 | 0;\n      if (($$1391 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3 >> 1] = $198;\n      HEAP32[$4 + 1179664 + ($$1391 << 2) >> 2] = $198 << 16 >> 16;\n      $203 = $$1391 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($203 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($203 + 1 << 2) >> 2] = $$2387;\n      HEAP32[$4 + 1310736 + ($203 + 2 << 2) >> 2] = $$0382;\n      HEAP32[$4 + 1310736 + ($203 + 3 << 2) >> 2] = $$2387;\n      HEAP32[$4 + 1310736 + ($203 + 4 << 2) >> 2] = $$2387;\n      HEAP32[$4 + 1310736 + ($203 + 5 << 2) >> 2] = $$0382;\n      HEAP32[$4 + 1310736 + ($203 + 6 << 2) >> 2] = $$0382;\n      $$2392 = $198;\n      break;\n     }\n    }\n    if ($62) {\n     $65 = HEAP32[$4 + 1179664 + ($57 + -1 << 2) >> 2] | 0;\n     $68 = HEAP32[$4 + 1179664 + ($61 + -1 << 2) >> 2] | 0;\n     L36 : do if (($65 | 0) > ($68 | 0)) {\n      HEAP16[$$3 >> 1] = $68;\n      $$0374 = $21;\n      $$0378 = 0;\n      while (1) {\n       if (($$0378 | 0) >= ($$1391 | 0)) {\n        $83 = $68;\n        break L36;\n       }\n       if ((HEAP32[$$0374 >> 2] | 0) == ($65 | 0)) HEAP32[$$0374 >> 2] = $68;\n       $$0374 = $$0374 + 4 | 0;\n       $$0378 = $$0378 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3 >> 1] = $65;\n      if (($65 | 0) < ($68 | 0)) {\n       $$1375 = $21;\n       $$1379 = 0;\n       while (1) {\n        if (($$1379 | 0) >= ($$1391 | 0)) {\n         $83 = $65;\n         break L36;\n        }\n        if ((HEAP32[$$1375 >> 2] | 0) == ($68 | 0)) HEAP32[$$1375 >> 2] = $65;\n        $$1375 = $$1375 + 4 | 0;\n        $$1379 = $$1379 + 1 | 0;\n       }\n      } else $83 = $65;\n     } while (0);\n     $85 = ($83 << 16 >> 16) * 7 | 0;\n     $87 = $4 + 1310736 + ($85 + -7 << 2) | 0;\n     HEAP32[$87 >> 2] = (HEAP32[$87 >> 2] | 0) + 1;\n     $91 = $4 + 1310736 + ($85 + -6 << 2) | 0;\n     HEAP32[$91 >> 2] = (HEAP32[$91 >> 2] | 0) + $$2387;\n     $95 = $4 + 1310736 + ($85 + -5 << 2) | 0;\n     HEAP32[$95 >> 2] = (HEAP32[$95 >> 2] | 0) + $$0382;\n     HEAP32[$4 + 1310736 + ($85 + -1 << 2) >> 2] = $$0382;\n     $$2392 = $$1391;\n     break;\n    }\n    $101 = HEAP16[$$3 + -2 >> 1] | 0;\n    if ($101 << 16 >> 16 <= 0) {\n     HEAP16[$$3 >> 1] = $56;\n     $139 = $57 * 7 | 0;\n     $141 = $4 + 1310736 + ($139 + -7 << 2) | 0;\n     HEAP32[$141 >> 2] = (HEAP32[$141 >> 2] | 0) + 1;\n     $145 = $4 + 1310736 + ($139 + -6 << 2) | 0;\n     HEAP32[$145 >> 2] = (HEAP32[$145 >> 2] | 0) + $$2387;\n     $149 = $4 + 1310736 + ($139 + -5 << 2) | 0;\n     HEAP32[$149 >> 2] = (HEAP32[$149 >> 2] | 0) + $$0382;\n     $153 = $4 + 1310736 + ($139 + -4 << 2) | 0;\n     if ((HEAP32[$153 >> 2] | 0) > ($$2387 | 0)) HEAP32[$153 >> 2] = $$2387;\n     HEAP32[$4 + 1310736 + ($139 + -1 << 2) >> 2] = $$0382;\n     $$2392 = $$1391;\n     break;\n    }\n    $106 = HEAP32[$4 + 1179664 + ($57 + -1 << 2) >> 2] | 0;\n    $109 = HEAP32[$4 + 1179664 + (($101 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L60 : do if (($106 | 0) > ($109 | 0)) {\n     HEAP16[$$3 >> 1] = $109;\n     $$2376 = $21;\n     $$2380 = 0;\n     while (1) {\n      if (($$2380 | 0) >= ($$1391 | 0)) {\n       $124 = $109;\n       break L60;\n      }\n      if ((HEAP32[$$2376 >> 2] | 0) == ($106 | 0)) HEAP32[$$2376 >> 2] = $109;\n      $$2376 = $$2376 + 4 | 0;\n      $$2380 = $$2380 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3 >> 1] = $106;\n     if (($106 | 0) < ($109 | 0)) {\n      $$3377 = $21;\n      $$3381 = 0;\n      while (1) {\n       if (($$3381 | 0) >= ($$1391 | 0)) {\n        $124 = $106;\n        break L60;\n       }\n       if ((HEAP32[$$3377 >> 2] | 0) == ($109 | 0)) HEAP32[$$3377 >> 2] = $106;\n       $$3377 = $$3377 + 4 | 0;\n       $$3381 = $$3381 + 1 | 0;\n      }\n     } else $124 = $106;\n    } while (0);\n    $126 = ($124 << 16 >> 16) * 7 | 0;\n    $128 = $4 + 1310736 + ($126 + -7 << 2) | 0;\n    HEAP32[$128 >> 2] = (HEAP32[$128 >> 2] | 0) + 1;\n    $132 = $4 + 1310736 + ($126 + -6 << 2) | 0;\n    HEAP32[$132 >> 2] = (HEAP32[$132 >> 2] | 0) + $$2387;\n    $136 = $4 + 1310736 + ($126 + -5 << 2) | 0;\n    HEAP32[$136 >> 2] = (HEAP32[$136 >> 2] | 0) + $$0382;\n    $$2392 = $$1391;\n   } else {\n    HEAP16[$$3 >> 1] = 0;\n    HEAP8[$$1394 >> 0] = 0;\n    $$2392 = $$1391;\n   } while (0);\n   $$1 = $$1 + 2 | 0;\n   $$1391 = $$2392;\n   $$1394 = $$1394 + 1 | 0;\n   $$2387 = $$2387 + 1 | 0;\n   $$3 = $$3 + 2 | 0;\n  }\n  $$0369 = $$1 + $1 + 4 | 0;\n  $$0382 = $$0382 + 1 | 0;\n  $$0390 = $$1391;\n  $$0393 = $$1394 + 2 | 0;\n  $$2 = $$3 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $226 = $4 + 12 | 0;\n  $$1383 = 1;\n  $$3388 = 1;\n  $$4 = $21;\n  while (1) {\n   if (($$3388 | 0) > ($$0390 | 0)) break;\n   $228 = HEAP32[$$4 >> 2] | 0;\n   if (($228 | 0) == ($$3388 | 0)) {\n    $$2384 = $$1383 + 1 | 0;\n    $234 = $$1383;\n   } else {\n    $$2384 = $$1383;\n    $234 = HEAP32[$4 + 1179664 + ($228 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $234;\n   $$1383 = $$2384;\n   $$3388 = $$3388 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $237 = $4 + 8 | 0;\n  $238 = $$1383 + -1 | 0;\n  HEAP32[$237 >> 2] = $238;\n  if (!$238) $$0 = 0; else {\n   _memset($226 | 0, 0, $238 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $238 << 4 | 0) | 0;\n   $$4389 = 0;\n   while (1) {\n    if (($$4389 | 0) >= ($238 | 0)) break;\n    $244 = $$4389 << 2;\n    HEAP32[$4 + 131084 + ($244 << 2) >> 2] = $5;\n    HEAP32[$4 + 131084 + (($244 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($244 | 2) << 2) >> 2] = $6;\n    HEAP32[$4 + 131084 + (($244 | 3) << 2) >> 2] = 0;\n    $$4389 = $$4389 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0390 | 0)) break;\n    $256 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $257 = $$5 * 7 | 0;\n    $260 = $4 + 12 + ($256 << 2) | 0;\n    HEAP32[$260 >> 2] = (HEAP32[$260 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($257 << 2) >> 2] | 0);\n    $267 = $256 << 1;\n    $268 = $4 + 655376 + ($267 << 3) | 0;\n    HEAPF64[$268 >> 3] = +HEAPF64[$268 >> 3] + +(HEAP32[$4 + 1310736 + ($257 + 1 << 2) >> 2] | 0);\n    $276 = $4 + 655376 + (($267 | 1) << 3) | 0;\n    HEAPF64[$276 >> 3] = +HEAPF64[$276 >> 3] + +(HEAP32[$4 + 1310736 + ($257 + 2 << 2) >> 2] | 0);\n    $279 = $256 << 2;\n    $280 = $4 + 131084 + ($279 << 2) | 0;\n    $284 = HEAP32[$4 + 1310736 + ($257 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$280 >> 2] | 0) > ($284 | 0)) HEAP32[$280 >> 2] = $284;\n    $287 = $4 + 131084 + (($279 | 1) << 2) | 0;\n    $291 = HEAP32[$4 + 1310736 + ($257 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$287 >> 2] | 0) < ($291 | 0)) HEAP32[$287 >> 2] = $291;\n    $294 = $4 + 131084 + (($279 | 2) << 2) | 0;\n    $298 = HEAP32[$4 + 1310736 + ($257 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$294 >> 2] | 0) > ($298 | 0)) HEAP32[$294 >> 2] = $298;\n    $301 = $4 + 131084 + (($279 | 3) << 2) | 0;\n    $305 = HEAP32[$4 + 1310736 + ($257 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$301 >> 2] | 0) < ($305 | 0)) HEAP32[$301 >> 2] = $305;\n    $$5 = $$5 + 1 | 0;\n   }\n   $308 = HEAP32[$237 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($308 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $312 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $313 = $$6 << 1;\n    $314 = $4 + 655376 + ($313 << 3) | 0;\n    HEAPF64[$314 >> 3] = +HEAPF64[$314 >> 3] / $312;\n    $318 = $4 + 655376 + (($313 | 1) << 3) | 0;\n    HEAPF64[$318 >> 3] = +HEAPF64[$318 >> 3] / $312;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubEBIC($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0369 = 0, $$0370 = 0, $$0372 = 0, $$0374 = 0, $$0378 = 0, $$0382 = 0, $$0385 = 0, $$0390 = 0, $$0393 = 0, $$1 = 0, $$1371 = 0, $$1373 = 0, $$1375 = 0, $$1379 = 0, $$1383 = 0, $$1386 = 0, $$1391 = 0, $$1394 = 0, $$2 = 0, $$2376 = 0, $$2380 = 0, $$2384 = 0, $$2387 = 0, $$2392 = 0, $$3 = 0, $$3377 = 0, $$3381 = 0, $$3388 = 0, $$4 = 0, $$4389 = 0, $$5 = 0, $$6 = 0, $101 = 0, $106 = 0, $109 = 0, $124 = 0, $126 = 0, $128 = 0, $132 = 0, $136 = 0, $139 = 0, $141 = 0, $145 = 0, $149 = 0, $15 = 0, $153 = 0, $158 = 0, $160 = 0, $164 = 0, $168 = 0, $172 = 0, $178 = 0, $181 = 0, $183 = 0, $187 = 0, $191 = 0, $195 = 0, $198 = 0, $203 = 0, $21 = 0, $22 = 0, $226 = 0, $228 = 0, $234 = 0, $237 = 0, $238 = 0, $244 = 0, $256 = 0, $257 = 0, $260 = 0, $267 = 0, $268 = 0, $276 = 0, $279 = 0, $280 = 0, $284 = 0, $287 = 0, $291 = 0, $294 = 0, $298 = 0, $30 = 0, $301 = 0, $305 = 0, $308 = 0, $312 = 0.0, $313 = 0, $314 = 0, $318 = 0, $36 = 0, $37 = 0, $40 = 0, $42 = 0, $46 = 0, $5 = 0, $50 = 0, $56 = 0, $57 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $65 = 0, $68 = 0, $7 = 0, $8 = 0, $83 = 0, $85 = 0, $87 = 0, $91 = 0, $95 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = ($1 | 0) / 2 | 0;\n $6 = ($2 | 0) / 2 | 0;\n $7 = HEAP32[$4 >> 2] | 0;\n $8 = $6 + -1 | 0;\n $$0370 = $7;\n $$0372 = $7 + ((Math_imul($8, $5) | 0) << 1) | 0;\n $$0385 = 0;\n while (1) {\n  if (($$0385 | 0) >= ($5 | 0)) break;\n  HEAP16[$$0372 >> 1] = 0;\n  HEAP16[$$0370 >> 1] = 0;\n  $$0370 = $$0370 + 2 | 0;\n  $$0372 = $$0372 + 2 | 0;\n  $$0385 = $$0385 + 1 | 0;\n }\n $15 = $5 + -1 | 0;\n $$1371 = $7;\n $$1373 = $7 + ($15 << 1) | 0;\n $$1386 = 0;\n while (1) {\n  if (($$1386 | 0) >= ($6 | 0)) break;\n  HEAP16[$$1373 >> 1] = 0;\n  HEAP16[$$1371 >> 1] = 0;\n  $$1371 = $$1371 + ($5 << 1) | 0;\n  $$1373 = $$1373 + ($5 << 1) | 0;\n  $$1386 = $$1386 + 1 | 0;\n }\n $21 = $4 + 1179664 | 0;\n $22 = $5 + 1 | 0;\n $30 = 0 - $5 | 0;\n $$0369 = $0 + (($1 << 1) + 2) | 0;\n $$0382 = 1;\n $$0390 = 0;\n $$0393 = (HEAP32[$4 + 4 >> 2] | 0) + $22 | 0;\n $$2 = $7 + ($22 << 1) | 0;\n L9 : while (1) {\n  if (($$0382 | 0) >= ($8 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0369;\n  $$1391 = $$0390;\n  $$1394 = $$0393;\n  $$2387 = 1;\n  $$3 = $$2;\n  while (1) {\n   if (($$2387 | 0) >= ($15 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0 | 0) > ($3 | 0)) {\n    HEAP16[$$3 >> 1] = 0;\n    HEAP8[$$1394 >> 0] = 0;\n    $$2392 = $$1391;\n   } else {\n    HEAP8[$$1394 >> 0] = -1;\n    $36 = $$3 + ($30 << 1) | 0;\n    $37 = HEAP16[$36 >> 1] | 0;\n    if ($37 << 16 >> 16 > 0) {\n     HEAP16[$$3 >> 1] = $37;\n     $40 = ($37 << 16 >> 16) * 7 | 0;\n     $42 = $4 + 1310736 + ($40 + -7 << 2) | 0;\n     HEAP32[$42 >> 2] = (HEAP32[$42 >> 2] | 0) + 1;\n     $46 = $4 + 1310736 + ($40 + -6 << 2) | 0;\n     HEAP32[$46 >> 2] = (HEAP32[$46 >> 2] | 0) + $$2387;\n     $50 = $4 + 1310736 + ($40 + -5 << 2) | 0;\n     HEAP32[$50 >> 2] = (HEAP32[$50 >> 2] | 0) + $$0382;\n     HEAP32[$4 + 1310736 + ($40 + -1 << 2) >> 2] = $$0382;\n     $$2392 = $$1391;\n     break;\n    }\n    $56 = HEAP16[$36 + 2 >> 1] | 0;\n    $57 = $56 << 16 >> 16;\n    $60 = HEAP16[$36 + -2 >> 1] | 0;\n    $61 = $60 << 16 >> 16;\n    $62 = $60 << 16 >> 16 > 0;\n    if ($56 << 16 >> 16 <= 0) {\n     if ($62) {\n      HEAP16[$$3 >> 1] = $60;\n      $158 = $61 * 7 | 0;\n      $160 = $4 + 1310736 + ($158 + -7 << 2) | 0;\n      HEAP32[$160 >> 2] = (HEAP32[$160 >> 2] | 0) + 1;\n      $164 = $4 + 1310736 + ($158 + -6 << 2) | 0;\n      HEAP32[$164 >> 2] = (HEAP32[$164 >> 2] | 0) + $$2387;\n      $168 = $4 + 1310736 + ($158 + -5 << 2) | 0;\n      HEAP32[$168 >> 2] = (HEAP32[$168 >> 2] | 0) + $$0382;\n      $172 = $4 + 1310736 + ($158 + -3 << 2) | 0;\n      if ((HEAP32[$172 >> 2] | 0) < ($$2387 | 0)) HEAP32[$172 >> 2] = $$2387;\n      HEAP32[$4 + 1310736 + ($158 + -1 << 2) >> 2] = $$0382;\n      $$2392 = $$1391;\n      break;\n     }\n     $178 = HEAP16[$$3 + -2 >> 1] | 0;\n     if ($178 << 16 >> 16 > 0) {\n      HEAP16[$$3 >> 1] = $178;\n      $181 = ($178 << 16 >> 16) * 7 | 0;\n      $183 = $4 + 1310736 + ($181 + -7 << 2) | 0;\n      HEAP32[$183 >> 2] = (HEAP32[$183 >> 2] | 0) + 1;\n      $187 = $4 + 1310736 + ($181 + -6 << 2) | 0;\n      HEAP32[$187 >> 2] = (HEAP32[$187 >> 2] | 0) + $$2387;\n      $191 = $4 + 1310736 + ($181 + -5 << 2) | 0;\n      HEAP32[$191 >> 2] = (HEAP32[$191 >> 2] | 0) + $$0382;\n      $195 = $4 + 1310736 + ($181 + -3 << 2) | 0;\n      if ((HEAP32[$195 >> 2] | 0) >= ($$2387 | 0)) {\n       $$2392 = $$1391;\n       break;\n      }\n      HEAP32[$195 >> 2] = $$2387;\n      $$2392 = $$1391;\n      break;\n     } else {\n      $198 = $$1391 + 1 | 0;\n      if (($$1391 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3 >> 1] = $198;\n      HEAP32[$4 + 1179664 + ($$1391 << 2) >> 2] = $198 << 16 >> 16;\n      $203 = $$1391 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($203 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($203 + 1 << 2) >> 2] = $$2387;\n      HEAP32[$4 + 1310736 + ($203 + 2 << 2) >> 2] = $$0382;\n      HEAP32[$4 + 1310736 + ($203 + 3 << 2) >> 2] = $$2387;\n      HEAP32[$4 + 1310736 + ($203 + 4 << 2) >> 2] = $$2387;\n      HEAP32[$4 + 1310736 + ($203 + 5 << 2) >> 2] = $$0382;\n      HEAP32[$4 + 1310736 + ($203 + 6 << 2) >> 2] = $$0382;\n      $$2392 = $198;\n      break;\n     }\n    }\n    if ($62) {\n     $65 = HEAP32[$4 + 1179664 + ($57 + -1 << 2) >> 2] | 0;\n     $68 = HEAP32[$4 + 1179664 + ($61 + -1 << 2) >> 2] | 0;\n     L37 : do if (($65 | 0) > ($68 | 0)) {\n      HEAP16[$$3 >> 1] = $68;\n      $$0374 = $21;\n      $$0378 = 0;\n      while (1) {\n       if (($$0378 | 0) >= ($$1391 | 0)) {\n        $83 = $68;\n        break L37;\n       }\n       if ((HEAP32[$$0374 >> 2] | 0) == ($65 | 0)) HEAP32[$$0374 >> 2] = $68;\n       $$0374 = $$0374 + 4 | 0;\n       $$0378 = $$0378 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3 >> 1] = $65;\n      if (($65 | 0) < ($68 | 0)) {\n       $$1375 = $21;\n       $$1379 = 0;\n       while (1) {\n        if (($$1379 | 0) >= ($$1391 | 0)) {\n         $83 = $65;\n         break L37;\n        }\n        if ((HEAP32[$$1375 >> 2] | 0) == ($68 | 0)) HEAP32[$$1375 >> 2] = $65;\n        $$1375 = $$1375 + 4 | 0;\n        $$1379 = $$1379 + 1 | 0;\n       }\n      } else $83 = $65;\n     } while (0);\n     $85 = ($83 << 16 >> 16) * 7 | 0;\n     $87 = $4 + 1310736 + ($85 + -7 << 2) | 0;\n     HEAP32[$87 >> 2] = (HEAP32[$87 >> 2] | 0) + 1;\n     $91 = $4 + 1310736 + ($85 + -6 << 2) | 0;\n     HEAP32[$91 >> 2] = (HEAP32[$91 >> 2] | 0) + $$2387;\n     $95 = $4 + 1310736 + ($85 + -5 << 2) | 0;\n     HEAP32[$95 >> 2] = (HEAP32[$95 >> 2] | 0) + $$0382;\n     HEAP32[$4 + 1310736 + ($85 + -1 << 2) >> 2] = $$0382;\n     $$2392 = $$1391;\n     break;\n    }\n    $101 = HEAP16[$$3 + -2 >> 1] | 0;\n    if ($101 << 16 >> 16 <= 0) {\n     HEAP16[$$3 >> 1] = $56;\n     $139 = $57 * 7 | 0;\n     $141 = $4 + 1310736 + ($139 + -7 << 2) | 0;\n     HEAP32[$141 >> 2] = (HEAP32[$141 >> 2] | 0) + 1;\n     $145 = $4 + 1310736 + ($139 + -6 << 2) | 0;\n     HEAP32[$145 >> 2] = (HEAP32[$145 >> 2] | 0) + $$2387;\n     $149 = $4 + 1310736 + ($139 + -5 << 2) | 0;\n     HEAP32[$149 >> 2] = (HEAP32[$149 >> 2] | 0) + $$0382;\n     $153 = $4 + 1310736 + ($139 + -4 << 2) | 0;\n     if ((HEAP32[$153 >> 2] | 0) > ($$2387 | 0)) HEAP32[$153 >> 2] = $$2387;\n     HEAP32[$4 + 1310736 + ($139 + -1 << 2) >> 2] = $$0382;\n     $$2392 = $$1391;\n     break;\n    }\n    $106 = HEAP32[$4 + 1179664 + ($57 + -1 << 2) >> 2] | 0;\n    $109 = HEAP32[$4 + 1179664 + (($101 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L61 : do if (($106 | 0) > ($109 | 0)) {\n     HEAP16[$$3 >> 1] = $109;\n     $$2376 = $21;\n     $$2380 = 0;\n     while (1) {\n      if (($$2380 | 0) >= ($$1391 | 0)) {\n       $124 = $109;\n       break L61;\n      }\n      if ((HEAP32[$$2376 >> 2] | 0) == ($106 | 0)) HEAP32[$$2376 >> 2] = $109;\n      $$2376 = $$2376 + 4 | 0;\n      $$2380 = $$2380 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3 >> 1] = $106;\n     if (($106 | 0) < ($109 | 0)) {\n      $$3377 = $21;\n      $$3381 = 0;\n      while (1) {\n       if (($$3381 | 0) >= ($$1391 | 0)) {\n        $124 = $106;\n        break L61;\n       }\n       if ((HEAP32[$$3377 >> 2] | 0) == ($109 | 0)) HEAP32[$$3377 >> 2] = $106;\n       $$3377 = $$3377 + 4 | 0;\n       $$3381 = $$3381 + 1 | 0;\n      }\n     } else $124 = $106;\n    } while (0);\n    $126 = ($124 << 16 >> 16) * 7 | 0;\n    $128 = $4 + 1310736 + ($126 + -7 << 2) | 0;\n    HEAP32[$128 >> 2] = (HEAP32[$128 >> 2] | 0) + 1;\n    $132 = $4 + 1310736 + ($126 + -6 << 2) | 0;\n    HEAP32[$132 >> 2] = (HEAP32[$132 >> 2] | 0) + $$2387;\n    $136 = $4 + 1310736 + ($126 + -5 << 2) | 0;\n    HEAP32[$136 >> 2] = (HEAP32[$136 >> 2] | 0) + $$0382;\n    $$2392 = $$1391;\n   } while (0);\n   $$1 = $$1 + 2 | 0;\n   $$1391 = $$2392;\n   $$1394 = $$1394 + 1 | 0;\n   $$2387 = $$2387 + 1 | 0;\n   $$3 = $$3 + 2 | 0;\n  }\n  $$0369 = $$1 + $1 + 4 | 0;\n  $$0382 = $$0382 + 1 | 0;\n  $$0390 = $$1391;\n  $$0393 = $$1394 + 2 | 0;\n  $$2 = $$3 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $226 = $4 + 12 | 0;\n  $$1383 = 1;\n  $$3388 = 1;\n  $$4 = $21;\n  while (1) {\n   if (($$3388 | 0) > ($$0390 | 0)) break;\n   $228 = HEAP32[$$4 >> 2] | 0;\n   if (($228 | 0) == ($$3388 | 0)) {\n    $$2384 = $$1383 + 1 | 0;\n    $234 = $$1383;\n   } else {\n    $$2384 = $$1383;\n    $234 = HEAP32[$4 + 1179664 + ($228 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $234;\n   $$1383 = $$2384;\n   $$3388 = $$3388 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $237 = $4 + 8 | 0;\n  $238 = $$1383 + -1 | 0;\n  HEAP32[$237 >> 2] = $238;\n  if (!$238) $$0 = 0; else {\n   _memset($226 | 0, 0, $238 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $238 << 4 | 0) | 0;\n   $$4389 = 0;\n   while (1) {\n    if (($$4389 | 0) >= ($238 | 0)) break;\n    $244 = $$4389 << 2;\n    HEAP32[$4 + 131084 + ($244 << 2) >> 2] = $5;\n    HEAP32[$4 + 131084 + (($244 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($244 | 2) << 2) >> 2] = $6;\n    HEAP32[$4 + 131084 + (($244 | 3) << 2) >> 2] = 0;\n    $$4389 = $$4389 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0390 | 0)) break;\n    $256 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $257 = $$5 * 7 | 0;\n    $260 = $4 + 12 + ($256 << 2) | 0;\n    HEAP32[$260 >> 2] = (HEAP32[$260 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($257 << 2) >> 2] | 0);\n    $267 = $256 << 1;\n    $268 = $4 + 655376 + ($267 << 3) | 0;\n    HEAPF64[$268 >> 3] = +HEAPF64[$268 >> 3] + +(HEAP32[$4 + 1310736 + ($257 + 1 << 2) >> 2] | 0);\n    $276 = $4 + 655376 + (($267 | 1) << 3) | 0;\n    HEAPF64[$276 >> 3] = +HEAPF64[$276 >> 3] + +(HEAP32[$4 + 1310736 + ($257 + 2 << 2) >> 2] | 0);\n    $279 = $256 << 2;\n    $280 = $4 + 131084 + ($279 << 2) | 0;\n    $284 = HEAP32[$4 + 1310736 + ($257 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$280 >> 2] | 0) > ($284 | 0)) HEAP32[$280 >> 2] = $284;\n    $287 = $4 + 131084 + (($279 | 1) << 2) | 0;\n    $291 = HEAP32[$4 + 1310736 + ($257 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$287 >> 2] | 0) < ($291 | 0)) HEAP32[$287 >> 2] = $291;\n    $294 = $4 + 131084 + (($279 | 2) << 2) | 0;\n    $298 = HEAP32[$4 + 1310736 + ($257 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$294 >> 2] | 0) > ($298 | 0)) HEAP32[$294 >> 2] = $298;\n    $301 = $4 + 131084 + (($279 | 3) << 2) | 0;\n    $305 = HEAP32[$4 + 1310736 + ($257 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$301 >> 2] | 0) < ($305 | 0)) HEAP32[$301 >> 2] = $305;\n    $$5 = $$5 + 1 | 0;\n   }\n   $308 = HEAP32[$237 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($308 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $312 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $313 = $$6 << 1;\n    $314 = $4 + 655376 + ($313 << 3) | 0;\n    HEAPF64[$314 >> 3] = +HEAPF64[$314 >> 3] / $312;\n    $318 = $4 + 655376 + (($313 | 1) << 3) | 0;\n    HEAPF64[$318 >> 3] = +HEAPF64[$318 >> 3] / $312;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubEWRC($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0367 = 0, $$0368 = 0, $$0370 = 0, $$0372 = 0, $$0376 = 0, $$0380 = 0, $$0383 = 0, $$0388 = 0, $$0391 = 0, $$1 = 0, $$1369 = 0, $$1371 = 0, $$1373 = 0, $$1377 = 0, $$1381 = 0, $$1384 = 0, $$1389 = 0, $$1392 = 0, $$2 = 0, $$2374 = 0, $$2378 = 0, $$2382 = 0, $$2385 = 0, $$2390 = 0, $$3 = 0, $$3375 = 0, $$3379 = 0, $$3386 = 0, $$4 = 0, $$4387 = 0, $$5 = 0, $$6 = 0, $102 = 0, $105 = 0, $120 = 0, $122 = 0, $124 = 0, $128 = 0, $13 = 0, $132 = 0, $135 = 0, $137 = 0, $141 = 0, $145 = 0, $149 = 0, $154 = 0, $156 = 0, $160 = 0, $164 = 0, $168 = 0, $174 = 0, $177 = 0, $179 = 0, $183 = 0, $187 = 0, $19 = 0, $191 = 0, $194 = 0, $199 = 0, $20 = 0, $221 = 0, $223 = 0, $229 = 0, $232 = 0, $233 = 0, $239 = 0, $251 = 0, $252 = 0, $255 = 0, $26 = 0, $262 = 0, $263 = 0, $271 = 0, $274 = 0, $275 = 0, $279 = 0, $282 = 0, $286 = 0, $289 = 0, $293 = 0, $296 = 0, $300 = 0, $303 = 0, $307 = 0.0, $308 = 0, $309 = 0, $313 = 0, $32 = 0, $33 = 0, $36 = 0, $38 = 0, $42 = 0, $46 = 0, $5 = 0, $52 = 0, $53 = 0, $56 = 0, $57 = 0, $58 = 0, $6 = 0, $61 = 0, $64 = 0, $79 = 0, $81 = 0, $83 = 0, $87 = 0, $91 = 0, $97 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = HEAP32[$4 >> 2] | 0;\n $6 = $2 + -1 | 0;\n $$0368 = $5;\n $$0370 = $5 + ((Math_imul($6, $1) | 0) << 1) | 0;\n $$0383 = 0;\n while (1) {\n  if (($$0383 | 0) >= ($1 | 0)) break;\n  HEAP16[$$0370 >> 1] = 0;\n  HEAP16[$$0368 >> 1] = 0;\n  $$0368 = $$0368 + 2 | 0;\n  $$0370 = $$0370 + 2 | 0;\n  $$0383 = $$0383 + 1 | 0;\n }\n $13 = $1 + -1 | 0;\n $$1369 = $5;\n $$1371 = $5 + ($13 << 1) | 0;\n $$1384 = 0;\n while (1) {\n  if (($$1384 | 0) >= ($2 | 0)) break;\n  HEAP16[$$1371 >> 1] = 0;\n  HEAP16[$$1369 >> 1] = 0;\n  $$1369 = $$1369 + ($1 << 1) | 0;\n  $$1371 = $$1371 + ($1 << 1) | 0;\n  $$1384 = $$1384 + 1 | 0;\n }\n $19 = $4 + 1179664 | 0;\n $20 = $1 + 1 | 0;\n $26 = 0 - $1 | 0;\n $$0367 = $0 + $20 | 0;\n $$0380 = 1;\n $$0388 = 0;\n $$0391 = (HEAP32[$4 + 4 >> 2] | 0) + $20 | 0;\n $$2 = $5 + ($20 << 1) | 0;\n L9 : while (1) {\n  if (($$0380 | 0) >= ($6 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0367;\n  $$1389 = $$0388;\n  $$1392 = $$0391;\n  $$2385 = 1;\n  $$3 = $$2;\n  while (1) {\n   if (($$2385 | 0) >= ($13 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0 | 0) > ($3 | 0)) {\n    HEAP8[$$1392 >> 0] = -1;\n    $32 = $$3 + ($26 << 1) | 0;\n    $33 = HEAP16[$32 >> 1] | 0;\n    if ($33 << 16 >> 16 > 0) {\n     HEAP16[$$3 >> 1] = $33;\n     $36 = ($33 << 16 >> 16) * 7 | 0;\n     $38 = $4 + 1310736 + ($36 + -7 << 2) | 0;\n     HEAP32[$38 >> 2] = (HEAP32[$38 >> 2] | 0) + 1;\n     $42 = $4 + 1310736 + ($36 + -6 << 2) | 0;\n     HEAP32[$42 >> 2] = (HEAP32[$42 >> 2] | 0) + $$2385;\n     $46 = $4 + 1310736 + ($36 + -5 << 2) | 0;\n     HEAP32[$46 >> 2] = (HEAP32[$46 >> 2] | 0) + $$0380;\n     HEAP32[$4 + 1310736 + ($36 + -1 << 2) >> 2] = $$0380;\n     $$2390 = $$1389;\n     break;\n    }\n    $52 = HEAP16[$32 + 2 >> 1] | 0;\n    $53 = $52 << 16 >> 16;\n    $56 = HEAP16[$32 + -2 >> 1] | 0;\n    $57 = $56 << 16 >> 16;\n    $58 = $56 << 16 >> 16 > 0;\n    if ($52 << 16 >> 16 <= 0) {\n     if ($58) {\n      HEAP16[$$3 >> 1] = $56;\n      $154 = $57 * 7 | 0;\n      $156 = $4 + 1310736 + ($154 + -7 << 2) | 0;\n      HEAP32[$156 >> 2] = (HEAP32[$156 >> 2] | 0) + 1;\n      $160 = $4 + 1310736 + ($154 + -6 << 2) | 0;\n      HEAP32[$160 >> 2] = (HEAP32[$160 >> 2] | 0) + $$2385;\n      $164 = $4 + 1310736 + ($154 + -5 << 2) | 0;\n      HEAP32[$164 >> 2] = (HEAP32[$164 >> 2] | 0) + $$0380;\n      $168 = $4 + 1310736 + ($154 + -3 << 2) | 0;\n      if ((HEAP32[$168 >> 2] | 0) < ($$2385 | 0)) HEAP32[$168 >> 2] = $$2385;\n      HEAP32[$4 + 1310736 + ($154 + -1 << 2) >> 2] = $$0380;\n      $$2390 = $$1389;\n      break;\n     }\n     $174 = HEAP16[$$3 + -2 >> 1] | 0;\n     if ($174 << 16 >> 16 > 0) {\n      HEAP16[$$3 >> 1] = $174;\n      $177 = ($174 << 16 >> 16) * 7 | 0;\n      $179 = $4 + 1310736 + ($177 + -7 << 2) | 0;\n      HEAP32[$179 >> 2] = (HEAP32[$179 >> 2] | 0) + 1;\n      $183 = $4 + 1310736 + ($177 + -6 << 2) | 0;\n      HEAP32[$183 >> 2] = (HEAP32[$183 >> 2] | 0) + $$2385;\n      $187 = $4 + 1310736 + ($177 + -5 << 2) | 0;\n      HEAP32[$187 >> 2] = (HEAP32[$187 >> 2] | 0) + $$0380;\n      $191 = $4 + 1310736 + ($177 + -3 << 2) | 0;\n      if ((HEAP32[$191 >> 2] | 0) >= ($$2385 | 0)) {\n       $$2390 = $$1389;\n       break;\n      }\n      HEAP32[$191 >> 2] = $$2385;\n      $$2390 = $$1389;\n      break;\n     } else {\n      $194 = $$1389 + 1 | 0;\n      if (($$1389 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3 >> 1] = $194;\n      HEAP32[$4 + 1179664 + ($$1389 << 2) >> 2] = $194 << 16 >> 16;\n      $199 = $$1389 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($199 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($199 + 1 << 2) >> 2] = $$2385;\n      HEAP32[$4 + 1310736 + ($199 + 2 << 2) >> 2] = $$0380;\n      HEAP32[$4 + 1310736 + ($199 + 3 << 2) >> 2] = $$2385;\n      HEAP32[$4 + 1310736 + ($199 + 4 << 2) >> 2] = $$2385;\n      HEAP32[$4 + 1310736 + ($199 + 5 << 2) >> 2] = $$0380;\n      HEAP32[$4 + 1310736 + ($199 + 6 << 2) >> 2] = $$0380;\n      $$2390 = $194;\n      break;\n     }\n    }\n    if ($58) {\n     $61 = HEAP32[$4 + 1179664 + ($53 + -1 << 2) >> 2] | 0;\n     $64 = HEAP32[$4 + 1179664 + ($57 + -1 << 2) >> 2] | 0;\n     L36 : do if (($61 | 0) > ($64 | 0)) {\n      HEAP16[$$3 >> 1] = $64;\n      $$0372 = $19;\n      $$0376 = 0;\n      while (1) {\n       if (($$0376 | 0) >= ($$1389 | 0)) {\n        $79 = $64;\n        break L36;\n       }\n       if ((HEAP32[$$0372 >> 2] | 0) == ($61 | 0)) HEAP32[$$0372 >> 2] = $64;\n       $$0372 = $$0372 + 4 | 0;\n       $$0376 = $$0376 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3 >> 1] = $61;\n      if (($61 | 0) < ($64 | 0)) {\n       $$1373 = $19;\n       $$1377 = 0;\n       while (1) {\n        if (($$1377 | 0) >= ($$1389 | 0)) {\n         $79 = $61;\n         break L36;\n        }\n        if ((HEAP32[$$1373 >> 2] | 0) == ($64 | 0)) HEAP32[$$1373 >> 2] = $61;\n        $$1373 = $$1373 + 4 | 0;\n        $$1377 = $$1377 + 1 | 0;\n       }\n      } else $79 = $61;\n     } while (0);\n     $81 = ($79 << 16 >> 16) * 7 | 0;\n     $83 = $4 + 1310736 + ($81 + -7 << 2) | 0;\n     HEAP32[$83 >> 2] = (HEAP32[$83 >> 2] | 0) + 1;\n     $87 = $4 + 1310736 + ($81 + -6 << 2) | 0;\n     HEAP32[$87 >> 2] = (HEAP32[$87 >> 2] | 0) + $$2385;\n     $91 = $4 + 1310736 + ($81 + -5 << 2) | 0;\n     HEAP32[$91 >> 2] = (HEAP32[$91 >> 2] | 0) + $$0380;\n     HEAP32[$4 + 1310736 + ($81 + -1 << 2) >> 2] = $$0380;\n     $$2390 = $$1389;\n     break;\n    }\n    $97 = HEAP16[$$3 + -2 >> 1] | 0;\n    if ($97 << 16 >> 16 <= 0) {\n     HEAP16[$$3 >> 1] = $52;\n     $135 = $53 * 7 | 0;\n     $137 = $4 + 1310736 + ($135 + -7 << 2) | 0;\n     HEAP32[$137 >> 2] = (HEAP32[$137 >> 2] | 0) + 1;\n     $141 = $4 + 1310736 + ($135 + -6 << 2) | 0;\n     HEAP32[$141 >> 2] = (HEAP32[$141 >> 2] | 0) + $$2385;\n     $145 = $4 + 1310736 + ($135 + -5 << 2) | 0;\n     HEAP32[$145 >> 2] = (HEAP32[$145 >> 2] | 0) + $$0380;\n     $149 = $4 + 1310736 + ($135 + -4 << 2) | 0;\n     if ((HEAP32[$149 >> 2] | 0) > ($$2385 | 0)) HEAP32[$149 >> 2] = $$2385;\n     HEAP32[$4 + 1310736 + ($135 + -1 << 2) >> 2] = $$0380;\n     $$2390 = $$1389;\n     break;\n    }\n    $102 = HEAP32[$4 + 1179664 + ($53 + -1 << 2) >> 2] | 0;\n    $105 = HEAP32[$4 + 1179664 + (($97 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L60 : do if (($102 | 0) > ($105 | 0)) {\n     HEAP16[$$3 >> 1] = $105;\n     $$2374 = $19;\n     $$2378 = 0;\n     while (1) {\n      if (($$2378 | 0) >= ($$1389 | 0)) {\n       $120 = $105;\n       break L60;\n      }\n      if ((HEAP32[$$2374 >> 2] | 0) == ($102 | 0)) HEAP32[$$2374 >> 2] = $105;\n      $$2374 = $$2374 + 4 | 0;\n      $$2378 = $$2378 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3 >> 1] = $102;\n     if (($102 | 0) < ($105 | 0)) {\n      $$3375 = $19;\n      $$3379 = 0;\n      while (1) {\n       if (($$3379 | 0) >= ($$1389 | 0)) {\n        $120 = $102;\n        break L60;\n       }\n       if ((HEAP32[$$3375 >> 2] | 0) == ($105 | 0)) HEAP32[$$3375 >> 2] = $102;\n       $$3375 = $$3375 + 4 | 0;\n       $$3379 = $$3379 + 1 | 0;\n      }\n     } else $120 = $102;\n    } while (0);\n    $122 = ($120 << 16 >> 16) * 7 | 0;\n    $124 = $4 + 1310736 + ($122 + -7 << 2) | 0;\n    HEAP32[$124 >> 2] = (HEAP32[$124 >> 2] | 0) + 1;\n    $128 = $4 + 1310736 + ($122 + -6 << 2) | 0;\n    HEAP32[$128 >> 2] = (HEAP32[$128 >> 2] | 0) + $$2385;\n    $132 = $4 + 1310736 + ($122 + -5 << 2) | 0;\n    HEAP32[$132 >> 2] = (HEAP32[$132 >> 2] | 0) + $$0380;\n    $$2390 = $$1389;\n   } else {\n    HEAP16[$$3 >> 1] = 0;\n    HEAP8[$$1392 >> 0] = 0;\n    $$2390 = $$1389;\n   } while (0);\n   $$1 = $$1 + 1 | 0;\n   $$1389 = $$2390;\n   $$1392 = $$1392 + 1 | 0;\n   $$2385 = $$2385 + 1 | 0;\n   $$3 = $$3 + 2 | 0;\n  }\n  $$0367 = $$1 + 2 | 0;\n  $$0380 = $$0380 + 1 | 0;\n  $$0388 = $$1389;\n  $$0391 = $$1392 + 2 | 0;\n  $$2 = $$3 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $221 = $4 + 12 | 0;\n  $$1381 = 1;\n  $$3386 = 1;\n  $$4 = $19;\n  while (1) {\n   if (($$3386 | 0) > ($$0388 | 0)) break;\n   $223 = HEAP32[$$4 >> 2] | 0;\n   if (($223 | 0) == ($$3386 | 0)) {\n    $$2382 = $$1381 + 1 | 0;\n    $229 = $$1381;\n   } else {\n    $$2382 = $$1381;\n    $229 = HEAP32[$4 + 1179664 + ($223 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $229;\n   $$1381 = $$2382;\n   $$3386 = $$3386 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $232 = $4 + 8 | 0;\n  $233 = $$1381 + -1 | 0;\n  HEAP32[$232 >> 2] = $233;\n  if (!$233) $$0 = 0; else {\n   _memset($221 | 0, 0, $233 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $233 << 4 | 0) | 0;\n   $$4387 = 0;\n   while (1) {\n    if (($$4387 | 0) >= ($233 | 0)) break;\n    $239 = $$4387 << 2;\n    HEAP32[$4 + 131084 + ($239 << 2) >> 2] = $1;\n    HEAP32[$4 + 131084 + (($239 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($239 | 2) << 2) >> 2] = $2;\n    HEAP32[$4 + 131084 + (($239 | 3) << 2) >> 2] = 0;\n    $$4387 = $$4387 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0388 | 0)) break;\n    $251 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $252 = $$5 * 7 | 0;\n    $255 = $4 + 12 + ($251 << 2) | 0;\n    HEAP32[$255 >> 2] = (HEAP32[$255 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($252 << 2) >> 2] | 0);\n    $262 = $251 << 1;\n    $263 = $4 + 655376 + ($262 << 3) | 0;\n    HEAPF64[$263 >> 3] = +HEAPF64[$263 >> 3] + +(HEAP32[$4 + 1310736 + ($252 + 1 << 2) >> 2] | 0);\n    $271 = $4 + 655376 + (($262 | 1) << 3) | 0;\n    HEAPF64[$271 >> 3] = +HEAPF64[$271 >> 3] + +(HEAP32[$4 + 1310736 + ($252 + 2 << 2) >> 2] | 0);\n    $274 = $251 << 2;\n    $275 = $4 + 131084 + ($274 << 2) | 0;\n    $279 = HEAP32[$4 + 1310736 + ($252 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$275 >> 2] | 0) > ($279 | 0)) HEAP32[$275 >> 2] = $279;\n    $282 = $4 + 131084 + (($274 | 1) << 2) | 0;\n    $286 = HEAP32[$4 + 1310736 + ($252 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$282 >> 2] | 0) < ($286 | 0)) HEAP32[$282 >> 2] = $286;\n    $289 = $4 + 131084 + (($274 | 2) << 2) | 0;\n    $293 = HEAP32[$4 + 1310736 + ($252 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$289 >> 2] | 0) > ($293 | 0)) HEAP32[$289 >> 2] = $293;\n    $296 = $4 + 131084 + (($274 | 3) << 2) | 0;\n    $300 = HEAP32[$4 + 1310736 + ($252 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$296 >> 2] | 0) < ($300 | 0)) HEAP32[$296 >> 2] = $300;\n    $$5 = $$5 + 1 | 0;\n   }\n   $303 = HEAP32[$232 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($303 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $307 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $308 = $$6 << 1;\n    $309 = $4 + 655376 + ($308 << 3) | 0;\n    HEAPF64[$309 >> 3] = +HEAPF64[$309 >> 3] / $307;\n    $313 = $4 + 655376 + (($308 | 1) << 3) | 0;\n    HEAPF64[$313 >> 3] = +HEAPF64[$313 >> 3] / $307;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubEBRC($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0367 = 0, $$0368 = 0, $$0370 = 0, $$0372 = 0, $$0376 = 0, $$0380 = 0, $$0383 = 0, $$0388 = 0, $$0391 = 0, $$1 = 0, $$1369 = 0, $$1371 = 0, $$1373 = 0, $$1377 = 0, $$1381 = 0, $$1384 = 0, $$1389 = 0, $$1392 = 0, $$2 = 0, $$2374 = 0, $$2378 = 0, $$2382 = 0, $$2385 = 0, $$2390 = 0, $$3 = 0, $$3375 = 0, $$3379 = 0, $$3386 = 0, $$4 = 0, $$4387 = 0, $$5 = 0, $$6 = 0, $102 = 0, $105 = 0, $120 = 0, $122 = 0, $124 = 0, $128 = 0, $13 = 0, $132 = 0, $135 = 0, $137 = 0, $141 = 0, $145 = 0, $149 = 0, $154 = 0, $156 = 0, $160 = 0, $164 = 0, $168 = 0, $174 = 0, $177 = 0, $179 = 0, $183 = 0, $187 = 0, $19 = 0, $191 = 0, $194 = 0, $199 = 0, $20 = 0, $221 = 0, $223 = 0, $229 = 0, $232 = 0, $233 = 0, $239 = 0, $251 = 0, $252 = 0, $255 = 0, $26 = 0, $262 = 0, $263 = 0, $271 = 0, $274 = 0, $275 = 0, $279 = 0, $282 = 0, $286 = 0, $289 = 0, $293 = 0, $296 = 0, $300 = 0, $303 = 0, $307 = 0.0, $308 = 0, $309 = 0, $313 = 0, $32 = 0, $33 = 0, $36 = 0, $38 = 0, $42 = 0, $46 = 0, $5 = 0, $52 = 0, $53 = 0, $56 = 0, $57 = 0, $58 = 0, $6 = 0, $61 = 0, $64 = 0, $79 = 0, $81 = 0, $83 = 0, $87 = 0, $91 = 0, $97 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = HEAP32[$4 >> 2] | 0;\n $6 = $2 + -1 | 0;\n $$0368 = $5;\n $$0370 = $5 + ((Math_imul($6, $1) | 0) << 1) | 0;\n $$0383 = 0;\n while (1) {\n  if (($$0383 | 0) >= ($1 | 0)) break;\n  HEAP16[$$0370 >> 1] = 0;\n  HEAP16[$$0368 >> 1] = 0;\n  $$0368 = $$0368 + 2 | 0;\n  $$0370 = $$0370 + 2 | 0;\n  $$0383 = $$0383 + 1 | 0;\n }\n $13 = $1 + -1 | 0;\n $$1369 = $5;\n $$1371 = $5 + ($13 << 1) | 0;\n $$1384 = 0;\n while (1) {\n  if (($$1384 | 0) >= ($2 | 0)) break;\n  HEAP16[$$1371 >> 1] = 0;\n  HEAP16[$$1369 >> 1] = 0;\n  $$1369 = $$1369 + ($1 << 1) | 0;\n  $$1371 = $$1371 + ($1 << 1) | 0;\n  $$1384 = $$1384 + 1 | 0;\n }\n $19 = $4 + 1179664 | 0;\n $20 = $1 + 1 | 0;\n $26 = 0 - $1 | 0;\n $$0367 = $0 + $20 | 0;\n $$0380 = 1;\n $$0388 = 0;\n $$0391 = (HEAP32[$4 + 4 >> 2] | 0) + $20 | 0;\n $$2 = $5 + ($20 << 1) | 0;\n L9 : while (1) {\n  if (($$0380 | 0) >= ($6 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0367;\n  $$1389 = $$0388;\n  $$1392 = $$0391;\n  $$2385 = 1;\n  $$3 = $$2;\n  while (1) {\n   if (($$2385 | 0) >= ($13 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0 | 0) > ($3 | 0)) {\n    HEAP16[$$3 >> 1] = 0;\n    HEAP8[$$1392 >> 0] = 0;\n    $$2390 = $$1389;\n   } else {\n    HEAP8[$$1392 >> 0] = -1;\n    $32 = $$3 + ($26 << 1) | 0;\n    $33 = HEAP16[$32 >> 1] | 0;\n    if ($33 << 16 >> 16 > 0) {\n     HEAP16[$$3 >> 1] = $33;\n     $36 = ($33 << 16 >> 16) * 7 | 0;\n     $38 = $4 + 1310736 + ($36 + -7 << 2) | 0;\n     HEAP32[$38 >> 2] = (HEAP32[$38 >> 2] | 0) + 1;\n     $42 = $4 + 1310736 + ($36 + -6 << 2) | 0;\n     HEAP32[$42 >> 2] = (HEAP32[$42 >> 2] | 0) + $$2385;\n     $46 = $4 + 1310736 + ($36 + -5 << 2) | 0;\n     HEAP32[$46 >> 2] = (HEAP32[$46 >> 2] | 0) + $$0380;\n     HEAP32[$4 + 1310736 + ($36 + -1 << 2) >> 2] = $$0380;\n     $$2390 = $$1389;\n     break;\n    }\n    $52 = HEAP16[$32 + 2 >> 1] | 0;\n    $53 = $52 << 16 >> 16;\n    $56 = HEAP16[$32 + -2 >> 1] | 0;\n    $57 = $56 << 16 >> 16;\n    $58 = $56 << 16 >> 16 > 0;\n    if ($52 << 16 >> 16 <= 0) {\n     if ($58) {\n      HEAP16[$$3 >> 1] = $56;\n      $154 = $57 * 7 | 0;\n      $156 = $4 + 1310736 + ($154 + -7 << 2) | 0;\n      HEAP32[$156 >> 2] = (HEAP32[$156 >> 2] | 0) + 1;\n      $160 = $4 + 1310736 + ($154 + -6 << 2) | 0;\n      HEAP32[$160 >> 2] = (HEAP32[$160 >> 2] | 0) + $$2385;\n      $164 = $4 + 1310736 + ($154 + -5 << 2) | 0;\n      HEAP32[$164 >> 2] = (HEAP32[$164 >> 2] | 0) + $$0380;\n      $168 = $4 + 1310736 + ($154 + -3 << 2) | 0;\n      if ((HEAP32[$168 >> 2] | 0) < ($$2385 | 0)) HEAP32[$168 >> 2] = $$2385;\n      HEAP32[$4 + 1310736 + ($154 + -1 << 2) >> 2] = $$0380;\n      $$2390 = $$1389;\n      break;\n     }\n     $174 = HEAP16[$$3 + -2 >> 1] | 0;\n     if ($174 << 16 >> 16 > 0) {\n      HEAP16[$$3 >> 1] = $174;\n      $177 = ($174 << 16 >> 16) * 7 | 0;\n      $179 = $4 + 1310736 + ($177 + -7 << 2) | 0;\n      HEAP32[$179 >> 2] = (HEAP32[$179 >> 2] | 0) + 1;\n      $183 = $4 + 1310736 + ($177 + -6 << 2) | 0;\n      HEAP32[$183 >> 2] = (HEAP32[$183 >> 2] | 0) + $$2385;\n      $187 = $4 + 1310736 + ($177 + -5 << 2) | 0;\n      HEAP32[$187 >> 2] = (HEAP32[$187 >> 2] | 0) + $$0380;\n      $191 = $4 + 1310736 + ($177 + -3 << 2) | 0;\n      if ((HEAP32[$191 >> 2] | 0) >= ($$2385 | 0)) {\n       $$2390 = $$1389;\n       break;\n      }\n      HEAP32[$191 >> 2] = $$2385;\n      $$2390 = $$1389;\n      break;\n     } else {\n      $194 = $$1389 + 1 | 0;\n      if (($$1389 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3 >> 1] = $194;\n      HEAP32[$4 + 1179664 + ($$1389 << 2) >> 2] = $194 << 16 >> 16;\n      $199 = $$1389 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($199 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($199 + 1 << 2) >> 2] = $$2385;\n      HEAP32[$4 + 1310736 + ($199 + 2 << 2) >> 2] = $$0380;\n      HEAP32[$4 + 1310736 + ($199 + 3 << 2) >> 2] = $$2385;\n      HEAP32[$4 + 1310736 + ($199 + 4 << 2) >> 2] = $$2385;\n      HEAP32[$4 + 1310736 + ($199 + 5 << 2) >> 2] = $$0380;\n      HEAP32[$4 + 1310736 + ($199 + 6 << 2) >> 2] = $$0380;\n      $$2390 = $194;\n      break;\n     }\n    }\n    if ($58) {\n     $61 = HEAP32[$4 + 1179664 + ($53 + -1 << 2) >> 2] | 0;\n     $64 = HEAP32[$4 + 1179664 + ($57 + -1 << 2) >> 2] | 0;\n     L37 : do if (($61 | 0) > ($64 | 0)) {\n      HEAP16[$$3 >> 1] = $64;\n      $$0372 = $19;\n      $$0376 = 0;\n      while (1) {\n       if (($$0376 | 0) >= ($$1389 | 0)) {\n        $79 = $64;\n        break L37;\n       }\n       if ((HEAP32[$$0372 >> 2] | 0) == ($61 | 0)) HEAP32[$$0372 >> 2] = $64;\n       $$0372 = $$0372 + 4 | 0;\n       $$0376 = $$0376 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3 >> 1] = $61;\n      if (($61 | 0) < ($64 | 0)) {\n       $$1373 = $19;\n       $$1377 = 0;\n       while (1) {\n        if (($$1377 | 0) >= ($$1389 | 0)) {\n         $79 = $61;\n         break L37;\n        }\n        if ((HEAP32[$$1373 >> 2] | 0) == ($64 | 0)) HEAP32[$$1373 >> 2] = $61;\n        $$1373 = $$1373 + 4 | 0;\n        $$1377 = $$1377 + 1 | 0;\n       }\n      } else $79 = $61;\n     } while (0);\n     $81 = ($79 << 16 >> 16) * 7 | 0;\n     $83 = $4 + 1310736 + ($81 + -7 << 2) | 0;\n     HEAP32[$83 >> 2] = (HEAP32[$83 >> 2] | 0) + 1;\n     $87 = $4 + 1310736 + ($81 + -6 << 2) | 0;\n     HEAP32[$87 >> 2] = (HEAP32[$87 >> 2] | 0) + $$2385;\n     $91 = $4 + 1310736 + ($81 + -5 << 2) | 0;\n     HEAP32[$91 >> 2] = (HEAP32[$91 >> 2] | 0) + $$0380;\n     HEAP32[$4 + 1310736 + ($81 + -1 << 2) >> 2] = $$0380;\n     $$2390 = $$1389;\n     break;\n    }\n    $97 = HEAP16[$$3 + -2 >> 1] | 0;\n    if ($97 << 16 >> 16 <= 0) {\n     HEAP16[$$3 >> 1] = $52;\n     $135 = $53 * 7 | 0;\n     $137 = $4 + 1310736 + ($135 + -7 << 2) | 0;\n     HEAP32[$137 >> 2] = (HEAP32[$137 >> 2] | 0) + 1;\n     $141 = $4 + 1310736 + ($135 + -6 << 2) | 0;\n     HEAP32[$141 >> 2] = (HEAP32[$141 >> 2] | 0) + $$2385;\n     $145 = $4 + 1310736 + ($135 + -5 << 2) | 0;\n     HEAP32[$145 >> 2] = (HEAP32[$145 >> 2] | 0) + $$0380;\n     $149 = $4 + 1310736 + ($135 + -4 << 2) | 0;\n     if ((HEAP32[$149 >> 2] | 0) > ($$2385 | 0)) HEAP32[$149 >> 2] = $$2385;\n     HEAP32[$4 + 1310736 + ($135 + -1 << 2) >> 2] = $$0380;\n     $$2390 = $$1389;\n     break;\n    }\n    $102 = HEAP32[$4 + 1179664 + ($53 + -1 << 2) >> 2] | 0;\n    $105 = HEAP32[$4 + 1179664 + (($97 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L61 : do if (($102 | 0) > ($105 | 0)) {\n     HEAP16[$$3 >> 1] = $105;\n     $$2374 = $19;\n     $$2378 = 0;\n     while (1) {\n      if (($$2378 | 0) >= ($$1389 | 0)) {\n       $120 = $105;\n       break L61;\n      }\n      if ((HEAP32[$$2374 >> 2] | 0) == ($102 | 0)) HEAP32[$$2374 >> 2] = $105;\n      $$2374 = $$2374 + 4 | 0;\n      $$2378 = $$2378 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3 >> 1] = $102;\n     if (($102 | 0) < ($105 | 0)) {\n      $$3375 = $19;\n      $$3379 = 0;\n      while (1) {\n       if (($$3379 | 0) >= ($$1389 | 0)) {\n        $120 = $102;\n        break L61;\n       }\n       if ((HEAP32[$$3375 >> 2] | 0) == ($105 | 0)) HEAP32[$$3375 >> 2] = $102;\n       $$3375 = $$3375 + 4 | 0;\n       $$3379 = $$3379 + 1 | 0;\n      }\n     } else $120 = $102;\n    } while (0);\n    $122 = ($120 << 16 >> 16) * 7 | 0;\n    $124 = $4 + 1310736 + ($122 + -7 << 2) | 0;\n    HEAP32[$124 >> 2] = (HEAP32[$124 >> 2] | 0) + 1;\n    $128 = $4 + 1310736 + ($122 + -6 << 2) | 0;\n    HEAP32[$128 >> 2] = (HEAP32[$128 >> 2] | 0) + $$2385;\n    $132 = $4 + 1310736 + ($122 + -5 << 2) | 0;\n    HEAP32[$132 >> 2] = (HEAP32[$132 >> 2] | 0) + $$0380;\n    $$2390 = $$1389;\n   } while (0);\n   $$1 = $$1 + 1 | 0;\n   $$1389 = $$2390;\n   $$1392 = $$1392 + 1 | 0;\n   $$2385 = $$2385 + 1 | 0;\n   $$3 = $$3 + 2 | 0;\n  }\n  $$0367 = $$1 + 2 | 0;\n  $$0380 = $$0380 + 1 | 0;\n  $$0388 = $$1389;\n  $$0391 = $$1392 + 2 | 0;\n  $$2 = $$3 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $221 = $4 + 12 | 0;\n  $$1381 = 1;\n  $$3386 = 1;\n  $$4 = $19;\n  while (1) {\n   if (($$3386 | 0) > ($$0388 | 0)) break;\n   $223 = HEAP32[$$4 >> 2] | 0;\n   if (($223 | 0) == ($$3386 | 0)) {\n    $$2382 = $$1381 + 1 | 0;\n    $229 = $$1381;\n   } else {\n    $$2382 = $$1381;\n    $229 = HEAP32[$4 + 1179664 + ($223 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $229;\n   $$1381 = $$2382;\n   $$3386 = $$3386 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $232 = $4 + 8 | 0;\n  $233 = $$1381 + -1 | 0;\n  HEAP32[$232 >> 2] = $233;\n  if (!$233) $$0 = 0; else {\n   _memset($221 | 0, 0, $233 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $233 << 4 | 0) | 0;\n   $$4387 = 0;\n   while (1) {\n    if (($$4387 | 0) >= ($233 | 0)) break;\n    $239 = $$4387 << 2;\n    HEAP32[$4 + 131084 + ($239 << 2) >> 2] = $1;\n    HEAP32[$4 + 131084 + (($239 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($239 | 2) << 2) >> 2] = $2;\n    HEAP32[$4 + 131084 + (($239 | 3) << 2) >> 2] = 0;\n    $$4387 = $$4387 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0388 | 0)) break;\n    $251 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $252 = $$5 * 7 | 0;\n    $255 = $4 + 12 + ($251 << 2) | 0;\n    HEAP32[$255 >> 2] = (HEAP32[$255 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($252 << 2) >> 2] | 0);\n    $262 = $251 << 1;\n    $263 = $4 + 655376 + ($262 << 3) | 0;\n    HEAPF64[$263 >> 3] = +HEAPF64[$263 >> 3] + +(HEAP32[$4 + 1310736 + ($252 + 1 << 2) >> 2] | 0);\n    $271 = $4 + 655376 + (($262 | 1) << 3) | 0;\n    HEAPF64[$271 >> 3] = +HEAPF64[$271 >> 3] + +(HEAP32[$4 + 1310736 + ($252 + 2 << 2) >> 2] | 0);\n    $274 = $251 << 2;\n    $275 = $4 + 131084 + ($274 << 2) | 0;\n    $279 = HEAP32[$4 + 1310736 + ($252 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$275 >> 2] | 0) > ($279 | 0)) HEAP32[$275 >> 2] = $279;\n    $282 = $4 + 131084 + (($274 | 1) << 2) | 0;\n    $286 = HEAP32[$4 + 1310736 + ($252 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$282 >> 2] | 0) < ($286 | 0)) HEAP32[$282 >> 2] = $286;\n    $289 = $4 + 131084 + (($274 | 2) << 2) | 0;\n    $293 = HEAP32[$4 + 1310736 + ($252 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$289 >> 2] | 0) > ($293 | 0)) HEAP32[$289 >> 2] = $293;\n    $296 = $4 + 131084 + (($274 | 3) << 2) | 0;\n    $300 = HEAP32[$4 + 1310736 + ($252 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$296 >> 2] | 0) < ($300 | 0)) HEAP32[$296 >> 2] = $300;\n    $$5 = $$5 + 1 | 0;\n   }\n   $303 = HEAP32[$232 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($303 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $307 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $308 = $$6 << 1;\n    $309 = $4 + 655376 + ($308 << 3) | 0;\n    HEAPF64[$309 >> 3] = +HEAPF64[$309 >> 3] / $307;\n    $313 = $4 + 655376 + (($308 | 1) << 3) | 0;\n    HEAPF64[$313 >> 3] = +HEAPF64[$313 >> 3] / $307;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubDWZ($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0364 = 0, $$0365 = 0, $$0367 = 0, $$0369 = 0, $$0371 = 0, $$0375 = 0, $$0378 = 0, $$0383 = 0, $$0386 = 0, $$1 = 0, $$1366 = 0, $$1368 = 0, $$1370 = 0, $$1372 = 0, $$1376 = 0, $$1379 = 0, $$1384 = 0, $$1387 = 0, $$2 = 0, $$2373 = 0, $$2377 = 0, $$2380 = 0, $$2385 = 0, $$2388 = 0, $$3 = 0, $$3374 = 0, $$3381 = 0, $$3389 = 0, $$4 = 0, $$4382 = 0, $$5 = 0, $$6 = 0, $100 = 0, $103 = 0, $118 = 0, $120 = 0, $122 = 0, $126 = 0, $13 = 0, $130 = 0, $133 = 0, $135 = 0, $139 = 0, $143 = 0, $147 = 0, $152 = 0, $154 = 0, $158 = 0, $162 = 0, $166 = 0, $172 = 0, $175 = 0, $177 = 0, $181 = 0, $185 = 0, $189 = 0, $19 = 0, $192 = 0, $197 = 0, $20 = 0, $219 = 0, $221 = 0, $227 = 0, $230 = 0, $231 = 0, $237 = 0, $24 = 0, $249 = 0, $250 = 0, $253 = 0, $260 = 0, $261 = 0, $269 = 0, $272 = 0, $273 = 0, $277 = 0, $280 = 0, $284 = 0, $287 = 0, $291 = 0, $294 = 0, $298 = 0, $30 = 0, $301 = 0, $305 = 0.0, $306 = 0, $307 = 0, $31 = 0, $311 = 0, $34 = 0, $36 = 0, $40 = 0, $44 = 0, $5 = 0, $50 = 0, $51 = 0, $54 = 0, $55 = 0, $56 = 0, $59 = 0, $6 = 0, $62 = 0, $77 = 0, $79 = 0, $81 = 0, $85 = 0, $89 = 0, $95 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = HEAP32[$4 >> 2] | 0;\n $6 = $2 + -1 | 0;\n $$0367 = $5;\n $$0378 = 0;\n $$0386 = $5 + ((Math_imul($6, $1) | 0) << 1) | 0;\n while (1) {\n  if (($$0378 | 0) >= ($1 | 0)) break;\n  HEAP16[$$0386 >> 1] = 0;\n  HEAP16[$$0367 >> 1] = 0;\n  $$0367 = $$0367 + 2 | 0;\n  $$0378 = $$0378 + 1 | 0;\n  $$0386 = $$0386 + 2 | 0;\n }\n $13 = $1 + -1 | 0;\n $$1368 = $5;\n $$1379 = 0;\n $$1387 = $5 + ($13 << 1) | 0;\n while (1) {\n  if (($$1379 | 0) >= ($2 | 0)) break;\n  HEAP16[$$1387 >> 1] = 0;\n  HEAP16[$$1368 >> 1] = 0;\n  $$1368 = $$1368 + ($1 << 1) | 0;\n  $$1379 = $$1379 + 1 | 0;\n  $$1387 = $$1387 + ($1 << 1) | 0;\n }\n $19 = $4 + 1179664 | 0;\n $20 = $1 + 1 | 0;\n $24 = 0 - $1 | 0;\n $$0364 = $0 + $20 | 0;\n $$0365 = $3 + $20 | 0;\n $$0375 = 1;\n $$0383 = 0;\n $$2388 = $5 + ($20 << 1) | 0;\n L9 : while (1) {\n  if (($$0375 | 0) >= ($6 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0364;\n  $$1366 = $$0365;\n  $$1384 = $$0383;\n  $$2380 = 1;\n  $$3389 = $$2388;\n  while (1) {\n   if (($$2380 | 0) >= ($13 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0) > (HEAPU8[$$1366 >> 0] | 0)) {\n    $30 = $$3389 + ($24 << 1) | 0;\n    $31 = HEAP16[$30 >> 1] | 0;\n    if ($31 << 16 >> 16 > 0) {\n     HEAP16[$$3389 >> 1] = $31;\n     $34 = ($31 << 16 >> 16) * 7 | 0;\n     $36 = $4 + 1310736 + ($34 + -7 << 2) | 0;\n     HEAP32[$36 >> 2] = (HEAP32[$36 >> 2] | 0) + 1;\n     $40 = $4 + 1310736 + ($34 + -6 << 2) | 0;\n     HEAP32[$40 >> 2] = (HEAP32[$40 >> 2] | 0) + $$2380;\n     $44 = $4 + 1310736 + ($34 + -5 << 2) | 0;\n     HEAP32[$44 >> 2] = (HEAP32[$44 >> 2] | 0) + $$0375;\n     HEAP32[$4 + 1310736 + ($34 + -1 << 2) >> 2] = $$0375;\n     $$2385 = $$1384;\n     break;\n    }\n    $50 = HEAP16[$30 + 2 >> 1] | 0;\n    $51 = $50 << 16 >> 16;\n    $54 = HEAP16[$30 + -2 >> 1] | 0;\n    $55 = $54 << 16 >> 16;\n    $56 = $54 << 16 >> 16 > 0;\n    if ($50 << 16 >> 16 <= 0) {\n     if ($56) {\n      HEAP16[$$3389 >> 1] = $54;\n      $152 = $55 * 7 | 0;\n      $154 = $4 + 1310736 + ($152 + -7 << 2) | 0;\n      HEAP32[$154 >> 2] = (HEAP32[$154 >> 2] | 0) + 1;\n      $158 = $4 + 1310736 + ($152 + -6 << 2) | 0;\n      HEAP32[$158 >> 2] = (HEAP32[$158 >> 2] | 0) + $$2380;\n      $162 = $4 + 1310736 + ($152 + -5 << 2) | 0;\n      HEAP32[$162 >> 2] = (HEAP32[$162 >> 2] | 0) + $$0375;\n      $166 = $4 + 1310736 + ($152 + -3 << 2) | 0;\n      if ((HEAP32[$166 >> 2] | 0) < ($$2380 | 0)) HEAP32[$166 >> 2] = $$2380;\n      HEAP32[$4 + 1310736 + ($152 + -1 << 2) >> 2] = $$0375;\n      $$2385 = $$1384;\n      break;\n     }\n     $172 = HEAP16[$$3389 + -2 >> 1] | 0;\n     if ($172 << 16 >> 16 > 0) {\n      HEAP16[$$3389 >> 1] = $172;\n      $175 = ($172 << 16 >> 16) * 7 | 0;\n      $177 = $4 + 1310736 + ($175 + -7 << 2) | 0;\n      HEAP32[$177 >> 2] = (HEAP32[$177 >> 2] | 0) + 1;\n      $181 = $4 + 1310736 + ($175 + -6 << 2) | 0;\n      HEAP32[$181 >> 2] = (HEAP32[$181 >> 2] | 0) + $$2380;\n      $185 = $4 + 1310736 + ($175 + -5 << 2) | 0;\n      HEAP32[$185 >> 2] = (HEAP32[$185 >> 2] | 0) + $$0375;\n      $189 = $4 + 1310736 + ($175 + -3 << 2) | 0;\n      if ((HEAP32[$189 >> 2] | 0) >= ($$2380 | 0)) {\n       $$2385 = $$1384;\n       break;\n      }\n      HEAP32[$189 >> 2] = $$2380;\n      $$2385 = $$1384;\n      break;\n     } else {\n      $192 = $$1384 + 1 | 0;\n      if (($$1384 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3389 >> 1] = $192;\n      HEAP32[$4 + 1179664 + ($$1384 << 2) >> 2] = $192 << 16 >> 16;\n      $197 = $$1384 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($197 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($197 + 1 << 2) >> 2] = $$2380;\n      HEAP32[$4 + 1310736 + ($197 + 2 << 2) >> 2] = $$0375;\n      HEAP32[$4 + 1310736 + ($197 + 3 << 2) >> 2] = $$2380;\n      HEAP32[$4 + 1310736 + ($197 + 4 << 2) >> 2] = $$2380;\n      HEAP32[$4 + 1310736 + ($197 + 5 << 2) >> 2] = $$0375;\n      HEAP32[$4 + 1310736 + ($197 + 6 << 2) >> 2] = $$0375;\n      $$2385 = $192;\n      break;\n     }\n    }\n    if ($56) {\n     $59 = HEAP32[$4 + 1179664 + ($51 + -1 << 2) >> 2] | 0;\n     $62 = HEAP32[$4 + 1179664 + ($55 + -1 << 2) >> 2] | 0;\n     L36 : do if (($59 | 0) > ($62 | 0)) {\n      HEAP16[$$3389 >> 1] = $62;\n      $$0369 = $19;\n      $$0371 = 0;\n      while (1) {\n       if (($$0371 | 0) >= ($$1384 | 0)) {\n        $77 = $62;\n        break L36;\n       }\n       if ((HEAP32[$$0369 >> 2] | 0) == ($59 | 0)) HEAP32[$$0369 >> 2] = $62;\n       $$0369 = $$0369 + 4 | 0;\n       $$0371 = $$0371 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3389 >> 1] = $59;\n      if (($59 | 0) < ($62 | 0)) {\n       $$1370 = $19;\n       $$1372 = 0;\n       while (1) {\n        if (($$1372 | 0) >= ($$1384 | 0)) {\n         $77 = $59;\n         break L36;\n        }\n        if ((HEAP32[$$1370 >> 2] | 0) == ($62 | 0)) HEAP32[$$1370 >> 2] = $59;\n        $$1370 = $$1370 + 4 | 0;\n        $$1372 = $$1372 + 1 | 0;\n       }\n      } else $77 = $59;\n     } while (0);\n     $79 = ($77 << 16 >> 16) * 7 | 0;\n     $81 = $4 + 1310736 + ($79 + -7 << 2) | 0;\n     HEAP32[$81 >> 2] = (HEAP32[$81 >> 2] | 0) + 1;\n     $85 = $4 + 1310736 + ($79 + -6 << 2) | 0;\n     HEAP32[$85 >> 2] = (HEAP32[$85 >> 2] | 0) + $$2380;\n     $89 = $4 + 1310736 + ($79 + -5 << 2) | 0;\n     HEAP32[$89 >> 2] = (HEAP32[$89 >> 2] | 0) + $$0375;\n     HEAP32[$4 + 1310736 + ($79 + -1 << 2) >> 2] = $$0375;\n     $$2385 = $$1384;\n     break;\n    }\n    $95 = HEAP16[$$3389 + -2 >> 1] | 0;\n    if ($95 << 16 >> 16 <= 0) {\n     HEAP16[$$3389 >> 1] = $50;\n     $133 = $51 * 7 | 0;\n     $135 = $4 + 1310736 + ($133 + -7 << 2) | 0;\n     HEAP32[$135 >> 2] = (HEAP32[$135 >> 2] | 0) + 1;\n     $139 = $4 + 1310736 + ($133 + -6 << 2) | 0;\n     HEAP32[$139 >> 2] = (HEAP32[$139 >> 2] | 0) + $$2380;\n     $143 = $4 + 1310736 + ($133 + -5 << 2) | 0;\n     HEAP32[$143 >> 2] = (HEAP32[$143 >> 2] | 0) + $$0375;\n     $147 = $4 + 1310736 + ($133 + -4 << 2) | 0;\n     if ((HEAP32[$147 >> 2] | 0) > ($$2380 | 0)) HEAP32[$147 >> 2] = $$2380;\n     HEAP32[$4 + 1310736 + ($133 + -1 << 2) >> 2] = $$0375;\n     $$2385 = $$1384;\n     break;\n    }\n    $100 = HEAP32[$4 + 1179664 + ($51 + -1 << 2) >> 2] | 0;\n    $103 = HEAP32[$4 + 1179664 + (($95 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L60 : do if (($100 | 0) > ($103 | 0)) {\n     HEAP16[$$3389 >> 1] = $103;\n     $$2 = $19;\n     $$2373 = 0;\n     while (1) {\n      if (($$2373 | 0) >= ($$1384 | 0)) {\n       $118 = $103;\n       break L60;\n      }\n      if ((HEAP32[$$2 >> 2] | 0) == ($100 | 0)) HEAP32[$$2 >> 2] = $103;\n      $$2 = $$2 + 4 | 0;\n      $$2373 = $$2373 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3389 >> 1] = $100;\n     if (($100 | 0) < ($103 | 0)) {\n      $$3 = $19;\n      $$3374 = 0;\n      while (1) {\n       if (($$3374 | 0) >= ($$1384 | 0)) {\n        $118 = $100;\n        break L60;\n       }\n       if ((HEAP32[$$3 >> 2] | 0) == ($103 | 0)) HEAP32[$$3 >> 2] = $100;\n       $$3 = $$3 + 4 | 0;\n       $$3374 = $$3374 + 1 | 0;\n      }\n     } else $118 = $100;\n    } while (0);\n    $120 = ($118 << 16 >> 16) * 7 | 0;\n    $122 = $4 + 1310736 + ($120 + -7 << 2) | 0;\n    HEAP32[$122 >> 2] = (HEAP32[$122 >> 2] | 0) + 1;\n    $126 = $4 + 1310736 + ($120 + -6 << 2) | 0;\n    HEAP32[$126 >> 2] = (HEAP32[$126 >> 2] | 0) + $$2380;\n    $130 = $4 + 1310736 + ($120 + -5 << 2) | 0;\n    HEAP32[$130 >> 2] = (HEAP32[$130 >> 2] | 0) + $$0375;\n    $$2385 = $$1384;\n   } else {\n    HEAP16[$$3389 >> 1] = 0;\n    $$2385 = $$1384;\n   } while (0);\n   $$1 = $$1 + 1 | 0;\n   $$1366 = $$1366 + 1 | 0;\n   $$1384 = $$2385;\n   $$2380 = $$2380 + 1 | 0;\n   $$3389 = $$3389 + 2 | 0;\n  }\n  $$0364 = $$1 + 2 | 0;\n  $$0365 = $$1366 + 2 | 0;\n  $$0375 = $$0375 + 1 | 0;\n  $$0383 = $$1384;\n  $$2388 = $$3389 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $219 = $4 + 12 | 0;\n  $$1376 = 1;\n  $$3381 = 1;\n  $$4 = $19;\n  while (1) {\n   if (($$3381 | 0) > ($$0383 | 0)) break;\n   $221 = HEAP32[$$4 >> 2] | 0;\n   if (($221 | 0) == ($$3381 | 0)) {\n    $$2377 = $$1376 + 1 | 0;\n    $227 = $$1376;\n   } else {\n    $$2377 = $$1376;\n    $227 = HEAP32[$4 + 1179664 + ($221 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $227;\n   $$1376 = $$2377;\n   $$3381 = $$3381 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $230 = $4 + 8 | 0;\n  $231 = $$1376 + -1 | 0;\n  HEAP32[$230 >> 2] = $231;\n  if (!$231) $$0 = 0; else {\n   _memset($219 | 0, 0, $231 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $231 << 4 | 0) | 0;\n   $$4382 = 0;\n   while (1) {\n    if (($$4382 | 0) >= ($231 | 0)) break;\n    $237 = $$4382 << 2;\n    HEAP32[$4 + 131084 + ($237 << 2) >> 2] = $1;\n    HEAP32[$4 + 131084 + (($237 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($237 | 2) << 2) >> 2] = $2;\n    HEAP32[$4 + 131084 + (($237 | 3) << 2) >> 2] = 0;\n    $$4382 = $$4382 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0383 | 0)) break;\n    $249 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $250 = $$5 * 7 | 0;\n    $253 = $4 + 12 + ($249 << 2) | 0;\n    HEAP32[$253 >> 2] = (HEAP32[$253 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($250 << 2) >> 2] | 0);\n    $260 = $249 << 1;\n    $261 = $4 + 655376 + ($260 << 3) | 0;\n    HEAPF64[$261 >> 3] = +HEAPF64[$261 >> 3] + +(HEAP32[$4 + 1310736 + ($250 + 1 << 2) >> 2] | 0);\n    $269 = $4 + 655376 + (($260 | 1) << 3) | 0;\n    HEAPF64[$269 >> 3] = +HEAPF64[$269 >> 3] + +(HEAP32[$4 + 1310736 + ($250 + 2 << 2) >> 2] | 0);\n    $272 = $249 << 2;\n    $273 = $4 + 131084 + ($272 << 2) | 0;\n    $277 = HEAP32[$4 + 1310736 + ($250 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$273 >> 2] | 0) > ($277 | 0)) HEAP32[$273 >> 2] = $277;\n    $280 = $4 + 131084 + (($272 | 1) << 2) | 0;\n    $284 = HEAP32[$4 + 1310736 + ($250 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$280 >> 2] | 0) < ($284 | 0)) HEAP32[$280 >> 2] = $284;\n    $287 = $4 + 131084 + (($272 | 2) << 2) | 0;\n    $291 = HEAP32[$4 + 1310736 + ($250 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$287 >> 2] | 0) > ($291 | 0)) HEAP32[$287 >> 2] = $291;\n    $294 = $4 + 131084 + (($272 | 3) << 2) | 0;\n    $298 = HEAP32[$4 + 1310736 + ($250 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$294 >> 2] | 0) < ($298 | 0)) HEAP32[$294 >> 2] = $298;\n    $$5 = $$5 + 1 | 0;\n   }\n   $301 = HEAP32[$230 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($301 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $305 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $306 = $$6 << 1;\n    $307 = $4 + 655376 + ($306 << 3) | 0;\n    HEAPF64[$307 >> 3] = +HEAPF64[$307 >> 3] / $305;\n    $311 = $4 + 655376 + (($306 | 1) << 3) | 0;\n    HEAPF64[$311 >> 3] = +HEAPF64[$311 >> 3] / $305;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubDBZ($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0364 = 0, $$0365 = 0, $$0367 = 0, $$0369 = 0, $$0371 = 0, $$0375 = 0, $$0378 = 0, $$0383 = 0, $$0386 = 0, $$1 = 0, $$1366 = 0, $$1368 = 0, $$1370 = 0, $$1372 = 0, $$1376 = 0, $$1379 = 0, $$1384 = 0, $$1387 = 0, $$2 = 0, $$2373 = 0, $$2377 = 0, $$2380 = 0, $$2385 = 0, $$2388 = 0, $$3 = 0, $$3374 = 0, $$3381 = 0, $$3389 = 0, $$4 = 0, $$4382 = 0, $$5 = 0, $$6 = 0, $100 = 0, $103 = 0, $118 = 0, $120 = 0, $122 = 0, $126 = 0, $13 = 0, $130 = 0, $133 = 0, $135 = 0, $139 = 0, $143 = 0, $147 = 0, $152 = 0, $154 = 0, $158 = 0, $162 = 0, $166 = 0, $172 = 0, $175 = 0, $177 = 0, $181 = 0, $185 = 0, $189 = 0, $19 = 0, $192 = 0, $197 = 0, $20 = 0, $219 = 0, $221 = 0, $227 = 0, $230 = 0, $231 = 0, $237 = 0, $24 = 0, $249 = 0, $250 = 0, $253 = 0, $260 = 0, $261 = 0, $269 = 0, $272 = 0, $273 = 0, $277 = 0, $280 = 0, $284 = 0, $287 = 0, $291 = 0, $294 = 0, $298 = 0, $30 = 0, $301 = 0, $305 = 0.0, $306 = 0, $307 = 0, $31 = 0, $311 = 0, $34 = 0, $36 = 0, $40 = 0, $44 = 0, $5 = 0, $50 = 0, $51 = 0, $54 = 0, $55 = 0, $56 = 0, $59 = 0, $6 = 0, $62 = 0, $77 = 0, $79 = 0, $81 = 0, $85 = 0, $89 = 0, $95 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = HEAP32[$4 >> 2] | 0;\n $6 = $2 + -1 | 0;\n $$0367 = $5;\n $$0378 = 0;\n $$0386 = $5 + ((Math_imul($6, $1) | 0) << 1) | 0;\n while (1) {\n  if (($$0378 | 0) >= ($1 | 0)) break;\n  HEAP16[$$0386 >> 1] = 0;\n  HEAP16[$$0367 >> 1] = 0;\n  $$0367 = $$0367 + 2 | 0;\n  $$0378 = $$0378 + 1 | 0;\n  $$0386 = $$0386 + 2 | 0;\n }\n $13 = $1 + -1 | 0;\n $$1368 = $5;\n $$1379 = 0;\n $$1387 = $5 + ($13 << 1) | 0;\n while (1) {\n  if (($$1379 | 0) >= ($2 | 0)) break;\n  HEAP16[$$1387 >> 1] = 0;\n  HEAP16[$$1368 >> 1] = 0;\n  $$1368 = $$1368 + ($1 << 1) | 0;\n  $$1379 = $$1379 + 1 | 0;\n  $$1387 = $$1387 + ($1 << 1) | 0;\n }\n $19 = $4 + 1179664 | 0;\n $20 = $1 + 1 | 0;\n $24 = 0 - $1 | 0;\n $$0364 = $0 + $20 | 0;\n $$0365 = $3 + $20 | 0;\n $$0375 = 1;\n $$0383 = 0;\n $$2388 = $5 + ($20 << 1) | 0;\n L9 : while (1) {\n  if (($$0375 | 0) >= ($6 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0364;\n  $$1366 = $$0365;\n  $$1384 = $$0383;\n  $$2380 = 1;\n  $$3389 = $$2388;\n  while (1) {\n   if (($$2380 | 0) >= ($13 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0) > (HEAPU8[$$1366 >> 0] | 0)) {\n    HEAP16[$$3389 >> 1] = 0;\n    $$2385 = $$1384;\n   } else {\n    $30 = $$3389 + ($24 << 1) | 0;\n    $31 = HEAP16[$30 >> 1] | 0;\n    if ($31 << 16 >> 16 > 0) {\n     HEAP16[$$3389 >> 1] = $31;\n     $34 = ($31 << 16 >> 16) * 7 | 0;\n     $36 = $4 + 1310736 + ($34 + -7 << 2) | 0;\n     HEAP32[$36 >> 2] = (HEAP32[$36 >> 2] | 0) + 1;\n     $40 = $4 + 1310736 + ($34 + -6 << 2) | 0;\n     HEAP32[$40 >> 2] = (HEAP32[$40 >> 2] | 0) + $$2380;\n     $44 = $4 + 1310736 + ($34 + -5 << 2) | 0;\n     HEAP32[$44 >> 2] = (HEAP32[$44 >> 2] | 0) + $$0375;\n     HEAP32[$4 + 1310736 + ($34 + -1 << 2) >> 2] = $$0375;\n     $$2385 = $$1384;\n     break;\n    }\n    $50 = HEAP16[$30 + 2 >> 1] | 0;\n    $51 = $50 << 16 >> 16;\n    $54 = HEAP16[$30 + -2 >> 1] | 0;\n    $55 = $54 << 16 >> 16;\n    $56 = $54 << 16 >> 16 > 0;\n    if ($50 << 16 >> 16 <= 0) {\n     if ($56) {\n      HEAP16[$$3389 >> 1] = $54;\n      $152 = $55 * 7 | 0;\n      $154 = $4 + 1310736 + ($152 + -7 << 2) | 0;\n      HEAP32[$154 >> 2] = (HEAP32[$154 >> 2] | 0) + 1;\n      $158 = $4 + 1310736 + ($152 + -6 << 2) | 0;\n      HEAP32[$158 >> 2] = (HEAP32[$158 >> 2] | 0) + $$2380;\n      $162 = $4 + 1310736 + ($152 + -5 << 2) | 0;\n      HEAP32[$162 >> 2] = (HEAP32[$162 >> 2] | 0) + $$0375;\n      $166 = $4 + 1310736 + ($152 + -3 << 2) | 0;\n      if ((HEAP32[$166 >> 2] | 0) < ($$2380 | 0)) HEAP32[$166 >> 2] = $$2380;\n      HEAP32[$4 + 1310736 + ($152 + -1 << 2) >> 2] = $$0375;\n      $$2385 = $$1384;\n      break;\n     }\n     $172 = HEAP16[$$3389 + -2 >> 1] | 0;\n     if ($172 << 16 >> 16 > 0) {\n      HEAP16[$$3389 >> 1] = $172;\n      $175 = ($172 << 16 >> 16) * 7 | 0;\n      $177 = $4 + 1310736 + ($175 + -7 << 2) | 0;\n      HEAP32[$177 >> 2] = (HEAP32[$177 >> 2] | 0) + 1;\n      $181 = $4 + 1310736 + ($175 + -6 << 2) | 0;\n      HEAP32[$181 >> 2] = (HEAP32[$181 >> 2] | 0) + $$2380;\n      $185 = $4 + 1310736 + ($175 + -5 << 2) | 0;\n      HEAP32[$185 >> 2] = (HEAP32[$185 >> 2] | 0) + $$0375;\n      $189 = $4 + 1310736 + ($175 + -3 << 2) | 0;\n      if ((HEAP32[$189 >> 2] | 0) >= ($$2380 | 0)) {\n       $$2385 = $$1384;\n       break;\n      }\n      HEAP32[$189 >> 2] = $$2380;\n      $$2385 = $$1384;\n      break;\n     } else {\n      $192 = $$1384 + 1 | 0;\n      if (($$1384 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3389 >> 1] = $192;\n      HEAP32[$4 + 1179664 + ($$1384 << 2) >> 2] = $192 << 16 >> 16;\n      $197 = $$1384 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($197 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($197 + 1 << 2) >> 2] = $$2380;\n      HEAP32[$4 + 1310736 + ($197 + 2 << 2) >> 2] = $$0375;\n      HEAP32[$4 + 1310736 + ($197 + 3 << 2) >> 2] = $$2380;\n      HEAP32[$4 + 1310736 + ($197 + 4 << 2) >> 2] = $$2380;\n      HEAP32[$4 + 1310736 + ($197 + 5 << 2) >> 2] = $$0375;\n      HEAP32[$4 + 1310736 + ($197 + 6 << 2) >> 2] = $$0375;\n      $$2385 = $192;\n      break;\n     }\n    }\n    if ($56) {\n     $59 = HEAP32[$4 + 1179664 + ($51 + -1 << 2) >> 2] | 0;\n     $62 = HEAP32[$4 + 1179664 + ($55 + -1 << 2) >> 2] | 0;\n     L37 : do if (($59 | 0) > ($62 | 0)) {\n      HEAP16[$$3389 >> 1] = $62;\n      $$0369 = $19;\n      $$0371 = 0;\n      while (1) {\n       if (($$0371 | 0) >= ($$1384 | 0)) {\n        $77 = $62;\n        break L37;\n       }\n       if ((HEAP32[$$0369 >> 2] | 0) == ($59 | 0)) HEAP32[$$0369 >> 2] = $62;\n       $$0369 = $$0369 + 4 | 0;\n       $$0371 = $$0371 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3389 >> 1] = $59;\n      if (($59 | 0) < ($62 | 0)) {\n       $$1370 = $19;\n       $$1372 = 0;\n       while (1) {\n        if (($$1372 | 0) >= ($$1384 | 0)) {\n         $77 = $59;\n         break L37;\n        }\n        if ((HEAP32[$$1370 >> 2] | 0) == ($62 | 0)) HEAP32[$$1370 >> 2] = $59;\n        $$1370 = $$1370 + 4 | 0;\n        $$1372 = $$1372 + 1 | 0;\n       }\n      } else $77 = $59;\n     } while (0);\n     $79 = ($77 << 16 >> 16) * 7 | 0;\n     $81 = $4 + 1310736 + ($79 + -7 << 2) | 0;\n     HEAP32[$81 >> 2] = (HEAP32[$81 >> 2] | 0) + 1;\n     $85 = $4 + 1310736 + ($79 + -6 << 2) | 0;\n     HEAP32[$85 >> 2] = (HEAP32[$85 >> 2] | 0) + $$2380;\n     $89 = $4 + 1310736 + ($79 + -5 << 2) | 0;\n     HEAP32[$89 >> 2] = (HEAP32[$89 >> 2] | 0) + $$0375;\n     HEAP32[$4 + 1310736 + ($79 + -1 << 2) >> 2] = $$0375;\n     $$2385 = $$1384;\n     break;\n    }\n    $95 = HEAP16[$$3389 + -2 >> 1] | 0;\n    if ($95 << 16 >> 16 <= 0) {\n     HEAP16[$$3389 >> 1] = $50;\n     $133 = $51 * 7 | 0;\n     $135 = $4 + 1310736 + ($133 + -7 << 2) | 0;\n     HEAP32[$135 >> 2] = (HEAP32[$135 >> 2] | 0) + 1;\n     $139 = $4 + 1310736 + ($133 + -6 << 2) | 0;\n     HEAP32[$139 >> 2] = (HEAP32[$139 >> 2] | 0) + $$2380;\n     $143 = $4 + 1310736 + ($133 + -5 << 2) | 0;\n     HEAP32[$143 >> 2] = (HEAP32[$143 >> 2] | 0) + $$0375;\n     $147 = $4 + 1310736 + ($133 + -4 << 2) | 0;\n     if ((HEAP32[$147 >> 2] | 0) > ($$2380 | 0)) HEAP32[$147 >> 2] = $$2380;\n     HEAP32[$4 + 1310736 + ($133 + -1 << 2) >> 2] = $$0375;\n     $$2385 = $$1384;\n     break;\n    }\n    $100 = HEAP32[$4 + 1179664 + ($51 + -1 << 2) >> 2] | 0;\n    $103 = HEAP32[$4 + 1179664 + (($95 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L61 : do if (($100 | 0) > ($103 | 0)) {\n     HEAP16[$$3389 >> 1] = $103;\n     $$2 = $19;\n     $$2373 = 0;\n     while (1) {\n      if (($$2373 | 0) >= ($$1384 | 0)) {\n       $118 = $103;\n       break L61;\n      }\n      if ((HEAP32[$$2 >> 2] | 0) == ($100 | 0)) HEAP32[$$2 >> 2] = $103;\n      $$2 = $$2 + 4 | 0;\n      $$2373 = $$2373 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3389 >> 1] = $100;\n     if (($100 | 0) < ($103 | 0)) {\n      $$3 = $19;\n      $$3374 = 0;\n      while (1) {\n       if (($$3374 | 0) >= ($$1384 | 0)) {\n        $118 = $100;\n        break L61;\n       }\n       if ((HEAP32[$$3 >> 2] | 0) == ($103 | 0)) HEAP32[$$3 >> 2] = $100;\n       $$3 = $$3 + 4 | 0;\n       $$3374 = $$3374 + 1 | 0;\n      }\n     } else $118 = $100;\n    } while (0);\n    $120 = ($118 << 16 >> 16) * 7 | 0;\n    $122 = $4 + 1310736 + ($120 + -7 << 2) | 0;\n    HEAP32[$122 >> 2] = (HEAP32[$122 >> 2] | 0) + 1;\n    $126 = $4 + 1310736 + ($120 + -6 << 2) | 0;\n    HEAP32[$126 >> 2] = (HEAP32[$126 >> 2] | 0) + $$2380;\n    $130 = $4 + 1310736 + ($120 + -5 << 2) | 0;\n    HEAP32[$130 >> 2] = (HEAP32[$130 >> 2] | 0) + $$0375;\n    $$2385 = $$1384;\n   } while (0);\n   $$1 = $$1 + 1 | 0;\n   $$1366 = $$1366 + 1 | 0;\n   $$1384 = $$2385;\n   $$2380 = $$2380 + 1 | 0;\n   $$3389 = $$3389 + 2 | 0;\n  }\n  $$0364 = $$1 + 2 | 0;\n  $$0365 = $$1366 + 2 | 0;\n  $$0375 = $$0375 + 1 | 0;\n  $$0383 = $$1384;\n  $$2388 = $$3389 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $219 = $4 + 12 | 0;\n  $$1376 = 1;\n  $$3381 = 1;\n  $$4 = $19;\n  while (1) {\n   if (($$3381 | 0) > ($$0383 | 0)) break;\n   $221 = HEAP32[$$4 >> 2] | 0;\n   if (($221 | 0) == ($$3381 | 0)) {\n    $$2377 = $$1376 + 1 | 0;\n    $227 = $$1376;\n   } else {\n    $$2377 = $$1376;\n    $227 = HEAP32[$4 + 1179664 + ($221 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $227;\n   $$1376 = $$2377;\n   $$3381 = $$3381 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $230 = $4 + 8 | 0;\n  $231 = $$1376 + -1 | 0;\n  HEAP32[$230 >> 2] = $231;\n  if (!$231) $$0 = 0; else {\n   _memset($219 | 0, 0, $231 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $231 << 4 | 0) | 0;\n   $$4382 = 0;\n   while (1) {\n    if (($$4382 | 0) >= ($231 | 0)) break;\n    $237 = $$4382 << 2;\n    HEAP32[$4 + 131084 + ($237 << 2) >> 2] = $1;\n    HEAP32[$4 + 131084 + (($237 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($237 | 2) << 2) >> 2] = $2;\n    HEAP32[$4 + 131084 + (($237 | 3) << 2) >> 2] = 0;\n    $$4382 = $$4382 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0383 | 0)) break;\n    $249 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $250 = $$5 * 7 | 0;\n    $253 = $4 + 12 + ($249 << 2) | 0;\n    HEAP32[$253 >> 2] = (HEAP32[$253 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($250 << 2) >> 2] | 0);\n    $260 = $249 << 1;\n    $261 = $4 + 655376 + ($260 << 3) | 0;\n    HEAPF64[$261 >> 3] = +HEAPF64[$261 >> 3] + +(HEAP32[$4 + 1310736 + ($250 + 1 << 2) >> 2] | 0);\n    $269 = $4 + 655376 + (($260 | 1) << 3) | 0;\n    HEAPF64[$269 >> 3] = +HEAPF64[$269 >> 3] + +(HEAP32[$4 + 1310736 + ($250 + 2 << 2) >> 2] | 0);\n    $272 = $249 << 2;\n    $273 = $4 + 131084 + ($272 << 2) | 0;\n    $277 = HEAP32[$4 + 1310736 + ($250 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$273 >> 2] | 0) > ($277 | 0)) HEAP32[$273 >> 2] = $277;\n    $280 = $4 + 131084 + (($272 | 1) << 2) | 0;\n    $284 = HEAP32[$4 + 1310736 + ($250 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$280 >> 2] | 0) < ($284 | 0)) HEAP32[$280 >> 2] = $284;\n    $287 = $4 + 131084 + (($272 | 2) << 2) | 0;\n    $291 = HEAP32[$4 + 1310736 + ($250 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$287 >> 2] | 0) > ($291 | 0)) HEAP32[$287 >> 2] = $291;\n    $294 = $4 + 131084 + (($272 | 3) << 2) | 0;\n    $298 = HEAP32[$4 + 1310736 + ($250 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$294 >> 2] | 0) < ($298 | 0)) HEAP32[$294 >> 2] = $298;\n    $$5 = $$5 + 1 | 0;\n   }\n   $301 = HEAP32[$230 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($301 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $305 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $306 = $$6 << 1;\n    $307 = $4 + 655376 + ($306 << 3) | 0;\n    HEAPF64[$307 >> 3] = +HEAPF64[$307 >> 3] / $305;\n    $311 = $4 + 655376 + (($306 | 1) << 3) | 0;\n    HEAPF64[$311 >> 3] = +HEAPF64[$311 >> 3] / $305;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubDWIC($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0360 = 0, $$0361 = 0, $$0363 = 0, $$0365 = 0, $$0369 = 0, $$0373 = 0, $$0376 = 0, $$0381 = 0, $$1 = 0, $$1362 = 0, $$1364 = 0, $$1366 = 0, $$1370 = 0, $$1374 = 0, $$1377 = 0, $$1382 = 0, $$2 = 0, $$2367 = 0, $$2371 = 0, $$2375 = 0, $$2378 = 0, $$2383 = 0, $$3 = 0, $$3368 = 0, $$3372 = 0, $$3379 = 0, $$4 = 0, $$4380 = 0, $$5 = 0, $$6 = 0, $103 = 0, $106 = 0, $121 = 0, $123 = 0, $125 = 0, $129 = 0, $133 = 0, $136 = 0, $138 = 0, $142 = 0, $146 = 0, $15 = 0, $150 = 0, $155 = 0, $157 = 0, $161 = 0, $165 = 0, $169 = 0, $175 = 0, $178 = 0, $180 = 0, $184 = 0, $188 = 0, $192 = 0, $195 = 0, $200 = 0, $21 = 0, $221 = 0, $223 = 0, $229 = 0, $232 = 0, $233 = 0, $239 = 0, $251 = 0, $252 = 0, $255 = 0, $262 = 0, $263 = 0, $27 = 0, $271 = 0, $274 = 0, $275 = 0, $279 = 0, $282 = 0, $286 = 0, $289 = 0, $293 = 0, $296 = 0, $300 = 0, $303 = 0, $307 = 0.0, $308 = 0, $309 = 0, $313 = 0, $33 = 0, $34 = 0, $37 = 0, $39 = 0, $43 = 0, $47 = 0, $5 = 0, $53 = 0, $54 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $62 = 0, $65 = 0, $7 = 0, $8 = 0, $80 = 0, $82 = 0, $84 = 0, $88 = 0, $92 = 0, $98 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = ($1 | 0) / 2 | 0;\n $6 = ($2 | 0) / 2 | 0;\n $7 = HEAP32[$4 >> 2] | 0;\n $8 = $6 + -1 | 0;\n $$0361 = $7;\n $$0363 = $7 + ((Math_imul($8, $5) | 0) << 1) | 0;\n $$0376 = 0;\n while (1) {\n  if (($$0376 | 0) >= ($5 | 0)) break;\n  HEAP16[$$0363 >> 1] = 0;\n  HEAP16[$$0361 >> 1] = 0;\n  $$0361 = $$0361 + 2 | 0;\n  $$0363 = $$0363 + 2 | 0;\n  $$0376 = $$0376 + 1 | 0;\n }\n $15 = $5 + -1 | 0;\n $$1362 = $7;\n $$1364 = $7 + ($15 << 1) | 0;\n $$1377 = 0;\n while (1) {\n  if (($$1377 | 0) >= ($6 | 0)) break;\n  HEAP16[$$1364 >> 1] = 0;\n  HEAP16[$$1362 >> 1] = 0;\n  $$1362 = $$1362 + ($5 << 1) | 0;\n  $$1364 = $$1364 + ($5 << 1) | 0;\n  $$1377 = $$1377 + 1 | 0;\n }\n $21 = $4 + 1179664 | 0;\n $27 = 0 - $5 | 0;\n $$0360 = $0 + (($1 << 1) + 2) | 0;\n $$0373 = 1;\n $$0381 = 0;\n $$2 = $7 + ($5 + 1 << 1) | 0;\n L9 : while (1) {\n  if (($$0373 | 0) >= ($8 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0360;\n  $$1382 = $$0381;\n  $$2378 = 1;\n  $$3 = $$2;\n  while (1) {\n   if (($$2378 | 0) >= ($15 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0 | 0) > ($3 | 0)) {\n    $33 = $$3 + ($27 << 1) | 0;\n    $34 = HEAP16[$33 >> 1] | 0;\n    if ($34 << 16 >> 16 > 0) {\n     HEAP16[$$3 >> 1] = $34;\n     $37 = ($34 << 16 >> 16) * 7 | 0;\n     $39 = $4 + 1310736 + ($37 + -7 << 2) | 0;\n     HEAP32[$39 >> 2] = (HEAP32[$39 >> 2] | 0) + 1;\n     $43 = $4 + 1310736 + ($37 + -6 << 2) | 0;\n     HEAP32[$43 >> 2] = (HEAP32[$43 >> 2] | 0) + $$2378;\n     $47 = $4 + 1310736 + ($37 + -5 << 2) | 0;\n     HEAP32[$47 >> 2] = (HEAP32[$47 >> 2] | 0) + $$0373;\n     HEAP32[$4 + 1310736 + ($37 + -1 << 2) >> 2] = $$0373;\n     $$2383 = $$1382;\n     break;\n    }\n    $53 = HEAP16[$33 + 2 >> 1] | 0;\n    $54 = $53 << 16 >> 16;\n    $57 = HEAP16[$33 + -2 >> 1] | 0;\n    $58 = $57 << 16 >> 16;\n    $59 = $57 << 16 >> 16 > 0;\n    if ($53 << 16 >> 16 <= 0) {\n     if ($59) {\n      HEAP16[$$3 >> 1] = $57;\n      $155 = $58 * 7 | 0;\n      $157 = $4 + 1310736 + ($155 + -7 << 2) | 0;\n      HEAP32[$157 >> 2] = (HEAP32[$157 >> 2] | 0) + 1;\n      $161 = $4 + 1310736 + ($155 + -6 << 2) | 0;\n      HEAP32[$161 >> 2] = (HEAP32[$161 >> 2] | 0) + $$2378;\n      $165 = $4 + 1310736 + ($155 + -5 << 2) | 0;\n      HEAP32[$165 >> 2] = (HEAP32[$165 >> 2] | 0) + $$0373;\n      $169 = $4 + 1310736 + ($155 + -3 << 2) | 0;\n      if ((HEAP32[$169 >> 2] | 0) < ($$2378 | 0)) HEAP32[$169 >> 2] = $$2378;\n      HEAP32[$4 + 1310736 + ($155 + -1 << 2) >> 2] = $$0373;\n      $$2383 = $$1382;\n      break;\n     }\n     $175 = HEAP16[$$3 + -2 >> 1] | 0;\n     if ($175 << 16 >> 16 > 0) {\n      HEAP16[$$3 >> 1] = $175;\n      $178 = ($175 << 16 >> 16) * 7 | 0;\n      $180 = $4 + 1310736 + ($178 + -7 << 2) | 0;\n      HEAP32[$180 >> 2] = (HEAP32[$180 >> 2] | 0) + 1;\n      $184 = $4 + 1310736 + ($178 + -6 << 2) | 0;\n      HEAP32[$184 >> 2] = (HEAP32[$184 >> 2] | 0) + $$2378;\n      $188 = $4 + 1310736 + ($178 + -5 << 2) | 0;\n      HEAP32[$188 >> 2] = (HEAP32[$188 >> 2] | 0) + $$0373;\n      $192 = $4 + 1310736 + ($178 + -3 << 2) | 0;\n      if ((HEAP32[$192 >> 2] | 0) >= ($$2378 | 0)) {\n       $$2383 = $$1382;\n       break;\n      }\n      HEAP32[$192 >> 2] = $$2378;\n      $$2383 = $$1382;\n      break;\n     } else {\n      $195 = $$1382 + 1 | 0;\n      if (($$1382 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3 >> 1] = $195;\n      HEAP32[$4 + 1179664 + ($$1382 << 2) >> 2] = $195 << 16 >> 16;\n      $200 = $$1382 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($200 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($200 + 1 << 2) >> 2] = $$2378;\n      HEAP32[$4 + 1310736 + ($200 + 2 << 2) >> 2] = $$0373;\n      HEAP32[$4 + 1310736 + ($200 + 3 << 2) >> 2] = $$2378;\n      HEAP32[$4 + 1310736 + ($200 + 4 << 2) >> 2] = $$2378;\n      HEAP32[$4 + 1310736 + ($200 + 5 << 2) >> 2] = $$0373;\n      HEAP32[$4 + 1310736 + ($200 + 6 << 2) >> 2] = $$0373;\n      $$2383 = $195;\n      break;\n     }\n    }\n    if ($59) {\n     $62 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n     $65 = HEAP32[$4 + 1179664 + ($58 + -1 << 2) >> 2] | 0;\n     L36 : do if (($62 | 0) > ($65 | 0)) {\n      HEAP16[$$3 >> 1] = $65;\n      $$0365 = $21;\n      $$0369 = 0;\n      while (1) {\n       if (($$0369 | 0) >= ($$1382 | 0)) {\n        $80 = $65;\n        break L36;\n       }\n       if ((HEAP32[$$0365 >> 2] | 0) == ($62 | 0)) HEAP32[$$0365 >> 2] = $65;\n       $$0365 = $$0365 + 4 | 0;\n       $$0369 = $$0369 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3 >> 1] = $62;\n      if (($62 | 0) < ($65 | 0)) {\n       $$1366 = $21;\n       $$1370 = 0;\n       while (1) {\n        if (($$1370 | 0) >= ($$1382 | 0)) {\n         $80 = $62;\n         break L36;\n        }\n        if ((HEAP32[$$1366 >> 2] | 0) == ($65 | 0)) HEAP32[$$1366 >> 2] = $62;\n        $$1366 = $$1366 + 4 | 0;\n        $$1370 = $$1370 + 1 | 0;\n       }\n      } else $80 = $62;\n     } while (0);\n     $82 = ($80 << 16 >> 16) * 7 | 0;\n     $84 = $4 + 1310736 + ($82 + -7 << 2) | 0;\n     HEAP32[$84 >> 2] = (HEAP32[$84 >> 2] | 0) + 1;\n     $88 = $4 + 1310736 + ($82 + -6 << 2) | 0;\n     HEAP32[$88 >> 2] = (HEAP32[$88 >> 2] | 0) + $$2378;\n     $92 = $4 + 1310736 + ($82 + -5 << 2) | 0;\n     HEAP32[$92 >> 2] = (HEAP32[$92 >> 2] | 0) + $$0373;\n     HEAP32[$4 + 1310736 + ($82 + -1 << 2) >> 2] = $$0373;\n     $$2383 = $$1382;\n     break;\n    }\n    $98 = HEAP16[$$3 + -2 >> 1] | 0;\n    if ($98 << 16 >> 16 <= 0) {\n     HEAP16[$$3 >> 1] = $53;\n     $136 = $54 * 7 | 0;\n     $138 = $4 + 1310736 + ($136 + -7 << 2) | 0;\n     HEAP32[$138 >> 2] = (HEAP32[$138 >> 2] | 0) + 1;\n     $142 = $4 + 1310736 + ($136 + -6 << 2) | 0;\n     HEAP32[$142 >> 2] = (HEAP32[$142 >> 2] | 0) + $$2378;\n     $146 = $4 + 1310736 + ($136 + -5 << 2) | 0;\n     HEAP32[$146 >> 2] = (HEAP32[$146 >> 2] | 0) + $$0373;\n     $150 = $4 + 1310736 + ($136 + -4 << 2) | 0;\n     if ((HEAP32[$150 >> 2] | 0) > ($$2378 | 0)) HEAP32[$150 >> 2] = $$2378;\n     HEAP32[$4 + 1310736 + ($136 + -1 << 2) >> 2] = $$0373;\n     $$2383 = $$1382;\n     break;\n    }\n    $103 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n    $106 = HEAP32[$4 + 1179664 + (($98 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L60 : do if (($103 | 0) > ($106 | 0)) {\n     HEAP16[$$3 >> 1] = $106;\n     $$2367 = $21;\n     $$2371 = 0;\n     while (1) {\n      if (($$2371 | 0) >= ($$1382 | 0)) {\n       $121 = $106;\n       break L60;\n      }\n      if ((HEAP32[$$2367 >> 2] | 0) == ($103 | 0)) HEAP32[$$2367 >> 2] = $106;\n      $$2367 = $$2367 + 4 | 0;\n      $$2371 = $$2371 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3 >> 1] = $103;\n     if (($103 | 0) < ($106 | 0)) {\n      $$3368 = $21;\n      $$3372 = 0;\n      while (1) {\n       if (($$3372 | 0) >= ($$1382 | 0)) {\n        $121 = $103;\n        break L60;\n       }\n       if ((HEAP32[$$3368 >> 2] | 0) == ($106 | 0)) HEAP32[$$3368 >> 2] = $103;\n       $$3368 = $$3368 + 4 | 0;\n       $$3372 = $$3372 + 1 | 0;\n      }\n     } else $121 = $103;\n    } while (0);\n    $123 = ($121 << 16 >> 16) * 7 | 0;\n    $125 = $4 + 1310736 + ($123 + -7 << 2) | 0;\n    HEAP32[$125 >> 2] = (HEAP32[$125 >> 2] | 0) + 1;\n    $129 = $4 + 1310736 + ($123 + -6 << 2) | 0;\n    HEAP32[$129 >> 2] = (HEAP32[$129 >> 2] | 0) + $$2378;\n    $133 = $4 + 1310736 + ($123 + -5 << 2) | 0;\n    HEAP32[$133 >> 2] = (HEAP32[$133 >> 2] | 0) + $$0373;\n    $$2383 = $$1382;\n   } else {\n    HEAP16[$$3 >> 1] = 0;\n    $$2383 = $$1382;\n   } while (0);\n   $$1 = $$1 + 2 | 0;\n   $$1382 = $$2383;\n   $$2378 = $$2378 + 1 | 0;\n   $$3 = $$3 + 2 | 0;\n  }\n  $$0360 = $$1 + $1 + 4 | 0;\n  $$0373 = $$0373 + 1 | 0;\n  $$0381 = $$1382;\n  $$2 = $$3 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $221 = $4 + 12 | 0;\n  $$1374 = 1;\n  $$3379 = 1;\n  $$4 = $21;\n  while (1) {\n   if (($$3379 | 0) > ($$0381 | 0)) break;\n   $223 = HEAP32[$$4 >> 2] | 0;\n   if (($223 | 0) == ($$3379 | 0)) {\n    $$2375 = $$1374 + 1 | 0;\n    $229 = $$1374;\n   } else {\n    $$2375 = $$1374;\n    $229 = HEAP32[$4 + 1179664 + ($223 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $229;\n   $$1374 = $$2375;\n   $$3379 = $$3379 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $232 = $4 + 8 | 0;\n  $233 = $$1374 + -1 | 0;\n  HEAP32[$232 >> 2] = $233;\n  if (!$233) $$0 = 0; else {\n   _memset($221 | 0, 0, $233 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $233 << 4 | 0) | 0;\n   $$4380 = 0;\n   while (1) {\n    if (($$4380 | 0) >= ($233 | 0)) break;\n    $239 = $$4380 << 2;\n    HEAP32[$4 + 131084 + ($239 << 2) >> 2] = $5;\n    HEAP32[$4 + 131084 + (($239 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($239 | 2) << 2) >> 2] = $6;\n    HEAP32[$4 + 131084 + (($239 | 3) << 2) >> 2] = 0;\n    $$4380 = $$4380 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0381 | 0)) break;\n    $251 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $252 = $$5 * 7 | 0;\n    $255 = $4 + 12 + ($251 << 2) | 0;\n    HEAP32[$255 >> 2] = (HEAP32[$255 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($252 << 2) >> 2] | 0);\n    $262 = $251 << 1;\n    $263 = $4 + 655376 + ($262 << 3) | 0;\n    HEAPF64[$263 >> 3] = +HEAPF64[$263 >> 3] + +(HEAP32[$4 + 1310736 + ($252 + 1 << 2) >> 2] | 0);\n    $271 = $4 + 655376 + (($262 | 1) << 3) | 0;\n    HEAPF64[$271 >> 3] = +HEAPF64[$271 >> 3] + +(HEAP32[$4 + 1310736 + ($252 + 2 << 2) >> 2] | 0);\n    $274 = $251 << 2;\n    $275 = $4 + 131084 + ($274 << 2) | 0;\n    $279 = HEAP32[$4 + 1310736 + ($252 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$275 >> 2] | 0) > ($279 | 0)) HEAP32[$275 >> 2] = $279;\n    $282 = $4 + 131084 + (($274 | 1) << 2) | 0;\n    $286 = HEAP32[$4 + 1310736 + ($252 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$282 >> 2] | 0) < ($286 | 0)) HEAP32[$282 >> 2] = $286;\n    $289 = $4 + 131084 + (($274 | 2) << 2) | 0;\n    $293 = HEAP32[$4 + 1310736 + ($252 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$289 >> 2] | 0) > ($293 | 0)) HEAP32[$289 >> 2] = $293;\n    $296 = $4 + 131084 + (($274 | 3) << 2) | 0;\n    $300 = HEAP32[$4 + 1310736 + ($252 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$296 >> 2] | 0) < ($300 | 0)) HEAP32[$296 >> 2] = $300;\n    $$5 = $$5 + 1 | 0;\n   }\n   $303 = HEAP32[$232 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($303 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $307 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $308 = $$6 << 1;\n    $309 = $4 + 655376 + ($308 << 3) | 0;\n    HEAPF64[$309 >> 3] = +HEAPF64[$309 >> 3] / $307;\n    $313 = $4 + 655376 + (($308 | 1) << 3) | 0;\n    HEAPF64[$313 >> 3] = +HEAPF64[$313 >> 3] / $307;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubDBIC($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0360 = 0, $$0361 = 0, $$0363 = 0, $$0365 = 0, $$0369 = 0, $$0373 = 0, $$0376 = 0, $$0381 = 0, $$1 = 0, $$1362 = 0, $$1364 = 0, $$1366 = 0, $$1370 = 0, $$1374 = 0, $$1377 = 0, $$1382 = 0, $$2 = 0, $$2367 = 0, $$2371 = 0, $$2375 = 0, $$2378 = 0, $$2383 = 0, $$3 = 0, $$3368 = 0, $$3372 = 0, $$3379 = 0, $$4 = 0, $$4380 = 0, $$5 = 0, $$6 = 0, $103 = 0, $106 = 0, $121 = 0, $123 = 0, $125 = 0, $129 = 0, $133 = 0, $136 = 0, $138 = 0, $142 = 0, $146 = 0, $15 = 0, $150 = 0, $155 = 0, $157 = 0, $161 = 0, $165 = 0, $169 = 0, $175 = 0, $178 = 0, $180 = 0, $184 = 0, $188 = 0, $192 = 0, $195 = 0, $200 = 0, $21 = 0, $221 = 0, $223 = 0, $229 = 0, $232 = 0, $233 = 0, $239 = 0, $251 = 0, $252 = 0, $255 = 0, $262 = 0, $263 = 0, $27 = 0, $271 = 0, $274 = 0, $275 = 0, $279 = 0, $282 = 0, $286 = 0, $289 = 0, $293 = 0, $296 = 0, $300 = 0, $303 = 0, $307 = 0.0, $308 = 0, $309 = 0, $313 = 0, $33 = 0, $34 = 0, $37 = 0, $39 = 0, $43 = 0, $47 = 0, $5 = 0, $53 = 0, $54 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $62 = 0, $65 = 0, $7 = 0, $8 = 0, $80 = 0, $82 = 0, $84 = 0, $88 = 0, $92 = 0, $98 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = ($1 | 0) / 2 | 0;\n $6 = ($2 | 0) / 2 | 0;\n $7 = HEAP32[$4 >> 2] | 0;\n $8 = $6 + -1 | 0;\n $$0361 = $7;\n $$0363 = $7 + ((Math_imul($8, $5) | 0) << 1) | 0;\n $$0376 = 0;\n while (1) {\n  if (($$0376 | 0) >= ($5 | 0)) break;\n  HEAP16[$$0363 >> 1] = 0;\n  HEAP16[$$0361 >> 1] = 0;\n  $$0361 = $$0361 + 2 | 0;\n  $$0363 = $$0363 + 2 | 0;\n  $$0376 = $$0376 + 1 | 0;\n }\n $15 = $5 + -1 | 0;\n $$1362 = $7;\n $$1364 = $7 + ($15 << 1) | 0;\n $$1377 = 0;\n while (1) {\n  if (($$1377 | 0) >= ($6 | 0)) break;\n  HEAP16[$$1364 >> 1] = 0;\n  HEAP16[$$1362 >> 1] = 0;\n  $$1362 = $$1362 + ($5 << 1) | 0;\n  $$1364 = $$1364 + ($5 << 1) | 0;\n  $$1377 = $$1377 + 1 | 0;\n }\n $21 = $4 + 1179664 | 0;\n $27 = 0 - $5 | 0;\n $$0360 = $0 + (($1 << 1) + 2) | 0;\n $$0373 = 1;\n $$0381 = 0;\n $$2 = $7 + ($5 + 1 << 1) | 0;\n L9 : while (1) {\n  if (($$0373 | 0) >= ($8 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0360;\n  $$1382 = $$0381;\n  $$2378 = 1;\n  $$3 = $$2;\n  while (1) {\n   if (($$2378 | 0) >= ($15 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0 | 0) > ($3 | 0)) {\n    HEAP16[$$3 >> 1] = 0;\n    $$2383 = $$1382;\n   } else {\n    $33 = $$3 + ($27 << 1) | 0;\n    $34 = HEAP16[$33 >> 1] | 0;\n    if ($34 << 16 >> 16 > 0) {\n     HEAP16[$$3 >> 1] = $34;\n     $37 = ($34 << 16 >> 16) * 7 | 0;\n     $39 = $4 + 1310736 + ($37 + -7 << 2) | 0;\n     HEAP32[$39 >> 2] = (HEAP32[$39 >> 2] | 0) + 1;\n     $43 = $4 + 1310736 + ($37 + -6 << 2) | 0;\n     HEAP32[$43 >> 2] = (HEAP32[$43 >> 2] | 0) + $$2378;\n     $47 = $4 + 1310736 + ($37 + -5 << 2) | 0;\n     HEAP32[$47 >> 2] = (HEAP32[$47 >> 2] | 0) + $$0373;\n     HEAP32[$4 + 1310736 + ($37 + -1 << 2) >> 2] = $$0373;\n     $$2383 = $$1382;\n     break;\n    }\n    $53 = HEAP16[$33 + 2 >> 1] | 0;\n    $54 = $53 << 16 >> 16;\n    $57 = HEAP16[$33 + -2 >> 1] | 0;\n    $58 = $57 << 16 >> 16;\n    $59 = $57 << 16 >> 16 > 0;\n    if ($53 << 16 >> 16 <= 0) {\n     if ($59) {\n      HEAP16[$$3 >> 1] = $57;\n      $155 = $58 * 7 | 0;\n      $157 = $4 + 1310736 + ($155 + -7 << 2) | 0;\n      HEAP32[$157 >> 2] = (HEAP32[$157 >> 2] | 0) + 1;\n      $161 = $4 + 1310736 + ($155 + -6 << 2) | 0;\n      HEAP32[$161 >> 2] = (HEAP32[$161 >> 2] | 0) + $$2378;\n      $165 = $4 + 1310736 + ($155 + -5 << 2) | 0;\n      HEAP32[$165 >> 2] = (HEAP32[$165 >> 2] | 0) + $$0373;\n      $169 = $4 + 1310736 + ($155 + -3 << 2) | 0;\n      if ((HEAP32[$169 >> 2] | 0) < ($$2378 | 0)) HEAP32[$169 >> 2] = $$2378;\n      HEAP32[$4 + 1310736 + ($155 + -1 << 2) >> 2] = $$0373;\n      $$2383 = $$1382;\n      break;\n     }\n     $175 = HEAP16[$$3 + -2 >> 1] | 0;\n     if ($175 << 16 >> 16 > 0) {\n      HEAP16[$$3 >> 1] = $175;\n      $178 = ($175 << 16 >> 16) * 7 | 0;\n      $180 = $4 + 1310736 + ($178 + -7 << 2) | 0;\n      HEAP32[$180 >> 2] = (HEAP32[$180 >> 2] | 0) + 1;\n      $184 = $4 + 1310736 + ($178 + -6 << 2) | 0;\n      HEAP32[$184 >> 2] = (HEAP32[$184 >> 2] | 0) + $$2378;\n      $188 = $4 + 1310736 + ($178 + -5 << 2) | 0;\n      HEAP32[$188 >> 2] = (HEAP32[$188 >> 2] | 0) + $$0373;\n      $192 = $4 + 1310736 + ($178 + -3 << 2) | 0;\n      if ((HEAP32[$192 >> 2] | 0) >= ($$2378 | 0)) {\n       $$2383 = $$1382;\n       break;\n      }\n      HEAP32[$192 >> 2] = $$2378;\n      $$2383 = $$1382;\n      break;\n     } else {\n      $195 = $$1382 + 1 | 0;\n      if (($$1382 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3 >> 1] = $195;\n      HEAP32[$4 + 1179664 + ($$1382 << 2) >> 2] = $195 << 16 >> 16;\n      $200 = $$1382 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($200 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($200 + 1 << 2) >> 2] = $$2378;\n      HEAP32[$4 + 1310736 + ($200 + 2 << 2) >> 2] = $$0373;\n      HEAP32[$4 + 1310736 + ($200 + 3 << 2) >> 2] = $$2378;\n      HEAP32[$4 + 1310736 + ($200 + 4 << 2) >> 2] = $$2378;\n      HEAP32[$4 + 1310736 + ($200 + 5 << 2) >> 2] = $$0373;\n      HEAP32[$4 + 1310736 + ($200 + 6 << 2) >> 2] = $$0373;\n      $$2383 = $195;\n      break;\n     }\n    }\n    if ($59) {\n     $62 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n     $65 = HEAP32[$4 + 1179664 + ($58 + -1 << 2) >> 2] | 0;\n     L37 : do if (($62 | 0) > ($65 | 0)) {\n      HEAP16[$$3 >> 1] = $65;\n      $$0365 = $21;\n      $$0369 = 0;\n      while (1) {\n       if (($$0369 | 0) >= ($$1382 | 0)) {\n        $80 = $65;\n        break L37;\n       }\n       if ((HEAP32[$$0365 >> 2] | 0) == ($62 | 0)) HEAP32[$$0365 >> 2] = $65;\n       $$0365 = $$0365 + 4 | 0;\n       $$0369 = $$0369 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3 >> 1] = $62;\n      if (($62 | 0) < ($65 | 0)) {\n       $$1366 = $21;\n       $$1370 = 0;\n       while (1) {\n        if (($$1370 | 0) >= ($$1382 | 0)) {\n         $80 = $62;\n         break L37;\n        }\n        if ((HEAP32[$$1366 >> 2] | 0) == ($65 | 0)) HEAP32[$$1366 >> 2] = $62;\n        $$1366 = $$1366 + 4 | 0;\n        $$1370 = $$1370 + 1 | 0;\n       }\n      } else $80 = $62;\n     } while (0);\n     $82 = ($80 << 16 >> 16) * 7 | 0;\n     $84 = $4 + 1310736 + ($82 + -7 << 2) | 0;\n     HEAP32[$84 >> 2] = (HEAP32[$84 >> 2] | 0) + 1;\n     $88 = $4 + 1310736 + ($82 + -6 << 2) | 0;\n     HEAP32[$88 >> 2] = (HEAP32[$88 >> 2] | 0) + $$2378;\n     $92 = $4 + 1310736 + ($82 + -5 << 2) | 0;\n     HEAP32[$92 >> 2] = (HEAP32[$92 >> 2] | 0) + $$0373;\n     HEAP32[$4 + 1310736 + ($82 + -1 << 2) >> 2] = $$0373;\n     $$2383 = $$1382;\n     break;\n    }\n    $98 = HEAP16[$$3 + -2 >> 1] | 0;\n    if ($98 << 16 >> 16 <= 0) {\n     HEAP16[$$3 >> 1] = $53;\n     $136 = $54 * 7 | 0;\n     $138 = $4 + 1310736 + ($136 + -7 << 2) | 0;\n     HEAP32[$138 >> 2] = (HEAP32[$138 >> 2] | 0) + 1;\n     $142 = $4 + 1310736 + ($136 + -6 << 2) | 0;\n     HEAP32[$142 >> 2] = (HEAP32[$142 >> 2] | 0) + $$2378;\n     $146 = $4 + 1310736 + ($136 + -5 << 2) | 0;\n     HEAP32[$146 >> 2] = (HEAP32[$146 >> 2] | 0) + $$0373;\n     $150 = $4 + 1310736 + ($136 + -4 << 2) | 0;\n     if ((HEAP32[$150 >> 2] | 0) > ($$2378 | 0)) HEAP32[$150 >> 2] = $$2378;\n     HEAP32[$4 + 1310736 + ($136 + -1 << 2) >> 2] = $$0373;\n     $$2383 = $$1382;\n     break;\n    }\n    $103 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n    $106 = HEAP32[$4 + 1179664 + (($98 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L61 : do if (($103 | 0) > ($106 | 0)) {\n     HEAP16[$$3 >> 1] = $106;\n     $$2367 = $21;\n     $$2371 = 0;\n     while (1) {\n      if (($$2371 | 0) >= ($$1382 | 0)) {\n       $121 = $106;\n       break L61;\n      }\n      if ((HEAP32[$$2367 >> 2] | 0) == ($103 | 0)) HEAP32[$$2367 >> 2] = $106;\n      $$2367 = $$2367 + 4 | 0;\n      $$2371 = $$2371 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3 >> 1] = $103;\n     if (($103 | 0) < ($106 | 0)) {\n      $$3368 = $21;\n      $$3372 = 0;\n      while (1) {\n       if (($$3372 | 0) >= ($$1382 | 0)) {\n        $121 = $103;\n        break L61;\n       }\n       if ((HEAP32[$$3368 >> 2] | 0) == ($106 | 0)) HEAP32[$$3368 >> 2] = $103;\n       $$3368 = $$3368 + 4 | 0;\n       $$3372 = $$3372 + 1 | 0;\n      }\n     } else $121 = $103;\n    } while (0);\n    $123 = ($121 << 16 >> 16) * 7 | 0;\n    $125 = $4 + 1310736 + ($123 + -7 << 2) | 0;\n    HEAP32[$125 >> 2] = (HEAP32[$125 >> 2] | 0) + 1;\n    $129 = $4 + 1310736 + ($123 + -6 << 2) | 0;\n    HEAP32[$129 >> 2] = (HEAP32[$129 >> 2] | 0) + $$2378;\n    $133 = $4 + 1310736 + ($123 + -5 << 2) | 0;\n    HEAP32[$133 >> 2] = (HEAP32[$133 >> 2] | 0) + $$0373;\n    $$2383 = $$1382;\n   } while (0);\n   $$1 = $$1 + 2 | 0;\n   $$1382 = $$2383;\n   $$2378 = $$2378 + 1 | 0;\n   $$3 = $$3 + 2 | 0;\n  }\n  $$0360 = $$1 + $1 + 4 | 0;\n  $$0373 = $$0373 + 1 | 0;\n  $$0381 = $$1382;\n  $$2 = $$3 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $221 = $4 + 12 | 0;\n  $$1374 = 1;\n  $$3379 = 1;\n  $$4 = $21;\n  while (1) {\n   if (($$3379 | 0) > ($$0381 | 0)) break;\n   $223 = HEAP32[$$4 >> 2] | 0;\n   if (($223 | 0) == ($$3379 | 0)) {\n    $$2375 = $$1374 + 1 | 0;\n    $229 = $$1374;\n   } else {\n    $$2375 = $$1374;\n    $229 = HEAP32[$4 + 1179664 + ($223 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $229;\n   $$1374 = $$2375;\n   $$3379 = $$3379 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $232 = $4 + 8 | 0;\n  $233 = $$1374 + -1 | 0;\n  HEAP32[$232 >> 2] = $233;\n  if (!$233) $$0 = 0; else {\n   _memset($221 | 0, 0, $233 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $233 << 4 | 0) | 0;\n   $$4380 = 0;\n   while (1) {\n    if (($$4380 | 0) >= ($233 | 0)) break;\n    $239 = $$4380 << 2;\n    HEAP32[$4 + 131084 + ($239 << 2) >> 2] = $5;\n    HEAP32[$4 + 131084 + (($239 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($239 | 2) << 2) >> 2] = $6;\n    HEAP32[$4 + 131084 + (($239 | 3) << 2) >> 2] = 0;\n    $$4380 = $$4380 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0381 | 0)) break;\n    $251 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $252 = $$5 * 7 | 0;\n    $255 = $4 + 12 + ($251 << 2) | 0;\n    HEAP32[$255 >> 2] = (HEAP32[$255 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($252 << 2) >> 2] | 0);\n    $262 = $251 << 1;\n    $263 = $4 + 655376 + ($262 << 3) | 0;\n    HEAPF64[$263 >> 3] = +HEAPF64[$263 >> 3] + +(HEAP32[$4 + 1310736 + ($252 + 1 << 2) >> 2] | 0);\n    $271 = $4 + 655376 + (($262 | 1) << 3) | 0;\n    HEAPF64[$271 >> 3] = +HEAPF64[$271 >> 3] + +(HEAP32[$4 + 1310736 + ($252 + 2 << 2) >> 2] | 0);\n    $274 = $251 << 2;\n    $275 = $4 + 131084 + ($274 << 2) | 0;\n    $279 = HEAP32[$4 + 1310736 + ($252 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$275 >> 2] | 0) > ($279 | 0)) HEAP32[$275 >> 2] = $279;\n    $282 = $4 + 131084 + (($274 | 1) << 2) | 0;\n    $286 = HEAP32[$4 + 1310736 + ($252 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$282 >> 2] | 0) < ($286 | 0)) HEAP32[$282 >> 2] = $286;\n    $289 = $4 + 131084 + (($274 | 2) << 2) | 0;\n    $293 = HEAP32[$4 + 1310736 + ($252 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$289 >> 2] | 0) > ($293 | 0)) HEAP32[$289 >> 2] = $293;\n    $296 = $4 + 131084 + (($274 | 3) << 2) | 0;\n    $300 = HEAP32[$4 + 1310736 + ($252 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$296 >> 2] | 0) < ($300 | 0)) HEAP32[$296 >> 2] = $300;\n    $$5 = $$5 + 1 | 0;\n   }\n   $303 = HEAP32[$232 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($303 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $307 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $308 = $$6 << 1;\n    $309 = $4 + 655376 + ($308 << 3) | 0;\n    HEAPF64[$309 >> 3] = +HEAPF64[$309 >> 3] / $307;\n    $313 = $4 + 655376 + (($308 | 1) << 3) | 0;\n    HEAPF64[$313 >> 3] = +HEAPF64[$313 >> 3] / $307;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubDWRC($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0358 = 0, $$0359 = 0, $$0361 = 0, $$0363 = 0, $$0367 = 0, $$0371 = 0, $$0374 = 0, $$0379 = 0, $$1 = 0, $$1360 = 0, $$1362 = 0, $$1364 = 0, $$1368 = 0, $$1372 = 0, $$1375 = 0, $$1380 = 0, $$2 = 0, $$2365 = 0, $$2369 = 0, $$2373 = 0, $$2376 = 0, $$2381 = 0, $$3 = 0, $$3366 = 0, $$3370 = 0, $$3377 = 0, $$4 = 0, $$4378 = 0, $$5 = 0, $$6 = 0, $102 = 0, $117 = 0, $119 = 0, $121 = 0, $125 = 0, $129 = 0, $13 = 0, $132 = 0, $134 = 0, $138 = 0, $142 = 0, $146 = 0, $151 = 0, $153 = 0, $157 = 0, $161 = 0, $165 = 0, $171 = 0, $174 = 0, $176 = 0, $180 = 0, $184 = 0, $188 = 0, $19 = 0, $191 = 0, $196 = 0, $20 = 0, $216 = 0, $218 = 0, $224 = 0, $227 = 0, $228 = 0, $23 = 0, $234 = 0, $246 = 0, $247 = 0, $250 = 0, $257 = 0, $258 = 0, $266 = 0, $269 = 0, $270 = 0, $274 = 0, $277 = 0, $281 = 0, $284 = 0, $288 = 0, $29 = 0, $291 = 0, $295 = 0, $298 = 0, $30 = 0, $302 = 0.0, $303 = 0, $304 = 0, $308 = 0, $33 = 0, $35 = 0, $39 = 0, $43 = 0, $49 = 0, $5 = 0, $50 = 0, $53 = 0, $54 = 0, $55 = 0, $58 = 0, $6 = 0, $61 = 0, $76 = 0, $78 = 0, $80 = 0, $84 = 0, $88 = 0, $94 = 0, $99 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = HEAP32[$4 >> 2] | 0;\n $6 = $2 + -1 | 0;\n $$0359 = $5;\n $$0361 = $5 + ((Math_imul($6, $1) | 0) << 1) | 0;\n $$0374 = 0;\n while (1) {\n  if (($$0374 | 0) >= ($1 | 0)) break;\n  HEAP16[$$0361 >> 1] = 0;\n  HEAP16[$$0359 >> 1] = 0;\n  $$0359 = $$0359 + 2 | 0;\n  $$0361 = $$0361 + 2 | 0;\n  $$0374 = $$0374 + 1 | 0;\n }\n $13 = $1 + -1 | 0;\n $$1360 = $5;\n $$1362 = $5 + ($13 << 1) | 0;\n $$1375 = 0;\n while (1) {\n  if (($$1375 | 0) >= ($2 | 0)) break;\n  HEAP16[$$1362 >> 1] = 0;\n  HEAP16[$$1360 >> 1] = 0;\n  $$1360 = $$1360 + ($1 << 1) | 0;\n  $$1362 = $$1362 + ($1 << 1) | 0;\n  $$1375 = $$1375 + 1 | 0;\n }\n $19 = $4 + 1179664 | 0;\n $20 = $1 + 1 | 0;\n $23 = 0 - $1 | 0;\n $$0358 = $0 + $20 | 0;\n $$0371 = 1;\n $$0379 = 0;\n $$2 = $5 + ($20 << 1) | 0;\n L9 : while (1) {\n  if (($$0371 | 0) >= ($6 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0358;\n  $$1380 = $$0379;\n  $$2376 = 1;\n  $$3 = $$2;\n  while (1) {\n   if (($$2376 | 0) >= ($13 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0 | 0) > ($3 | 0)) {\n    $29 = $$3 + ($23 << 1) | 0;\n    $30 = HEAP16[$29 >> 1] | 0;\n    if ($30 << 16 >> 16 > 0) {\n     HEAP16[$$3 >> 1] = $30;\n     $33 = ($30 << 16 >> 16) * 7 | 0;\n     $35 = $4 + 1310736 + ($33 + -7 << 2) | 0;\n     HEAP32[$35 >> 2] = (HEAP32[$35 >> 2] | 0) + 1;\n     $39 = $4 + 1310736 + ($33 + -6 << 2) | 0;\n     HEAP32[$39 >> 2] = (HEAP32[$39 >> 2] | 0) + $$2376;\n     $43 = $4 + 1310736 + ($33 + -5 << 2) | 0;\n     HEAP32[$43 >> 2] = (HEAP32[$43 >> 2] | 0) + $$0371;\n     HEAP32[$4 + 1310736 + ($33 + -1 << 2) >> 2] = $$0371;\n     $$2381 = $$1380;\n     break;\n    }\n    $49 = HEAP16[$29 + 2 >> 1] | 0;\n    $50 = $49 << 16 >> 16;\n    $53 = HEAP16[$29 + -2 >> 1] | 0;\n    $54 = $53 << 16 >> 16;\n    $55 = $53 << 16 >> 16 > 0;\n    if ($49 << 16 >> 16 <= 0) {\n     if ($55) {\n      HEAP16[$$3 >> 1] = $53;\n      $151 = $54 * 7 | 0;\n      $153 = $4 + 1310736 + ($151 + -7 << 2) | 0;\n      HEAP32[$153 >> 2] = (HEAP32[$153 >> 2] | 0) + 1;\n      $157 = $4 + 1310736 + ($151 + -6 << 2) | 0;\n      HEAP32[$157 >> 2] = (HEAP32[$157 >> 2] | 0) + $$2376;\n      $161 = $4 + 1310736 + ($151 + -5 << 2) | 0;\n      HEAP32[$161 >> 2] = (HEAP32[$161 >> 2] | 0) + $$0371;\n      $165 = $4 + 1310736 + ($151 + -3 << 2) | 0;\n      if ((HEAP32[$165 >> 2] | 0) < ($$2376 | 0)) HEAP32[$165 >> 2] = $$2376;\n      HEAP32[$4 + 1310736 + ($151 + -1 << 2) >> 2] = $$0371;\n      $$2381 = $$1380;\n      break;\n     }\n     $171 = HEAP16[$$3 + -2 >> 1] | 0;\n     if ($171 << 16 >> 16 > 0) {\n      HEAP16[$$3 >> 1] = $171;\n      $174 = ($171 << 16 >> 16) * 7 | 0;\n      $176 = $4 + 1310736 + ($174 + -7 << 2) | 0;\n      HEAP32[$176 >> 2] = (HEAP32[$176 >> 2] | 0) + 1;\n      $180 = $4 + 1310736 + ($174 + -6 << 2) | 0;\n      HEAP32[$180 >> 2] = (HEAP32[$180 >> 2] | 0) + $$2376;\n      $184 = $4 + 1310736 + ($174 + -5 << 2) | 0;\n      HEAP32[$184 >> 2] = (HEAP32[$184 >> 2] | 0) + $$0371;\n      $188 = $4 + 1310736 + ($174 + -3 << 2) | 0;\n      if ((HEAP32[$188 >> 2] | 0) >= ($$2376 | 0)) {\n       $$2381 = $$1380;\n       break;\n      }\n      HEAP32[$188 >> 2] = $$2376;\n      $$2381 = $$1380;\n      break;\n     } else {\n      $191 = $$1380 + 1 | 0;\n      if (($$1380 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3 >> 1] = $191;\n      HEAP32[$4 + 1179664 + ($$1380 << 2) >> 2] = $191 << 16 >> 16;\n      $196 = $$1380 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($196 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($196 + 1 << 2) >> 2] = $$2376;\n      HEAP32[$4 + 1310736 + ($196 + 2 << 2) >> 2] = $$0371;\n      HEAP32[$4 + 1310736 + ($196 + 3 << 2) >> 2] = $$2376;\n      HEAP32[$4 + 1310736 + ($196 + 4 << 2) >> 2] = $$2376;\n      HEAP32[$4 + 1310736 + ($196 + 5 << 2) >> 2] = $$0371;\n      HEAP32[$4 + 1310736 + ($196 + 6 << 2) >> 2] = $$0371;\n      $$2381 = $191;\n      break;\n     }\n    }\n    if ($55) {\n     $58 = HEAP32[$4 + 1179664 + ($50 + -1 << 2) >> 2] | 0;\n     $61 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n     L36 : do if (($58 | 0) > ($61 | 0)) {\n      HEAP16[$$3 >> 1] = $61;\n      $$0363 = $19;\n      $$0367 = 0;\n      while (1) {\n       if (($$0367 | 0) >= ($$1380 | 0)) {\n        $76 = $61;\n        break L36;\n       }\n       if ((HEAP32[$$0363 >> 2] | 0) == ($58 | 0)) HEAP32[$$0363 >> 2] = $61;\n       $$0363 = $$0363 + 4 | 0;\n       $$0367 = $$0367 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3 >> 1] = $58;\n      if (($58 | 0) < ($61 | 0)) {\n       $$1364 = $19;\n       $$1368 = 0;\n       while (1) {\n        if (($$1368 | 0) >= ($$1380 | 0)) {\n         $76 = $58;\n         break L36;\n        }\n        if ((HEAP32[$$1364 >> 2] | 0) == ($61 | 0)) HEAP32[$$1364 >> 2] = $58;\n        $$1364 = $$1364 + 4 | 0;\n        $$1368 = $$1368 + 1 | 0;\n       }\n      } else $76 = $58;\n     } while (0);\n     $78 = ($76 << 16 >> 16) * 7 | 0;\n     $80 = $4 + 1310736 + ($78 + -7 << 2) | 0;\n     HEAP32[$80 >> 2] = (HEAP32[$80 >> 2] | 0) + 1;\n     $84 = $4 + 1310736 + ($78 + -6 << 2) | 0;\n     HEAP32[$84 >> 2] = (HEAP32[$84 >> 2] | 0) + $$2376;\n     $88 = $4 + 1310736 + ($78 + -5 << 2) | 0;\n     HEAP32[$88 >> 2] = (HEAP32[$88 >> 2] | 0) + $$0371;\n     HEAP32[$4 + 1310736 + ($78 + -1 << 2) >> 2] = $$0371;\n     $$2381 = $$1380;\n     break;\n    }\n    $94 = HEAP16[$$3 + -2 >> 1] | 0;\n    if ($94 << 16 >> 16 <= 0) {\n     HEAP16[$$3 >> 1] = $49;\n     $132 = $50 * 7 | 0;\n     $134 = $4 + 1310736 + ($132 + -7 << 2) | 0;\n     HEAP32[$134 >> 2] = (HEAP32[$134 >> 2] | 0) + 1;\n     $138 = $4 + 1310736 + ($132 + -6 << 2) | 0;\n     HEAP32[$138 >> 2] = (HEAP32[$138 >> 2] | 0) + $$2376;\n     $142 = $4 + 1310736 + ($132 + -5 << 2) | 0;\n     HEAP32[$142 >> 2] = (HEAP32[$142 >> 2] | 0) + $$0371;\n     $146 = $4 + 1310736 + ($132 + -4 << 2) | 0;\n     if ((HEAP32[$146 >> 2] | 0) > ($$2376 | 0)) HEAP32[$146 >> 2] = $$2376;\n     HEAP32[$4 + 1310736 + ($132 + -1 << 2) >> 2] = $$0371;\n     $$2381 = $$1380;\n     break;\n    }\n    $99 = HEAP32[$4 + 1179664 + ($50 + -1 << 2) >> 2] | 0;\n    $102 = HEAP32[$4 + 1179664 + (($94 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L60 : do if (($99 | 0) > ($102 | 0)) {\n     HEAP16[$$3 >> 1] = $102;\n     $$2365 = $19;\n     $$2369 = 0;\n     while (1) {\n      if (($$2369 | 0) >= ($$1380 | 0)) {\n       $117 = $102;\n       break L60;\n      }\n      if ((HEAP32[$$2365 >> 2] | 0) == ($99 | 0)) HEAP32[$$2365 >> 2] = $102;\n      $$2365 = $$2365 + 4 | 0;\n      $$2369 = $$2369 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3 >> 1] = $99;\n     if (($99 | 0) < ($102 | 0)) {\n      $$3366 = $19;\n      $$3370 = 0;\n      while (1) {\n       if (($$3370 | 0) >= ($$1380 | 0)) {\n        $117 = $99;\n        break L60;\n       }\n       if ((HEAP32[$$3366 >> 2] | 0) == ($102 | 0)) HEAP32[$$3366 >> 2] = $99;\n       $$3366 = $$3366 + 4 | 0;\n       $$3370 = $$3370 + 1 | 0;\n      }\n     } else $117 = $99;\n    } while (0);\n    $119 = ($117 << 16 >> 16) * 7 | 0;\n    $121 = $4 + 1310736 + ($119 + -7 << 2) | 0;\n    HEAP32[$121 >> 2] = (HEAP32[$121 >> 2] | 0) + 1;\n    $125 = $4 + 1310736 + ($119 + -6 << 2) | 0;\n    HEAP32[$125 >> 2] = (HEAP32[$125 >> 2] | 0) + $$2376;\n    $129 = $4 + 1310736 + ($119 + -5 << 2) | 0;\n    HEAP32[$129 >> 2] = (HEAP32[$129 >> 2] | 0) + $$0371;\n    $$2381 = $$1380;\n   } else {\n    HEAP16[$$3 >> 1] = 0;\n    $$2381 = $$1380;\n   } while (0);\n   $$1 = $$1 + 1 | 0;\n   $$1380 = $$2381;\n   $$2376 = $$2376 + 1 | 0;\n   $$3 = $$3 + 2 | 0;\n  }\n  $$0358 = $$1 + 2 | 0;\n  $$0371 = $$0371 + 1 | 0;\n  $$0379 = $$1380;\n  $$2 = $$3 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $216 = $4 + 12 | 0;\n  $$1372 = 1;\n  $$3377 = 1;\n  $$4 = $19;\n  while (1) {\n   if (($$3377 | 0) > ($$0379 | 0)) break;\n   $218 = HEAP32[$$4 >> 2] | 0;\n   if (($218 | 0) == ($$3377 | 0)) {\n    $$2373 = $$1372 + 1 | 0;\n    $224 = $$1372;\n   } else {\n    $$2373 = $$1372;\n    $224 = HEAP32[$4 + 1179664 + ($218 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $224;\n   $$1372 = $$2373;\n   $$3377 = $$3377 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $227 = $4 + 8 | 0;\n  $228 = $$1372 + -1 | 0;\n  HEAP32[$227 >> 2] = $228;\n  if (!$228) $$0 = 0; else {\n   _memset($216 | 0, 0, $228 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $228 << 4 | 0) | 0;\n   $$4378 = 0;\n   while (1) {\n    if (($$4378 | 0) >= ($228 | 0)) break;\n    $234 = $$4378 << 2;\n    HEAP32[$4 + 131084 + ($234 << 2) >> 2] = $1;\n    HEAP32[$4 + 131084 + (($234 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($234 | 2) << 2) >> 2] = $2;\n    HEAP32[$4 + 131084 + (($234 | 3) << 2) >> 2] = 0;\n    $$4378 = $$4378 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0379 | 0)) break;\n    $246 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $247 = $$5 * 7 | 0;\n    $250 = $4 + 12 + ($246 << 2) | 0;\n    HEAP32[$250 >> 2] = (HEAP32[$250 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($247 << 2) >> 2] | 0);\n    $257 = $246 << 1;\n    $258 = $4 + 655376 + ($257 << 3) | 0;\n    HEAPF64[$258 >> 3] = +HEAPF64[$258 >> 3] + +(HEAP32[$4 + 1310736 + ($247 + 1 << 2) >> 2] | 0);\n    $266 = $4 + 655376 + (($257 | 1) << 3) | 0;\n    HEAPF64[$266 >> 3] = +HEAPF64[$266 >> 3] + +(HEAP32[$4 + 1310736 + ($247 + 2 << 2) >> 2] | 0);\n    $269 = $246 << 2;\n    $270 = $4 + 131084 + ($269 << 2) | 0;\n    $274 = HEAP32[$4 + 1310736 + ($247 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$270 >> 2] | 0) > ($274 | 0)) HEAP32[$270 >> 2] = $274;\n    $277 = $4 + 131084 + (($269 | 1) << 2) | 0;\n    $281 = HEAP32[$4 + 1310736 + ($247 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$277 >> 2] | 0) < ($281 | 0)) HEAP32[$277 >> 2] = $281;\n    $284 = $4 + 131084 + (($269 | 2) << 2) | 0;\n    $288 = HEAP32[$4 + 1310736 + ($247 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$284 >> 2] | 0) > ($288 | 0)) HEAP32[$284 >> 2] = $288;\n    $291 = $4 + 131084 + (($269 | 3) << 2) | 0;\n    $295 = HEAP32[$4 + 1310736 + ($247 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$291 >> 2] | 0) < ($295 | 0)) HEAP32[$291 >> 2] = $295;\n    $$5 = $$5 + 1 | 0;\n   }\n   $298 = HEAP32[$227 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($298 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $302 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $303 = $$6 << 1;\n    $304 = $4 + 655376 + ($303 << 3) | 0;\n    HEAPF64[$304 >> 3] = +HEAPF64[$304 >> 3] / $302;\n    $308 = $4 + 655376 + (($303 | 1) << 3) | 0;\n    HEAPF64[$308 >> 3] = +HEAPF64[$308 >> 3] / $302;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arLabelingSubDBRC($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0358 = 0, $$0359 = 0, $$0361 = 0, $$0363 = 0, $$0367 = 0, $$0371 = 0, $$0374 = 0, $$0379 = 0, $$1 = 0, $$1360 = 0, $$1362 = 0, $$1364 = 0, $$1368 = 0, $$1372 = 0, $$1375 = 0, $$1380 = 0, $$2 = 0, $$2365 = 0, $$2369 = 0, $$2373 = 0, $$2376 = 0, $$2381 = 0, $$3 = 0, $$3366 = 0, $$3370 = 0, $$3377 = 0, $$4 = 0, $$4378 = 0, $$5 = 0, $$6 = 0, $102 = 0, $117 = 0, $119 = 0, $121 = 0, $125 = 0, $129 = 0, $13 = 0, $132 = 0, $134 = 0, $138 = 0, $142 = 0, $146 = 0, $151 = 0, $153 = 0, $157 = 0, $161 = 0, $165 = 0, $171 = 0, $174 = 0, $176 = 0, $180 = 0, $184 = 0, $188 = 0, $19 = 0, $191 = 0, $196 = 0, $20 = 0, $216 = 0, $218 = 0, $224 = 0, $227 = 0, $228 = 0, $23 = 0, $234 = 0, $246 = 0, $247 = 0, $250 = 0, $257 = 0, $258 = 0, $266 = 0, $269 = 0, $270 = 0, $274 = 0, $277 = 0, $281 = 0, $284 = 0, $288 = 0, $29 = 0, $291 = 0, $295 = 0, $298 = 0, $30 = 0, $302 = 0.0, $303 = 0, $304 = 0, $308 = 0, $33 = 0, $35 = 0, $39 = 0, $43 = 0, $49 = 0, $5 = 0, $50 = 0, $53 = 0, $54 = 0, $55 = 0, $58 = 0, $6 = 0, $61 = 0, $76 = 0, $78 = 0, $80 = 0, $84 = 0, $88 = 0, $94 = 0, $99 = 0, $vararg_buffer = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $5 = HEAP32[$4 >> 2] | 0;\n $6 = $2 + -1 | 0;\n $$0359 = $5;\n $$0361 = $5 + ((Math_imul($6, $1) | 0) << 1) | 0;\n $$0374 = 0;\n while (1) {\n  if (($$0374 | 0) >= ($1 | 0)) break;\n  HEAP16[$$0361 >> 1] = 0;\n  HEAP16[$$0359 >> 1] = 0;\n  $$0359 = $$0359 + 2 | 0;\n  $$0361 = $$0361 + 2 | 0;\n  $$0374 = $$0374 + 1 | 0;\n }\n $13 = $1 + -1 | 0;\n $$1360 = $5;\n $$1362 = $5 + ($13 << 1) | 0;\n $$1375 = 0;\n while (1) {\n  if (($$1375 | 0) >= ($2 | 0)) break;\n  HEAP16[$$1362 >> 1] = 0;\n  HEAP16[$$1360 >> 1] = 0;\n  $$1360 = $$1360 + ($1 << 1) | 0;\n  $$1362 = $$1362 + ($1 << 1) | 0;\n  $$1375 = $$1375 + 1 | 0;\n }\n $19 = $4 + 1179664 | 0;\n $20 = $1 + 1 | 0;\n $23 = 0 - $1 | 0;\n $$0358 = $0 + $20 | 0;\n $$0371 = 1;\n $$0379 = 0;\n $$2 = $5 + ($20 << 1) | 0;\n L9 : while (1) {\n  if (($$0371 | 0) >= ($6 | 0)) {\n   label = 59;\n   break;\n  }\n  $$1 = $$0358;\n  $$1380 = $$0379;\n  $$2376 = 1;\n  $$3 = $$2;\n  while (1) {\n   if (($$2376 | 0) >= ($13 | 0)) break;\n   do if ((HEAPU8[$$1 >> 0] | 0 | 0) > ($3 | 0)) {\n    HEAP16[$$3 >> 1] = 0;\n    $$2381 = $$1380;\n   } else {\n    $29 = $$3 + ($23 << 1) | 0;\n    $30 = HEAP16[$29 >> 1] | 0;\n    if ($30 << 16 >> 16 > 0) {\n     HEAP16[$$3 >> 1] = $30;\n     $33 = ($30 << 16 >> 16) * 7 | 0;\n     $35 = $4 + 1310736 + ($33 + -7 << 2) | 0;\n     HEAP32[$35 >> 2] = (HEAP32[$35 >> 2] | 0) + 1;\n     $39 = $4 + 1310736 + ($33 + -6 << 2) | 0;\n     HEAP32[$39 >> 2] = (HEAP32[$39 >> 2] | 0) + $$2376;\n     $43 = $4 + 1310736 + ($33 + -5 << 2) | 0;\n     HEAP32[$43 >> 2] = (HEAP32[$43 >> 2] | 0) + $$0371;\n     HEAP32[$4 + 1310736 + ($33 + -1 << 2) >> 2] = $$0371;\n     $$2381 = $$1380;\n     break;\n    }\n    $49 = HEAP16[$29 + 2 >> 1] | 0;\n    $50 = $49 << 16 >> 16;\n    $53 = HEAP16[$29 + -2 >> 1] | 0;\n    $54 = $53 << 16 >> 16;\n    $55 = $53 << 16 >> 16 > 0;\n    if ($49 << 16 >> 16 <= 0) {\n     if ($55) {\n      HEAP16[$$3 >> 1] = $53;\n      $151 = $54 * 7 | 0;\n      $153 = $4 + 1310736 + ($151 + -7 << 2) | 0;\n      HEAP32[$153 >> 2] = (HEAP32[$153 >> 2] | 0) + 1;\n      $157 = $4 + 1310736 + ($151 + -6 << 2) | 0;\n      HEAP32[$157 >> 2] = (HEAP32[$157 >> 2] | 0) + $$2376;\n      $161 = $4 + 1310736 + ($151 + -5 << 2) | 0;\n      HEAP32[$161 >> 2] = (HEAP32[$161 >> 2] | 0) + $$0371;\n      $165 = $4 + 1310736 + ($151 + -3 << 2) | 0;\n      if ((HEAP32[$165 >> 2] | 0) < ($$2376 | 0)) HEAP32[$165 >> 2] = $$2376;\n      HEAP32[$4 + 1310736 + ($151 + -1 << 2) >> 2] = $$0371;\n      $$2381 = $$1380;\n      break;\n     }\n     $171 = HEAP16[$$3 + -2 >> 1] | 0;\n     if ($171 << 16 >> 16 > 0) {\n      HEAP16[$$3 >> 1] = $171;\n      $174 = ($171 << 16 >> 16) * 7 | 0;\n      $176 = $4 + 1310736 + ($174 + -7 << 2) | 0;\n      HEAP32[$176 >> 2] = (HEAP32[$176 >> 2] | 0) + 1;\n      $180 = $4 + 1310736 + ($174 + -6 << 2) | 0;\n      HEAP32[$180 >> 2] = (HEAP32[$180 >> 2] | 0) + $$2376;\n      $184 = $4 + 1310736 + ($174 + -5 << 2) | 0;\n      HEAP32[$184 >> 2] = (HEAP32[$184 >> 2] | 0) + $$0371;\n      $188 = $4 + 1310736 + ($174 + -3 << 2) | 0;\n      if ((HEAP32[$188 >> 2] | 0) >= ($$2376 | 0)) {\n       $$2381 = $$1380;\n       break;\n      }\n      HEAP32[$188 >> 2] = $$2376;\n      $$2381 = $$1380;\n      break;\n     } else {\n      $191 = $$1380 + 1 | 0;\n      if (($$1380 | 0) > 32767) {\n       label = 54;\n       break L9;\n      }\n      HEAP16[$$3 >> 1] = $191;\n      HEAP32[$4 + 1179664 + ($$1380 << 2) >> 2] = $191 << 16 >> 16;\n      $196 = $$1380 * 7 | 0;\n      HEAP32[$4 + 1310736 + ($196 << 2) >> 2] = 1;\n      HEAP32[$4 + 1310736 + ($196 + 1 << 2) >> 2] = $$2376;\n      HEAP32[$4 + 1310736 + ($196 + 2 << 2) >> 2] = $$0371;\n      HEAP32[$4 + 1310736 + ($196 + 3 << 2) >> 2] = $$2376;\n      HEAP32[$4 + 1310736 + ($196 + 4 << 2) >> 2] = $$2376;\n      HEAP32[$4 + 1310736 + ($196 + 5 << 2) >> 2] = $$0371;\n      HEAP32[$4 + 1310736 + ($196 + 6 << 2) >> 2] = $$0371;\n      $$2381 = $191;\n      break;\n     }\n    }\n    if ($55) {\n     $58 = HEAP32[$4 + 1179664 + ($50 + -1 << 2) >> 2] | 0;\n     $61 = HEAP32[$4 + 1179664 + ($54 + -1 << 2) >> 2] | 0;\n     L37 : do if (($58 | 0) > ($61 | 0)) {\n      HEAP16[$$3 >> 1] = $61;\n      $$0363 = $19;\n      $$0367 = 0;\n      while (1) {\n       if (($$0367 | 0) >= ($$1380 | 0)) {\n        $76 = $61;\n        break L37;\n       }\n       if ((HEAP32[$$0363 >> 2] | 0) == ($58 | 0)) HEAP32[$$0363 >> 2] = $61;\n       $$0363 = $$0363 + 4 | 0;\n       $$0367 = $$0367 + 1 | 0;\n      }\n     } else {\n      HEAP16[$$3 >> 1] = $58;\n      if (($58 | 0) < ($61 | 0)) {\n       $$1364 = $19;\n       $$1368 = 0;\n       while (1) {\n        if (($$1368 | 0) >= ($$1380 | 0)) {\n         $76 = $58;\n         break L37;\n        }\n        if ((HEAP32[$$1364 >> 2] | 0) == ($61 | 0)) HEAP32[$$1364 >> 2] = $58;\n        $$1364 = $$1364 + 4 | 0;\n        $$1368 = $$1368 + 1 | 0;\n       }\n      } else $76 = $58;\n     } while (0);\n     $78 = ($76 << 16 >> 16) * 7 | 0;\n     $80 = $4 + 1310736 + ($78 + -7 << 2) | 0;\n     HEAP32[$80 >> 2] = (HEAP32[$80 >> 2] | 0) + 1;\n     $84 = $4 + 1310736 + ($78 + -6 << 2) | 0;\n     HEAP32[$84 >> 2] = (HEAP32[$84 >> 2] | 0) + $$2376;\n     $88 = $4 + 1310736 + ($78 + -5 << 2) | 0;\n     HEAP32[$88 >> 2] = (HEAP32[$88 >> 2] | 0) + $$0371;\n     HEAP32[$4 + 1310736 + ($78 + -1 << 2) >> 2] = $$0371;\n     $$2381 = $$1380;\n     break;\n    }\n    $94 = HEAP16[$$3 + -2 >> 1] | 0;\n    if ($94 << 16 >> 16 <= 0) {\n     HEAP16[$$3 >> 1] = $49;\n     $132 = $50 * 7 | 0;\n     $134 = $4 + 1310736 + ($132 + -7 << 2) | 0;\n     HEAP32[$134 >> 2] = (HEAP32[$134 >> 2] | 0) + 1;\n     $138 = $4 + 1310736 + ($132 + -6 << 2) | 0;\n     HEAP32[$138 >> 2] = (HEAP32[$138 >> 2] | 0) + $$2376;\n     $142 = $4 + 1310736 + ($132 + -5 << 2) | 0;\n     HEAP32[$142 >> 2] = (HEAP32[$142 >> 2] | 0) + $$0371;\n     $146 = $4 + 1310736 + ($132 + -4 << 2) | 0;\n     if ((HEAP32[$146 >> 2] | 0) > ($$2376 | 0)) HEAP32[$146 >> 2] = $$2376;\n     HEAP32[$4 + 1310736 + ($132 + -1 << 2) >> 2] = $$0371;\n     $$2381 = $$1380;\n     break;\n    }\n    $99 = HEAP32[$4 + 1179664 + ($50 + -1 << 2) >> 2] | 0;\n    $102 = HEAP32[$4 + 1179664 + (($94 << 16 >> 16) + -1 << 2) >> 2] | 0;\n    L61 : do if (($99 | 0) > ($102 | 0)) {\n     HEAP16[$$3 >> 1] = $102;\n     $$2365 = $19;\n     $$2369 = 0;\n     while (1) {\n      if (($$2369 | 0) >= ($$1380 | 0)) {\n       $117 = $102;\n       break L61;\n      }\n      if ((HEAP32[$$2365 >> 2] | 0) == ($99 | 0)) HEAP32[$$2365 >> 2] = $102;\n      $$2365 = $$2365 + 4 | 0;\n      $$2369 = $$2369 + 1 | 0;\n     }\n    } else {\n     HEAP16[$$3 >> 1] = $99;\n     if (($99 | 0) < ($102 | 0)) {\n      $$3366 = $19;\n      $$3370 = 0;\n      while (1) {\n       if (($$3370 | 0) >= ($$1380 | 0)) {\n        $117 = $99;\n        break L61;\n       }\n       if ((HEAP32[$$3366 >> 2] | 0) == ($102 | 0)) HEAP32[$$3366 >> 2] = $99;\n       $$3366 = $$3366 + 4 | 0;\n       $$3370 = $$3370 + 1 | 0;\n      }\n     } else $117 = $99;\n    } while (0);\n    $119 = ($117 << 16 >> 16) * 7 | 0;\n    $121 = $4 + 1310736 + ($119 + -7 << 2) | 0;\n    HEAP32[$121 >> 2] = (HEAP32[$121 >> 2] | 0) + 1;\n    $125 = $4 + 1310736 + ($119 + -6 << 2) | 0;\n    HEAP32[$125 >> 2] = (HEAP32[$125 >> 2] | 0) + $$2376;\n    $129 = $4 + 1310736 + ($119 + -5 << 2) | 0;\n    HEAP32[$129 >> 2] = (HEAP32[$129 >> 2] | 0) + $$0371;\n    $$2381 = $$1380;\n   } while (0);\n   $$1 = $$1 + 1 | 0;\n   $$1380 = $$2381;\n   $$2376 = $$2376 + 1 | 0;\n   $$3 = $$3 + 2 | 0;\n  }\n  $$0358 = $$1 + 2 | 0;\n  $$0371 = $$0371 + 1 | 0;\n  $$0379 = $$1380;\n  $$2 = $$3 + 4 | 0;\n }\n L80 : do if ((label | 0) == 54) {\n  _arLog(0, 3, 3524, $vararg_buffer);\n  $$0 = -1;\n } else if ((label | 0) == 59) {\n  $216 = $4 + 12 | 0;\n  $$1372 = 1;\n  $$3377 = 1;\n  $$4 = $19;\n  while (1) {\n   if (($$3377 | 0) > ($$0379 | 0)) break;\n   $218 = HEAP32[$$4 >> 2] | 0;\n   if (($218 | 0) == ($$3377 | 0)) {\n    $$2373 = $$1372 + 1 | 0;\n    $224 = $$1372;\n   } else {\n    $$2373 = $$1372;\n    $224 = HEAP32[$4 + 1179664 + ($218 + -1 << 2) >> 2] | 0;\n   }\n   HEAP32[$$4 >> 2] = $224;\n   $$1372 = $$2373;\n   $$3377 = $$3377 + 1 | 0;\n   $$4 = $$4 + 4 | 0;\n  }\n  $227 = $4 + 8 | 0;\n  $228 = $$1372 + -1 | 0;\n  HEAP32[$227 >> 2] = $228;\n  if (!$228) $$0 = 0; else {\n   _memset($216 | 0, 0, $228 << 2 | 0) | 0;\n   _memset($4 + 655376 | 0, 0, $228 << 4 | 0) | 0;\n   $$4378 = 0;\n   while (1) {\n    if (($$4378 | 0) >= ($228 | 0)) break;\n    $234 = $$4378 << 2;\n    HEAP32[$4 + 131084 + ($234 << 2) >> 2] = $1;\n    HEAP32[$4 + 131084 + (($234 | 1) << 2) >> 2] = 0;\n    HEAP32[$4 + 131084 + (($234 | 2) << 2) >> 2] = $2;\n    HEAP32[$4 + 131084 + (($234 | 3) << 2) >> 2] = 0;\n    $$4378 = $$4378 + 1 | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0379 | 0)) break;\n    $246 = (HEAP32[$4 + 1179664 + ($$5 << 2) >> 2] | 0) + -1 | 0;\n    $247 = $$5 * 7 | 0;\n    $250 = $4 + 12 + ($246 << 2) | 0;\n    HEAP32[$250 >> 2] = (HEAP32[$250 >> 2] | 0) + (HEAP32[$4 + 1310736 + ($247 << 2) >> 2] | 0);\n    $257 = $246 << 1;\n    $258 = $4 + 655376 + ($257 << 3) | 0;\n    HEAPF64[$258 >> 3] = +HEAPF64[$258 >> 3] + +(HEAP32[$4 + 1310736 + ($247 + 1 << 2) >> 2] | 0);\n    $266 = $4 + 655376 + (($257 | 1) << 3) | 0;\n    HEAPF64[$266 >> 3] = +HEAPF64[$266 >> 3] + +(HEAP32[$4 + 1310736 + ($247 + 2 << 2) >> 2] | 0);\n    $269 = $246 << 2;\n    $270 = $4 + 131084 + ($269 << 2) | 0;\n    $274 = HEAP32[$4 + 1310736 + ($247 + 3 << 2) >> 2] | 0;\n    if ((HEAP32[$270 >> 2] | 0) > ($274 | 0)) HEAP32[$270 >> 2] = $274;\n    $277 = $4 + 131084 + (($269 | 1) << 2) | 0;\n    $281 = HEAP32[$4 + 1310736 + ($247 + 4 << 2) >> 2] | 0;\n    if ((HEAP32[$277 >> 2] | 0) < ($281 | 0)) HEAP32[$277 >> 2] = $281;\n    $284 = $4 + 131084 + (($269 | 2) << 2) | 0;\n    $288 = HEAP32[$4 + 1310736 + ($247 + 5 << 2) >> 2] | 0;\n    if ((HEAP32[$284 >> 2] | 0) > ($288 | 0)) HEAP32[$284 >> 2] = $288;\n    $291 = $4 + 131084 + (($269 | 3) << 2) | 0;\n    $295 = HEAP32[$4 + 1310736 + ($247 + 6 << 2) >> 2] | 0;\n    if ((HEAP32[$291 >> 2] | 0) < ($295 | 0)) HEAP32[$291 >> 2] = $295;\n    $$5 = $$5 + 1 | 0;\n   }\n   $298 = HEAP32[$227 >> 2] | 0;\n   $$6 = 0;\n   while (1) {\n    if (($$6 | 0) >= ($298 | 0)) {\n     $$0 = 0;\n     break L80;\n    }\n    $302 = +(HEAP32[$4 + 12 + ($$6 << 2) >> 2] | 0);\n    $303 = $$6 << 1;\n    $304 = $4 + 655376 + ($303 << 3) | 0;\n    HEAPF64[$304 >> 3] = +HEAPF64[$304 >> 3] / $302;\n    $308 = $4 + 655376 + (($303 | 1) << 3) | 0;\n    HEAPF64[$308 >> 3] = +HEAPF64[$308 >> 3] / $302;\n    $$6 = $$6 + 1 | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_116parse_array_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i$i132 = 0, $$0$i$i$i112 = 0, $$0$i$i$i119 = 0, $$0$i$i$i123 = 0, $$0$i$i$i127 = 0, $$0$i$i$idx$i = 0, $$7 = 0, $103 = 0, $104 = 0, $105 = 0, $108 = 0, $112 = 0, $113 = 0, $115 = 0, $123 = 0, $13 = 0, $131 = 0, $132 = 0, $142 = 0, $143 = 0, $144 = 0, $147 = 0, $15 = 0, $17 = 0, $18 = 0, $21 = 0, $22 = 0, $25 = 0, $27 = 0, $3 = 0, $35 = 0, $4 = 0, $41 = 0, $45 = 0, $46 = 0, $49 = 0, $5 = 0, $50 = 0, $53 = 0, $55 = 0, $6 = 0, $63 = 0, $67 = 0, $7 = 0, $75 = 0, $76 = 0, $8 = 0, $83 = 0, $88 = 0, $89 = 0, $9 = 0, $91 = 0, $92 = 0, $99 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 112 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112);\n $3 = sp + 96 | 0;\n $4 = sp + 72 | 0;\n $5 = sp + 48 | 0;\n $6 = sp + 36 | 0;\n $7 = sp + 24 | 0;\n $8 = sp + 12 | 0;\n $9 = sp;\n do if (($0 | 0) == ($1 | 0)) $$7 = $0; else if ((HEAP8[$0 >> 0] | 0) == 65) {\n  $13 = $0 + 1 | 0;\n  if (($13 | 0) == ($1 | 0)) $$7 = $0; else {\n   $15 = HEAP8[$13 >> 0] | 0;\n   if ($15 << 24 >> 24 == 95) {\n    $17 = $0 + 2 | 0;\n    $18 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($17, $1, $2) | 0;\n    if (($18 | 0) == ($17 | 0)) {\n     $$7 = $0;\n     break;\n    }\n    $21 = $2 + 4 | 0;\n    $22 = HEAP32[$21 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($22 | 0)) {\n     $$7 = $0;\n     break;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($3, $22 + -12 | 0, 2);\n    $25 = __ZNSt3__211char_traitsIcE6lengthEPKc(15111) | 0;\n    $27 = HEAP8[$3 + 11 >> 0] | 0;\n    if (($25 | 0) == (($27 << 24 >> 24 < 0 ? HEAP32[$3 + 4 >> 2] | 0 : $27 & 255) | 0)) {\n     $35 = (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($3, 15111, $25) | 0) == 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     if ($35) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE5eraseEjj((HEAP32[$21 >> 2] | 0) + -12 | 0);\n    } else __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc((HEAP32[$21 >> 2] | 0) + -12 | 0, 0, 16552) | 0;\n    $$7 = $18;\n    break;\n   }\n   if (($15 + -49 & 255) < 9) {\n    $41 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($13, $1) | 0;\n    if (($41 | 0) == ($1 | 0)) {\n     $$7 = $0;\n     break;\n    }\n    if ((HEAP8[$41 >> 0] | 0) != 95) {\n     $$7 = $0;\n     break;\n    }\n    $45 = $41 + 1 | 0;\n    $46 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($45, $1, $2) | 0;\n    if (($46 | 0) == ($45 | 0)) {\n     $$7 = $0;\n     break;\n    }\n    $49 = $2 + 4 | 0;\n    $50 = HEAP32[$49 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($50 | 0)) {\n     $$7 = $0;\n     break;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($3, $50 + -12 | 0, 2);\n    $53 = __ZNSt3__211char_traitsIcE6lengthEPKc(15111) | 0;\n    $55 = HEAP8[$3 + 11 >> 0] | 0;\n    if (($53 | 0) == (($55 << 24 >> 24 < 0 ? HEAP32[$3 + 4 >> 2] | 0 : $55 & 255) | 0)) {\n     $63 = (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($3, 15111, $53) | 0) == 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     if ($63) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE5eraseEjj((HEAP32[$49 >> 2] | 0) + -12 | 0);\n    } else __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $67 = (HEAP32[$49 >> 2] | 0) + -12 | 0;\n    HEAP32[$5 >> 2] = 0;\n    HEAP32[$5 + 4 >> 2] = 0;\n    HEAP32[$5 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($5, $13, $41);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($5, 0, 15111) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15166) | 0;\n    HEAP32[$3 >> 2] = HEAP32[$4 >> 2];\n    HEAP32[$3 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n    HEAP32[$3 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n    $$0$i$i$i112 = 0;\n    while (1) {\n     if (($$0$i$i$i112 | 0) == 3) break;\n     HEAP32[$4 + ($$0$i$i$i112 << 2) >> 2] = 0;\n     $$0$i$i$i112 = $$0$i$i$i112 + 1 | 0;\n    }\n    $75 = HEAP8[$3 + 11 >> 0] | 0;\n    $76 = $75 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKcj($67, 0, $76 ? HEAP32[$3 >> 2] | 0 : $3, $76 ? HEAP32[$3 + 4 >> 2] | 0 : $75 & 255) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    $$7 = $46;\n    break;\n   }\n   $83 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($13, $1, $2) | 0;\n   if (($83 | 0) == ($13 | 0) | ($83 | 0) == ($1 | 0)) $$7 = $0; else if ((HEAP8[$83 >> 0] | 0) == 95) {\n    $88 = $83 + 1 | 0;\n    $89 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($88, $1, $2) | 0;\n    if (($89 | 0) == ($88 | 0)) $$7 = $0; else {\n     $91 = $2 + 4 | 0;\n     $92 = HEAP32[$91 >> 2] | 0;\n     if ((($92 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$7 = $0; else {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($4, $92 + -24 | 0);\n      $99 = HEAP32[$91 >> 2] | 0;\n      $$0$i$i$idx$i = 0;\n      while (1) {\n       if (($$0$i$i$idx$i | 0) == -1) break;\n       $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($99 + ($$0$i$i$add$i * 24 | 0) | 0);\n       $$0$i$i$idx$i = $$0$i$i$add$i;\n      }\n      HEAP32[$91 >> 2] = $99 + -24;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($5, $99 + -48 | 0);\n      $103 = HEAP32[$91 >> 2] | 0;\n      $104 = $103 + -24 | 0;\n      $105 = $104 + 11 | 0;\n      if ((HEAP8[$105 >> 0] | 0) < 0) {\n       $108 = HEAP32[$104 >> 2] | 0;\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($108, $3);\n       HEAP32[$103 + -20 >> 2] = 0;\n      } else {\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($104, $3);\n       HEAP8[$105 >> 0] = 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($104);\n      HEAP32[$104 >> 2] = HEAP32[$4 >> 2];\n      HEAP32[$104 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n      HEAP32[$104 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n      $$0$i$i$i$i = 0;\n      while (1) {\n       if (($$0$i$i$i$i | 0) == 3) break;\n       HEAP32[$4 + ($$0$i$i$i$i << 2) >> 2] = 0;\n       $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n      }\n      $112 = $4 + 12 | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($3, $112, 2);\n      $113 = __ZNSt3__211char_traitsIcE6lengthEPKc(15111) | 0;\n      $115 = HEAP8[$3 + 11 >> 0] | 0;\n      if (($113 | 0) == (($115 << 24 >> 24 < 0 ? HEAP32[$3 + 4 >> 2] | 0 : $115 & 255) | 0)) {\n       $123 = (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($3, 15111, $113) | 0) == 0;\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n       if ($123) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE5eraseEjj($112);\n      } else __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($9, $5);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($9, 0, 15111) | 0;\n      HEAP32[$8 >> 2] = HEAP32[$9 >> 2];\n      HEAP32[$8 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n      HEAP32[$8 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n      $$0$i$i$i119 = 0;\n      while (1) {\n       if (($$0$i$i$i119 | 0) == 3) break;\n       HEAP32[$9 + ($$0$i$i$i119 << 2) >> 2] = 0;\n       $$0$i$i$i119 = $$0$i$i$i119 + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($8, 15166) | 0;\n      HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n      HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n      HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n      $$0$i$i$i123 = 0;\n      while (1) {\n       if (($$0$i$i$i123 | 0) == 3) break;\n       HEAP32[$8 + ($$0$i$i$i123 << 2) >> 2] = 0;\n       $$0$i$i$i123 = $$0$i$i$i123 + 1 | 0;\n      }\n      $131 = HEAP8[$112 + 11 >> 0] | 0;\n      $132 = $131 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($7, $132 ? HEAP32[$112 >> 2] | 0 : $112, $132 ? HEAP32[$4 + 16 >> 2] | 0 : $131 & 255) | 0;\n      HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n      HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n      HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n      $$0$i$i$i127 = 0;\n      while (1) {\n       if (($$0$i$i$i127 | 0) == 3) break;\n       HEAP32[$7 + ($$0$i$i$i127 << 2) >> 2] = 0;\n       $$0$i$i$i127 = $$0$i$i$i127 + 1 | 0;\n      }\n      $142 = HEAP32[$91 >> 2] | 0;\n      $143 = $142 + -12 | 0;\n      $144 = $143 + 11 | 0;\n      if ((HEAP8[$144 >> 0] | 0) < 0) {\n       $147 = HEAP32[$143 >> 2] | 0;\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($147, $3);\n       HEAP32[$142 + -8 >> 2] = 0;\n      } else {\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($143, $3);\n       HEAP8[$144 >> 0] = 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($143);\n      HEAP32[$143 >> 2] = HEAP32[$6 >> 2];\n      HEAP32[$143 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n      HEAP32[$143 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n      $$0$i$i$i$i132 = 0;\n      while (1) {\n       if (($$0$i$i$i$i132 | 0) == 3) break;\n       HEAP32[$6 + ($$0$i$i$i$i132 << 2) >> 2] = 0;\n       $$0$i$i$i$i132 = $$0$i$i$i$i132 + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($5);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n      $$7 = $89;\n     }\n    }\n   } else $$7 = $0;\n  }\n } else $$7 = $0; while (0);\n STACKTOP = sp;\n return $$7 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_123parse_unnamed_type_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$add$i133 = 0, $$0$i$i$add$i139 = 0, $$0$i$i$add$i143 = 0, $$0$i$i$add$i148 = 0, $$0$i$i$add$i154 = 0, $$0$i$i$add$i158 = 0, $$0$i$i$add$i162 = 0, $$0$i$i$i$i = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i132 = 0, $$0$i$i$idx$i138 = 0, $$0$i$i$idx$i142 = 0, $$0$i$i$idx$i147 = 0, $$0$i$i$idx$i153 = 0, $$0$i$i$idx$i157 = 0, $$0$i$i$idx$i161 = 0, $$0105 = 0, $$0105$lcssa = 0, $$0106 = 0, $$0110 = 0, $$0110$lcssa = 0, $$0116 = 0, $$2108 = 0, $$3109 = 0, $$7 = 0, $$byval_copy = 0, $101 = 0, $104 = 0, $113 = 0, $114 = 0, $125 = 0, $128 = 0, $130 = 0, $141 = 0, $147 = 0, $152 = 0, $18 = 0, $19 = 0, $25 = 0, $27 = 0, $3 = 0, $4 = 0, $44 = 0, $49 = 0, $5 = 0, $50 = 0, $56 = 0, $6 = 0, $62 = 0, $64 = 0, $67 = 0, $7 = 0, $74 = 0, $78 = 0, $79 = 0, $80 = 0, $82 = 0, $87 = 0, $89 = 0, $98 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 80 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80);\n $$byval_copy = sp + 56 | 0;\n $3 = sp + 40 | 0;\n $4 = sp + 28 | 0;\n $5 = sp + 12 | 0;\n $6 = sp;\n $7 = sp + 24 | 0;\n L1 : do if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 85) {\n  switch (HEAP8[$0 + 1 >> 0] | 0) {\n  case 116:\n   {\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15920, __ZNSt3__211char_traitsIcE6lengthEPKc(15920) | 0);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($$byval_copy, $3);\n    $18 = $2 + 4 | 0;\n    $19 = HEAP32[$18 >> 2] | 0;\n    if ($19 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($19, $$byval_copy);\n     HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $$byval_copy);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($$byval_copy);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $25 = $0 + 2 | 0;\n    if (($25 | 0) == ($1 | 0)) {\n     $27 = HEAP32[$18 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($27 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$18 >> 2] = $27 + -24;\n     $$7 = $0;\n     break L1;\n    }\n    if (((HEAP8[$25 >> 0] | 0) + -48 | 0) >>> 0 < 10) {\n     $$0110 = $0 + 3 | 0;\n     while (1) {\n      if (($$0110 | 0) == ($1 | 0)) {\n       $$0110$lcssa = $1;\n       break;\n      }\n      if (((HEAP8[$$0110 >> 0] | 0) + -48 | 0) >>> 0 >= 10) {\n       $$0110$lcssa = $$0110;\n       break;\n      }\n      $$0110 = $$0110 + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE23__append_forward_unsafeIPKcEERS7_T_SC_((HEAP32[$18 >> 2] | 0) + -24 | 0, $25, $$0110$lcssa);\n     $$0116 = $$0110$lcssa;\n    } else $$0116 = $25;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9push_backEc((HEAP32[$18 >> 2] | 0) + -24 | 0, 39);\n    if (($$0116 | 0) != ($1 | 0)) if ((HEAP8[$$0116 >> 0] | 0) == 95) {\n     $$7 = $$0116 + 1 | 0;\n     break L1;\n    }\n    $44 = HEAP32[$18 >> 2] | 0;\n    $$0$i$i$idx$i132 = 0;\n    while (1) {\n     if (($$0$i$i$idx$i132 | 0) == -1) break;\n     $$0$i$i$add$i133 = $$0$i$i$idx$i132 + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($44 + ($$0$i$i$add$i133 * 24 | 0) | 0);\n     $$0$i$i$idx$i132 = $$0$i$i$add$i133;\n    }\n    HEAP32[$18 >> 2] = $44 + -24;\n    $$7 = $0;\n    break L1;\n    break;\n   }\n  case 108:\n   break;\n  default:\n   {\n    $$7 = $0;\n    break L1;\n   }\n  }\n  HEAP32[$4 >> 2] = 0;\n  HEAP32[$4 + 4 >> 2] = 0;\n  HEAP32[$4 + 8 >> 2] = 0;\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($4, 15929, __ZNSt3__211char_traitsIcE6lengthEPKc(15929) | 0);\n  __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($$byval_copy, $4);\n  $49 = $2 + 4 | 0;\n  $50 = HEAP32[$49 >> 2] | 0;\n  if ($50 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($50, $$byval_copy);\n   HEAP32[$49 >> 2] = (HEAP32[$49 >> 2] | 0) + 24;\n  } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $$byval_copy);\n  __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($$byval_copy);\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n  $56 = $0 + 2 | 0;\n  do if ((HEAP8[$56 >> 0] | 0) == 118) {\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9push_backEc((HEAP32[$49 >> 2] | 0) + -24 | 0, 41);\n   $$2108 = $0 + 3 | 0;\n  } else {\n   $62 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($56, $1, $2) | 0;\n   if (($62 | 0) == ($56 | 0)) {\n    $64 = HEAP32[$49 >> 2] | 0;\n    $$0$i$i$idx$i138 = 0;\n    while (1) {\n     if (($$0$i$i$idx$i138 | 0) == -1) break;\n     $$0$i$i$add$i139 = $$0$i$i$idx$i138 + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($64 + ($$0$i$i$add$i139 * 24 | 0) | 0);\n     $$0$i$i$idx$i138 = $$0$i$i$add$i139;\n    }\n    HEAP32[$49 >> 2] = $64 + -24;\n    $$7 = $0;\n    break L1;\n   }\n   $67 = HEAP32[$49 >> 2] | 0;\n   if ((($67 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n    $$7 = $0;\n    break L1;\n   }\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, $67 + -24 | 0);\n   $74 = HEAP32[$49 >> 2] | 0;\n   $$0$i$i$idx$i142 = 0;\n   while (1) {\n    if (($$0$i$i$idx$i142 | 0) == -1) break;\n    $$0$i$i$add$i143 = $$0$i$i$idx$i142 + -1 | 0;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($74 + ($$0$i$i$add$i143 * 24 | 0) | 0);\n    $$0$i$i$idx$i142 = $$0$i$i$add$i143;\n   }\n   HEAP32[$49 >> 2] = $74 + -24;\n   $78 = $5 + 11 | 0;\n   $79 = HEAP8[$78 >> 0] | 0;\n   $80 = $79 << 24 >> 24 < 0;\n   $82 = $5 + 4 | 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($74 + -48 | 0, $80 ? HEAP32[$5 >> 2] | 0 : $5, $80 ? HEAP32[$82 >> 2] | 0 : $79 & 255) | 0;\n   $$0106 = $62;\n   while (1) {\n    $87 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($$0106, $1, $2) | 0;\n    if (($87 | 0) == ($$0106 | 0)) {\n     label = 54;\n     break;\n    }\n    $89 = HEAP32[$49 >> 2] | 0;\n    if ((($89 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n     label = 82;\n     break;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $89 + -24 | 0);\n    if ((HEAP8[$78 >> 0] | 0) < 0) {\n     $98 = HEAP32[$5 >> 2] | 0;\n     HEAP8[$$byval_copy >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($98, $$byval_copy);\n     HEAP32[$82 >> 2] = 0;\n    } else {\n     HEAP8[$$byval_copy >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($5, $$byval_copy);\n     HEAP8[$78 >> 0] = 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($5);\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i$i | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    $101 = HEAP32[$49 >> 2] | 0;\n    $$0$i$i$idx$i147 = 0;\n    while (1) {\n     if (($$0$i$i$idx$i147 | 0) == -1) break;\n     $$0$i$i$add$i148 = $$0$i$i$idx$i147 + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($101 + ($$0$i$i$add$i148 * 24 | 0) | 0);\n     $$0$i$i$idx$i147 = $$0$i$i$add$i148;\n    }\n    HEAP32[$49 >> 2] = $101 + -24;\n    $104 = HEAP8[$78 >> 0] | 0;\n    if (($104 << 24 >> 24 < 0 ? HEAP32[$82 >> 2] | 0 : $104 & 255) | 0) {\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($101 + -48 | 0, 15341) | 0;\n     $113 = HEAP8[$78 >> 0] | 0;\n     $114 = $113 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$49 >> 2] | 0) + -24 | 0, $114 ? HEAP32[$5 >> 2] | 0 : $5, $114 ? HEAP32[$82 >> 2] | 0 : $113 & 255) | 0;\n    }\n    $$0106 = $87;\n   }\n   if ((label | 0) == 54) {\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$49 >> 2] | 0) + -24 | 0, 15117) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    $$2108 = $$0106;\n    break;\n   } else if ((label | 0) == 82) {\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    $$7 = $0;\n    break L1;\n   }\n  } while (0);\n  if (($$2108 | 0) != ($1 | 0)) if ((HEAP8[$$2108 >> 0] | 0) == 69) {\n   $128 = $$2108 + 1 | 0;\n   if (($128 | 0) == ($1 | 0)) {\n    $130 = HEAP32[$49 >> 2] | 0;\n    $$0$i$i$idx$i157 = 0;\n    while (1) {\n     if (($$0$i$i$idx$i157 | 0) == -1) break;\n     $$0$i$i$add$i158 = $$0$i$i$idx$i157 + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($130 + ($$0$i$i$add$i158 * 24 | 0) | 0);\n     $$0$i$i$idx$i157 = $$0$i$i$add$i158;\n    }\n    HEAP32[$49 >> 2] = $130 + -24;\n    $$7 = $0;\n    break;\n   }\n   if (((HEAP8[$128 >> 0] | 0) + -48 | 0) >>> 0 < 10) {\n    $$0105 = $$2108 + 2 | 0;\n    while (1) {\n     if (($$0105 | 0) == ($1 | 0)) {\n      $$0105$lcssa = $1;\n      break;\n     }\n     if (((HEAP8[$$0105 >> 0] | 0) + -48 | 0) >>> 0 >= 10) {\n      $$0105$lcssa = $$0105;\n      break;\n     }\n     $$0105 = $$0105 + 1 | 0;\n    }\n    $141 = (HEAP32[$49 >> 2] | 0) + -24 | 0;\n    if ((HEAP8[$141 + 11 >> 0] | 0) < 0) $147 = HEAP32[$141 >> 2] | 0; else $147 = $141;\n    HEAP32[$7 >> 2] = $147 + 7;\n    HEAP32[$$byval_copy >> 2] = HEAP32[$7 >> 2];\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertIPKcEENS_9enable_ifIXaasr21__is_forward_iteratorIT_EE5valuesr38__libcpp_string_gets_noexcept_iteratorISC_EE5valueENS_11__wrap_iterIPcEEE4typeENSD_ISA_EESC_SC_($141, $$byval_copy, $128, $$0105$lcssa) | 0;\n    $$3109 = $$0105$lcssa;\n   } else $$3109 = $128;\n   if (($$3109 | 0) != ($1 | 0)) if ((HEAP8[$$3109 >> 0] | 0) == 95) {\n    $$7 = $$3109 + 1 | 0;\n    break;\n   }\n   $152 = HEAP32[$49 >> 2] | 0;\n   $$0$i$i$idx$i161 = 0;\n   while (1) {\n    if (($$0$i$i$idx$i161 | 0) == -1) break;\n    $$0$i$i$add$i162 = $$0$i$i$idx$i161 + -1 | 0;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($152 + ($$0$i$i$add$i162 * 24 | 0) | 0);\n    $$0$i$i$idx$i161 = $$0$i$i$add$i162;\n   }\n   HEAP32[$49 >> 2] = $152 + -24;\n   $$7 = $0;\n   break;\n  }\n  $125 = HEAP32[$49 >> 2] | 0;\n  $$0$i$i$idx$i153 = 0;\n  while (1) {\n   if (($$0$i$i$idx$i153 | 0) == -1) break;\n   $$0$i$i$add$i154 = $$0$i$i$idx$i153 + -1 | 0;\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($125 + ($$0$i$i$add$i154 * 24 | 0) | 0);\n   $$0$i$i$idx$i153 = $$0$i$i$add$i154;\n  }\n  HEAP32[$49 >> 2] = $125 + -24;\n  $$7 = $0;\n } else $$7 = $0; else $$7 = $0; while (0);\n STACKTOP = sp;\n return $$7 | 0;\n}\n\nfunction _dispose_chunk($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$041722 = 0, $$0418$lcssa = 0, $$041821 = 0, $$0429 = 0, $$0436 = 0, $$1 = 0, $$1416 = 0, $$1424 = 0, $$1424$be = 0, $$1424$ph = 0, $$1427 = 0, $$1427$be = 0, $$1427$ph = 0, $$1431 = 0, $$1431$be = 0, $$1431$ph = 0, $$1435 = 0, $$1435$be = 0, $$1435$ph = 0, $$2 = 0, $$3 = 0, $$3433 = 0, $$pre$phi28Z2D = 0, $$pre$phi30Z2D = 0, $$pre$phiZ2D = 0, $101 = 0, $102 = 0, $108 = 0, $11 = 0, $110 = 0, $111 = 0, $117 = 0, $12 = 0, $125 = 0, $13 = 0, $130 = 0, $131 = 0, $134 = 0, $136 = 0, $138 = 0, $151 = 0, $156 = 0, $158 = 0, $161 = 0, $163 = 0, $166 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $173 = 0, $175 = 0, $176 = 0, $178 = 0, $179 = 0, $184 = 0, $185 = 0, $194 = 0, $199 = 0, $2 = 0, $20 = 0, $202 = 0, $203 = 0, $209 = 0, $22 = 0, $224 = 0, $227 = 0, $228 = 0, $229 = 0, $233 = 0, $234 = 0, $24 = 0, $240 = 0, $245 = 0, $246 = 0, $249 = 0, $251 = 0, $254 = 0, $259 = 0, $265 = 0, $269 = 0, $270 = 0, $277 = 0, $289 = 0, $294 = 0, $301 = 0, $302 = 0, $303 = 0, $37 = 0, $4 = 0, $42 = 0, $44 = 0, $47 = 0, $49 = 0, $52 = 0, $55 = 0, $56 = 0, $57 = 0, $59 = 0, $61 = 0, $62 = 0, $64 = 0, $65 = 0, $7 = 0, $70 = 0, $71 = 0, $80 = 0, $85 = 0, $88 = 0, $89 = 0, $95 = 0;\n $2 = $0 + $1 | 0;\n $4 = HEAP32[$0 + 4 >> 2] | 0;\n L1 : do if (!($4 & 1)) {\n  $7 = HEAP32[$0 >> 2] | 0;\n  if (!($4 & 3)) return;\n  $11 = $0 + (0 - $7) | 0;\n  $12 = $7 + $1 | 0;\n  $13 = HEAP32[4355] | 0;\n  if ($11 >>> 0 < $13 >>> 0) _abort();\n  if ((HEAP32[4356] | 0) == ($11 | 0)) {\n   $101 = $2 + 4 | 0;\n   $102 = HEAP32[$101 >> 2] | 0;\n   if (($102 & 3 | 0) != 3) {\n    $$1 = $11;\n    $$1416 = $12;\n    break;\n   }\n   HEAP32[4353] = $12;\n   HEAP32[$101 >> 2] = $102 & -2;\n   HEAP32[$11 + 4 >> 2] = $12 | 1;\n   HEAP32[$2 >> 2] = $12;\n   return;\n  }\n  $17 = $7 >>> 3;\n  if ($7 >>> 0 < 256) {\n   $20 = HEAP32[$11 + 8 >> 2] | 0;\n   $22 = HEAP32[$11 + 12 >> 2] | 0;\n   $24 = 17444 + ($17 << 1 << 2) | 0;\n   if (($20 | 0) != ($24 | 0)) {\n    if ($13 >>> 0 > $20 >>> 0) _abort();\n    if ((HEAP32[$20 + 12 >> 2] | 0) != ($11 | 0)) _abort();\n   }\n   if (($22 | 0) == ($20 | 0)) {\n    HEAP32[4351] = HEAP32[4351] & ~(1 << $17);\n    $$1 = $11;\n    $$1416 = $12;\n    break;\n   }\n   if (($22 | 0) == ($24 | 0)) $$pre$phi30Z2D = $22 + 8 | 0; else {\n    if ($13 >>> 0 > $22 >>> 0) _abort();\n    $37 = $22 + 8 | 0;\n    if ((HEAP32[$37 >> 2] | 0) == ($11 | 0)) $$pre$phi30Z2D = $37; else _abort();\n   }\n   HEAP32[$20 + 12 >> 2] = $22;\n   HEAP32[$$pre$phi30Z2D >> 2] = $20;\n   $$1 = $11;\n   $$1416 = $12;\n   break;\n  }\n  $42 = HEAP32[$11 + 24 >> 2] | 0;\n  $44 = HEAP32[$11 + 12 >> 2] | 0;\n  do if (($44 | 0) == ($11 | 0)) {\n   $55 = $11 + 16 | 0;\n   $56 = $55 + 4 | 0;\n   $57 = HEAP32[$56 >> 2] | 0;\n   if (!$57) {\n    $59 = HEAP32[$55 >> 2] | 0;\n    if (!$59) {\n     $$3 = 0;\n     break;\n    } else {\n     $$1424$ph = $59;\n     $$1427$ph = $55;\n    }\n   } else {\n    $$1424$ph = $57;\n    $$1427$ph = $56;\n   }\n   $$1424 = $$1424$ph;\n   $$1427 = $$1427$ph;\n   while (1) {\n    $61 = $$1424 + 20 | 0;\n    $62 = HEAP32[$61 >> 2] | 0;\n    if (!$62) {\n     $64 = $$1424 + 16 | 0;\n     $65 = HEAP32[$64 >> 2] | 0;\n     if (!$65) break; else {\n      $$1424$be = $65;\n      $$1427$be = $64;\n     }\n    } else {\n     $$1424$be = $62;\n     $$1427$be = $61;\n    }\n    $$1424 = $$1424$be;\n    $$1427 = $$1427$be;\n   }\n   if ($13 >>> 0 > $$1427 >>> 0) _abort(); else {\n    HEAP32[$$1427 >> 2] = 0;\n    $$3 = $$1424;\n    break;\n   }\n  } else {\n   $47 = HEAP32[$11 + 8 >> 2] | 0;\n   if ($13 >>> 0 > $47 >>> 0) _abort();\n   $49 = $47 + 12 | 0;\n   if ((HEAP32[$49 >> 2] | 0) != ($11 | 0)) _abort();\n   $52 = $44 + 8 | 0;\n   if ((HEAP32[$52 >> 2] | 0) == ($11 | 0)) {\n    HEAP32[$49 >> 2] = $44;\n    HEAP32[$52 >> 2] = $47;\n    $$3 = $44;\n    break;\n   } else _abort();\n  } while (0);\n  if (!$42) {\n   $$1 = $11;\n   $$1416 = $12;\n  } else {\n   $70 = HEAP32[$11 + 28 >> 2] | 0;\n   $71 = 17708 + ($70 << 2) | 0;\n   do if ((HEAP32[$71 >> 2] | 0) == ($11 | 0)) {\n    HEAP32[$71 >> 2] = $$3;\n    if (!$$3) {\n     HEAP32[4352] = HEAP32[4352] & ~(1 << $70);\n     $$1 = $11;\n     $$1416 = $12;\n     break L1;\n    }\n   } else if ((HEAP32[4355] | 0) >>> 0 > $42 >>> 0) _abort(); else {\n    $80 = $42 + 16 | 0;\n    HEAP32[((HEAP32[$80 >> 2] | 0) == ($11 | 0) ? $80 : $42 + 20 | 0) >> 2] = $$3;\n    if (!$$3) {\n     $$1 = $11;\n     $$1416 = $12;\n     break L1;\n    } else break;\n   } while (0);\n   $85 = HEAP32[4355] | 0;\n   if ($85 >>> 0 > $$3 >>> 0) _abort();\n   HEAP32[$$3 + 24 >> 2] = $42;\n   $88 = $11 + 16 | 0;\n   $89 = HEAP32[$88 >> 2] | 0;\n   do if ($89 | 0) if ($85 >>> 0 > $89 >>> 0) _abort(); else {\n    HEAP32[$$3 + 16 >> 2] = $89;\n    HEAP32[$89 + 24 >> 2] = $$3;\n    break;\n   } while (0);\n   $95 = HEAP32[$88 + 4 >> 2] | 0;\n   if (!$95) {\n    $$1 = $11;\n    $$1416 = $12;\n   } else if ((HEAP32[4355] | 0) >>> 0 > $95 >>> 0) _abort(); else {\n    HEAP32[$$3 + 20 >> 2] = $95;\n    HEAP32[$95 + 24 >> 2] = $$3;\n    $$1 = $11;\n    $$1416 = $12;\n    break;\n   }\n  }\n } else {\n  $$1 = $0;\n  $$1416 = $1;\n } while (0);\n $108 = HEAP32[4355] | 0;\n if ($2 >>> 0 < $108 >>> 0) _abort();\n $110 = $2 + 4 | 0;\n $111 = HEAP32[$110 >> 2] | 0;\n if (!($111 & 2)) {\n  if ((HEAP32[4357] | 0) == ($2 | 0)) {\n   $117 = (HEAP32[4354] | 0) + $$1416 | 0;\n   HEAP32[4354] = $117;\n   HEAP32[4357] = $$1;\n   HEAP32[$$1 + 4 >> 2] = $117 | 1;\n   if (($$1 | 0) != (HEAP32[4356] | 0)) return;\n   HEAP32[4356] = 0;\n   HEAP32[4353] = 0;\n   return;\n  }\n  if ((HEAP32[4356] | 0) == ($2 | 0)) {\n   $125 = (HEAP32[4353] | 0) + $$1416 | 0;\n   HEAP32[4353] = $125;\n   HEAP32[4356] = $$1;\n   HEAP32[$$1 + 4 >> 2] = $125 | 1;\n   HEAP32[$$1 + $125 >> 2] = $125;\n   return;\n  }\n  $130 = ($111 & -8) + $$1416 | 0;\n  $131 = $111 >>> 3;\n  L99 : do if ($111 >>> 0 < 256) {\n   $134 = HEAP32[$2 + 8 >> 2] | 0;\n   $136 = HEAP32[$2 + 12 >> 2] | 0;\n   $138 = 17444 + ($131 << 1 << 2) | 0;\n   if (($134 | 0) != ($138 | 0)) {\n    if ($108 >>> 0 > $134 >>> 0) _abort();\n    if ((HEAP32[$134 + 12 >> 2] | 0) != ($2 | 0)) _abort();\n   }\n   if (($136 | 0) == ($134 | 0)) {\n    HEAP32[4351] = HEAP32[4351] & ~(1 << $131);\n    break;\n   }\n   if (($136 | 0) == ($138 | 0)) $$pre$phi28Z2D = $136 + 8 | 0; else {\n    if ($108 >>> 0 > $136 >>> 0) _abort();\n    $151 = $136 + 8 | 0;\n    if ((HEAP32[$151 >> 2] | 0) == ($2 | 0)) $$pre$phi28Z2D = $151; else _abort();\n   }\n   HEAP32[$134 + 12 >> 2] = $136;\n   HEAP32[$$pre$phi28Z2D >> 2] = $134;\n  } else {\n   $156 = HEAP32[$2 + 24 >> 2] | 0;\n   $158 = HEAP32[$2 + 12 >> 2] | 0;\n   do if (($158 | 0) == ($2 | 0)) {\n    $169 = $2 + 16 | 0;\n    $170 = $169 + 4 | 0;\n    $171 = HEAP32[$170 >> 2] | 0;\n    if (!$171) {\n     $173 = HEAP32[$169 >> 2] | 0;\n     if (!$173) {\n      $$3433 = 0;\n      break;\n     } else {\n      $$1431$ph = $173;\n      $$1435$ph = $169;\n     }\n    } else {\n     $$1431$ph = $171;\n     $$1435$ph = $170;\n    }\n    $$1431 = $$1431$ph;\n    $$1435 = $$1435$ph;\n    while (1) {\n     $175 = $$1431 + 20 | 0;\n     $176 = HEAP32[$175 >> 2] | 0;\n     if (!$176) {\n      $178 = $$1431 + 16 | 0;\n      $179 = HEAP32[$178 >> 2] | 0;\n      if (!$179) break; else {\n       $$1431$be = $179;\n       $$1435$be = $178;\n      }\n     } else {\n      $$1431$be = $176;\n      $$1435$be = $175;\n     }\n     $$1431 = $$1431$be;\n     $$1435 = $$1435$be;\n    }\n    if ($108 >>> 0 > $$1435 >>> 0) _abort(); else {\n     HEAP32[$$1435 >> 2] = 0;\n     $$3433 = $$1431;\n     break;\n    }\n   } else {\n    $161 = HEAP32[$2 + 8 >> 2] | 0;\n    if ($108 >>> 0 > $161 >>> 0) _abort();\n    $163 = $161 + 12 | 0;\n    if ((HEAP32[$163 >> 2] | 0) != ($2 | 0)) _abort();\n    $166 = $158 + 8 | 0;\n    if ((HEAP32[$166 >> 2] | 0) == ($2 | 0)) {\n     HEAP32[$163 >> 2] = $158;\n     HEAP32[$166 >> 2] = $161;\n     $$3433 = $158;\n     break;\n    } else _abort();\n   } while (0);\n   if ($156 | 0) {\n    $184 = HEAP32[$2 + 28 >> 2] | 0;\n    $185 = 17708 + ($184 << 2) | 0;\n    do if ((HEAP32[$185 >> 2] | 0) == ($2 | 0)) {\n     HEAP32[$185 >> 2] = $$3433;\n     if (!$$3433) {\n      HEAP32[4352] = HEAP32[4352] & ~(1 << $184);\n      break L99;\n     }\n    } else if ((HEAP32[4355] | 0) >>> 0 > $156 >>> 0) _abort(); else {\n     $194 = $156 + 16 | 0;\n     HEAP32[((HEAP32[$194 >> 2] | 0) == ($2 | 0) ? $194 : $156 + 20 | 0) >> 2] = $$3433;\n     if (!$$3433) break L99; else break;\n    } while (0);\n    $199 = HEAP32[4355] | 0;\n    if ($199 >>> 0 > $$3433 >>> 0) _abort();\n    HEAP32[$$3433 + 24 >> 2] = $156;\n    $202 = $2 + 16 | 0;\n    $203 = HEAP32[$202 >> 2] | 0;\n    do if ($203 | 0) if ($199 >>> 0 > $203 >>> 0) _abort(); else {\n     HEAP32[$$3433 + 16 >> 2] = $203;\n     HEAP32[$203 + 24 >> 2] = $$3433;\n     break;\n    } while (0);\n    $209 = HEAP32[$202 + 4 >> 2] | 0;\n    if ($209 | 0) if ((HEAP32[4355] | 0) >>> 0 > $209 >>> 0) _abort(); else {\n     HEAP32[$$3433 + 20 >> 2] = $209;\n     HEAP32[$209 + 24 >> 2] = $$3433;\n     break;\n    }\n   }\n  } while (0);\n  HEAP32[$$1 + 4 >> 2] = $130 | 1;\n  HEAP32[$$1 + $130 >> 2] = $130;\n  if (($$1 | 0) == (HEAP32[4356] | 0)) {\n   HEAP32[4353] = $130;\n   return;\n  } else $$2 = $130;\n } else {\n  HEAP32[$110 >> 2] = $111 & -2;\n  HEAP32[$$1 + 4 >> 2] = $$1416 | 1;\n  HEAP32[$$1 + $$1416 >> 2] = $$1416;\n  $$2 = $$1416;\n }\n $224 = $$2 >>> 3;\n if ($$2 >>> 0 < 256) {\n  $227 = 17444 + ($224 << 1 << 2) | 0;\n  $228 = HEAP32[4351] | 0;\n  $229 = 1 << $224;\n  if (!($228 & $229)) {\n   HEAP32[4351] = $228 | $229;\n   $$0436 = $227;\n   $$pre$phiZ2D = $227 + 8 | 0;\n  } else {\n   $233 = $227 + 8 | 0;\n   $234 = HEAP32[$233 >> 2] | 0;\n   if ((HEAP32[4355] | 0) >>> 0 > $234 >>> 0) _abort(); else {\n    $$0436 = $234;\n    $$pre$phiZ2D = $233;\n   }\n  }\n  HEAP32[$$pre$phiZ2D >> 2] = $$1;\n  HEAP32[$$0436 + 12 >> 2] = $$1;\n  HEAP32[$$1 + 8 >> 2] = $$0436;\n  HEAP32[$$1 + 12 >> 2] = $227;\n  return;\n }\n $240 = $$2 >>> 8;\n if (!$240) $$0429 = 0; else if ($$2 >>> 0 > 16777215) $$0429 = 31; else {\n  $245 = ($240 + 1048320 | 0) >>> 16 & 8;\n  $246 = $240 << $245;\n  $249 = ($246 + 520192 | 0) >>> 16 & 4;\n  $251 = $246 << $249;\n  $254 = ($251 + 245760 | 0) >>> 16 & 2;\n  $259 = 14 - ($249 | $245 | $254) + ($251 << $254 >>> 15) | 0;\n  $$0429 = $$2 >>> ($259 + 7 | 0) & 1 | $259 << 1;\n }\n $265 = 17708 + ($$0429 << 2) | 0;\n HEAP32[$$1 + 28 >> 2] = $$0429;\n HEAP32[$$1 + 20 >> 2] = 0;\n HEAP32[$$1 + 16 >> 2] = 0;\n $269 = HEAP32[4352] | 0;\n $270 = 1 << $$0429;\n if (!($269 & $270)) {\n  HEAP32[4352] = $269 | $270;\n  HEAP32[$265 >> 2] = $$1;\n  HEAP32[$$1 + 24 >> 2] = $265;\n  HEAP32[$$1 + 12 >> 2] = $$1;\n  HEAP32[$$1 + 8 >> 2] = $$1;\n  return;\n }\n $277 = HEAP32[$265 >> 2] | 0;\n L189 : do if ((HEAP32[$277 + 4 >> 2] & -8 | 0) == ($$2 | 0)) $$0418$lcssa = $277; else {\n  $$041722 = $$2 << (($$0429 | 0) == 31 ? 0 : 25 - ($$0429 >>> 1) | 0);\n  $$041821 = $277;\n  while (1) {\n   $294 = $$041821 + 16 + ($$041722 >>> 31 << 2) | 0;\n   $289 = HEAP32[$294 >> 2] | 0;\n   if (!$289) break;\n   if ((HEAP32[$289 + 4 >> 2] & -8 | 0) == ($$2 | 0)) {\n    $$0418$lcssa = $289;\n    break L189;\n   } else {\n    $$041722 = $$041722 << 1;\n    $$041821 = $289;\n   }\n  }\n  if ((HEAP32[4355] | 0) >>> 0 > $294 >>> 0) _abort();\n  HEAP32[$294 >> 2] = $$1;\n  HEAP32[$$1 + 24 >> 2] = $$041821;\n  HEAP32[$$1 + 12 >> 2] = $$1;\n  HEAP32[$$1 + 8 >> 2] = $$1;\n  return;\n } while (0);\n $301 = $$0418$lcssa + 8 | 0;\n $302 = HEAP32[$301 >> 2] | 0;\n $303 = HEAP32[4355] | 0;\n if (!($303 >>> 0 <= $302 >>> 0 & $303 >>> 0 <= $$0418$lcssa >>> 0)) _abort();\n HEAP32[$302 + 12 >> 2] = $$1;\n HEAP32[$301 >> 2] = $$1;\n HEAP32[$$1 + 8 >> 2] = $302;\n HEAP32[$$1 + 12 >> 2] = $$0418$lcssa;\n HEAP32[$$1 + 24 >> 2] = 0;\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_118parse_special_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i158 = 0, $$0$i$i$i161 = 0, $$0$i$i$idx$i = 0, $$11 = 0, $$4156 = 0, $$8 = 0, $$8151 = 0, $104 = 0, $105 = 0, $106 = 0, $109 = 0, $113 = 0, $115 = 0, $119 = 0, $124 = 0, $128 = 0, $129 = 0, $133 = 0, $136 = 0, $137 = 0, $141 = 0, $15 = 0, $18 = 0, $19 = 0, $23 = 0, $26 = 0, $27 = 0, $3 = 0, $31 = 0, $34 = 0, $35 = 0, $39 = 0, $4 = 0, $42 = 0, $43 = 0, $47 = 0, $5 = 0, $50 = 0, $51 = 0, $53 = 0, $55 = 0, $59 = 0, $6 = 0, $62 = 0, $63 = 0, $65 = 0, $7 = 0, $70 = 0, $71 = 0, $73 = 0, $74 = 0, $8 = 0, $81 = 0, $93 = 0, $94 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 60 | 0;\n $4 = sp + 48 | 0;\n $5 = sp + 36 | 0;\n $6 = sp + 24 | 0;\n $7 = sp + 12 | 0;\n $8 = sp;\n L1 : do if (($1 - $0 | 0) > 2) {\n  switch (HEAP8[$0 >> 0] | 0) {\n  case 84:\n   break;\n  case 71:\n   {\n    switch (HEAP8[$0 + 1 >> 0] | 0) {\n    case 86:\n     {\n      $128 = $0 + 2 | 0;\n      $129 = __ZN10__cxxabiv112_GLOBAL__N_110parse_nameINS0_2DbEEEPKcS4_S4_RT_($128, $1, $2) | 0;\n      if (($129 | 0) == ($128 | 0)) {\n       $$11 = $0;\n       label = 60;\n       break L1;\n      }\n      $133 = HEAP32[$2 + 4 >> 2] | 0;\n      if ((HEAP32[$2 >> 2] | 0) == ($133 | 0)) {\n       $$8 = $0;\n       break L1;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($133 + -24 | 0, 0, 16949) | 0;\n      $$11 = $129;\n      label = 60;\n      break L1;\n      break;\n     }\n    case 82:\n     {\n      $136 = $0 + 2 | 0;\n      $137 = __ZN10__cxxabiv112_GLOBAL__N_110parse_nameINS0_2DbEEEPKcS4_S4_RT_($136, $1, $2) | 0;\n      if (($137 | 0) == ($136 | 0)) {\n       $$11 = $0;\n       label = 60;\n       break L1;\n      }\n      $141 = HEAP32[$2 + 4 >> 2] | 0;\n      if ((HEAP32[$2 >> 2] | 0) == ($141 | 0)) {\n       $$8 = $0;\n       break L1;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($141 + -24 | 0, 0, 16969) | 0;\n      $$11 = $137;\n      label = 60;\n      break L1;\n      break;\n     }\n    default:\n     {\n      $$11 = $0;\n      label = 60;\n      break L1;\n     }\n    }\n    break;\n   }\n  default:\n   {\n    $$11 = $0;\n    label = 60;\n    break L1;\n   }\n  }\n  $15 = $0 + 1 | 0;\n  switch (HEAP8[$15 >> 0] | 0) {\n  case 86:\n   {\n    $18 = $0 + 2 | 0;\n    $19 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($18, $1, $2) | 0;\n    if (($19 | 0) == ($18 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $23 = HEAP32[$2 + 4 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($23 | 0)) {\n     $$8 = $0;\n     break L1;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($23 + -24 | 0, 0, 16798) | 0;\n    $$11 = $19;\n    label = 60;\n    break L1;\n    break;\n   }\n  case 84:\n   {\n    $26 = $0 + 2 | 0;\n    $27 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($26, $1, $2) | 0;\n    if (($27 | 0) == ($26 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $31 = HEAP32[$2 + 4 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($31 | 0)) {\n     $$8 = $0;\n     break L1;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($31 + -24 | 0, 0, 16810) | 0;\n    $$11 = $27;\n    label = 60;\n    break L1;\n    break;\n   }\n  case 73:\n   {\n    $34 = $0 + 2 | 0;\n    $35 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($34, $1, $2) | 0;\n    if (($35 | 0) == ($34 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $39 = HEAP32[$2 + 4 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($39 | 0)) {\n     $$8 = $0;\n     break L1;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($39 + -24 | 0, 0, 16819) | 0;\n    $$11 = $35;\n    label = 60;\n    break L1;\n    break;\n   }\n  case 83:\n   {\n    $42 = $0 + 2 | 0;\n    $43 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($42, $1, $2) | 0;\n    if (($43 | 0) == ($42 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $47 = HEAP32[$2 + 4 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($47 | 0)) {\n     $$8 = $0;\n     break L1;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($47 + -24 | 0, 0, 16833) | 0;\n    $$11 = $43;\n    label = 60;\n    break L1;\n    break;\n   }\n  case 99:\n   {\n    $50 = $0 + 2 | 0;\n    $51 = __ZN10__cxxabiv112_GLOBAL__N_117parse_call_offsetEPKcS2_($50, $1) | 0;\n    if (($51 | 0) == ($50 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $53 = __ZN10__cxxabiv112_GLOBAL__N_117parse_call_offsetEPKcS2_($51, $1) | 0;\n    if (($53 | 0) == ($51 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $55 = __ZN10__cxxabiv112_GLOBAL__N_114parse_encodingINS0_2DbEEEPKcS4_S4_RT_($53, $1, $2) | 0;\n    if (($55 | 0) == ($53 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $59 = HEAP32[$2 + 4 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($59 | 0)) {\n     $$8 = $0;\n     break L1;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($59 + -24 | 0, 0, 16852) | 0;\n    $$11 = $55;\n    label = 60;\n    break L1;\n    break;\n   }\n  case 67:\n   {\n    $62 = $0 + 2 | 0;\n    $63 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($62, $1, $2) | 0;\n    if (($63 | 0) == ($62 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $65 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($63, $1) | 0;\n    if (($65 | 0) == ($63 | 0) | ($65 | 0) == ($1 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    if ((HEAP8[$65 >> 0] | 0) != 95) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $70 = $65 + 1 | 0;\n    $71 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($70, $1, $2) | 0;\n    if (($71 | 0) == ($70 | 0)) {\n     $$11 = $0;\n     label = 60;\n     break L1;\n    }\n    $73 = $2 + 4 | 0;\n    $74 = HEAP32[$73 >> 2] | 0;\n    if ((($74 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n     $$8 = $0;\n     break L1;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, $74 + -24 | 0);\n    $81 = HEAP32[$73 >> 2] | 0;\n    $$0$i$i$idx$i = 0;\n    while (1) {\n     if (($$0$i$i$idx$i | 0) == -1) break;\n     $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($81 + ($$0$i$i$add$i * 24 | 0) | 0);\n     $$0$i$i$idx$i = $$0$i$i$add$i;\n    }\n    HEAP32[$73 >> 2] = $81 + -24;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($4, 0, 16879) | 0;\n    HEAP32[$7 >> 2] = HEAP32[$4 >> 2];\n    HEAP32[$7 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n    HEAP32[$7 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n    $$0$i$i$i161 = 0;\n    while (1) {\n     if (($$0$i$i$i161 | 0) == 3) break;\n     HEAP32[$4 + ($$0$i$i$i161 << 2) >> 2] = 0;\n     $$0$i$i$i161 = $$0$i$i$i161 + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($7, 16904) | 0;\n    HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n    HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n    HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n    $$0$i$i$i158 = 0;\n    while (1) {\n     if (($$0$i$i$i158 | 0) == 3) break;\n     HEAP32[$7 + ($$0$i$i$i158 << 2) >> 2] = 0;\n     $$0$i$i$i158 = $$0$i$i$i158 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($8, (HEAP32[$73 >> 2] | 0) + -24 | 0);\n    $93 = HEAP8[$8 + 11 >> 0] | 0;\n    $94 = $93 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($6, $94 ? HEAP32[$8 >> 2] | 0 : $8, $94 ? HEAP32[$8 + 4 >> 2] | 0 : $93 & 255) | 0;\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    $104 = HEAP32[$73 >> 2] | 0;\n    $105 = $104 + -24 | 0;\n    $106 = $105 + 11 | 0;\n    if ((HEAP8[$106 >> 0] | 0) < 0) {\n     $109 = HEAP32[$105 >> 2] | 0;\n     HEAP8[$3 >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($109, $3);\n     HEAP32[$104 + -20 >> 2] = 0;\n    } else {\n     HEAP8[$3 >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($105, $3);\n     HEAP8[$106 >> 0] = 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($105);\n    HEAP32[$105 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$105 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$105 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i$i | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    $$11 = $71;\n    label = 60;\n    break L1;\n    break;\n   }\n  default:\n   {\n    $113 = __ZN10__cxxabiv112_GLOBAL__N_117parse_call_offsetEPKcS2_($15, $1) | 0;\n    do if (($113 | 0) == ($15 | 0)) {\n     $$4156 = 3;\n     $$8151 = $0;\n    } else {\n     $115 = __ZN10__cxxabiv112_GLOBAL__N_114parse_encodingINS0_2DbEEEPKcS4_S4_RT_($113, $1, $2) | 0;\n     if (($115 | 0) == ($113 | 0)) {\n      $$4156 = 0;\n      $$8151 = $0;\n     } else {\n      $119 = HEAP32[$2 + 4 >> 2] | 0;\n      if ((HEAP32[$2 >> 2] | 0) == ($119 | 0)) {\n       $$4156 = 1;\n       $$8151 = $0;\n      } else {\n       $124 = $119 + -24 | 0;\n       if ((HEAP8[$0 + 2 >> 0] | 0) == 118) {\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($124, 0, 16909) | 0;\n        $$4156 = 0;\n        $$8151 = $115;\n        break;\n       } else {\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($124, 0, 16927) | 0;\n        $$4156 = 0;\n        $$8151 = $115;\n        break;\n       }\n      }\n     }\n    } while (0);\n    switch ($$4156 & 3) {\n    case 3:\n    case 0:\n     {\n      $$11 = $$8151;\n      label = 60;\n      break L1;\n      break;\n     }\n    default:\n     {}\n    }\n    if (!$$4156) {\n     $$11 = $$8151;\n     label = 60;\n     break L1;\n    } else {\n     $$8 = $0;\n     break L1;\n    }\n   }\n  }\n } else {\n  $$11 = $0;\n  label = 60;\n } while (0);\n if ((label | 0) == 60) $$8 = $$11;\n STACKTOP = sp;\n return $$8 | 0;\n}\n\nfunction ___intscan($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0154215 = 0, $$0157 = 0, $$0159 = 0, $$1155184 = 0, $$1158 = 0, $$1160 = 0, $$1160170 = 0, $$1165 = 0, $$1165168 = 0, $$1165169 = 0, $$2156202 = 0, $$3162208 = 0, $$4163$lcssa = 0, $$6$lcssa = 0, $$7190 = 0, $$8 = 0, $$pre$phi237Z2D = 0, $$pre$phi239Z2D = 0, $104 = 0, $112 = 0, $128 = 0, $130 = 0, $131 = 0, $135 = 0, $136 = 0, $144 = 0, $145 = 0, $150 = 0, $151 = 0, $154 = 0, $156 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $165 = 0, $166 = 0, $167 = 0, $175 = 0, $185 = 0, $186 = 0, $190 = 0, $191 = 0, $199 = 0, $20 = 0, $200 = 0, $206 = 0, $207 = 0, $209 = 0, $21 = 0, $211 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $225 = 0, $226 = 0, $227 = 0, $235 = 0, $243 = 0, $251 = 0, $255 = 0, $265 = 0, $267 = 0, $276 = 0, $277 = 0, $28 = 0, $284 = 0, $286 = 0, $289 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $32 = 0, $40 = 0, $42 = 0, $50 = 0, $54 = 0, $6 = 0, $68 = 0, $7 = 0, $70 = 0, $74 = 0, $75 = 0, $8 = 0, $83 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $93 = 0, $94 = 0, $96 = 0, $spec$select166 = 0, label = 0;\n L1 : do if ($1 >>> 0 > 36) {\n  $6 = ___errno_location() | 0;\n  HEAP32[$6 >> 2] = 22;\n  $291 = 0;\n  $292 = 0;\n } else {\n  $7 = $0 + 4 | 0;\n  $8 = $0 + 100 | 0;\n  do {\n   $9 = HEAP32[$7 >> 2] | 0;\n   if ($9 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n    HEAP32[$7 >> 2] = $9 + 1;\n    $16 = HEAPU8[$9 >> 0] | 0;\n   } else $16 = ___shgetc($0) | 0;\n  } while ((_isspace($16) | 0) != 0);\n  L11 : do switch ($16 | 0) {\n  case 43:\n  case 45:\n   {\n    $20 = (($16 | 0) == 45) << 31 >> 31;\n    $21 = HEAP32[$7 >> 2] | 0;\n    if ($21 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n     HEAP32[$7 >> 2] = $21 + 1;\n     $$0157 = $20;\n     $$0159 = HEAPU8[$21 >> 0] | 0;\n     break L11;\n    } else {\n     $$0157 = $20;\n     $$0159 = ___shgetc($0) | 0;\n     break L11;\n    }\n    break;\n   }\n  default:\n   {\n    $$0157 = 0;\n    $$0159 = $16;\n   }\n  } while (0);\n  $28 = ($1 | 0) == 0;\n  do if (($1 | 16 | 0) == 16 & ($$0159 | 0) == 48) {\n   $32 = HEAP32[$7 >> 2] | 0;\n   if ($32 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n    HEAP32[$7 >> 2] = $32 + 1;\n    $40 = HEAPU8[$32 >> 0] | 0;\n   } else $40 = ___shgetc($0) | 0;\n   if (($40 | 32 | 0) != 120) if ($28) {\n    $$1160170 = $40;\n    $$1165168 = 8;\n    label = 47;\n    break;\n   } else {\n    $$1160 = $40;\n    $$1165 = $1;\n    label = 32;\n    break;\n   }\n   $42 = HEAP32[$7 >> 2] | 0;\n   if ($42 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n    HEAP32[$7 >> 2] = $42 + 1;\n    $50 = HEAPU8[$42 >> 0] | 0;\n   } else $50 = ___shgetc($0) | 0;\n   if ((HEAPU8[11773 + $50 >> 0] | 0) > 15) {\n    $54 = (HEAP32[$8 >> 2] | 0) == 0;\n    if (!$54) HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + -1;\n    if (!$2) {\n     ___shlim($0, 0);\n     $291 = 0;\n     $292 = 0;\n     break L1;\n    }\n    if ($54) {\n     $291 = 0;\n     $292 = 0;\n     break L1;\n    }\n    HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + -1;\n    $291 = 0;\n    $292 = 0;\n    break L1;\n   } else {\n    $$1160170 = $50;\n    $$1165168 = 16;\n    label = 47;\n   }\n  } else {\n   $spec$select166 = $28 ? 10 : $1;\n   if ($spec$select166 >>> 0 > (HEAPU8[11773 + $$0159 >> 0] | 0) >>> 0) {\n    $$1160 = $$0159;\n    $$1165 = $spec$select166;\n    label = 32;\n   } else {\n    if (HEAP32[$8 >> 2] | 0) HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + -1;\n    ___shlim($0, 0);\n    $68 = ___errno_location() | 0;\n    HEAP32[$68 >> 2] = 22;\n    $291 = 0;\n    $292 = 0;\n    break L1;\n   }\n  } while (0);\n  L43 : do if ((label | 0) == 32) if (($$1165 | 0) == 10) {\n   $70 = $$1160 + -48 | 0;\n   if ($70 >>> 0 < 10) {\n    $$0154215 = 0;\n    $74 = $70;\n    do {\n     $$0154215 = ($$0154215 * 10 | 0) + $74 | 0;\n     $75 = HEAP32[$7 >> 2] | 0;\n     if ($75 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n      HEAP32[$7 >> 2] = $75 + 1;\n      $83 = HEAPU8[$75 >> 0] | 0;\n     } else $83 = ___shgetc($0) | 0;\n     $74 = $83 + -48 | 0;\n    } while ($74 >>> 0 < 10 & $$0154215 >>> 0 < 429496729);\n    if ($74 >>> 0 < 10) {\n     $$3162208 = $83;\n     $88 = $$0154215;\n     $89 = 0;\n     $93 = $74;\n     while (1) {\n      $90 = ___muldi3($88 | 0, $89 | 0, 10, 0) | 0;\n      $91 = tempRet0;\n      $94 = (($93 | 0) < 0) << 31 >> 31;\n      $96 = ~$94;\n      if ($91 >>> 0 > $96 >>> 0 | ($91 | 0) == ($96 | 0) & $90 >>> 0 > ~$93 >>> 0) {\n       $$1165169 = 10;\n       $$8 = $$3162208;\n       $293 = $88;\n       $294 = $89;\n       label = 76;\n       break L43;\n      }\n      $88 = _i64Add($90 | 0, $91 | 0, $93 | 0, $94 | 0) | 0;\n      $89 = tempRet0;\n      $104 = HEAP32[$7 >> 2] | 0;\n      if ($104 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n       HEAP32[$7 >> 2] = $104 + 1;\n       $112 = HEAPU8[$104 >> 0] | 0;\n      } else $112 = ___shgetc($0) | 0;\n      $93 = $112 + -48 | 0;\n      if (!($93 >>> 0 < 10 & ($89 >>> 0 < 429496729 | ($89 | 0) == 429496729 & $88 >>> 0 < 2576980378))) break; else $$3162208 = $112;\n     }\n     if ($93 >>> 0 > 9) {\n      $$1158 = $$0157;\n      $265 = $89;\n      $267 = $88;\n     } else {\n      $$1165169 = 10;\n      $$8 = $112;\n      $293 = $88;\n      $294 = $89;\n      label = 76;\n     }\n    } else {\n     $$1158 = $$0157;\n     $265 = 0;\n     $267 = $$0154215;\n    }\n   } else {\n    $$1158 = $$0157;\n    $265 = 0;\n    $267 = 0;\n   }\n  } else {\n   $$1160170 = $$1160;\n   $$1165168 = $$1165;\n   label = 47;\n  } while (0);\n  L63 : do if ((label | 0) == 47) {\n   if (!($$1165168 + -1 & $$1165168)) {\n    $128 = HEAP8[12029 + (($$1165168 * 23 | 0) >>> 5 & 7) >> 0] | 0;\n    $130 = HEAP8[11773 + $$1160170 >> 0] | 0;\n    $131 = $130 & 255;\n    if ($$1165168 >>> 0 > $131 >>> 0) {\n     $$1155184 = 0;\n     $135 = $131;\n     do {\n      $$1155184 = $135 | $$1155184 << $128;\n      $136 = HEAP32[$7 >> 2] | 0;\n      if ($136 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n       HEAP32[$7 >> 2] = $136 + 1;\n       $144 = HEAPU8[$136 >> 0] | 0;\n      } else $144 = ___shgetc($0) | 0;\n      $145 = HEAP8[11773 + $144 >> 0] | 0;\n      $135 = $145 & 255;\n     } while ($$1155184 >>> 0 < 134217728 & $$1165168 >>> 0 > $135 >>> 0);\n     $$4163$lcssa = $144;\n     $$pre$phi237Z2D = $135;\n     $154 = 0;\n     $156 = $$1155184;\n     $295 = $145;\n    } else {\n     $$4163$lcssa = $$1160170;\n     $$pre$phi237Z2D = $131;\n     $154 = 0;\n     $156 = 0;\n     $295 = $130;\n    }\n    $150 = _bitshift64Lshr(-1, -1, $128 | 0) | 0;\n    $151 = tempRet0;\n    if ($$1165168 >>> 0 <= $$pre$phi237Z2D >>> 0 | ($151 >>> 0 < $154 >>> 0 | ($151 | 0) == ($154 | 0) & $150 >>> 0 < $156 >>> 0)) {\n     $$1165169 = $$1165168;\n     $$8 = $$4163$lcssa;\n     $293 = $156;\n     $294 = $154;\n     label = 76;\n     break;\n    }\n    $160 = $156;\n    $161 = $154;\n    $165 = $295;\n    while (1) {\n     $162 = _bitshift64Shl($160 | 0, $161 | 0, $128 | 0) | 0;\n     $163 = tempRet0;\n     $166 = $162 | $165 & 255;\n     $167 = HEAP32[$7 >> 2] | 0;\n     if ($167 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n      HEAP32[$7 >> 2] = $167 + 1;\n      $175 = HEAPU8[$167 >> 0] | 0;\n     } else $175 = ___shgetc($0) | 0;\n     $165 = HEAP8[11773 + $175 >> 0] | 0;\n     if ($$1165168 >>> 0 <= ($165 & 255) >>> 0 | ($163 >>> 0 > $151 >>> 0 | ($163 | 0) == ($151 | 0) & $166 >>> 0 > $150 >>> 0)) {\n      $$1165169 = $$1165168;\n      $$8 = $175;\n      $293 = $166;\n      $294 = $163;\n      label = 76;\n      break L63;\n     } else {\n      $160 = $166;\n      $161 = $163;\n     }\n    }\n   }\n   $185 = HEAP8[11773 + $$1160170 >> 0] | 0;\n   $186 = $185 & 255;\n   if ($$1165168 >>> 0 > $186 >>> 0) {\n    $$2156202 = 0;\n    $190 = $186;\n    do {\n     $$2156202 = $190 + (Math_imul($$2156202, $$1165168) | 0) | 0;\n     $191 = HEAP32[$7 >> 2] | 0;\n     if ($191 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n      HEAP32[$7 >> 2] = $191 + 1;\n      $199 = HEAPU8[$191 >> 0] | 0;\n     } else $199 = ___shgetc($0) | 0;\n     $200 = HEAP8[11773 + $199 >> 0] | 0;\n     $190 = $200 & 255;\n    } while ($$2156202 >>> 0 < 119304647 & $$1165168 >>> 0 > $190 >>> 0);\n    $$6$lcssa = $199;\n    $$pre$phi239Z2D = $190;\n    $296 = $200;\n    $297 = $$2156202;\n    $298 = 0;\n   } else {\n    $$6$lcssa = $$1160170;\n    $$pre$phi239Z2D = $186;\n    $296 = $185;\n    $297 = 0;\n    $298 = 0;\n   }\n   if ($$1165168 >>> 0 > $$pre$phi239Z2D >>> 0) {\n    $206 = ___udivdi3(-1, -1, $$1165168 | 0, 0) | 0;\n    $207 = tempRet0;\n    $$7190 = $$6$lcssa;\n    $209 = $298;\n    $211 = $297;\n    $218 = $296;\n    while (1) {\n     if ($209 >>> 0 > $207 >>> 0 | ($209 | 0) == ($207 | 0) & $211 >>> 0 > $206 >>> 0) {\n      $$1165169 = $$1165168;\n      $$8 = $$7190;\n      $293 = $211;\n      $294 = $209;\n      label = 76;\n      break L63;\n     }\n     $215 = ___muldi3($211 | 0, $209 | 0, $$1165168 | 0, 0) | 0;\n     $216 = tempRet0;\n     $217 = $218 & 255;\n     if ($216 >>> 0 > 4294967295 | ($216 | 0) == -1 & $215 >>> 0 > ~$217 >>> 0) {\n      $$1165169 = $$1165168;\n      $$8 = $$7190;\n      $293 = $211;\n      $294 = $209;\n      label = 76;\n      break L63;\n     }\n     $225 = _i64Add($215 | 0, $216 | 0, $217 | 0, 0) | 0;\n     $226 = tempRet0;\n     $227 = HEAP32[$7 >> 2] | 0;\n     if ($227 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n      HEAP32[$7 >> 2] = $227 + 1;\n      $235 = HEAPU8[$227 >> 0] | 0;\n     } else $235 = ___shgetc($0) | 0;\n     $218 = HEAP8[11773 + $235 >> 0] | 0;\n     if ($$1165168 >>> 0 <= ($218 & 255) >>> 0) {\n      $$1165169 = $$1165168;\n      $$8 = $235;\n      $293 = $225;\n      $294 = $226;\n      label = 76;\n      break;\n     } else {\n      $$7190 = $235;\n      $209 = $226;\n      $211 = $225;\n     }\n    }\n   } else {\n    $$1165169 = $$1165168;\n    $$8 = $$6$lcssa;\n    $293 = $297;\n    $294 = $298;\n    label = 76;\n   }\n  } while (0);\n  if ((label | 0) == 76) if ($$1165169 >>> 0 > (HEAPU8[11773 + $$8 >> 0] | 0) >>> 0) {\n   do {\n    $243 = HEAP32[$7 >> 2] | 0;\n    if ($243 >>> 0 < (HEAP32[$8 >> 2] | 0) >>> 0) {\n     HEAP32[$7 >> 2] = $243 + 1;\n     $251 = HEAPU8[$243 >> 0] | 0;\n    } else $251 = ___shgetc($0) | 0;\n   } while ($$1165169 >>> 0 > (HEAPU8[11773 + $251 >> 0] | 0) >>> 0);\n   $255 = ___errno_location() | 0;\n   HEAP32[$255 >> 2] = 34;\n   $$1158 = ($3 & 1 | 0) == 0 & 0 == 0 ? $$0157 : 0;\n   $265 = $4;\n   $267 = $3;\n  } else {\n   $$1158 = $$0157;\n   $265 = $294;\n   $267 = $293;\n  }\n  if (HEAP32[$8 >> 2] | 0) HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + -1;\n  if (!($265 >>> 0 < $4 >>> 0 | ($265 | 0) == ($4 | 0) & $267 >>> 0 < $3 >>> 0)) {\n   if (!(($3 & 1 | 0) != 0 | 0 != 0 | ($$1158 | 0) != 0)) {\n    $276 = ___errno_location() | 0;\n    HEAP32[$276 >> 2] = 34;\n    $277 = _i64Add($3 | 0, $4 | 0, -1, -1) | 0;\n    $291 = tempRet0;\n    $292 = $277;\n    break;\n   }\n   if ($265 >>> 0 > $4 >>> 0 | ($265 | 0) == ($4 | 0) & $267 >>> 0 > $3 >>> 0) {\n    $284 = ___errno_location() | 0;\n    HEAP32[$284 >> 2] = 34;\n    $291 = $4;\n    $292 = $3;\n    break;\n   }\n  }\n  $286 = (($$1158 | 0) < 0) << 31 >> 31;\n  $289 = _i64Subtract($267 ^ $$1158 | 0, $265 ^ $286 | 0, $$1158 | 0, $286 | 0) | 0;\n  $291 = tempRet0;\n  $292 = $289;\n } while (0);\n tempRet0 = $291;\n return $292 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_128parse_pointer_to_member_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i$i63 = 0, $$0$i$i$i$i80 = 0, $$0$i$i$i$i85 = 0, $$0$i$i$i51 = 0, $$0$i$i$i54 = 0, $$0$i$i$i58 = 0, $$0$i$i$i66 = 0, $$0$i$i$i70 = 0, $$0$i$i$i74 = 0, $$0$i$i$idx$i = 0, $$345 = 0, $100 = 0, $104 = 0, $105 = 0, $106 = 0, $109 = 0, $13 = 0, $14 = 0, $16 = 0, $18 = 0, $19 = 0, $26 = 0, $3 = 0, $30 = 0, $4 = 0, $42 = 0, $43 = 0, $5 = 0, $56 = 0, $57 = 0, $58 = 0, $6 = 0, $61 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $73 = 0, $8 = 0, $81 = 0, $82 = 0, $9 = 0, $95 = 0, $96 = 0, $97 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 112 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112);\n $3 = sp + 96 | 0;\n $4 = sp + 72 | 0;\n $5 = sp + 48 | 0;\n $6 = sp + 36 | 0;\n $7 = sp + 24 | 0;\n $8 = sp + 12 | 0;\n $9 = sp;\n if (($0 | 0) == ($1 | 0)) $$345 = $0; else if ((HEAP8[$0 >> 0] | 0) == 77) {\n  $13 = $0 + 1 | 0;\n  $14 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($13, $1, $2) | 0;\n  if (($14 | 0) == ($13 | 0)) $$345 = $0; else {\n   $16 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($14, $1, $2) | 0;\n   if (($16 | 0) == ($14 | 0)) $$345 = $0; else {\n    $18 = $2 + 4 | 0;\n    $19 = HEAP32[$18 >> 2] | 0;\n    if ((($19 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$345 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($4, $19 + -24 | 0);\n     $26 = HEAP32[$18 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($26 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$18 >> 2] = $26 + -24;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($5, $26 + -48 | 0);\n     $30 = $4 + 12 | 0;\n     L11 : do if ((HEAP8[((HEAP8[$30 + 11 >> 0] | 0) < 0 ? HEAP32[$30 >> 2] | 0 : $30) >> 0] | 0) == 40) {\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15119) | 0;\n      HEAP32[$8 >> 2] = HEAP32[$4 >> 2];\n      HEAP32[$8 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n      HEAP32[$8 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n      $$0$i$i$i = 0;\n      while (1) {\n       if (($$0$i$i$i | 0) == 3) break;\n       HEAP32[$4 + ($$0$i$i$i << 2) >> 2] = 0;\n       $$0$i$i$i = $$0$i$i$i + 1 | 0;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($9, $5);\n      $42 = HEAP8[$9 + 11 >> 0] | 0;\n      $43 = $42 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($8, $43 ? HEAP32[$9 >> 2] | 0 : $9, $43 ? HEAP32[$9 + 4 >> 2] | 0 : $42 & 255) | 0;\n      HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n      HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n      HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n      $$0$i$i$i51 = 0;\n      while (1) {\n       if (($$0$i$i$i51 | 0) == 3) break;\n       HEAP32[$8 + ($$0$i$i$i51 << 2) >> 2] = 0;\n       $$0$i$i$i51 = $$0$i$i$i51 + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($7, 16541) | 0;\n      HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n      HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n      HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n      $$0$i$i$i54 = 0;\n      while (1) {\n       if (($$0$i$i$i54 | 0) == 3) break;\n       HEAP32[$7 + ($$0$i$i$i54 << 2) >> 2] = 0;\n       $$0$i$i$i54 = $$0$i$i$i54 + 1 | 0;\n      }\n      $56 = HEAP32[$18 >> 2] | 0;\n      $57 = $56 + -24 | 0;\n      $58 = $57 + 11 | 0;\n      if ((HEAP8[$58 >> 0] | 0) < 0) {\n       $61 = HEAP32[$57 >> 2] | 0;\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($61, $3);\n       HEAP32[$56 + -20 >> 2] = 0;\n      } else {\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($57, $3);\n       HEAP8[$58 >> 0] = 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($57);\n      HEAP32[$57 >> 2] = HEAP32[$6 >> 2];\n      HEAP32[$57 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n      HEAP32[$57 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n      $$0$i$i$i$i = 0;\n      while (1) {\n       if (($$0$i$i$i$i | 0) == 3) break;\n       HEAP32[$6 + ($$0$i$i$i$i << 2) >> 2] = 0;\n       $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($30, 0, 15117) | 0;\n      HEAP32[$6 >> 2] = HEAP32[$30 >> 2];\n      HEAP32[$6 + 4 >> 2] = HEAP32[$30 + 4 >> 2];\n      HEAP32[$6 + 8 >> 2] = HEAP32[$30 + 8 >> 2];\n      $$0$i$i$i58 = 0;\n      while (1) {\n       if (($$0$i$i$i58 | 0) == 3) break;\n       HEAP32[$30 + ($$0$i$i$i58 << 2) >> 2] = 0;\n       $$0$i$i$i58 = $$0$i$i$i58 + 1 | 0;\n      }\n      $68 = HEAP32[$18 >> 2] | 0;\n      $69 = $68 + -12 | 0;\n      $70 = $69 + 11 | 0;\n      if ((HEAP8[$70 >> 0] | 0) < 0) {\n       $73 = HEAP32[$69 >> 2] | 0;\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($73, $3);\n       HEAP32[$68 + -8 >> 2] = 0;\n      } else {\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($69, $3);\n       HEAP8[$70 >> 0] = 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($69);\n      HEAP32[$69 >> 2] = HEAP32[$6 >> 2];\n      HEAP32[$69 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n      HEAP32[$69 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n      $$0$i$i$i$i63 = 0;\n      while (1) {\n       if (($$0$i$i$i$i63 | 0) == 3) break;\n       HEAP32[$6 + ($$0$i$i$i$i63 << 2) >> 2] = 0;\n       $$0$i$i$i$i63 = $$0$i$i$i$i63 + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n     } else {\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15151) | 0;\n      HEAP32[$8 >> 2] = HEAP32[$4 >> 2];\n      HEAP32[$8 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n      HEAP32[$8 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n      $$0$i$i$i66 = 0;\n      while (1) {\n       if (($$0$i$i$i66 | 0) == 3) break;\n       HEAP32[$4 + ($$0$i$i$i66 << 2) >> 2] = 0;\n       $$0$i$i$i66 = $$0$i$i$i66 + 1 | 0;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($9, $5);\n      $81 = HEAP8[$9 + 11 >> 0] | 0;\n      $82 = $81 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($8, $82 ? HEAP32[$9 >> 2] | 0 : $9, $82 ? HEAP32[$9 + 4 >> 2] | 0 : $81 & 255) | 0;\n      HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n      HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n      HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n      $$0$i$i$i70 = 0;\n      while (1) {\n       if (($$0$i$i$i70 | 0) == 3) break;\n       HEAP32[$8 + ($$0$i$i$i70 << 2) >> 2] = 0;\n       $$0$i$i$i70 = $$0$i$i$i70 + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($7, 16541) | 0;\n      HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n      HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n      HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n      $$0$i$i$i74 = 0;\n      while (1) {\n       if (($$0$i$i$i74 | 0) == 3) break;\n       HEAP32[$7 + ($$0$i$i$i74 << 2) >> 2] = 0;\n       $$0$i$i$i74 = $$0$i$i$i74 + 1 | 0;\n      }\n      $95 = HEAP32[$18 >> 2] | 0;\n      $96 = $95 + -24 | 0;\n      $97 = $96 + 11 | 0;\n      if ((HEAP8[$97 >> 0] | 0) < 0) {\n       $100 = HEAP32[$96 >> 2] | 0;\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($100, $3);\n       HEAP32[$95 + -20 >> 2] = 0;\n      } else {\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($96, $3);\n       HEAP8[$97 >> 0] = 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($96);\n      HEAP32[$96 >> 2] = HEAP32[$6 >> 2];\n      HEAP32[$96 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n      HEAP32[$96 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n      $$0$i$i$i$i80 = 0;\n      while (1) {\n       if (($$0$i$i$i$i80 | 0) == 3) break;\n       HEAP32[$6 + ($$0$i$i$i$i80 << 2) >> 2] = 0;\n       $$0$i$i$i$i80 = $$0$i$i$i$i80 + 1 | 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n      $104 = HEAP32[$18 >> 2] | 0;\n      $105 = $104 + -12 | 0;\n      $106 = $105 + 11 | 0;\n      if ((HEAP8[$106 >> 0] | 0) < 0) {\n       $109 = HEAP32[$105 >> 2] | 0;\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($109, $3);\n       HEAP32[$104 + -8 >> 2] = 0;\n      } else {\n       HEAP8[$3 >> 0] = 0;\n       __ZNSt3__211char_traitsIcE6assignERcRKc($105, $3);\n       HEAP8[$106 >> 0] = 0;\n      }\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($105);\n      HEAP32[$105 >> 2] = HEAP32[$30 >> 2];\n      HEAP32[$105 + 4 >> 2] = HEAP32[$30 + 4 >> 2];\n      HEAP32[$105 + 8 >> 2] = HEAP32[$30 + 8 >> 2];\n      $$0$i$i$i$i85 = 0;\n      while (1) {\n       if (($$0$i$i$i$i85 | 0) == 3) break L11;\n       HEAP32[$30 + ($$0$i$i$i$i85 << 2) >> 2] = 0;\n       $$0$i$i$i$i85 = $$0$i$i$i$i85 + 1 | 0;\n      }\n     } while (0);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($5);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n     $$345 = $16;\n    }\n   }\n  }\n } else $$345 = $0;\n STACKTOP = sp;\n return $$345 | 0;\n}\n\nfunction _decode_bch($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$ = 0, $$0 = 0, $$0235 = 0, $$0237 = 0, $$0238 = 0, $$0240 = 0, $$0242 = 0, $$0245 = 0, $$0251 = 0, $$0253 = 0, $$0259 = 0, $$0261 = 0, $$0268 = 0, $$10 = 0, $$11 = 0, $$12 = 0, $$1236 = 0, $$1239 = 0, $$1241 = 0, $$1243 = 0, $$1246 = 0, $$1252 = 0, $$1254 = 0, $$1256 = 0, $$1260 = 0, $$1262 = 0, $$1264 = 0, $$2 = 0, $$2244 = 0, $$2247 = 0, $$2257 = 0, $$2265 = 0, $$3 = 0, $$3248 = 0, $$3258 = 0, $$3266 = 0, $$4 = 0, $$4249 = 0, $$5 = 0, $$5250 = 0, $$6 = 0, $$7 = 0, $$8 = 0, $$9 = 0, $$pre$phiZ2D = 0, $$pre280 = 0, $$sink = 0, $10 = 0, $105 = 0, $106 = 0, $107 = 0, $11 = 0, $114 = 0, $118 = 0, $12 = 0, $122 = 0, $126 = 0, $129 = 0, $137 = 0, $138 = 0, $14 = 0, $145 = 0, $157 = 0, $158 = 0, $161 = 0, $17 = 0, $175 = 0, $179 = 0, $18 = 0, $188 = 0, $189 = 0, $190 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $200 = 0, $205 = 0, $206 = 0, $21 = 0, $23 = 0, $30 = 0, $32 = 0, $33 = 0, $39 = 0, $41 = 0, $5 = 0, $52 = 0, $53 = 0, $55 = 0, $57 = 0, $58 = 0, $6 = 0, $66 = 0, $7 = 0, $79 = 0, $8 = 0, $81 = 0, $82 = 0, $84 = 0, $89 = 0, $9 = 0, $90 = 0, $93 = 0, label = 0, sp = 0, $$1243$looptemp = 0, $$0240$looptemp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 2368 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(2368);\n $5 = sp + 2304 | 0;\n $6 = sp + 864 | 0;\n $7 = sp + 784 | 0;\n $8 = sp + 704 | 0;\n $9 = sp + 624 | 0;\n $10 = sp + 548 | 0;\n $11 = sp + 40 | 0;\n $12 = sp;\n switch ($0 | 0) {\n case 2830:\n  {\n   $$0268 = $3;\n   $$1252 = 1392;\n   $$1254 = 884;\n   $$1260 = 120;\n   $$1262 = 127;\n   $$3258 = 64;\n   $$3266 = 9;\n   label = 8;\n   break;\n  }\n case 772:\n  {\n   $$0251 = 820;\n   $$0253 = 632;\n   $$0259 = 13;\n   $$0261 = 15;\n   $$2257 = 9;\n   $$2265 = 1;\n   label = 5;\n   break;\n  }\n case 1028:\n  {\n   $$0251 = 820;\n   $$0253 = 632;\n   $$0259 = 13;\n   $$0261 = 15;\n   $$2257 = 5;\n   $$2265 = 2;\n   label = 5;\n   break;\n  }\n case 1029:\n  {\n   $$1256 = 12;\n   $$1264 = 2;\n   label = 4;\n   break;\n  }\n case 1285:\n  {\n   $$1256 = 7;\n   $$1264 = 3;\n   label = 4;\n   break;\n  }\n default:\n  $$0237 = -1;\n }\n if ((label | 0) == 4) {\n  $$0251 = 692;\n  $$0253 = 508;\n  $$0259 = 22;\n  $$0261 = 31;\n  $$2257 = $$1256;\n  $$2265 = $$1264;\n  label = 5;\n }\n L6 : do if ((label | 0) == 5) {\n  $$0245 = 0;\n  $14 = $1;\n  $17 = $2;\n  while (1) {\n   if (($$0245 | 0) == ($$0259 | 0)) {\n    $$0268 = $5;\n    $$1252 = $$0251;\n    $$1254 = $$0253;\n    $$1260 = $$0259;\n    $$1262 = $$0261;\n    $$3258 = $$2257;\n    $$3266 = $$2265;\n    label = 8;\n    break L6;\n   }\n   HEAP8[$5 + $$0245 >> 0] = $14 & 1;\n   $18 = _bitshift64Lshr($14 | 0, $17 | 0, 1) | 0;\n   $$0245 = $$0245 + 1 | 0;\n   $14 = $18;\n   $17 = tempRet0;\n  }\n } while (0);\n L11 : do if ((label | 0) == 8) {\n  $21 = $$3266 << 1;\n  $$0 = 0;\n  $$1246 = 1;\n  while (1) {\n   if (($$1246 | 0) > ($21 | 0)) break;\n   $23 = $10 + ($$1246 << 2) | 0;\n   HEAP32[$23 >> 2] = 0;\n   $$0242 = 0;\n   $33 = 0;\n   while (1) {\n    if (($$0242 | 0) >= ($$1260 | 0)) break;\n    if (!(HEAP8[$$0268 + $$0242 >> 0] | 0)) $205 = $33; else {\n     $30 = $$1254 + (((Math_imul($$0242, $$1246) | 0) % ($$1262 | 0) | 0) << 2) | 0;\n     $32 = $33 ^ HEAP32[$30 >> 2];\n     HEAP32[$23 >> 2] = $32;\n     $205 = $32;\n    }\n    $$0242 = $$0242 + 1 | 0;\n    $33 = $205;\n   }\n   HEAP32[$23 >> 2] = HEAP32[$$1252 + ($33 << 2) >> 2];\n   $$0 = ($33 | 0) == 0 ? $$0 : 1;\n   $$1246 = $$1246 + 1 | 0;\n  }\n  $39 = ($$0 | 0) != 0;\n  L24 : do if ($39) {\n   HEAP32[$7 >> 2] = 0;\n   $41 = HEAP32[$10 + 4 >> 2] | 0;\n   HEAP32[$7 + 4 >> 2] = $41;\n   HEAP32[$6 >> 2] = 0;\n   HEAP32[$6 + 72 >> 2] = 1;\n   $$2247 = 1;\n   while (1) {\n    if (($$2247 | 0) >= ($21 | 0)) break;\n    HEAP32[$6 + ($$2247 << 2) >> 2] = -1;\n    HEAP32[$6 + 72 + ($$2247 << 2) >> 2] = 0;\n    $$2247 = $$2247 + 1 | 0;\n   }\n   HEAP32[$8 >> 2] = 0;\n   HEAP32[$8 + 4 >> 2] = 0;\n   HEAP32[$9 >> 2] = -1;\n   HEAP32[$9 + 4 >> 2] = 0;\n   $$0240 = 0;\n   $52 = $41;\n   $55 = 0;\n   while (1) {\n    $$0240$looptemp = $$0240;\n    $$0240 = $$0240 + 1 | 0;\n    L32 : do if (($52 | 0) == -1) {\n     $53 = $$0240$looptemp + 2 | 0;\n     HEAP32[$8 + ($53 << 2) >> 2] = $55;\n     $$3248 = 0;\n     while (1) {\n      if (($$3248 | 0) > ($55 | 0)) {\n       $$pre$phiZ2D = $53;\n       $114 = $55;\n       break L32;\n      }\n      $57 = $6 + ($$0240 * 72 | 0) + ($$3248 << 2) | 0;\n      $58 = HEAP32[$57 >> 2] | 0;\n      HEAP32[$6 + ($53 * 72 | 0) + ($$3248 << 2) >> 2] = $58;\n      HEAP32[$57 >> 2] = HEAP32[$$1252 + ($58 << 2) >> 2];\n      $$3248 = $$3248 + 1 | 0;\n     }\n    } else {\n     $$0238 = $$0240$looptemp;\n     while (1) {\n      $66 = ($$0238 | 0) > 0;\n      if ($66 & (HEAP32[$7 + ($$0238 << 2) >> 2] | 0) == -1) $$0238 = $$0238 + -1 | 0; else break;\n     }\n     if ($66) {\n      $$1239 = $$0238;\n      $$1243 = $$0238;\n      while (1) {\n       $$1243$looptemp = $$1243;\n       $$1243 = $$1243 + -1 | 0;\n       if ((HEAP32[$7 + ($$1243 << 2) >> 2] | 0) == -1) $$2 = $$1239; else $$2 = (HEAP32[$9 + ($$1239 << 2) >> 2] | 0) < (HEAP32[$9 + ($$1243 << 2) >> 2] | 0) ? $$1243 : $$1239;\n       if (($$1243$looptemp | 0) <= 1) {\n        $$3 = $$2;\n        break;\n       } else $$1239 = $$2;\n      }\n     } else $$3 = $$0238;\n     $79 = $8 + ($$3 << 2) | 0;\n     $81 = $$0240 - $$3 | 0;\n     $82 = $81 + (HEAP32[$79 >> 2] | 0) | 0;\n     $84 = $$0240$looptemp + 2 | 0;\n     $$ = ($55 | 0) > ($82 | 0) ? $55 : $82;\n     HEAP32[$8 + ($84 << 2) >> 2] = $$;\n     $$4249 = 0;\n     while (1) {\n      if (($$4249 | 0) >= ($21 | 0)) break;\n      HEAP32[$6 + ($84 * 72 | 0) + ($$4249 << 2) >> 2] = 0;\n      $$4249 = $$4249 + 1 | 0;\n     }\n     $89 = $52 + $$1262 | 0;\n     $90 = $7 + ($$3 << 2) | 0;\n     $$pre280 = HEAP32[$79 >> 2] | 0;\n     $$5250 = 0;\n     while (1) {\n      if (($$5250 | 0) > ($$pre280 | 0)) break;\n      $93 = HEAP32[$6 + ($$3 * 72 | 0) + ($$5250 << 2) >> 2] | 0;\n      if (($93 | 0) != -1) HEAP32[$6 + ($84 * 72 | 0) + ($81 + $$5250 << 2) >> 2] = HEAP32[$$1254 + ((($89 + $93 - (HEAP32[$90 >> 2] | 0) | 0) % ($$1262 | 0) | 0) << 2) >> 2];\n      $$5250 = $$5250 + 1 | 0;\n     }\n     $$6 = 0;\n     while (1) {\n      if (($$6 | 0) > ($55 | 0)) {\n       $$pre$phiZ2D = $84;\n       $114 = $$;\n       break L32;\n      }\n      $105 = $6 + ($$0240 * 72 | 0) + ($$6 << 2) | 0;\n      $106 = HEAP32[$105 >> 2] | 0;\n      $107 = $6 + ($84 * 72 | 0) + ($$6 << 2) | 0;\n      HEAP32[$107 >> 2] = HEAP32[$107 >> 2] ^ $106;\n      HEAP32[$105 >> 2] = HEAP32[$$1252 + ($106 << 2) >> 2];\n      $$6 = $$6 + 1 | 0;\n     }\n    } while (0);\n    HEAP32[$9 + ($$pre$phiZ2D << 2) >> 2] = $$0240 - $114;\n    if (($$0240 | 0) >= ($21 | 0)) break;\n    $118 = HEAP32[$10 + ($$pre$phiZ2D << 2) >> 2] | 0;\n    if (($118 | 0) == -1) $$sink = 0; else $$sink = HEAP32[$$1254 + ($118 << 2) >> 2] | 0;\n    $122 = $7 + ($$pre$phiZ2D << 2) | 0;\n    HEAP32[$122 >> 2] = $$sink;\n    $$7 = 1;\n    $138 = $$sink;\n    while (1) {\n     if (($$7 | 0) > ($114 | 0)) break;\n     $126 = HEAP32[$10 + ($$pre$phiZ2D - $$7 << 2) >> 2] | 0;\n     if (($126 | 0) == -1) $206 = $138; else {\n      $129 = HEAP32[$6 + ($$pre$phiZ2D * 72 | 0) + ($$7 << 2) >> 2] | 0;\n      if (!$129) $206 = $138; else {\n       $137 = $138 ^ HEAP32[$$1254 + ((((HEAP32[$$1252 + ($129 << 2) >> 2] | 0) + $126 | 0) % ($$1262 | 0) | 0) << 2) >> 2];\n       HEAP32[$122 >> 2] = $137;\n       $206 = $137;\n      }\n     }\n     $$7 = $$7 + 1 | 0;\n     $138 = $206;\n    }\n    $52 = HEAP32[$$1252 + ($138 << 2) >> 2] | 0;\n    HEAP32[$122 >> 2] = $52;\n    if (($114 | 0) > ($$3266 | 0)) break; else $55 = $114;\n   }\n   if (($114 | 0) > ($$3266 | 0)) {\n    $$0237 = -1;\n    break L11;\n   }\n   $$8 = 0;\n   while (1) {\n    if (($$8 | 0) > ($114 | 0)) break;\n    $145 = $6 + ($$pre$phiZ2D * 72 | 0) + ($$8 << 2) | 0;\n    HEAP32[$145 >> 2] = HEAP32[$$1252 + (HEAP32[$145 >> 2] << 2) >> 2];\n    $$8 = $$8 + 1 | 0;\n   }\n   $$9 = 1;\n   while (1) {\n    if (($$9 | 0) > ($114 | 0)) break;\n    HEAP32[$12 + ($$9 << 2) >> 2] = HEAP32[$6 + ($$pre$phiZ2D * 72 | 0) + ($$9 << 2) >> 2];\n    $$9 = $$9 + 1 | 0;\n   }\n   $$0235 = 0;\n   $$10 = 1;\n   while (1) {\n    if (($$1262 | 0) < ($$10 | 0)) break;\n    $$2244 = 1;\n    $$4 = 1;\n    while (1) {\n     if (($$2244 | 0) > ($114 | 0)) break;\n     $157 = $12 + ($$2244 << 2) | 0;\n     $158 = HEAP32[$157 >> 2] | 0;\n     if (($158 | 0) == -1) $$5 = $$4; else {\n      $161 = ($158 + $$2244 | 0) % ($$1262 | 0) | 0;\n      HEAP32[$157 >> 2] = $161;\n      $$5 = HEAP32[$$1254 + ($161 << 2) >> 2] ^ $$4;\n     }\n     $$2244 = $$2244 + 1 | 0;\n     $$4 = $$5;\n    }\n    if (!$$4) {\n     HEAP32[$11 + ($$0235 << 2) >> 2] = $$1262 - $$10;\n     $$1236 = $$0235 + 1 | 0;\n    } else $$1236 = $$0235;\n    $$0235 = $$1236;\n    $$10 = $$10 + 1 | 0;\n   }\n   if (($$0235 | 0) != ($114 | 0)) {\n    $$0237 = -1;\n    break L11;\n   }\n   $$11 = 0;\n   while (1) {\n    if (($$11 | 0) >= ($114 | 0)) {\n     $$1241 = $$pre$phiZ2D;\n     break L24;\n    }\n    $175 = $$0268 + (HEAP32[$11 + ($$11 << 2) >> 2] | 0) | 0;\n    HEAP8[$175 >> 0] = HEAP8[$175 >> 0] ^ 1;\n    $$11 = $$11 + 1 | 0;\n   }\n  } else $$1241 = 0; while (0);\n  $179 = $4;\n  HEAP32[$179 >> 2] = 0;\n  HEAP32[$179 + 4 >> 2] = 0;\n  $$12 = $$1260 - $$3258 | 0;\n  $188 = 1;\n  $189 = 0;\n  $192 = 0;\n  $193 = 0;\n  while (1) {\n   if (($$12 | 0) >= ($$1260 | 0)) break;\n   $190 = ___muldi3($188 | 0, $189 | 0, HEAPU8[$$0268 + $$12 >> 0] | 0, 0) | 0;\n   $194 = _i64Add($190 | 0, tempRet0 | 0, $192 | 0, $193 | 0) | 0;\n   $195 = tempRet0;\n   $196 = $4;\n   HEAP32[$196 >> 2] = $194;\n   HEAP32[$196 + 4 >> 2] = $195;\n   $200 = _bitshift64Shl($188 | 0, $189 | 0, 1) | 0;\n   $$12 = $$12 + 1 | 0;\n   $188 = $200;\n   $189 = tempRet0;\n   $192 = $194;\n   $193 = $195;\n  }\n  if ($39) $$0237 = HEAP32[$8 + ($$1241 << 2) >> 2] | 0; else $$0237 = 0;\n } while (0);\n STACKTOP = sp;\n return $$0237 | 0;\n}\n\nfunction _check_rotation($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$0457 = 0.0, $$0458 = 0.0, $$0459 = 0.0, $$0460 = 0.0, $$0461 = 0.0, $$0462 = 0.0, $$0463 = 0.0, $$0464 = 0.0, $$0465 = 0.0, $$0466 = 0.0, $$0467 = 0.0, $$0468 = 0.0, $$0469 = 0.0, $$0470 = 0.0, $$0471 = 0.0, $$0472 = 0.0, $$0473 = 0.0, $$1 = 0, $$10 = 0.0, $$2 = 0.0, $$3 = 0.0, $$5 = 0.0, $$6 = 0.0, $$9 = 0.0, $$pre = 0.0, $$pre$phi15Z2D = 0.0, $$pre$phi17Z2D = 0.0, $$pre$phi19Z2D = 0.0, $$pre$phi21Z2D = 0.0, $$pre$phi23Z2D = 0.0, $$pre$phiZ2D = 0.0, $$pre14 = 0.0, $$pre18 = 0.0, $$pre20 = 0.0, $$sroa$0$0 = 0.0, $$sroa$0$1 = 0.0, $$sroa$0$1$$sroa$62$1 = 0.0, $$sroa$0$2 = 0.0, $$sroa$0333$0 = 0.0, $$sroa$0370$0 = 0.0, $$sroa$18$0 = 0.0, $$sroa$18384$0 = 0.0, $$sroa$33$0 = 0.0, $$sroa$33$1 = 0.0, $$sroa$33$2 = 0.0, $$sroa$33359$0 = 0.0, $$sroa$33397$0 = 0.0, $$sroa$62$0 = 0.0, $$sroa$62$1 = 0.0, $$sroa$62$1$$sroa$33$1 = 0.0, $$sroa$62$2 = 0.0, $1 = 0.0, $10 = 0, $102 = 0, $107 = 0.0, $109 = 0.0, $11 = 0.0, $113 = 0.0, $114 = 0.0, $116 = 0.0, $120 = 0.0, $123 = 0.0, $130 = 0.0, $133 = 0.0, $135 = 0.0, $137 = 0.0, $139 = 0.0, $14 = 0.0, $141 = 0.0, $143 = 0.0, $145 = 0.0, $150 = 0.0, $157 = 0.0, $164 = 0.0, $17 = 0.0, $171 = 0.0, $2 = 0, $20 = 0.0, $26 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0.0, $30 = 0.0, $35 = 0.0, $4 = 0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $5 = 0.0, $51 = 0, $56 = 0.0, $58 = 0.0, $6 = 0, $62 = 0.0, $63 = 0.0, $65 = 0.0, $69 = 0.0, $7 = 0.0, $72 = 0.0, $79 = 0.0, $8 = 0, $82 = 0.0, $84 = 0.0, $86 = 0.0, $88 = 0.0, $9 = 0.0, $90 = 0.0, $92 = 0.0, $94 = 0.0, $95 = 0.0, $96 = 0.0, $97 = 0.0;\n $1 = +HEAPF64[$0 >> 3];\n $2 = $0 + 8 | 0;\n $3 = +HEAPF64[$2 >> 3];\n $4 = $0 + 16 | 0;\n $5 = +HEAPF64[$4 >> 3];\n $6 = $0 + 24 | 0;\n $7 = +HEAPF64[$6 >> 3];\n $8 = $0 + 32 | 0;\n $9 = +HEAPF64[$8 >> 3];\n $10 = $0 + 40 | 0;\n $11 = +HEAPF64[$10 >> 3];\n $14 = $3 * $11 - $5 * $9;\n $17 = $5 * $7 - $1 * $11;\n $20 = $1 * $9 - $3 * $7;\n $26 = +Math_sqrt(+($20 * $20 + ($14 * $14 + $17 * $17)));\n do if (!($26 == 0.0)) {\n  $28 = $14 / $26;\n  $29 = $17 / $26;\n  $30 = $20 / $26;\n  $35 = $1 * $7 + $3 * $9 + $5 * $11;\n  $$0473 = $35 < 0.0 ? -$35 : $35;\n  $43 = (+Math_sqrt(+($$0473 + 1.0)) + +Math_sqrt(+(1.0 - $$0473))) * .5;\n  $44 = $1 * $29;\n  $45 = $3 * $28;\n  $46 = $44 - $45;\n  if ($46 != 0.0) {\n   $$0 = 0;\n   $$pre$phi15Z2D = $45;\n   $$pre$phi17Z2D = $46;\n   $$pre$phiZ2D = $44;\n   $$sroa$0$0 = $28;\n   $$sroa$0370$0 = $1;\n   $$sroa$18384$0 = $3;\n   $$sroa$33$0 = $29;\n   $$sroa$33397$0 = $5;\n   $$sroa$62$0 = $30;\n  } else {\n   $51 = $1 * $30 - $5 * $28 != 0.0;\n   $$2 = $51 ? $5 : $3;\n   $$3 = $51 ? $1 : $5;\n   $$5 = $51 ? $30 : $29;\n   $$6 = $51 ? $28 : $30;\n   $$pre = $$3 * $$5;\n   $$pre14 = $$2 * $$6;\n   $$0 = $51 ? 1 : 2;\n   $$pre$phi15Z2D = $$pre14;\n   $$pre$phi17Z2D = $$pre - $$pre14;\n   $$pre$phiZ2D = $$pre;\n   $$sroa$0$0 = $$6;\n   $$sroa$0370$0 = $$3;\n   $$sroa$18384$0 = $$2;\n   $$sroa$33$0 = $$5;\n   $$sroa$33397$0 = $51 ? $3 : $1;\n   $$sroa$62$0 = $51 ? $29 : $28;\n  }\n  if (!($$pre$phi17Z2D == 0.0)) {\n   $56 = ($$sroa$18384$0 * $$sroa$62$0 - $$sroa$33397$0 * $$sroa$33$0) / $$pre$phi17Z2D;\n   $58 = $43 * $$sroa$33$0 / $$pre$phi17Z2D;\n   $62 = $$pre$phi15Z2D - $$pre$phiZ2D;\n   $63 = ($$sroa$0370$0 * $$sroa$62$0 - $$sroa$33397$0 * $$sroa$0$0) / $62;\n   $65 = $43 * $$sroa$0$0 / $62;\n   $69 = $56 * $56 + $63 * $63 + 1.0;\n   $72 = $56 * $58 + $63 * $65;\n   $79 = $72 * $72 - $69 * ($58 * $58 + $65 * $65 + -1.0);\n   if (!($79 < 0.0)) {\n    $82 = +Math_sqrt(+$79);\n    $84 = ($82 - $72) / $69;\n    $86 = $58 + $56 * $84;\n    $88 = $65 + $63 * $84;\n    $90 = (-$72 - $82) / $69;\n    $92 = $58 + $56 * $90;\n    $94 = $65 + $63 * $90;\n    switch ($$0 & 3) {\n    case 1:\n     {\n      $$0467 = $94;\n      $$0468 = $90;\n      $$0469 = $92;\n      $$0470 = $88;\n      $$0471 = $84;\n      $$0472 = $86;\n      $$sroa$0$1 = $$sroa$0$0;\n      $$sroa$33$1 = $$sroa$62$0;\n      $$sroa$62$1 = $$sroa$33$0;\n      break;\n     }\n    case 2:\n     {\n      $$0467 = $92;\n      $$0468 = $94;\n      $$0469 = $90;\n      $$0470 = $86;\n      $$0471 = $88;\n      $$0472 = $84;\n      $$sroa$0$1 = $$sroa$62$0;\n      $$sroa$33$1 = $$sroa$33$0;\n      $$sroa$62$1 = $$sroa$0$0;\n      break;\n     }\n    default:\n     {\n      $$0467 = $90;\n      $$0468 = $94;\n      $$0469 = $92;\n      $$0470 = $84;\n      $$0471 = $88;\n      $$0472 = $86;\n      $$sroa$0$1 = $$sroa$0$0;\n      $$sroa$33$1 = $$sroa$33$0;\n      $$sroa$62$1 = $$sroa$62$0;\n     }\n    }\n    $95 = $7 * $$sroa$33$1;\n    $96 = $9 * $$sroa$0$1;\n    $97 = $95 - $96;\n    if ($97 != 0.0) {\n     $$1 = 0;\n     $$pre$phi19Z2D = $95;\n     $$pre$phi21Z2D = $96;\n     $$pre$phi23Z2D = $97;\n     $$sroa$0$2 = $$sroa$0$1;\n     $$sroa$0333$0 = $7;\n     $$sroa$18$0 = $9;\n     $$sroa$33$2 = $$sroa$33$1;\n     $$sroa$33359$0 = $11;\n     $$sroa$62$2 = $$sroa$62$1;\n    } else {\n     $102 = $7 * $$sroa$62$1 - $11 * $$sroa$0$1 != 0.0;\n     $$9 = $102 ? $11 : $9;\n     $$10 = $102 ? $7 : $11;\n     $$sroa$62$1$$sroa$33$1 = $102 ? $$sroa$62$1 : $$sroa$33$1;\n     $$sroa$0$1$$sroa$62$1 = $102 ? $$sroa$0$1 : $$sroa$62$1;\n     $$pre18 = $$10 * $$sroa$62$1$$sroa$33$1;\n     $$pre20 = $$9 * $$sroa$0$1$$sroa$62$1;\n     $$1 = $102 ? 1 : 2;\n     $$pre$phi19Z2D = $$pre18;\n     $$pre$phi21Z2D = $$pre20;\n     $$pre$phi23Z2D = $$pre18 - $$pre20;\n     $$sroa$0$2 = $$sroa$0$1$$sroa$62$1;\n     $$sroa$0333$0 = $$10;\n     $$sroa$18$0 = $$9;\n     $$sroa$33$2 = $$sroa$62$1$$sroa$33$1;\n     $$sroa$33359$0 = $102 ? $9 : $7;\n     $$sroa$62$2 = $102 ? $$sroa$33$1 : $$sroa$0$1;\n    }\n    if (!($$pre$phi23Z2D == 0.0)) {\n     $107 = ($$sroa$18$0 * $$sroa$62$2 - $$sroa$33359$0 * $$sroa$33$2) / $$pre$phi23Z2D;\n     $109 = $43 * $$sroa$33$2 / $$pre$phi23Z2D;\n     $113 = $$pre$phi21Z2D - $$pre$phi19Z2D;\n     $114 = ($$sroa$0333$0 * $$sroa$62$2 - $$sroa$33359$0 * $$sroa$0$2) / $113;\n     $116 = $43 * $$sroa$0$2 / $113;\n     $120 = $107 * $107 + $114 * $114 + 1.0;\n     $123 = $107 * $109 + $114 * $116;\n     $130 = $123 * $123 - $120 * ($109 * $109 + $116 * $116 + -1.0);\n     if (!($130 < 0.0)) {\n      $133 = +Math_sqrt(+$130);\n      $135 = ($133 - $123) / $120;\n      $137 = $109 + $107 * $135;\n      $139 = $116 + $114 * $135;\n      $141 = (-$123 - $133) / $120;\n      $143 = $109 + $107 * $141;\n      $145 = $116 + $114 * $141;\n      switch ($$1 & 3) {\n      case 1:\n       {\n        $$0461 = $145;\n        $$0462 = $141;\n        $$0463 = $143;\n        $$0464 = $139;\n        $$0465 = $135;\n        $$0466 = $137;\n        break;\n       }\n      case 2:\n       {\n        $$0461 = $143;\n        $$0462 = $145;\n        $$0463 = $141;\n        $$0464 = $137;\n        $$0465 = $139;\n        $$0466 = $135;\n        break;\n       }\n      default:\n       {\n        $$0461 = $141;\n        $$0462 = $145;\n        $$0463 = $143;\n        $$0464 = $135;\n        $$0465 = $139;\n        $$0466 = $137;\n       }\n      }\n      $150 = $$0472 * $$0466 + $$0471 * $$0465 + $$0470 * $$0464;\n      $$0460 = $150 < 0.0 ? -$150 : $150;\n      $157 = $$0472 * $$0463 + $$0471 * $$0462 + $$0470 * $$0461;\n      $$0459 = $157 < 0.0 ? -$157 : $157;\n      $164 = $$0469 * $$0466 + $$0468 * $$0465 + $$0467 * $$0464;\n      $$0458 = $164 < 0.0 ? -$164 : $164;\n      $171 = $$0469 * $$0463 + $$0468 * $$0462 + $$0467 * $$0461;\n      $$0457 = $171 < 0.0 ? -$171 : $171;\n      if ($$0460 < $$0459) if ($$0460 < $$0458) if ($$0460 < $$0457) {\n       HEAPF64[$0 >> 3] = $$0472;\n       HEAPF64[$2 >> 3] = $$0471;\n       HEAPF64[$4 >> 3] = $$0470;\n       HEAPF64[$6 >> 3] = $$0466;\n       HEAPF64[$8 >> 3] = $$0465;\n       HEAPF64[$10 >> 3] = $$0464;\n       break;\n      } else {\n       HEAPF64[$0 >> 3] = $$0469;\n       HEAPF64[$2 >> 3] = $$0468;\n       HEAPF64[$4 >> 3] = $$0467;\n       HEAPF64[$6 >> 3] = $$0463;\n       HEAPF64[$8 >> 3] = $$0462;\n       HEAPF64[$10 >> 3] = $$0461;\n       break;\n      } else {\n       HEAPF64[$0 >> 3] = $$0469;\n       HEAPF64[$2 >> 3] = $$0468;\n       HEAPF64[$4 >> 3] = $$0467;\n       if ($$0458 < $$0457) {\n        HEAPF64[$6 >> 3] = $$0466;\n        HEAPF64[$8 >> 3] = $$0465;\n        HEAPF64[$10 >> 3] = $$0464;\n        break;\n       } else {\n        HEAPF64[$6 >> 3] = $$0463;\n        HEAPF64[$8 >> 3] = $$0462;\n        HEAPF64[$10 >> 3] = $$0461;\n        break;\n       }\n      } else if ($$0459 < $$0458) if ($$0459 < $$0457) {\n       HEAPF64[$0 >> 3] = $$0472;\n       HEAPF64[$2 >> 3] = $$0471;\n       HEAPF64[$4 >> 3] = $$0470;\n       HEAPF64[$6 >> 3] = $$0463;\n       HEAPF64[$8 >> 3] = $$0462;\n       HEAPF64[$10 >> 3] = $$0461;\n       break;\n      } else {\n       HEAPF64[$0 >> 3] = $$0469;\n       HEAPF64[$2 >> 3] = $$0468;\n       HEAPF64[$4 >> 3] = $$0467;\n       HEAPF64[$6 >> 3] = $$0463;\n       HEAPF64[$8 >> 3] = $$0462;\n       HEAPF64[$10 >> 3] = $$0461;\n       break;\n      } else {\n       HEAPF64[$0 >> 3] = $$0469;\n       HEAPF64[$2 >> 3] = $$0468;\n       HEAPF64[$4 >> 3] = $$0467;\n       if ($$0458 < $$0457) {\n        HEAPF64[$6 >> 3] = $$0466;\n        HEAPF64[$8 >> 3] = $$0465;\n        HEAPF64[$10 >> 3] = $$0464;\n        break;\n       } else {\n        HEAPF64[$6 >> 3] = $$0463;\n        HEAPF64[$8 >> 3] = $$0462;\n        HEAPF64[$10 >> 3] = $$0461;\n        break;\n       }\n      }\n     }\n    }\n   }\n  }\n } while (0);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_117parse_vector_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i = 0, $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i131 = 0, $$0$i$i$i135 = 0, $$0$i$i$i139 = 0, $$0$i$i$i144 = 0, $$0$i$i$idx$i = 0, $$2103 = 0, $$899$ph = 0, $$9 = 0, $104 = 0, $105 = 0, $16 = 0, $17 = 0, $19 = 0, $25 = 0, $26 = 0, $3 = 0, $30 = 0, $33 = 0, $4 = 0, $45 = 0, $46 = 0, $5 = 0, $53 = 0, $6 = 0, $60 = 0, $61 = 0, $70 = 0, $73 = 0, $74 = 0, $77 = 0, $80 = 0, $84 = 0, $90 = 0, $92 = 0, $95 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 40 | 0;\n $4 = sp + 12 | 0;\n $5 = sp;\n $6 = sp + 24 | 0;\n L1 : do if (($1 - $0 | 0) > 3) if ((HEAP8[$0 >> 0] | 0) == 68) if ((HEAP8[$0 + 1 >> 0] | 0) == 118) {\n  $16 = $0 + 2 | 0;\n  $17 = HEAP8[$16 >> 0] | 0;\n  if (($17 + -49 & 255) < 9) {\n   $19 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($16, $1) | 0;\n   if (($19 | 0) == ($1 | 0)) {\n    $$9 = $0;\n    break;\n   }\n   if ((HEAP8[$19 >> 0] | 0) != 95) {\n    $$9 = $0;\n    break;\n   }\n   $25 = $19 - $16 | 0;\n   $26 = $19 + 1 | 0;\n   if (($26 | 0) == ($1 | 0)) {\n    $$9 = $0;\n    break;\n   }\n   if ((HEAP8[$26 >> 0] | 0) != 112) {\n    $30 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($26, $1, $2) | 0;\n    if (($30 | 0) == ($26 | 0)) {\n     $$9 = $0;\n     break;\n    }\n    $33 = $2 + 4 | 0;\n    if ((HEAP32[$2 >> 2] | 0) == (HEAP32[$33 >> 2] | 0)) {\n     $$9 = $0;\n     break;\n    };\n    HEAP32[$5 >> 2] = 0;\n    HEAP32[$5 + 4 >> 2] = 0;\n    HEAP32[$5 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($5, $16, $25);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($5, 0, 15157) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15166) | 0;\n    HEAP32[$3 >> 2] = HEAP32[$4 >> 2];\n    HEAP32[$3 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n    HEAP32[$3 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n    $$0$i$i$i131 = 0;\n    while (1) {\n     if (($$0$i$i$i131 | 0) == 3) break;\n     HEAP32[$4 + ($$0$i$i$i131 << 2) >> 2] = 0;\n     $$0$i$i$i131 = $$0$i$i$i131 + 1 | 0;\n    }\n    $45 = HEAP8[$3 + 11 >> 0] | 0;\n    $46 = $45 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$33 >> 2] | 0) + -24 | 0, $46 ? HEAP32[$3 >> 2] | 0 : $3, $46 ? HEAP32[$3 + 4 >> 2] | 0 : $45 & 255) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    $$9 = $30;\n    break;\n   }\n   $53 = $19 + 2 | 0;\n   HEAP32[$5 >> 2] = 0;\n   HEAP32[$5 + 4 >> 2] = 0;\n   HEAP32[$5 + 8 >> 2] = 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($5, $16, $25);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($5, 0, 15168) | 0;\n   HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n   HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n   HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n   $$0$i$i$i135 = 0;\n   while (1) {\n    if (($$0$i$i$i135 | 0) == 3) break;\n    HEAP32[$5 + ($$0$i$i$i135 << 2) >> 2] = 0;\n    $$0$i$i$i135 = $$0$i$i$i135 + 1 | 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15166) | 0;\n   HEAP32[$6 >> 2] = HEAP32[$4 >> 2];\n   HEAP32[$6 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n   HEAP32[$6 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n   $$0$i$i$i139 = 0;\n   while (1) {\n    if (($$0$i$i$i139 | 0) == 3) break;\n    HEAP32[$4 + ($$0$i$i$i139 << 2) >> 2] = 0;\n    $$0$i$i$i139 = $$0$i$i$i139 + 1 | 0;\n   }\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $6);\n   $60 = $2 + 4 | 0;\n   $61 = HEAP32[$60 >> 2] | 0;\n   if ($61 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($61, $3);\n    HEAP32[$60 >> 2] = (HEAP32[$60 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n   $$9 = $53;\n   break;\n  };\n  HEAP32[$4 >> 2] = 0;\n  HEAP32[$4 + 4 >> 2] = 0;\n  HEAP32[$4 + 8 >> 2] = 0;\n  $$0$i$i = 0;\n  while (1) {\n   if (($$0$i$i | 0) == 3) break;\n   HEAP32[$4 + ($$0$i$i << 2) >> 2] = 0;\n   $$0$i$i = $$0$i$i + 1 | 0;\n  }\n  if ($17 << 24 >> 24 == 95) {\n   $$2103 = $16;\n   label = 44;\n  } else {\n   $70 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0;\n   if (($70 | 0) == ($16 | 0)) {\n    $$2103 = $16;\n    label = 44;\n   } else {\n    $73 = $2 + 4 | 0;\n    $74 = HEAP32[$73 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) != ($74 | 0)) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, $74 + -24 | 0);\n     $77 = $4 + 11 | 0;\n     if ((HEAP8[$77 >> 0] | 0) < 0) {\n      $80 = HEAP32[$4 >> 2] | 0;\n      HEAP8[$3 >> 0] = 0;\n      __ZNSt3__211char_traitsIcE6assignERcRKc($80, $3);\n      HEAP32[$4 + 4 >> 2] = 0;\n     } else {\n      HEAP8[$3 >> 0] = 0;\n      __ZNSt3__211char_traitsIcE6assignERcRKc($4, $3);\n      HEAP8[$77 >> 0] = 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($4);\n     HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n     HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n     HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n     $$0$i$i$i$i = 0;\n     while (1) {\n      if (($$0$i$i$i$i | 0) == 3) break;\n      HEAP32[$5 + ($$0$i$i$i$i << 2) >> 2] = 0;\n      $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     $84 = HEAP32[$73 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($84 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$73 >> 2] = $84 + -24;\n     $$2103 = $70;\n     label = 44;\n    }\n   }\n  }\n  do if ((label | 0) == 44) {\n   if (($$2103 | 0) == ($1 | 0)) $$899$ph = $0; else if ((HEAP8[$$2103 >> 0] | 0) == 95) {\n    $90 = $$2103 + 1 | 0;\n    if (($90 | 0) == ($1 | 0)) $$899$ph = $0; else {\n     $92 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($90, $1, $2) | 0;\n     if (($92 | 0) == ($90 | 0)) $$899$ph = $0; else {\n      $95 = $2 + 4 | 0;\n      if ((HEAP32[$2 >> 2] | 0) == (HEAP32[$95 >> 2] | 0)) break;\n      __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($5, 15157, $4);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($5, 15166) | 0;\n      HEAP32[$3 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$3 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n      HEAP32[$3 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n      $$0$i$i$i144 = 0;\n      while (1) {\n       if (($$0$i$i$i144 | 0) == 3) break;\n       HEAP32[$5 + ($$0$i$i$i144 << 2) >> 2] = 0;\n       $$0$i$i$i144 = $$0$i$i$i144 + 1 | 0;\n      }\n      $104 = HEAP8[$3 + 11 >> 0] | 0;\n      $105 = $104 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$95 >> 2] | 0) + -24 | 0, $105 ? HEAP32[$3 >> 2] | 0 : $3, $105 ? HEAP32[$3 + 4 >> 2] | 0 : $104 & 255) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n      $$899$ph = $92;\n     }\n    }\n   } else $$899$ph = $0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n   $$9 = $$899$ph;\n   break L1;\n  } while (0);\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n  $$9 = $0;\n } else $$9 = $0; else $$9 = $0; else $$9 = $0; while (0);\n STACKTOP = sp;\n return $$9 | 0;\n}\n\nfunction _hexfloat($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0$be = 0, $$0$ph = 0, $$0133 = 0, $$0143 = 0, $$0151 = 0, $$0154 = 0.0, $$0155 = 0.0, $$0158 = 0.0, $$0163 = 0, $$0169 = 0.0, $$0170 = 0, $$0170173 = 0, $$0170174 = 0, $$1149 = 0, $$1149$ph = 0, $$1152 = 0, $$1156 = 0.0, $$1159 = 0.0, $$1164 = 0, $$2150 = 0, $$2153 = 0, $$2157 = 0.0, $$2160 = 0.0, $$2165 = 0, $$3 = 0, $$3$be = 0, $$3$lcssa = 0, $$3$ph = 0, $$3146 = 0, $$3146$ph = 0, $$3161$lcssa = 0.0, $$3161181 = 0.0, $$3166$lcssa = 0, $$3166185 = 0, $$4147 = 0, $$4162 = 0.0, $$4167$lcssa = 0, $$4167180 = 0, $$5168 = 0, $$pre = 0, $$pre$phi204Z2D = 0.0, $105 = 0, $106 = 0, $107 = 0, $117 = 0, $118 = 0, $131 = 0, $133 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $14 = 0, $142 = 0, $144 = 0, $150 = 0, $154 = 0, $156 = 0, $162 = 0, $167 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $177 = 0, $180 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $194 = 0.0, $195 = 0, $208 = 0.0, $21 = 0, $210 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $29 = 0, $30 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $42 = 0, $43 = 0, $47 = 0, $5 = 0, $52 = 0, $54 = 0, $6 = 0, $66 = 0.0, $7 = 0, $73 = 0, $75 = 0, $84 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond172 = 0, label = 0, $106$looptemp = 0;\n $5 = $0 + 4 | 0;\n $6 = HEAP32[$5 >> 2] | 0;\n $7 = $0 + 100 | 0;\n if ($6 >>> 0 < (HEAP32[$7 >> 2] | 0) >>> 0) {\n  HEAP32[$5 >> 2] = $6 + 1;\n  $$0$ph = HEAPU8[$6 >> 0] | 0;\n } else $$0$ph = ___shgetc($0) | 0;\n $$0 = $$0$ph;\n $$0143 = 0;\n L5 : while (1) {\n  switch ($$0 | 0) {\n  case 46:\n   {\n    label = 10;\n    break L5;\n    break;\n   }\n  case 48:\n   break;\n  default:\n   {\n    $$1149$ph = 0;\n    $$3$ph = $$0;\n    $$3146$ph = $$0143;\n    $212 = 0;\n    $213 = 0;\n    break L5;\n   }\n  }\n  $14 = HEAP32[$5 >> 2] | 0;\n  if ($14 >>> 0 < (HEAP32[$7 >> 2] | 0) >>> 0) {\n   HEAP32[$5 >> 2] = $14 + 1;\n   $$0$be = HEAPU8[$14 >> 0] | 0;\n  } else $$0$be = ___shgetc($0) | 0;\n  $$0 = $$0$be;\n  $$0143 = 1;\n }\n if ((label | 0) == 10) {\n  $21 = HEAP32[$5 >> 2] | 0;\n  if ($21 >>> 0 < (HEAP32[$7 >> 2] | 0) >>> 0) {\n   HEAP32[$5 >> 2] = $21 + 1;\n   $29 = HEAPU8[$21 >> 0] | 0;\n  } else $29 = ___shgetc($0) | 0;\n  if (($29 | 0) == 48) {\n   $37 = 0;\n   $38 = 0;\n   while (1) {\n    $30 = HEAP32[$5 >> 2] | 0;\n    if ($30 >>> 0 < (HEAP32[$7 >> 2] | 0) >>> 0) {\n     HEAP32[$5 >> 2] = $30 + 1;\n     $42 = HEAPU8[$30 >> 0] | 0;\n    } else $42 = ___shgetc($0) | 0;\n    $39 = _i64Add($37 | 0, $38 | 0, -1, -1) | 0;\n    $40 = tempRet0;\n    if (($42 | 0) == 48) {\n     $37 = $39;\n     $38 = $40;\n    } else {\n     $$1149$ph = 1;\n     $$3$ph = $42;\n     $$3146$ph = 1;\n     $212 = $39;\n     $213 = $40;\n     break;\n    }\n   }\n  } else {\n   $$1149$ph = 1;\n   $$3$ph = $29;\n   $$3146$ph = $$0143;\n   $212 = 0;\n   $213 = 0;\n  }\n }\n $$0151 = 0;\n $$0155 = 1.0;\n $$0158 = 0.0;\n $$0163 = 0;\n $$1149 = $$1149$ph;\n $$3 = $$3$ph;\n $$3146 = $$3146$ph;\n $52 = 0;\n $54 = 0;\n $97 = $212;\n $99 = $213;\n while (1) {\n  $43 = $$3 + -48 | 0;\n  $$pre = $$3 | 32;\n  if ($43 >>> 0 < 10) label = 24; else {\n   $47 = ($$3 | 0) == 46;\n   if (!($47 | ($$pre + -97 | 0) >>> 0 < 6)) {\n    $$3$lcssa = $$3;\n    break;\n   }\n   if ($47) if (!$$1149) {\n    $$2150 = 1;\n    $$2153 = $$0151;\n    $$2157 = $$0155;\n    $$2160 = $$0158;\n    $$2165 = $$0163;\n    $$4147 = $$3146;\n    $214 = $54;\n    $215 = $52;\n    $216 = $54;\n    $217 = $52;\n   } else {\n    $$3$lcssa = 46;\n    break;\n   } else label = 24;\n  }\n  if ((label | 0) == 24) {\n   label = 0;\n   $$0133 = ($$3 | 0) > 57 ? $$pre + -87 | 0 : $43;\n   do if (($52 | 0) < 0 | ($52 | 0) == 0 & $54 >>> 0 < 8) {\n    $$1152 = $$0151;\n    $$1156 = $$0155;\n    $$1159 = $$0158;\n    $$1164 = $$0133 + ($$0163 << 4) | 0;\n   } else if (($52 | 0) < 0 | ($52 | 0) == 0 & $54 >>> 0 < 14) {\n    $66 = $$0155 * .0625;\n    $$1152 = $$0151;\n    $$1156 = $66;\n    $$1159 = $$0158 + $66 * +($$0133 | 0);\n    $$1164 = $$0163;\n    break;\n   } else {\n    $or$cond = ($$0151 | 0) != 0 | ($$0133 | 0) == 0;\n    $$1152 = $or$cond ? $$0151 : 1;\n    $$1156 = $$0155;\n    $$1159 = $or$cond ? $$0158 : $$0158 + $$0155 * .5;\n    $$1164 = $$0163;\n    break;\n   } while (0);\n   $73 = _i64Add($54 | 0, $52 | 0, 1, 0) | 0;\n   $$2150 = $$1149;\n   $$2153 = $$1152;\n   $$2157 = $$1156;\n   $$2160 = $$1159;\n   $$2165 = $$1164;\n   $$4147 = 1;\n   $214 = $97;\n   $215 = $99;\n   $216 = $73;\n   $217 = tempRet0;\n  }\n  $75 = HEAP32[$5 >> 2] | 0;\n  if ($75 >>> 0 < (HEAP32[$7 >> 2] | 0) >>> 0) {\n   HEAP32[$5 >> 2] = $75 + 1;\n   $$3$be = HEAPU8[$75 >> 0] | 0;\n  } else $$3$be = ___shgetc($0) | 0;\n  $$0151 = $$2153;\n  $$0155 = $$2157;\n  $$0158 = $$2160;\n  $$0163 = $$2165;\n  $$1149 = $$2150;\n  $$3 = $$3$be;\n  $$3146 = $$4147;\n  $52 = $217;\n  $54 = $216;\n  $97 = $214;\n  $99 = $215;\n }\n do if (!$$3146) {\n  $84 = (HEAP32[$7 >> 2] | 0) == 0;\n  if (!$84) HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + -1;\n  if (!$4) ___shlim($0, 0); else if (!$84) {\n   HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + -1;\n   if (!(($$1149 | 0) == 0 | $84)) HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + -1;\n  }\n  $$0169 = +($3 | 0) * 0.0;\n } else {\n  $95 = ($$1149 | 0) == 0;\n  $96 = $95 ? $54 : $97;\n  $98 = $95 ? $52 : $99;\n  if (($52 | 0) < 0 | ($52 | 0) == 0 & $54 >>> 0 < 8) {\n   $$3166185 = $$0163;\n   $106 = $54;\n   $107 = $52;\n   while (1) {\n    $105 = $$3166185 << 4;\n    $106$looptemp = $106;\n    $106 = _i64Add($106 | 0, $107 | 0, 1, 0) | 0;\n    if (!(($107 | 0) < 0 | ($107 | 0) == 0 & $106$looptemp >>> 0 < 7)) {\n     $$3166$lcssa = $105;\n     break;\n    } else {\n     $$3166185 = $105;\n     $107 = tempRet0;\n    }\n   }\n  } else $$3166$lcssa = $$0163;\n  if (($$3$lcssa | 32 | 0) == 112) {\n   $117 = _scanexp($0, $4) | 0;\n   $118 = tempRet0;\n   if (($117 | 0) == 0 & ($118 | 0) == -2147483648) {\n    if (!$4) {\n     ___shlim($0, 0);\n     $$0169 = 0.0;\n     break;\n    }\n    if (!(HEAP32[$7 >> 2] | 0)) {\n     $135 = 0;\n     $136 = 0;\n    } else {\n     HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + -1;\n     $135 = 0;\n     $136 = 0;\n    }\n   } else {\n    $135 = $117;\n    $136 = $118;\n   }\n  } else if (!(HEAP32[$7 >> 2] | 0)) {\n   $135 = 0;\n   $136 = 0;\n  } else {\n   HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + -1;\n   $135 = 0;\n   $136 = 0;\n  }\n  $131 = _bitshift64Shl($96 | 0, $98 | 0, 2) | 0;\n  $133 = _i64Add($131 | 0, tempRet0 | 0, -32, -1) | 0;\n  $137 = _i64Add($133 | 0, tempRet0 | 0, $135 | 0, $136 | 0) | 0;\n  $138 = tempRet0;\n  if (!$$3166$lcssa) {\n   $$0169 = +($3 | 0) * 0.0;\n   break;\n  }\n  $142 = 0 - $2 | 0;\n  $144 = (($142 | 0) < 0) << 31 >> 31;\n  if (($138 | 0) > ($144 | 0) | ($138 | 0) == ($144 | 0) & $137 >>> 0 > $142 >>> 0) {\n   $150 = ___errno_location() | 0;\n   HEAP32[$150 >> 2] = 34;\n   $$0169 = +($3 | 0) * 1797693134862315708145274.0e284 * 1797693134862315708145274.0e284;\n   break;\n  }\n  $154 = $2 + -106 | 0;\n  $156 = (($154 | 0) < 0) << 31 >> 31;\n  if (($138 | 0) < ($156 | 0) | ($138 | 0) == ($156 | 0) & $137 >>> 0 < $154 >>> 0) {\n   $162 = ___errno_location() | 0;\n   HEAP32[$162 >> 2] = 34;\n   $$0169 = +($3 | 0) * 2.2250738585072014e-308 * 2.2250738585072014e-308;\n   break;\n  }\n  if (($$3166$lcssa | 0) > -1) {\n   $$3161181 = $$0158;\n   $$4167180 = $$3166$lcssa;\n   $171 = $137;\n   $172 = $138;\n   while (1) {\n    $167 = !($$3161181 >= .5);\n    $$5168 = $$4167180 << 1 | ($167 ^ 1) & 1;\n    $$4162 = $$3161181 + ($167 ? $$3161181 : $$3161181 + -1.0);\n    $173 = _i64Add($171 | 0, $172 | 0, -1, -1) | 0;\n    $174 = tempRet0;\n    if (($$5168 | 0) > -1) {\n     $$3161181 = $$4162;\n     $$4167180 = $$5168;\n     $171 = $173;\n     $172 = $174;\n    } else {\n     $$3161$lcssa = $$4162;\n     $$4167$lcssa = $$5168;\n     $182 = $173;\n     $183 = $174;\n     break;\n    }\n   }\n  } else {\n   $$3161$lcssa = $$0158;\n   $$4167$lcssa = $$3166$lcssa;\n   $182 = $137;\n   $183 = $138;\n  }\n  $177 = (($1 | 0) < 0) << 31 >> 31;\n  $180 = _i64Subtract(32, 0, $2 | 0, (($2 | 0) < 0) << 31 >> 31 | 0) | 0;\n  $184 = _i64Add($180 | 0, tempRet0 | 0, $182 | 0, $183 | 0) | 0;\n  $185 = tempRet0;\n  if (($185 | 0) < ($177 | 0) | ($185 | 0) == ($177 | 0) & $184 >>> 0 < $1 >>> 0) if (($184 | 0) > 0) {\n   $$0170 = $184;\n   label = 65;\n  } else {\n   $$0170174 = 0;\n   $195 = 84;\n   label = 67;\n  } else {\n   $$0170 = $1;\n   label = 65;\n  }\n  if ((label | 0) == 65) if (($$0170 | 0) < 53) {\n   $$0170174 = $$0170;\n   $195 = 84 - $$0170 | 0;\n   label = 67;\n  } else {\n   $$0154 = 0.0;\n   $$0170173 = $$0170;\n   $$pre$phi204Z2D = +($3 | 0);\n  }\n  if ((label | 0) == 67) {\n   $194 = +($3 | 0);\n   $$0154 = +_copysignl(+_scalbn(1.0, $195), $194);\n   $$0170173 = $$0170174;\n   $$pre$phi204Z2D = $194;\n  }\n  $or$cond172 = ($$4167$lcssa & 1 | 0) == 0 & ($$3161$lcssa != 0.0 & ($$0170173 | 0) < 32);\n  $208 = ($or$cond172 ? 0.0 : $$3161$lcssa) * $$pre$phi204Z2D + ($$0154 + $$pre$phi204Z2D * +(($$4167$lcssa + ($or$cond172 & 1) | 0) >>> 0)) - $$0154;\n  if (!($208 != 0.0)) {\n   $210 = ___errno_location() | 0;\n   HEAP32[$210 >> 2] = 34;\n  }\n  $$0169 = +_scalbnl($208, $182);\n } while (0);\n return +$$0169;\n}\n\nfunction ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) {\n $a$0 = $a$0 | 0;\n $a$1 = $a$1 | 0;\n $b$0 = $b$0 | 0;\n $b$1 = $b$1 | 0;\n $rem = $rem | 0;\n var $n_sroa_0_0_extract_trunc = 0, $n_sroa_1_4_extract_shift$0 = 0, $n_sroa_1_4_extract_trunc = 0, $d_sroa_0_0_extract_trunc = 0, $d_sroa_1_4_extract_shift$0 = 0, $d_sroa_1_4_extract_trunc = 0, $4 = 0, $17 = 0, $37 = 0, $51 = 0, $57 = 0, $58 = 0, $66 = 0, $78 = 0, $88 = 0, $89 = 0, $91 = 0, $92 = 0, $95 = 0, $105 = 0, $119 = 0, $125 = 0, $126 = 0, $130 = 0, $q_sroa_1_1_ph = 0, $q_sroa_0_1_ph = 0, $r_sroa_1_1_ph = 0, $r_sroa_0_1_ph = 0, $sr_1_ph = 0, $d_sroa_0_0_insert_insert99$0 = 0, $d_sroa_0_0_insert_insert99$1 = 0, $137$0 = 0, $137$1 = 0, $carry_0203 = 0, $sr_1202 = 0, $r_sroa_0_1201 = 0, $r_sroa_1_1200 = 0, $q_sroa_0_1199 = 0, $q_sroa_1_1198 = 0, $r_sroa_0_0_insert_insert42$0 = 0, $r_sroa_0_0_insert_insert42$1 = 0, $150$1 = 0, $151$0 = 0, $carry_0_lcssa$0 = 0, $carry_0_lcssa$1 = 0, $r_sroa_0_1_lcssa = 0, $r_sroa_1_1_lcssa = 0, $q_sroa_0_1_lcssa = 0, $q_sroa_1_1_lcssa = 0, $q_sroa_0_0_insert_ext75$0 = 0, $q_sroa_0_0_insert_ext75$1 = 0, $_0$0 = 0, $_0$1 = 0, $q_sroa_1_1198$looptemp = 0;\n $n_sroa_0_0_extract_trunc = $a$0;\n $n_sroa_1_4_extract_shift$0 = $a$1;\n $n_sroa_1_4_extract_trunc = $n_sroa_1_4_extract_shift$0;\n $d_sroa_0_0_extract_trunc = $b$0;\n $d_sroa_1_4_extract_shift$0 = $b$1;\n $d_sroa_1_4_extract_trunc = $d_sroa_1_4_extract_shift$0;\n if (!$n_sroa_1_4_extract_trunc) {\n  $4 = ($rem | 0) != 0;\n  if (!$d_sroa_1_4_extract_trunc) {\n   if ($4) {\n    HEAP32[$rem >> 2] = ($n_sroa_0_0_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);\n    HEAP32[$rem + 4 >> 2] = 0;\n   }\n   $_0$1 = 0;\n   $_0$0 = ($n_sroa_0_0_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;\n   return (tempRet0 = $_0$1, $_0$0) | 0;\n  } else {\n   if (!$4) {\n    $_0$1 = 0;\n    $_0$0 = 0;\n    return (tempRet0 = $_0$1, $_0$0) | 0;\n   }\n   HEAP32[$rem >> 2] = $a$0 | 0;\n   HEAP32[$rem + 4 >> 2] = $a$1 & 0;\n   $_0$1 = 0;\n   $_0$0 = 0;\n   return (tempRet0 = $_0$1, $_0$0) | 0;\n  }\n }\n $17 = ($d_sroa_1_4_extract_trunc | 0) == 0;\n do if (!$d_sroa_0_0_extract_trunc) {\n  if ($17) {\n   if ($rem | 0) {\n    HEAP32[$rem >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);\n    HEAP32[$rem + 4 >> 2] = 0;\n   }\n   $_0$1 = 0;\n   $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;\n   return (tempRet0 = $_0$1, $_0$0) | 0;\n  }\n  if (!$n_sroa_0_0_extract_trunc) {\n   if ($rem | 0) {\n    HEAP32[$rem >> 2] = 0;\n    HEAP32[$rem + 4 >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_1_4_extract_trunc >>> 0);\n   }\n   $_0$1 = 0;\n   $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_1_4_extract_trunc >>> 0) >>> 0;\n   return (tempRet0 = $_0$1, $_0$0) | 0;\n  }\n  $37 = $d_sroa_1_4_extract_trunc - 1 | 0;\n  if (!($37 & $d_sroa_1_4_extract_trunc)) {\n   if ($rem | 0) {\n    HEAP32[$rem >> 2] = $a$0 | 0;\n    HEAP32[$rem + 4 >> 2] = $37 & $n_sroa_1_4_extract_trunc | $a$1 & 0;\n   }\n   $_0$1 = 0;\n   $_0$0 = $n_sroa_1_4_extract_trunc >>> ((_llvm_cttz_i32($d_sroa_1_4_extract_trunc | 0) | 0) >>> 0);\n   return (tempRet0 = $_0$1, $_0$0) | 0;\n  }\n  $51 = (Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0) - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;\n  if ($51 >>> 0 <= 30) {\n   $57 = $51 + 1 | 0;\n   $58 = 31 - $51 | 0;\n   $sr_1_ph = $57;\n   $r_sroa_0_1_ph = $n_sroa_1_4_extract_trunc << $58 | $n_sroa_0_0_extract_trunc >>> ($57 >>> 0);\n   $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($57 >>> 0);\n   $q_sroa_0_1_ph = 0;\n   $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $58;\n   break;\n  }\n  if (!$rem) {\n   $_0$1 = 0;\n   $_0$0 = 0;\n   return (tempRet0 = $_0$1, $_0$0) | 0;\n  }\n  HEAP32[$rem >> 2] = $a$0 | 0;\n  HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;\n  $_0$1 = 0;\n  $_0$0 = 0;\n  return (tempRet0 = $_0$1, $_0$0) | 0;\n } else {\n  if (!$17) {\n   $119 = (Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0) - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;\n   if ($119 >>> 0 <= 31) {\n    $125 = $119 + 1 | 0;\n    $126 = 31 - $119 | 0;\n    $130 = $119 - 31 >> 31;\n    $sr_1_ph = $125;\n    $r_sroa_0_1_ph = $n_sroa_0_0_extract_trunc >>> ($125 >>> 0) & $130 | $n_sroa_1_4_extract_trunc << $126;\n    $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($125 >>> 0) & $130;\n    $q_sroa_0_1_ph = 0;\n    $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $126;\n    break;\n   }\n   if (!$rem) {\n    $_0$1 = 0;\n    $_0$0 = 0;\n    return (tempRet0 = $_0$1, $_0$0) | 0;\n   }\n   HEAP32[$rem >> 2] = $a$0 | 0;\n   HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;\n   $_0$1 = 0;\n   $_0$0 = 0;\n   return (tempRet0 = $_0$1, $_0$0) | 0;\n  }\n  $66 = $d_sroa_0_0_extract_trunc - 1 | 0;\n  if ($66 & $d_sroa_0_0_extract_trunc | 0) {\n   $88 = (Math_clz32($d_sroa_0_0_extract_trunc | 0) | 0) + 33 - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;\n   $89 = 64 - $88 | 0;\n   $91 = 32 - $88 | 0;\n   $92 = $91 >> 31;\n   $95 = $88 - 32 | 0;\n   $105 = $95 >> 31;\n   $sr_1_ph = $88;\n   $r_sroa_0_1_ph = $91 - 1 >> 31 & $n_sroa_1_4_extract_trunc >>> ($95 >>> 0) | ($n_sroa_1_4_extract_trunc << $91 | $n_sroa_0_0_extract_trunc >>> ($88 >>> 0)) & $105;\n   $r_sroa_1_1_ph = $105 & $n_sroa_1_4_extract_trunc >>> ($88 >>> 0);\n   $q_sroa_0_1_ph = $n_sroa_0_0_extract_trunc << $89 & $92;\n   $q_sroa_1_1_ph = ($n_sroa_1_4_extract_trunc << $89 | $n_sroa_0_0_extract_trunc >>> ($95 >>> 0)) & $92 | $n_sroa_0_0_extract_trunc << $91 & $88 - 33 >> 31;\n   break;\n  }\n  if ($rem | 0) {\n   HEAP32[$rem >> 2] = $66 & $n_sroa_0_0_extract_trunc;\n   HEAP32[$rem + 4 >> 2] = 0;\n  }\n  if (($d_sroa_0_0_extract_trunc | 0) == 1) {\n   $_0$1 = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;\n   $_0$0 = $a$0 | 0 | 0;\n   return (tempRet0 = $_0$1, $_0$0) | 0;\n  } else {\n   $78 = _llvm_cttz_i32($d_sroa_0_0_extract_trunc | 0) | 0;\n   $_0$1 = $n_sroa_1_4_extract_trunc >>> ($78 >>> 0) | 0;\n   $_0$0 = $n_sroa_1_4_extract_trunc << 32 - $78 | $n_sroa_0_0_extract_trunc >>> ($78 >>> 0) | 0;\n   return (tempRet0 = $_0$1, $_0$0) | 0;\n  }\n } while (0);\n if (!$sr_1_ph) {\n  $q_sroa_1_1_lcssa = $q_sroa_1_1_ph;\n  $q_sroa_0_1_lcssa = $q_sroa_0_1_ph;\n  $r_sroa_1_1_lcssa = $r_sroa_1_1_ph;\n  $r_sroa_0_1_lcssa = $r_sroa_0_1_ph;\n  $carry_0_lcssa$1 = 0;\n  $carry_0_lcssa$0 = 0;\n } else {\n  $d_sroa_0_0_insert_insert99$0 = $b$0 | 0 | 0;\n  $d_sroa_0_0_insert_insert99$1 = $d_sroa_1_4_extract_shift$0 | $b$1 & 0;\n  $137$0 = _i64Add($d_sroa_0_0_insert_insert99$0 | 0, $d_sroa_0_0_insert_insert99$1 | 0, -1, -1) | 0;\n  $137$1 = tempRet0;\n  $q_sroa_1_1198 = $q_sroa_1_1_ph;\n  $q_sroa_0_1199 = $q_sroa_0_1_ph;\n  $r_sroa_1_1200 = $r_sroa_1_1_ph;\n  $r_sroa_0_1201 = $r_sroa_0_1_ph;\n  $sr_1202 = $sr_1_ph;\n  $carry_0203 = 0;\n  do {\n   $q_sroa_1_1198$looptemp = $q_sroa_1_1198;\n   $q_sroa_1_1198 = $q_sroa_0_1199 >>> 31 | $q_sroa_1_1198 << 1;\n   $q_sroa_0_1199 = $carry_0203 | $q_sroa_0_1199 << 1;\n   $r_sroa_0_0_insert_insert42$0 = $r_sroa_0_1201 << 1 | $q_sroa_1_1198$looptemp >>> 31 | 0;\n   $r_sroa_0_0_insert_insert42$1 = $r_sroa_0_1201 >>> 31 | $r_sroa_1_1200 << 1 | 0;\n   _i64Subtract($137$0 | 0, $137$1 | 0, $r_sroa_0_0_insert_insert42$0 | 0, $r_sroa_0_0_insert_insert42$1 | 0) | 0;\n   $150$1 = tempRet0;\n   $151$0 = $150$1 >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1;\n   $carry_0203 = $151$0 & 1;\n   $r_sroa_0_1201 = _i64Subtract($r_sroa_0_0_insert_insert42$0 | 0, $r_sroa_0_0_insert_insert42$1 | 0, $151$0 & $d_sroa_0_0_insert_insert99$0 | 0, ((($150$1 | 0) < 0 ? -1 : 0) >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1) & $d_sroa_0_0_insert_insert99$1 | 0) | 0;\n   $r_sroa_1_1200 = tempRet0;\n   $sr_1202 = $sr_1202 - 1 | 0;\n  } while (($sr_1202 | 0) != 0);\n  $q_sroa_1_1_lcssa = $q_sroa_1_1198;\n  $q_sroa_0_1_lcssa = $q_sroa_0_1199;\n  $r_sroa_1_1_lcssa = $r_sroa_1_1200;\n  $r_sroa_0_1_lcssa = $r_sroa_0_1201;\n  $carry_0_lcssa$1 = 0;\n  $carry_0_lcssa$0 = $carry_0203;\n }\n $q_sroa_0_0_insert_ext75$0 = $q_sroa_0_1_lcssa;\n $q_sroa_0_0_insert_ext75$1 = 0;\n if ($rem | 0) {\n  HEAP32[$rem >> 2] = $r_sroa_0_1_lcssa;\n  HEAP32[$rem + 4 >> 2] = $r_sroa_1_1_lcssa;\n }\n $_0$1 = ($q_sroa_0_0_insert_ext75$0 | 0) >>> 31 | ($q_sroa_1_1_lcssa | $q_sroa_0_0_insert_ext75$1) << 1 | ($q_sroa_0_0_insert_ext75$1 << 1 | $q_sroa_0_0_insert_ext75$0 >>> 31) & 0 | $carry_0_lcssa$1;\n $_0$0 = ($q_sroa_0_0_insert_ext75$0 << 1 | 0 >>> 31) & -2 | $carry_0_lcssa$0;\n return (tempRet0 = $_0$1, $_0$0) | 0;\n}\n\nfunction _get_matrix_code($0, $1, $2, $3, $4, $5, $6) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n var $$0212 = 0, $$0213 = 0, $$0217 = 0, $$0225 = 0, $$0228 = 0, $$0230 = 0, $$1214 = 0, $$1218 = 0, $$2215 = 0, $$2219 = 0, $$3216 = 0, $$3220 = 0, $$4221 = 0, $$5222 = 0, $$6223 = 0, $$7224 = 0, $107 = 0, $11 = 0, $112 = 0, $113 = 0, $114 = 0, $12 = 0, $125 = 0, $126 = 0, $132 = 0, $133 = 0, $134 = 0, $138 = 0, $14 = 0, $149 = 0, $150 = 0, $151 = 0, $154 = 0, $160 = 0, $161 = 0, $164 = 0, $173 = 0, $174 = 0, $178 = 0, $188 = 0, $189 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $21 = 0, $25 = 0, $26 = 0, $30 = 0, $44 = 0, $55 = 0, $57 = 0, $58 = 0, $65 = 0, $67 = 0, $68 = 0, $7 = 0, $73 = 0, $74 = 0, $75 = 0, $8 = 0, $86 = 0, $87 = 0, $89 = 0, $9 = 0, $91 = 0, $92 = 0, $93 = 0, $97 = 0, $or$cond7249 = 0, $spec$select232 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $7 = sp + 24 | 0;\n $8 = sp + 8 | 0;\n $9 = sp;\n L1 : do if (($1 + -3 | 0) >>> 0 > 5) {\n  HEAP32[$2 >> 2] = -1;\n  HEAP32[$3 >> 2] = 0;\n  HEAPF64[$4 >> 3] = -1.0;\n  $$0212 = -1;\n } else {\n  HEAP32[$8 >> 2] = 0;\n  $11 = $1 + -1 | 0;\n  $12 = Math_imul($11, $1) | 0;\n  HEAP32[$8 + 4 >> 2] = $12;\n  $14 = Math_imul($1, $1) | 0;\n  HEAP32[$8 + 8 >> 2] = $14 + -1;\n  HEAP32[$8 + 12 >> 2] = $11;\n  $$0217 = 0;\n  $$0228 = 0;\n  $$0230 = -1;\n  while (1) {\n   if (($$0217 | 0) == 4) break;\n   $21 = HEAP8[$0 + (HEAP32[$8 + ($$0217 << 2) >> 2] | 0) >> 0] | 0;\n   $$0217 = $$0217 + 1 | 0;\n   $$0228 = ($21 & 255) > ($$0228 & 255) ? $21 : $$0228;\n   $$0230 = ($21 & 255) < ($$0230 & 255) ? $21 : $$0230;\n  }\n  $25 = $$0228 & 255;\n  $26 = $$0230 & 255;\n  if (($25 - $26 | 0) < 30) {\n   HEAP32[$2 >> 2] = -1;\n   HEAP32[$3 >> 2] = 0;\n   HEAPF64[$4 >> 3] = -1.0;\n   $$0212 = -2;\n   break;\n  }\n  $30 = ($25 + $26 | 0) >>> 1;\n  $$1218 = 0;\n  while (1) {\n   if (($$1218 | 0) == 4) break;\n   HEAP8[$7 + $$1218 >> 0] = $30 >>> 0 > (HEAPU8[$0 + (HEAP32[$8 + ($$1218 << 2) >> 2] | 0) >> 0] | 0) >>> 0 & 1;\n   $$1218 = $$1218 + 1 | 0;\n  }\n  $$2219 = 0;\n  while (1) {\n   if ($$2219 >>> 0 >= 4) {\n    label = 18;\n    break;\n   }\n   $44 = $$2219 + 1 | 0;\n   if ((HEAP8[$7 + $$2219 >> 0] | 0) == 1) if ((HEAP8[$7 + ($44 & 3) >> 0] | 0) == 1) if (!(HEAP8[$7 + ($$2219 + 2 & 3) >> 0] | 0)) {\n    label = 17;\n    break;\n   }\n   $$2219 = $44;\n  }\n  if ((label | 0) == 17) HEAP32[$3 >> 2] = $$2219; else if ((label | 0) == 18) if (($$2219 | 0) == 4) {\n   HEAP32[$2 >> 2] = -1;\n   HEAP32[$3 >> 2] = 0;\n   HEAPF64[$4 >> 3] = -1.0;\n   $$0212 = -3;\n   break;\n  }\n  $$0225 = 255;\n  $$3220 = 0;\n  while (1) {\n   if (($$3220 | 0) == ($14 | 0)) break;\n   $55 = $0 + $$3220 | 0;\n   $57 = HEAPU8[$55 >> 0] | 0;\n   $58 = $57 - $30 | 0;\n   $spec$select232 = ($58 | 0) < 0 ? 0 - $58 | 0 : $58;\n   HEAP8[$55 >> 0] = $30 >>> 0 > $57 >>> 0 & 1;\n   $$0225 = ($spec$select232 | 0) < ($$0225 | 0) ? $spec$select232 : $$0225;\n   $$3220 = $$3220 + 1 | 0;\n  }\n  $65 = HEAP32[$3 >> 2] | 0;\n  L31 : do switch ($65 | 0) {\n  case 0:\n   {\n    $$0213 = $65;\n    $194 = 0;\n    $195 = 0;\n    while (1) {\n     if (($$0213 | 0) >= ($1 | 0)) {\n      $149 = $194;\n      $173 = $195;\n      break L31;\n     }\n     $67 = ($$0213 | 0) == ($11 | 0);\n     $68 = Math_imul($$0213, $1) | 0;\n     $$4221 = 0;\n     $73 = $194;\n     $74 = $195;\n     while (1) {\n      if (($$4221 | 0) == ($1 | 0)) break;\n      if (!($$4221 | $$0213)) {\n       $196 = $73;\n       $197 = $74;\n      } else if ($67 & (($$4221 | 0) == 0 | ($$4221 | 0) == ($11 | 0))) {\n       $196 = $73;\n       $197 = $74;\n      } else {\n       $75 = _bitshift64Shl($73 | 0, $74 | 0, 1) | 0;\n       $196 = $75 | (HEAP8[$0 + ($$4221 + $68) >> 0] | 0) != 0;\n       $197 = tempRet0;\n      }\n      $$4221 = $$4221 + 1 | 0;\n      $73 = $196;\n      $74 = $197;\n     }\n     $$0213 = $$0213 + 1 | 0;\n     $194 = $73;\n     $195 = $74;\n    }\n    break;\n   }\n  case 1:\n   {\n    $$5222 = 0;\n    $192 = 0;\n    $193 = 0;\n    while (1) {\n     if (($$5222 | 0) >= ($1 | 0)) {\n      $149 = $192;\n      $173 = $193;\n      break L31;\n     }\n     $86 = ($$5222 | 0) == 0;\n     $87 = ($$5222 | 0) == ($11 | 0);\n     $$1214 = $11;\n     $91 = $192;\n     $92 = $193;\n     while (1) {\n      if (($$1214 | 0) <= -1) break;\n      $89 = ($$1214 | 0) == ($11 | 0);\n      if ($86 & $89) {\n       $198 = $91;\n       $199 = $92;\n      } else if ($87 & ($89 | ($$1214 | 0) == 0)) {\n       $198 = $91;\n       $199 = $92;\n      } else {\n       $93 = _bitshift64Shl($91 | 0, $92 | 0, 1) | 0;\n       $97 = $0 + ((Math_imul($$1214, $1) | 0) + $$5222) | 0;\n       $198 = $93 | (HEAP8[$97 >> 0] | 0) != 0;\n       $199 = tempRet0;\n      }\n      $$1214 = $$1214 + -1 | 0;\n      $91 = $198;\n      $92 = $199;\n     }\n     $$5222 = $$5222 + 1 | 0;\n     $192 = $91;\n     $193 = $92;\n    }\n    break;\n   }\n  case 2:\n   {\n    $$2215 = $11;\n    $190 = 0;\n    $191 = 0;\n    while (1) {\n     if (($$2215 | 0) <= -1) {\n      $149 = $190;\n      $173 = $191;\n      break L31;\n     }\n     $or$cond7249 = ($$2215 | 0) == ($11 | 0) | ($$2215 | 0) == 0;\n     $107 = Math_imul($$2215, $1) | 0;\n     $$6223 = $11;\n     $112 = $190;\n     $113 = $191;\n     while (1) {\n      if (($$6223 | 0) <= -1) break;\n      if ($or$cond7249 & ($$6223 | 0) == ($11 | 0) | ($$6223 | $$2215 | 0) == 0) {\n       $200 = $112;\n       $201 = $113;\n      } else {\n       $114 = _bitshift64Shl($112 | 0, $113 | 0, 1) | 0;\n       $200 = $114 | (HEAP8[$0 + ($$6223 + $107) >> 0] | 0) != 0;\n       $201 = tempRet0;\n      }\n      $$6223 = $$6223 + -1 | 0;\n      $112 = $200;\n      $113 = $201;\n     }\n     $$2215 = $$2215 + -1 | 0;\n     $190 = $112;\n     $191 = $113;\n    }\n    break;\n   }\n  case 3:\n   {\n    $$7224 = $11;\n    $188 = 0;\n    $189 = 0;\n    while (1) {\n     if (($$7224 | 0) <= -1) {\n      $149 = $188;\n      $173 = $189;\n      break L31;\n     }\n     $125 = ($$7224 | 0) == ($11 | 0);\n     $126 = ($$7224 | 0) == 0;\n     $$3216 = 0;\n     $132 = $188;\n     $133 = $189;\n     while (1) {\n      if (($$3216 | 0) >= ($1 | 0)) break;\n      if ($125 & ($$3216 | 0) == 0 | ($$3216 | $$7224 | 0) == 0 | $126 & ($$3216 | 0) == ($11 | 0)) {\n       $202 = $132;\n       $203 = $133;\n      } else {\n       $134 = _bitshift64Shl($132 | 0, $133 | 0, 1) | 0;\n       $138 = $0 + ((Math_imul($$3216, $1) | 0) + $$7224) | 0;\n       $202 = $134 | (HEAP8[$138 >> 0] | 0) != 0;\n       $203 = tempRet0;\n      }\n      $$3216 = $$3216 + 1 | 0;\n      $132 = $202;\n      $133 = $203;\n     }\n     $$7224 = $$7224 + -1 | 0;\n     $188 = $132;\n     $189 = $133;\n    }\n    break;\n   }\n  default:\n   {\n    $149 = 0;\n    $173 = 0;\n   }\n  } while (0);\n  HEAPF64[$4 >> 3] = ($$0225 | 0) > 30 ? 1.0 : +($$0225 | 0) / 30.0;\n  switch ($5 | 0) {\n  case 259:\n   {\n    $150 = HEAP8[4110 + $149 >> 0] | 0;\n    $151 = $150 << 24 >> 24;\n    $154 = $9;\n    HEAP32[$154 >> 2] = $151;\n    HEAP32[$154 + 4 >> 2] = (($151 | 0) < 0) << 31 >> 31;\n    if ($150 << 24 >> 24 < 0) {\n     HEAP32[$2 >> 2] = -1;\n     HEAPF64[$4 >> 3] = -1.0;\n     $$0212 = -4;\n     break L1;\n    }\n    break;\n   }\n  case 515:\n   {\n    $160 = HEAP8[3982 + $149 >> 0] | 0;\n    $161 = $160 << 24 >> 24;\n    $164 = $9;\n    HEAP32[$164 >> 2] = $161;\n    HEAP32[$164 + 4 >> 2] = (($161 | 0) < 0) << 31 >> 31;\n    if ($6 | 0) HEAP32[$6 >> 2] = HEAPU8[4046 + $149 >> 0];\n    if ($160 << 24 >> 24 < 0) {\n     HEAP32[$2 >> 2] = -1;\n     HEAPF64[$4 >> 3] = -1.0;\n     $$0212 = -4;\n     break L1;\n    }\n    break;\n   }\n  case 772:\n  case 1028:\n  case 1029:\n  case 1285:\n   {\n    $174 = _decode_bch($5, $149, $173, 0, $9) | 0;\n    if (($174 | 0) < 0) {\n     HEAP32[$2 >> 2] = -1;\n     HEAPF64[$4 >> 3] = -1.0;\n     $$0212 = -4;\n     break L1;\n    }\n    if (($6 | 0) != 0 & ($174 | 0) != 0) HEAP32[$6 >> 2] = $174;\n    break;\n   }\n  default:\n   {\n    $178 = $9;\n    HEAP32[$178 >> 2] = $149;\n    HEAP32[$178 + 4 >> 2] = $173;\n   }\n  }\n  HEAP32[$2 >> 2] = HEAP32[$9 >> 2];\n  $$0212 = 0;\n } while (0);\n STACKTOP = sp;\n return $$0212 | 0;\n}\n\nfunction _arMultiReadConfigFile($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0151 = 0, $$0152 = 0, $$0154 = 0, $$1 = 0, $$1$ph = 0, $$2 = 0, $$sink204 = 0, $$sink205 = 0, $10 = 0, $114 = 0, $12 = 0, $125 = 0, $15 = 0, $17 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $37 = 0, $4 = 0, $41 = 0, $5 = 0, $51 = 0, $52 = 0, $56 = 0, $57 = 0, $59 = 0, $6 = 0, $7 = 0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $86 = 0.0, $90 = 0.0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer11 = 0, $vararg_buffer13 = 0, $vararg_buffer17 = 0, $vararg_buffer21 = 0, $vararg_buffer24 = 0, $vararg_buffer28 = 0, $vararg_buffer31 = 0, $vararg_buffer35 = 0, $vararg_buffer41 = 0, $vararg_buffer45 = 0, $vararg_buffer49 = 0, $vararg_buffer5 = 0, $vararg_buffer55 = 0, $vararg_buffer59 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 2528 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(2528);\n $vararg_buffer59 = sp + 208 | 0;\n $vararg_buffer55 = sp + 200 | 0;\n $vararg_buffer49 = sp + 184 | 0;\n $vararg_buffer45 = sp + 176 | 0;\n $vararg_buffer41 = sp + 168 | 0;\n $vararg_buffer35 = sp + 152 | 0;\n $vararg_buffer31 = sp + 144 | 0;\n $vararg_buffer28 = sp + 136 | 0;\n $vararg_buffer24 = sp + 128 | 0;\n $vararg_buffer21 = sp + 120 | 0;\n $vararg_buffer17 = sp + 112 | 0;\n $vararg_buffer13 = sp + 104 | 0;\n $vararg_buffer11 = sp + 96 | 0;\n $vararg_buffer8 = sp + 88 | 0;\n $vararg_buffer5 = sp + 80 | 0;\n $vararg_buffer1 = sp + 72 | 0;\n $vararg_buffer = sp + 64 | 0;\n $2 = sp;\n $3 = sp + 2272 | 0;\n $4 = sp + 224 | 0;\n $5 = sp + 220 | 0;\n $6 = sp + 216 | 0;\n $7 = sp + 212 | 0;\n $8 = _fopen($0, 4886) | 0;\n do if (!$8) {\n  HEAP32[$vararg_buffer >> 2] = $0;\n  _arLog(0, 3, 4888, $vararg_buffer);\n  $10 = ___errno_location() | 0;\n  $12 = _strerror(HEAP32[$10 >> 2] | 0) | 0;\n  HEAP32[$vararg_buffer1 >> 2] = 19061;\n  HEAP32[$vararg_buffer1 + 4 >> 2] = $12;\n  _arLog(0, 3, 4941, $vararg_buffer1);\n  $$0154 = 0;\n } else {\n  _get_buff($3, $8);\n  HEAP32[$vararg_buffer5 >> 2] = $6;\n  if ((_sscanf($3, 4947, $vararg_buffer5) | 0) != 1) {\n   HEAP32[$vararg_buffer8 >> 2] = $0;\n   _arLog(0, 3, 4950, $vararg_buffer8);\n   _fclose($8) | 0;\n   $$0154 = 0;\n   break;\n  }\n  $15 = HEAP32[$6 >> 2] | 0;\n  $17 = _malloc($15 * 320 | 0) | 0;\n  if (!$17) {\n   _arLog(0, 3, 5051, $vararg_buffer11);\n   _exit(1);\n  }\n  $19 = ($1 | 0) == 0;\n  $20 = $2 + 8 | 0;\n  $21 = $2 + 16 | 0;\n  $22 = $2 + 24 | 0;\n  $23 = $2 + 32 | 0;\n  $24 = $2 + 40 | 0;\n  $25 = $2 + 48 | 0;\n  $26 = $2 + 56 | 0;\n  $$0151 = 0;\n  $$0152 = 0;\n  $28 = $15;\n  L10 : while (1) {\n   if (($$0151 | 0) >= ($28 | 0)) {\n    label = 31;\n    break;\n   }\n   _get_buff($3, $8);\n   $29 = $17 + ($$0151 * 320 | 0) | 0;\n   $30 = $17 + ($$0151 * 320 | 0) + 312 | 0;\n   HEAP32[$vararg_buffer13 >> 2] = $30;\n   HEAP32[$vararg_buffer13 + 4 >> 2] = $5;\n   if ((_sscanf($3, 5068, $vararg_buffer13) | 0) == 1) {\n    $41 = HEAP32[$30 >> 2] | 0;\n    HEAP32[$29 >> 2] = ($41 & -32768 | 0) == 0 & 0 == 0 ? $41 & 32767 : 0;\n    $$sink204 = 2;\n    $$sink205 = 1;\n   } else {\n    if ($19) {\n     label = 11;\n     break;\n    }\n    if (!(_arUtilGetDirectoryNameFromPath($4, $0, 2048, 1) | 0)) {\n     label = 13;\n     break;\n    }\n    _strncat($4, $3, 2047 - (_strlen($4) | 0) | 0) | 0;\n    $37 = _arPattLoad($1, $4) | 0;\n    HEAP32[$29 >> 2] = $37;\n    if (($37 | 0) < 0) {\n     label = 15;\n     break;\n    } else {\n     $$sink204 = 1;\n     $$sink205 = 0;\n    }\n   }\n   HEAP32[$17 + ($$0151 * 320 | 0) + 4 >> 2] = $$sink205;\n   $51 = $$0152 | $$sink204;\n   _get_buff($3, $8);\n   $52 = $17 + ($$0151 * 320 | 0) + 8 | 0;\n   HEAP32[$vararg_buffer28 >> 2] = $52;\n   if ((_sscanf($3, 5364, $vararg_buffer28) | 0) != 1) {\n    label = 18;\n    break;\n   }\n   _get_buff($3, $8);\n   $56 = $17 + ($$0151 * 320 | 0) + 16 | 0;\n   $57 = $17 + ($$0151 * 320 | 0) + 24 | 0;\n   $59 = $17 + ($$0151 * 320 | 0) + 40 | 0;\n   HEAP32[$vararg_buffer35 >> 2] = $56;\n   HEAP32[$vararg_buffer35 + 4 >> 2] = $57;\n   HEAP32[$vararg_buffer35 + 8 >> 2] = $17 + ($$0151 * 320 | 0) + 32;\n   HEAP32[$vararg_buffer35 + 12 >> 2] = $59;\n   if ((_sscanf($3, 5473, $vararg_buffer35) | 0) == 4) $$1$ph = 1; else {\n    HEAP32[$vararg_buffer41 >> 2] = $vararg_buffer5;\n    HEAP32[$vararg_buffer41 + 4 >> 2] = $7;\n    if ((_sscanf($3, 5489, $vararg_buffer41) | 0) != 2) {\n     label = 23;\n     break;\n    }\n    $$1$ph = 0;\n   }\n   $$1 = $$1$ph;\n   do {\n    _get_buff($3, $8);\n    HEAP32[$vararg_buffer49 >> 2] = $17 + ($$0151 * 320 | 0) + 16 + ($$1 << 5);\n    HEAP32[$vararg_buffer49 + 4 >> 2] = $17 + ($$0151 * 320 | 0) + 16 + ($$1 << 5) + 8;\n    HEAP32[$vararg_buffer49 + 8 >> 2] = $17 + ($$0151 * 320 | 0) + 16 + ($$1 << 5) + 16;\n    HEAP32[$vararg_buffer49 + 12 >> 2] = $17 + ($$0151 * 320 | 0) + 16 + ($$1 << 5) + 24;\n    if ((_sscanf($3, 5473, $vararg_buffer49) | 0) != 4) {\n     label = 25;\n     break L10;\n    }\n    $$1 = $$1 + 1 | 0;\n   } while ($$1 >>> 0 < 3);\n   _arUtilMatInv($56, $17 + ($$0151 * 320 | 0) + 112 | 0) | 0;\n   $75 = +HEAPF64[$52 >> 3];\n   $76 = $75 * -.5;\n   HEAPF64[$2 >> 3] = $76;\n   $77 = $75 * .5;\n   HEAPF64[$20 >> 3] = $77;\n   HEAPF64[$21 >> 3] = $77;\n   HEAPF64[$22 >> 3] = $77;\n   HEAPF64[$23 >> 3] = $77;\n   HEAPF64[$24 >> 3] = $76;\n   HEAPF64[$25 >> 3] = $76;\n   HEAPF64[$26 >> 3] = $76;\n   $78 = $17 + ($$0151 * 320 | 0) + 48 | 0;\n   $79 = $17 + ($$0151 * 320 | 0) + 56 | 0;\n   $80 = $17 + ($$0151 * 320 | 0) + 72 | 0;\n   $81 = $17 + ($$0151 * 320 | 0) + 80 | 0;\n   $82 = $17 + ($$0151 * 320 | 0) + 88 | 0;\n   $83 = $17 + ($$0151 * 320 | 0) + 104 | 0;\n   $$2 = 0;\n   while (1) {\n    if (($$2 | 0) == 4) break;\n    $86 = +HEAPF64[$2 + ($$2 << 4) >> 3];\n    $90 = +HEAPF64[$2 + ($$2 << 4) + 8 >> 3];\n    HEAPF64[$17 + ($$0151 * 320 | 0) + 208 + ($$2 * 24 | 0) >> 3] = +HEAPF64[$59 >> 3] + (+HEAPF64[$56 >> 3] * $86 + +HEAPF64[$57 >> 3] * $90);\n    HEAPF64[$17 + ($$0151 * 320 | 0) + 208 + ($$2 * 24 | 0) + 8 >> 3] = +HEAPF64[$80 >> 3] + ($86 * +HEAPF64[$78 >> 3] + $90 * +HEAPF64[$79 >> 3]);\n    HEAPF64[$17 + ($$0151 * 320 | 0) + 208 + ($$2 * 24 | 0) + 16 >> 3] = +HEAPF64[$83 >> 3] + ($86 * +HEAPF64[$81 >> 3] + $90 * +HEAPF64[$82 >> 3]);\n    $$2 = $$2 + 1 | 0;\n   }\n   $$0151 = $$0151 + 1 | 0;\n   $$0152 = $51;\n   $28 = HEAP32[$6 >> 2] | 0;\n  }\n  if ((label | 0) == 11) {\n   HEAP32[$vararg_buffer17 >> 2] = $0;\n   HEAP32[$vararg_buffer17 + 4 >> 2] = $3;\n   _arLog(0, 3, 5075, $vararg_buffer17);\n  } else if ((label | 0) == 13) {\n   HEAP32[$vararg_buffer21 >> 2] = $0;\n   _arLog(0, 3, 5203, $vararg_buffer21);\n  } else if ((label | 0) == 15) {\n   HEAP32[$vararg_buffer24 >> 2] = $0;\n   HEAP32[$vararg_buffer24 + 4 >> 2] = $4;\n   _arLog(0, 3, 5287, $vararg_buffer24);\n  } else if ((label | 0) == 18) {\n   HEAP32[$vararg_buffer31 >> 2] = $0;\n   HEAP32[$vararg_buffer31 + 4 >> 2] = $$0151 + 1;\n   _arLog(0, 3, 5368, $vararg_buffer31);\n  } else if ((label | 0) == 23) {\n   HEAP32[$vararg_buffer45 >> 2] = $0;\n   HEAP32[$vararg_buffer45 + 4 >> 2] = $$0151 + 1;\n   _arLog(0, 3, 5495, $vararg_buffer45);\n  } else if ((label | 0) == 25) {\n   HEAP32[$vararg_buffer55 >> 2] = $0;\n   HEAP32[$vararg_buffer55 + 4 >> 2] = $$0151 + 1;\n   _arLog(0, 3, 5495, $vararg_buffer55);\n  } else if ((label | 0) == 31) {\n   _fclose($8) | 0;\n   $114 = _malloc(136) | 0;\n   if (!$114) {\n    _arLog(0, 3, 5051, $vararg_buffer59);\n    _exit(1);\n   }\n   HEAP32[$114 >> 2] = $17;\n   HEAP32[$114 + 4 >> 2] = HEAP32[$6 >> 2];\n   HEAP32[$114 + 128 >> 2] = 0;\n   HEAP32[$114 + 104 >> 2] = 0;\n   do if (($$0152 & 3 | 0) == 3) HEAP32[$114 + 108 >> 2] = 2; else {\n    $125 = $114 + 108 | 0;\n    if (!($$0152 & 1)) {\n     HEAP32[$125 >> 2] = 1;\n     break;\n    } else {\n     HEAP32[$125 >> 2] = 0;\n     break;\n    }\n   } while (0);\n   HEAPF64[$114 + 112 >> 3] = .5;\n   HEAPF64[$114 + 120 >> 3] = .5;\n   $$0154 = $114;\n   break;\n  }\n  _fclose($8) | 0;\n  _free($17);\n  $$0154 = 0;\n } while (0);\n STACKTOP = sp;\n return $$0154 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0$i$i = 0, $$0$i$i$add$i = 0, $$0$i$i$add$i93 = 0, $$0$i$i$i = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i92 = 0, $$067 = 0, $$069 = 0, $$083 = 0, $$3 = 0, $$pre = 0, $$sroa$0$0$$sroa_idx$i = 0, $$sroa$0$0$copyload$i86103 = 0, $100 = 0, $101 = 0, $109 = 0, $113 = 0, $114 = 0, $115 = 0, $127 = 0, $13 = 0, $16 = 0, $18 = 0, $19 = 0, $22 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $36 = 0, $4 = 0, $48 = 0, $49 = 0, $5 = 0, $53 = 0, $56 = 0, $6 = 0, $64 = 0, $65 = 0, $66 = 0, $79 = 0, $81 = 0, $82 = 0, $83 = 0, $92 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 32 | 0;\n $4 = sp + 16 | 0;\n $5 = sp + 12 | 0;\n $6 = sp;\n do if (($1 - $0 | 0) > 1) if ((HEAP8[$0 >> 0] | 0) == 73) {\n  $13 = $2 + 61 | 0;\n  $$pre = $2 + 36 | 0;\n  if (HEAP8[$13 >> 0] | 0) {\n   $16 = HEAP32[$$pre >> 2] | 0;\n   $18 = HEAP32[$16 + -16 >> 2] | 0;\n   $19 = $16 + -12 | 0;\n   $$0$i$i$i = HEAP32[$19 >> 2] | 0;\n   while (1) {\n    if (($$0$i$i$i | 0) == ($18 | 0)) break;\n    $22 = $$0$i$i$i + -16 | 0;\n    __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($22);\n    $$0$i$i$i = $22;\n   }\n   HEAP32[$19 >> 2] = $18;\n  }\n  HEAP32[$4 >> 2] = 0;\n  HEAP32[$4 + 4 >> 2] = 0;\n  HEAP32[$4 + 8 >> 2] = 0;\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($4, 15153, __ZNSt3__211char_traitsIcE6lengthEPKc(15153) | 0);\n  $25 = $2 + 4 | 0;\n  $$sroa$0$0$$sroa_idx$i = $2 + 12 | 0;\n  $26 = $2 + 40 | 0;\n  $27 = $2 + 32 | 0;\n  $28 = $4 + 11 | 0;\n  $29 = $4 + 4 | 0;\n  $30 = $3 + 11 | 0;\n  $31 = $3 + 4 | 0;\n  $$083 = $0 + 1 | 0;\n  while (1) {\n   if ((HEAP8[$$083 >> 0] | 0) == 69) break;\n   if (HEAP8[$13 >> 0] | 0) {\n    HEAP32[$5 >> 2] = HEAP32[$$sroa$0$0$$sroa_idx$i >> 2];\n    $36 = HEAP32[$$pre >> 2] | 0;\n    if ($36 >>> 0 < (HEAP32[$26 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EEC2IS4_EERKNS1_IT_Lj4096EEE($3, $5);\n     HEAP32[$36 >> 2] = 0;\n     HEAP32[$36 + 4 >> 2] = 0;\n     HEAP32[$36 + 8 >> 2] = 0;\n     HEAP32[$36 + 12 >> 2] = HEAP32[$3 >> 2];\n     HEAP32[$$pre >> 2] = (HEAP32[$$pre >> 2] | 0) + 16;\n    } else __ZNSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($27, $5);\n   }\n   $48 = ((HEAP32[$25 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n   $49 = __ZN10__cxxabiv112_GLOBAL__N_118parse_template_argINS0_2DbEEEPKcS4_S4_RT_($$083, $1, $2) | 0;\n   $53 = ((HEAP32[$25 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n   if (HEAP8[$13 >> 0] | 0) {\n    $56 = HEAP32[$$pre >> 2] | 0;\n    $$0$i$i$idx$i = 0;\n    while (1) {\n     if (($$0$i$i$idx$i | 0) == -1) break;\n     $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n     __ZNSt3__213__vector_baseINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEED2Ev($56 + ($$0$i$i$add$i << 4) | 0);\n     $$0$i$i$idx$i = $$0$i$i$add$i;\n    }\n    HEAP32[$$pre >> 2] = $56 + -16;\n   }\n   if (($49 | 0) == ($$083 | 0) | ($49 | 0) == ($1 | 0)) {\n    label = 53;\n    break;\n   }\n   L29 : do if (HEAP8[$13 >> 0] | 0) {\n    $64 = HEAP32[$$pre >> 2] | 0;\n    $$sroa$0$0$copyload$i86103 = HEAP32[$$sroa$0$0$$sroa_idx$i >> 2] | 0;\n    HEAP32[$3 >> 2] = $$sroa$0$0$copyload$i86103;\n    $65 = $64 + -12 | 0;\n    $66 = HEAP32[$65 >> 2] | 0;\n    if ($66 >>> 0 < (HEAP32[$64 + -8 >> 2] | 0) >>> 0) {\n     HEAP32[$66 >> 2] = 0;\n     HEAP32[$66 + 4 >> 2] = 0;\n     HEAP32[$66 + 8 >> 2] = 0;\n     HEAP32[$66 + 12 >> 2] = $$sroa$0$0$copyload$i86103;\n     HEAP32[$65 >> 2] = (HEAP32[$65 >> 2] | 0) + 16;\n    } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($64 + -16 | 0, $3);\n    $$067 = $48;\n    while (1) {\n     if ($$067 >>> 0 >= $53 >>> 0) break L29;\n     $79 = HEAP32[(HEAP32[$$pre >> 2] | 0) + -12 >> 2] | 0;\n     $81 = (HEAP32[$2 >> 2] | 0) + ($$067 * 24 | 0) | 0;\n     $82 = $79 + -12 | 0;\n     $83 = HEAP32[$82 >> 2] | 0;\n     if (($83 | 0) == (HEAP32[$79 + -8 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($79 + -16 | 0, $81); else {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($83, $81);\n      HEAP32[$82 >> 2] = (HEAP32[$82 >> 2] | 0) + 24;\n     }\n     $$067 = $$067 + 1 | 0;\n    }\n   } while (0);\n   $$0 = $48;\n   while (1) {\n    if ($$0 >>> 0 >= $53 >>> 0) break;\n    $92 = HEAP8[$28 >> 0] | 0;\n    if (($92 << 24 >> 24 < 0 ? HEAP32[$29 >> 2] | 0 : $92 & 255) >>> 0 > 1) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15341) | 0;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, (HEAP32[$2 >> 2] | 0) + ($$0 * 24 | 0) | 0);\n    $100 = HEAP8[$30 >> 0] | 0;\n    $101 = $100 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($4, $101 ? HEAP32[$3 >> 2] | 0 : $3, $101 ? HEAP32[$31 >> 2] | 0 : $100 & 255) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$0 = $$0 + 1 | 0;\n   }\n   $$069 = $53;\n   while (1) {\n    if (($$069 | 0) == ($48 | 0)) break;\n    $109 = HEAP32[$25 >> 2] | 0;\n    $$0$i$i$idx$i92 = 0;\n    while (1) {\n     if (($$0$i$i$idx$i92 | 0) == -1) break;\n     $$0$i$i$add$i93 = $$0$i$i$idx$i92 + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($109 + ($$0$i$i$add$i93 * 24 | 0) | 0);\n     $$0$i$i$idx$i92 = $$0$i$i$add$i93;\n    }\n    HEAP32[$25 >> 2] = $109 + -24;\n    $$069 = $$069 + -1 | 0;\n   }\n   $$083 = $49;\n  }\n  if ((label | 0) == 53) {\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n   $$3 = $0;\n   break;\n  }\n  $113 = $$083 + 1 | 0;\n  $114 = HEAP8[$28 >> 0] | 0;\n  $115 = $114 << 24 >> 24 < 0;\n  if ((HEAP8[($115 ? HEAP32[$4 >> 2] | 0 : $4) + ($115 ? HEAP32[$29 >> 2] | 0 : $114 & 255) + -1 >> 0] | 0) == 62) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 16532) | 0; else __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15155) | 0;\n  HEAP32[$6 >> 2] = HEAP32[$4 >> 2];\n  HEAP32[$6 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n  HEAP32[$6 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n  $$0$i$i = 0;\n  while (1) {\n   if (($$0$i$i | 0) == 3) break;\n   HEAP32[$4 + ($$0$i$i << 2) >> 2] = 0;\n   $$0$i$i = $$0$i$i + 1 | 0;\n  }\n  __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $6);\n  $127 = HEAP32[$25 >> 2] | 0;\n  if ($127 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($127, $3);\n   HEAP32[$25 >> 2] = (HEAP32[$25 >> 2] | 0) + 24;\n  } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n  __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n  $$3 = $113;\n } else $$3 = $0; else $$3 = $0; while (0);\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction _get_global_id_code($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0177 = 0, $$0178 = 0, $$0178$off = 0, $$0182 = 0, $$0189 = 0, $$0202 = 0, $$0204 = 0, $$1 = 0, $$10 = 0, $$10199 = 0, $$11 = 0, $$11200 = 0, $$1179 = 0, $$1183 = 0, $$1190 = 0, $$12 = 0, $$2 = 0, $$2180 = 0, $$2180$off = 0, $$2191 = 0, $$3 = 0, $$3181 = 0, $$3185 = 0, $$3192 = 0, $$4 = 0, $$4186 = 0, $$4186$off = 0, $$4193 = 0, $$5 = 0, $$5187 = 0, $$5194 = 0, $$6 = 0, $$6188 = 0, $$6188$off = 0, $$6195 = 0, $$7 = 0, $$7196 = 0, $$8 = 0, $$8197 = 0, $$9 = 0, $$9198 = 0, $109 = 0, $113 = 0, $118 = 0, $119 = 0, $120 = 0, $123 = 0, $133 = 0, $137 = 0, $144 = 0.0, $145 = 0, $148 = 0, $15 = 0, $153 = 0, $154 = 0, $19 = 0, $20 = 0, $24 = 0, $38 = 0, $49 = 0, $5 = 0, $50 = 0, $53 = 0, $6 = 0, $63 = 0, $67 = 0, $7 = 0, $71 = 0, $72 = 0, $73 = 0, $78 = 0, $8 = 0, $85 = 0, $89 = 0, $97 = 0, $or$cond229245 = 0, $trunc = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 160 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(160);\n $5 = sp + 152 | 0;\n $6 = sp + 8 | 0;\n $7 = sp;\n $8 = sp + 24 | 0;\n HEAP32[$6 >> 2] = 0;\n HEAP32[$6 + 4 >> 2] = 182;\n HEAP32[$6 + 8 >> 2] = 195;\n HEAP32[$6 + 12 >> 2] = 13;\n $$0182 = 0;\n $$0202 = 0;\n $$0204 = -1;\n while (1) {\n  if (($$0182 | 0) == 4) break;\n  $15 = HEAP8[$0 + (HEAP32[$6 + ($$0182 << 2) >> 2] | 0) >> 0] | 0;\n  $$0182 = $$0182 + 1 | 0;\n  $$0202 = ($15 & 255) > ($$0202 & 255) ? $15 : $$0202;\n  $$0204 = ($15 & 255) < ($$0204 & 255) ? $15 : $$0204;\n }\n $19 = $$0202 & 255;\n $20 = $$0204 & 255;\n L5 : do if (($19 - $20 | 0) < 30) {\n  HEAP32[$2 >> 2] = 0;\n  HEAPF64[$3 >> 3] = -1.0;\n  $$0177 = -2;\n } else {\n  $24 = ($19 + $20 | 0) >>> 1;\n  $$1183 = 0;\n  while (1) {\n   if (($$1183 | 0) == 4) break;\n   HEAP8[$5 + $$1183 >> 0] = $24 >>> 0 > (HEAPU8[$0 + (HEAP32[$6 + ($$1183 << 2) >> 2] | 0) >> 0] | 0) >>> 0 & 1;\n   $$1183 = $$1183 + 1 | 0;\n  }\n  $trunc = 0;\n  while (1) {\n   if ($trunc >>> 0 >= 4) break;\n   $38 = $trunc + 1 | 0;\n   if ((HEAP8[$5 + $trunc >> 0] | 0) == 1) if ((HEAP8[$5 + ($38 & 3) >> 0] | 0) == 1) if (!(HEAP8[$5 + ($trunc + 2 & 3) >> 0] | 0)) break;\n   $trunc = $38;\n  }\n  L20 : do switch ($trunc & 2147483647 | 0) {\n  case 4:\n   {\n    HEAP32[$2 >> 2] = 0;\n    HEAPF64[$3 >> 3] = -1.0;\n    $$0177 = -3;\n    break L5;\n    break;\n   }\n  case 0:\n   {\n    $$0 = 119;\n    $$0178 = 0;\n    $$0189 = 255;\n    while (1) {\n     if (($$0178 | 0) == 14) {\n      $$12 = $$0189;\n      label = 57;\n      break L20;\n     }\n     $$0178$off = $$0178 + -3 | 0;\n     $49 = ($$0178 & 2147483646 | 0) == 12;\n     $50 = $$0178 * 14 | 0;\n     $$1 = $$0;\n     $$1190 = $$0189;\n     $$3185 = 0;\n     while (1) {\n      if (($$3185 | 0) == 14) break;\n      if (($$3185 + -3 | $$0178$off) >>> 0 < 8) {\n       $$2 = $$1;\n       $$2191 = $$1190;\n      } else {\n       $53 = $$3185 & 2147483646;\n       if (!(($$3185 | $$0178) & 2147483646)) {\n        $$2 = $$1;\n        $$2191 = $$1190;\n       } else if ($49 & (($53 | 0) == 0 | ($53 | 0) == 12)) {\n        $$2 = $$1;\n        $$2191 = $$1190;\n       } else {\n        $63 = (HEAPU8[$0 + ($$3185 + $50) >> 0] | 0) - $24 | 0;\n        HEAP8[$8 + $$1 >> 0] = $63 >>> 31;\n        $67 = ($63 | 0) > -1 ? $63 : 0 - $63 | 0;\n        $$2 = $$1 + -1 | 0;\n        $$2191 = ($67 | 0) < ($$1190 | 0) ? $67 : $$1190;\n       }\n      }\n      $$1 = $$2;\n      $$1190 = $$2191;\n      $$3185 = $$3185 + 1 | 0;\n     }\n     $$0 = $$1;\n     $$0178 = $$0178 + 1 | 0;\n     $$0189 = $$1190;\n    }\n    break;\n   }\n  case 1:\n   {\n    $$3 = 119;\n    $$3192 = 255;\n    $$4186 = 0;\n    while (1) {\n     if (($$4186 | 0) == 14) {\n      $$12 = $$3192;\n      label = 57;\n      break L20;\n     }\n     $$4186$off = $$4186 + -3 | 0;\n     $71 = $$4186 & 2147483646;\n     $72 = ($71 | 0) == 0;\n     $73 = ($71 | 0) == 12;\n     $$1179 = 13;\n     $$4 = $$3;\n     $$4193 = $$3192;\n     while (1) {\n      if (($$1179 | 0) <= -1) break;\n      if (($$1179 + -3 | $$4186$off) >>> 0 < 8) {\n       $$5 = $$4;\n       $$5194 = $$4193;\n      } else {\n       $78 = ($$1179 & -2 | 0) == 12;\n       if ($72 & $78) {\n        $$5 = $$4;\n        $$5194 = $$4193;\n       } else if ($73 & ($$1179 >>> 0 < 2 | $78)) {\n        $$5 = $$4;\n        $$5194 = $$4193;\n       } else {\n        $85 = (HEAPU8[$0 + (($$1179 * 14 | 0) + $$4186) >> 0] | 0) - $24 | 0;\n        HEAP8[$8 + $$4 >> 0] = $85 >>> 31;\n        $89 = ($85 | 0) > -1 ? $85 : 0 - $85 | 0;\n        $$5 = $$4 + -1 | 0;\n        $$5194 = ($89 | 0) < ($$4193 | 0) ? $89 : $$4193;\n       }\n      }\n      $$1179 = $$1179 + -1 | 0;\n      $$4 = $$5;\n      $$4193 = $$5194;\n     }\n     $$3 = $$4;\n     $$3192 = $$4193;\n     $$4186 = $$4186 + 1 | 0;\n    }\n    break;\n   }\n  case 2:\n   {\n    $$2180 = 13;\n    $$6 = 119;\n    $$6195 = 255;\n    while (1) {\n     if (($$2180 | 0) <= -1) {\n      $$12 = $$6195;\n      label = 57;\n      break L20;\n     }\n     $$2180$off = $$2180 + -3 | 0;\n     $or$cond229245 = $$2180 >>> 0 < 2 | ($$2180 & -2 | 0) == 12;\n     $97 = $$2180 * 14 | 0;\n     $$5187 = 13;\n     $$7 = $$6;\n     $$7196 = $$6195;\n     while (1) {\n      if (($$5187 | 0) <= -1) break;\n      if (($$5187 + -3 | $$2180$off) >>> 0 < 8) {\n       $$8 = $$7;\n       $$8197 = $$7196;\n      } else if (($$5187 | $$2180) >>> 0 < 2 | $or$cond229245 & ($$5187 & -2 | 0) == 12) {\n       $$8 = $$7;\n       $$8197 = $$7196;\n      } else {\n       $109 = (HEAPU8[$0 + ($$5187 + $97) >> 0] | 0) - $24 | 0;\n       HEAP8[$8 + $$7 >> 0] = $109 >>> 31;\n       $113 = ($109 | 0) > -1 ? $109 : 0 - $109 | 0;\n       $$8 = $$7 + -1 | 0;\n       $$8197 = ($113 | 0) < ($$7196 | 0) ? $113 : $$7196;\n      }\n      $$5187 = $$5187 + -1 | 0;\n      $$7 = $$8;\n      $$7196 = $$8197;\n     }\n     $$2180 = $$2180 + -1 | 0;\n     $$6 = $$7;\n     $$6195 = $$7196;\n    }\n    break;\n   }\n  case 3:\n   {\n    $$6188 = 13;\n    $$9 = 119;\n    $$9198 = 255;\n    while (1) {\n     if (($$6188 | 0) <= -1) {\n      $$12 = $$9198;\n      label = 57;\n      break L20;\n     }\n     $$6188$off = $$6188 + -3 | 0;\n     $118 = $$6188 & -2;\n     $119 = ($118 | 0) == 12;\n     $120 = ($118 | 0) == 0;\n     $$10 = $$9;\n     $$10199 = $$9198;\n     $$3181 = 0;\n     while (1) {\n      if (($$3181 | 0) == 14) break;\n      if (($$3181 + -3 | $$6188$off) >>> 0 < 8) {\n       $$11 = $$10;\n       $$11200 = $$10199;\n      } else {\n       $123 = $$3181 & 2147483646;\n       if ($119 & ($123 | 0) == 0) {\n        $$11 = $$10;\n        $$11200 = $$10199;\n       } else if (($123 | $118 | 0) == 0 | $120 & ($123 | 0) == 12) {\n        $$11 = $$10;\n        $$11200 = $$10199;\n       } else {\n        $133 = (HEAPU8[$0 + (($$3181 * 14 | 0) + $$6188) >> 0] | 0) - $24 | 0;\n        HEAP8[$8 + $$10 >> 0] = $133 >>> 31;\n        $137 = ($133 | 0) > -1 ? $133 : 0 - $133 | 0;\n        $$11 = $$10 + -1 | 0;\n        $$11200 = ($137 | 0) < ($$10199 | 0) ? $137 : $$10199;\n       }\n      }\n      $$10 = $$11;\n      $$10199 = $$11200;\n      $$3181 = $$3181 + 1 | 0;\n     }\n     $$6188 = $$6188 + -1 | 0;\n     $$9 = $$10;\n     $$9198 = $$10199;\n    }\n    break;\n   }\n  default:\n   {\n    HEAP32[$2 >> 2] = $trunc;\n    $144 = 1.0;\n   }\n  } while (0);\n  if ((label | 0) == 57) {\n   HEAP32[$2 >> 2] = $trunc;\n   $144 = ($$12 | 0) > 30 ? 1.0 : +($$12 | 0) / 30.0;\n  }\n  HEAPF64[$3 >> 3] = $144;\n  $145 = _decode_bch(2830, 0, 0, $8, $7) | 0;\n  if (($145 | 0) < 0) $$0177 = -4; else {\n   if ($4 | 0) HEAP32[$4 >> 2] = $145;\n   $148 = $7;\n   $153 = HEAP32[$148 + 4 >> 2] | 0;\n   $154 = $1;\n   HEAP32[$154 >> 2] = HEAP32[$148 >> 2];\n   HEAP32[$154 + 4 >> 2] = $153;\n   $$0177 = 0;\n  }\n } while (0);\n STACKTOP = sp;\n return $$0177 | 0;\n}\n\nfunction _icpGetInitXw2Xc_from_PlanarData($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0204 = 0, $$1 = 0, $101 = 0, $102 = 0, $108 = 0, $110 = 0, $112 = 0, $116 = 0, $118 = 0, $120 = 0.0, $121 = 0, $125 = 0.0, $128 = 0.0, $129 = 0.0, $130 = 0, $133 = 0.0, $137 = 0.0, $140 = 0.0, $141 = 0.0, $143 = 0.0, $144 = 0, $149 = 0.0, $150 = 0, $157 = 0.0, $158 = 0, $162 = 0.0, $164 = 0.0, $17 = 0, $170 = 0.0, $176 = 0.0, $184 = 0.0, $192 = 0.0, $193 = 0.0, $195 = 0.0, $196 = 0.0, $198 = 0.0, $200 = 0.0, $202 = 0.0, $204 = 0.0, $208 = 0.0, $215 = 0.0, $216 = 0.0, $217 = 0.0, $218 = 0.0, $38 = 0, $39 = 0, $41 = 0, $43 = 0, $45 = 0, $46 = 0, $48 = 0, $5 = 0, $61 = 0, $88 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer11 = 0, $vararg_buffer3 = 0, $vararg_buffer5 = 0, $vararg_buffer7 = 0, $vararg_buffer9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 128 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(128);\n $vararg_buffer11 = sp + 120 | 0;\n $vararg_buffer9 = sp + 112 | 0;\n $vararg_buffer7 = sp + 104 | 0;\n $vararg_buffer5 = sp + 96 | 0;\n $vararg_buffer3 = sp + 88 | 0;\n $vararg_buffer1 = sp + 80 | 0;\n $vararg_buffer = sp + 72 | 0;\n $5 = sp;\n L1 : do if (($3 | 0) < 4) $$0204 = -1; else {\n  $$0 = 0;\n  while (1) {\n   if (($$0 | 0) >= ($3 | 0)) break;\n   if (+HEAPF64[$2 + ($$0 * 24 | 0) + 16 >> 3] != 0.0) {\n    $$0204 = -1;\n    break L1;\n   } else $$0 = $$0 + 1 | 0;\n  }\n  if (+HEAPF64[$0 >> 3] == 0.0) $$0204 = -1; else if (+HEAPF64[$0 + 32 >> 3] != 0.0) $$0204 = -1; else {\n   $17 = $0 + 40 | 0;\n   if (+HEAPF64[$17 >> 3] == 0.0) $$0204 = -1; else if (+HEAPF64[$0 + 64 >> 3] != 0.0) $$0204 = -1; else if (+HEAPF64[$0 + 72 >> 3] != 0.0) $$0204 = -1; else if (+HEAPF64[$0 + 80 >> 3] != 1.0) $$0204 = -1; else if (+HEAPF64[$0 + 24 >> 3] != 0.0) $$0204 = -1; else if (+HEAPF64[$0 + 56 >> 3] != 0.0) $$0204 = -1; else if (+HEAPF64[$0 + 88 >> 3] != 0.0) $$0204 = -1; else {\n    $38 = $3 << 1;\n    $39 = _arMatrixAlloc($38, 8) | 0;\n    if (!$39) {\n     _arLog(0, 3, 4704, $vararg_buffer);\n     $$0204 = -1;\n     break;\n    }\n    $41 = _arMatrixAlloc($38, 1) | 0;\n    if (!$41) {\n     _arMatrixFree($39) | 0;\n     _arLog(0, 3, 4730, $vararg_buffer1);\n     $$0204 = -1;\n     break;\n    }\n    $$1 = 0;\n    while (1) {\n     if (($$1 | 0) == ($3 | 0)) break;\n     $43 = $2 + ($$1 * 24 | 0) | 0;\n     $45 = HEAP32[$39 >> 2] | 0;\n     $46 = $$1 << 4;\n     HEAPF64[$45 + ($46 << 3) >> 3] = +HEAPF64[$43 >> 3];\n     $48 = $2 + ($$1 * 24 | 0) + 8 | 0;\n     HEAPF64[$45 + (($46 | 1) << 3) >> 3] = +HEAPF64[$48 >> 3];\n     HEAPF64[$45 + (($46 | 2) << 3) >> 3] = 1.0;\n     HEAPF64[$45 + (($46 | 3) << 3) >> 3] = 0.0;\n     HEAPF64[$45 + (($46 | 4) << 3) >> 3] = 0.0;\n     HEAPF64[$45 + (($46 | 5) << 3) >> 3] = 0.0;\n     $61 = $1 + ($$1 << 4) | 0;\n     HEAPF64[$45 + (($46 | 6) << 3) >> 3] = -(+HEAPF64[$43 >> 3] * +HEAPF64[$61 >> 3]);\n     HEAPF64[$45 + (($46 | 7) << 3) >> 3] = -(+HEAPF64[$48 >> 3] * +HEAPF64[$61 >> 3]);\n     HEAPF64[$45 + (($46 | 8) << 3) >> 3] = 0.0;\n     HEAPF64[$45 + (($46 | 9) << 3) >> 3] = 0.0;\n     HEAPF64[$45 + (($46 | 10) << 3) >> 3] = 0.0;\n     HEAPF64[$45 + (($46 | 11) << 3) >> 3] = +HEAPF64[$43 >> 3];\n     HEAPF64[$45 + (($46 | 12) << 3) >> 3] = +HEAPF64[$48 >> 3];\n     HEAPF64[$45 + (($46 | 13) << 3) >> 3] = 1.0;\n     $88 = $1 + ($$1 << 4) + 8 | 0;\n     HEAPF64[$45 + (($46 | 14) << 3) >> 3] = -(+HEAPF64[$43 >> 3] * +HEAPF64[$88 >> 3]);\n     HEAPF64[$45 + (($46 | 15) << 3) >> 3] = -(+HEAPF64[$48 >> 3] * +HEAPF64[$88 >> 3]);\n     $101 = HEAP32[$41 >> 2] | 0;\n     $102 = $$1 << 1;\n     HEAPF64[$101 + ($102 << 3) >> 3] = +HEAPF64[$61 >> 3];\n     HEAPF64[$101 + (($102 | 1) << 3) >> 3] = +HEAPF64[$88 >> 3];\n     $$1 = $$1 + 1 | 0;\n    }\n    $108 = _arMatrixAllocTrans($39) | 0;\n    if (!$108) {\n     _arMatrixFree($39) | 0;\n     _arMatrixFree($41) | 0;\n     _arLog(0, 3, 4756, $vararg_buffer3);\n     $$0204 = -1;\n     break;\n    }\n    $110 = _arMatrixAllocMul($108, $39) | 0;\n    if (!$110) {\n     _arMatrixFree($39) | 0;\n     _arMatrixFree($41) | 0;\n     _arMatrixFree($108) | 0;\n     _arLog(0, 3, 4782, $vararg_buffer5);\n     $$0204 = -1;\n     break;\n    }\n    $112 = _arMatrixAllocMul($108, $41) | 0;\n    if (!$112) {\n     _arMatrixFree($39) | 0;\n     _arMatrixFree($41) | 0;\n     _arMatrixFree($108) | 0;\n     _arMatrixFree($110) | 0;\n     _arLog(0, 3, 4808, $vararg_buffer7);\n     $$0204 = -1;\n     break;\n    }\n    if ((_arMatrixSelfInv($110) | 0) < 0) {\n     _arMatrixFree($39) | 0;\n     _arMatrixFree($41) | 0;\n     _arMatrixFree($108) | 0;\n     _arMatrixFree($110) | 0;\n     _arMatrixFree($112) | 0;\n     _arLog(0, 3, 4834, $vararg_buffer9);\n     $$0204 = -1;\n     break;\n    }\n    $116 = _arMatrixAllocMul($110, $112) | 0;\n    if (!$116) {\n     _arMatrixFree($39) | 0;\n     _arMatrixFree($41) | 0;\n     _arMatrixFree($108) | 0;\n     _arMatrixFree($110) | 0;\n     _arMatrixFree($112) | 0;\n     _arLog(0, 3, 4860, $vararg_buffer11);\n     $$0204 = -1;\n     break;\n    } else {\n     $118 = HEAP32[$116 >> 2] | 0;\n     $120 = +HEAPF64[$118 + 48 >> 3];\n     $121 = $5 + 16 | 0;\n     $125 = +HEAPF64[$0 + 48 >> 3];\n     $128 = +HEAPF64[$17 >> 3];\n     $129 = (+HEAPF64[$118 + 24 >> 3] - $120 * $125) / $128;\n     $130 = $5 + 8 | 0;\n     $133 = +HEAPF64[$0 + 16 >> 3];\n     $137 = +HEAPF64[$0 + 8 >> 3];\n     $140 = +HEAPF64[$0 >> 3];\n     $141 = (+HEAPF64[$118 >> 3] - $120 * $133 - $129 * $137) / $140;\n     $143 = +HEAPF64[$118 + 56 >> 3];\n     $144 = $5 + 40 | 0;\n     $149 = (+HEAPF64[$118 + 32 >> 3] - $125 * $143) / $128;\n     $150 = $5 + 32 | 0;\n     $157 = (+HEAPF64[$118 + 8 >> 3] - $133 * $143 - $137 * $149) / $140;\n     $158 = $5 + 24 | 0;\n     $162 = (+HEAPF64[$118 + 40 >> 3] - $125) / $128;\n     $164 = +HEAPF64[$118 + 16 >> 3];\n     _arMatrixFree($39) | 0;\n     _arMatrixFree($41) | 0;\n     _arMatrixFree($108) | 0;\n     _arMatrixFree($110) | 0;\n     _arMatrixFree($112) | 0;\n     _arMatrixFree($116) | 0;\n     $170 = +Math_sqrt(+($120 * $120 + ($129 * $129 + $141 * $141)));\n     $176 = +Math_sqrt(+($143 * $143 + ($149 * $149 + $157 * $157)));\n     HEAPF64[$5 >> 3] = $141 / $170;\n     HEAPF64[$130 >> 3] = $129 / $170;\n     HEAPF64[$121 >> 3] = $120 / $170;\n     HEAPF64[$158 >> 3] = $157 / $176;\n     HEAPF64[$150 >> 3] = $149 / $176;\n     HEAPF64[$144 >> 3] = $143 / $176;\n     $184 = ($170 + $176) * .5;\n     _check_rotation($5);\n     $192 = +HEAPF64[$130 >> 3];\n     $193 = +HEAPF64[$144 >> 3];\n     $195 = +HEAPF64[$121 >> 3];\n     $196 = +HEAPF64[$150 >> 3];\n     $198 = $192 * $193 - $195 * $196;\n     $200 = +HEAPF64[$158 >> 3];\n     $202 = +HEAPF64[$5 >> 3];\n     $204 = $195 * $200 - $193 * $202;\n     $208 = $196 * $202 - $192 * $200;\n     $215 = +Math_sqrt(+($208 * $208 + ($198 * $198 + $204 * $204)));\n     $216 = $198 / $215;\n     HEAPF64[$5 + 48 >> 3] = $216;\n     $217 = $204 / $215;\n     HEAPF64[$5 + 56 >> 3] = $217;\n     $218 = $208 / $215;\n     HEAPF64[$5 + 64 >> 3] = $218;\n     HEAPF64[$4 >> 3] = $202;\n     HEAPF64[$4 + 32 >> 3] = $192;\n     HEAPF64[$4 + 64 >> 3] = $195;\n     HEAPF64[$4 + 8 >> 3] = $200;\n     HEAPF64[$4 + 40 >> 3] = $196;\n     HEAPF64[$4 + 72 >> 3] = $193;\n     HEAPF64[$4 + 16 >> 3] = $216;\n     HEAPF64[$4 + 48 >> 3] = $217;\n     HEAPF64[$4 + 80 >> 3] = $218;\n     HEAPF64[$4 + 24 >> 3] = ($164 - $133 - $137 * $162) / $140 / $184;\n     HEAPF64[$4 + 56 >> 3] = $162 / $184;\n     HEAPF64[$4 + 88 >> 3] = 1.0 / $184;\n     $$0204 = 0;\n     break;\n    }\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0204 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_123parse_binary_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$add$i71 = 0, $$0$i$i$i = 0, $$0$i$i$i50 = 0, $$0$i$i$i53 = 0, $$0$i$i$i57 = 0, $$0$i$i$i61 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i70 = 0, $$1 = 0, $10 = 0, $11 = 0, $12 = 0, $14 = 0, $16 = 0, $17 = 0, $24 = 0, $28 = 0, $29 = 0, $30 = 0, $33 = 0, $35 = 0, $36 = 0, $37 = 0, $39 = 0, $4 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $63 = 0, $64 = 0, $7 = 0, $78 = 0, $79 = 0, $8 = 0, $86 = 0, $87 = 0, $9 = 0, $95 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 96 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96);\n $4 = sp + 84 | 0;\n $5 = sp + 72 | 0;\n $6 = sp + 60 | 0;\n $7 = sp + 48 | 0;\n $8 = sp + 36 | 0;\n $9 = sp + 24 | 0;\n $10 = sp + 12 | 0;\n $11 = sp;\n $12 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $3) | 0;\n do if (($12 | 0) == ($0 | 0)) $$1 = $0; else {\n  $14 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($12, $1, $3) | 0;\n  $16 = $3 + 4 | 0;\n  if (($14 | 0) == ($12 | 0)) {\n   $95 = HEAP32[$16 >> 2] | 0;\n   $$0$i$i$idx$i70 = 0;\n   while (1) {\n    if (($$0$i$i$idx$i70 | 0) == -1) break;\n    $$0$i$i$add$i71 = $$0$i$i$idx$i70 + -1 | 0;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($95 + ($$0$i$i$add$i71 * 24 | 0) | 0);\n    $$0$i$i$idx$i70 = $$0$i$i$add$i71;\n   }\n   HEAP32[$16 >> 2] = $95 + -24;\n   $$1 = $0;\n   break;\n  }\n  $17 = HEAP32[$16 >> 2] | 0;\n  if ((($17 - (HEAP32[$3 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$1 = $0; else {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, $17 + -24 | 0);\n   $24 = HEAP32[$16 >> 2] | 0;\n   $$0$i$i$idx$i = 0;\n   while (1) {\n    if (($$0$i$i$idx$i | 0) == -1) break;\n    $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($24 + ($$0$i$i$add$i * 24 | 0) | 0);\n    $$0$i$i$idx$i = $$0$i$i$add$i;\n   }\n   HEAP32[$16 >> 2] = $24 + -24;\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $24 + -48 | 0);\n   $28 = HEAP32[$16 >> 2] | 0;\n   $29 = $28 + -24 | 0;\n   $30 = $29 + 11 | 0;\n   if ((HEAP8[$30 >> 0] | 0) < 0) {\n    $33 = HEAP32[$29 >> 2] | 0;\n    HEAP8[$4 >> 0] = 0;\n    __ZNSt3__211char_traitsIcE6assignERcRKc($33, $4);\n    HEAP32[$28 + -20 >> 2] = 0;\n   } else {\n    HEAP8[$4 >> 0] = 0;\n    __ZNSt3__211char_traitsIcE6assignERcRKc($29, $4);\n    HEAP8[$30 >> 0] = 0;\n   }\n   $35 = __ZNSt3__211char_traitsIcE6lengthEPKc(15155) | 0;\n   $36 = $2 + 11 | 0;\n   $37 = HEAP8[$36 >> 0] | 0;\n   $39 = $2 + 4 | 0;\n   if (($35 | 0) == (($37 << 24 >> 24 < 0 ? HEAP32[$39 >> 2] | 0 : $37 & 255) | 0)) if (!(__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($2, 15155, $35) | 0)) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9push_backEc($29, 40);\n   __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($11, 15119, $6);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($11, 15405) | 0;\n   HEAP32[$10 >> 2] = HEAP32[$11 >> 2];\n   HEAP32[$10 + 4 >> 2] = HEAP32[$11 + 4 >> 2];\n   HEAP32[$10 + 8 >> 2] = HEAP32[$11 + 8 >> 2];\n   $$0$i$i$i = 0;\n   while (1) {\n    if (($$0$i$i$i | 0) == 3) break;\n    HEAP32[$11 + ($$0$i$i$i << 2) >> 2] = 0;\n    $$0$i$i$i = $$0$i$i$i + 1 | 0;\n   }\n   $49 = HEAP8[$36 >> 0] | 0;\n   $50 = $49 << 24 >> 24 < 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($10, $50 ? HEAP32[$2 >> 2] | 0 : $2, $50 ? HEAP32[$39 >> 2] | 0 : $49 & 255) | 0;\n   HEAP32[$9 >> 2] = HEAP32[$10 >> 2];\n   HEAP32[$9 + 4 >> 2] = HEAP32[$10 + 4 >> 2];\n   HEAP32[$9 + 8 >> 2] = HEAP32[$10 + 8 >> 2];\n   $$0$i$i$i50 = 0;\n   while (1) {\n    if (($$0$i$i$i50 | 0) == 3) break;\n    HEAP32[$10 + ($$0$i$i$i50 << 2) >> 2] = 0;\n    $$0$i$i$i50 = $$0$i$i$i50 + 1 | 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($9, 15114) | 0;\n   HEAP32[$8 >> 2] = HEAP32[$9 >> 2];\n   HEAP32[$8 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n   HEAP32[$8 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n   $$0$i$i$i53 = 0;\n   while (1) {\n    if (($$0$i$i$i53 | 0) == 3) break;\n    HEAP32[$9 + ($$0$i$i$i53 << 2) >> 2] = 0;\n    $$0$i$i$i53 = $$0$i$i$i53 + 1 | 0;\n   }\n   $63 = HEAP8[$5 + 11 >> 0] | 0;\n   $64 = $63 << 24 >> 24 < 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($8, $64 ? HEAP32[$5 >> 2] | 0 : $5, $64 ? HEAP32[$5 + 4 >> 2] | 0 : $63 & 255) | 0;\n   HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n   HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n   HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n   $$0$i$i$i57 = 0;\n   while (1) {\n    if (($$0$i$i$i57 | 0) == 3) break;\n    HEAP32[$8 + ($$0$i$i$i57 << 2) >> 2] = 0;\n    $$0$i$i$i57 = $$0$i$i$i57 + 1 | 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($7, 15117) | 0;\n   HEAP32[$4 >> 2] = HEAP32[$7 >> 2];\n   HEAP32[$4 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n   HEAP32[$4 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n   $$0$i$i$i61 = 0;\n   while (1) {\n    if (($$0$i$i$i61 | 0) == 3) break;\n    HEAP32[$7 + ($$0$i$i$i61 << 2) >> 2] = 0;\n    $$0$i$i$i61 = $$0$i$i$i61 + 1 | 0;\n   }\n   $78 = HEAP8[$4 + 11 >> 0] | 0;\n   $79 = $78 << 24 >> 24 < 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($29, $79 ? HEAP32[$4 >> 2] | 0 : $4, $79 ? HEAP32[$4 + 4 >> 2] | 0 : $78 & 255) | 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($10);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($11);\n   $86 = __ZNSt3__211char_traitsIcE6lengthEPKc(15155) | 0;\n   $87 = HEAP8[$36 >> 0] | 0;\n   if (($86 | 0) == (($87 << 24 >> 24 < 0 ? HEAP32[$39 >> 2] | 0 : $87 & 255) | 0)) if (!(__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($2, 15155, $86) | 0)) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9push_backEc($29, 41);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n   $$1 = $14;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction _pattern_match($0, $1, $2, $3, $4, $5, $6) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n var $$0175 = 0.0, $$0178 = 0, $$0180 = 0, $$0184 = 0, $$0186 = 0, $$0192 = 0, $$0200 = 0, $$0208 = 0, $$0210 = 0, $$1176 = 0.0, $$1179 = 0, $$1181 = 0, $$1181$in = 0, $$1185 = 0, $$1187 = 0, $$1193 = 0, $$1201 = 0, $$1209 = 0, $$1211 = 0, $$2 = 0, $$2182 = 0, $$2188 = 0, $$2202 = 0, $$2212 = 0, $$3 = 0.0, $$3183 = 0, $$3183$in = 0, $$3189 = 0, $$3195 = 0, $$3203 = 0, $$3213 = 0, $$4 = 0.0, $$4190 = 0, $$4196 = 0, $$4204 = 0, $$5 = 0.0, $$5191 = 0, $$5197 = 0, $$5205 = 0, $$6206 = 0, $$7 = 0.0, $$7199 = 0, $$7207 = 0, $10 = 0, $115 = 0.0, $116 = 0, $12 = 0, $18 = 0, $20 = 0, $25 = 0, $31 = 0.0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $41 = 0, $44 = 0, $45 = 0, $61 = 0.0, $62 = 0, $65 = 0, $67 = 0, $75 = 0, $80 = 0, $86 = 0.0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $95 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer1 = sp + 8 | 0;\n $vararg_buffer = sp;\n L1 : do if (($0 | 0) == 0 | ($3 | 0) < 1) {\n  HEAP32[$4 >> 2] = 0;\n  HEAP32[$5 >> 2] = 0;\n  HEAPF64[$6 >> 3] = -1.0;\n  $$2 = -1;\n } else switch ($1 | 0) {\n case 0:\n  {\n   $9 = Math_imul($3, $3) | 0;\n   $10 = $9 * 3 | 0;\n   $12 = _malloc($9 * 12 | 0) | 0;\n   if (!$12) {\n    _arLog(0, 3, 5051, $vararg_buffer);\n    _exit(1);\n   }\n   $$0186 = 0;\n   $$0208 = 0;\n   while (1) {\n    if (($$0186 | 0) == ($10 | 0)) break;\n    $18 = $$0208 + (~HEAP8[$2 + $$0186 >> 0] & 255) | 0;\n    $$0186 = $$0186 + 1 | 0;\n    $$0208 = $18;\n   }\n   $20 = ($$0208 >>> 0) / ($10 >>> 0) | 0;\n   $$0210 = 0;\n   $$1187 = 0;\n   while (1) {\n    if (($$1187 | 0) == ($10 | 0)) break;\n    $25 = (~HEAP8[$2 + $$1187 >> 0] & 255) - $20 | 0;\n    HEAP32[$12 + ($$1187 << 2) >> 2] = $25;\n    $$0210 = (Math_imul($25, $25) | 0) + $$0210 | 0;\n    $$1187 = $$1187 + 1 | 0;\n   }\n   $31 = +Math_sqrt(+(+($$0210 | 0)));\n   if ($31 / (+($3 | 0) * 1.7320508) < 15.0) {\n    HEAP32[$4 >> 2] = 0;\n    HEAP32[$5 >> 2] = 0;\n    HEAPF64[$6 >> 3] = -1.0;\n    _free($12);\n    $$2 = -2;\n    break L1;\n   }\n   $36 = HEAP32[$0 >> 2] | 0;\n   $37 = $0 + 8 | 0;\n   $38 = $0 + 12 | 0;\n   $39 = $0 + 16 | 0;\n   $$0175 = 0.0;\n   $$0178 = 0;\n   $$0180 = -1;\n   $$0192 = -1;\n   $$0200 = -1;\n   while (1) {\n    if (($$0178 | 0) >= ($36 | 0)) break;\n    $41 = HEAP32[$37 >> 2] | 0;\n    $$1181$in = $$0180;\n    L23 : while (1) {\n     $$1181 = $$1181$in + 1 | 0;\n     switch (HEAP32[$41 + ($$1181 << 2) >> 2] | 0) {\n     case 0:\n      {\n       $$1181$in = $$1181;\n       break;\n      }\n     case 2:\n      {\n       $$3 = $$0175;\n       $$3195 = $$0192;\n       $$3203 = $$0200;\n       break L23;\n       break;\n      }\n     default:\n      {\n       label = 18;\n       break L23;\n      }\n     }\n    }\n    L25 : do if ((label | 0) == 18) {\n     label = 0;\n     $44 = $$1181 << 2;\n     $$0184 = 0;\n     $$1176 = $$0175;\n     $$1193 = $$0192;\n     $$1201 = $$0200;\n     while (1) {\n      if (($$0184 | 0) == 4) {\n       $$3 = $$1176;\n       $$3195 = $$1193;\n       $$3203 = $$1201;\n       break L25;\n      }\n      $45 = $$0184 + $44 | 0;\n      $$1211 = 0;\n      $$2188 = 0;\n      while (1) {\n       if (($$2188 | 0) == ($10 | 0)) break;\n       $$1211 = (Math_imul(HEAP32[(HEAP32[(HEAP32[$38 >> 2] | 0) + ($45 << 2) >> 2] | 0) + ($$2188 << 2) >> 2] | 0, HEAP32[$12 + ($$2188 << 2) >> 2] | 0) | 0) + $$1211 | 0;\n       $$2188 = $$2188 + 1 | 0;\n      }\n      $61 = +($$1211 | 0) / +HEAPF64[(HEAP32[$39 >> 2] | 0) + ($45 << 3) >> 3] / $31;\n      $62 = $61 > $$1176;\n      $$2202 = $62 ? $$0184 : $$1201;\n      $$0184 = $$0184 + 1 | 0;\n      $$1176 = $62 ? $61 : $$1176;\n      $$1193 = $62 ? $$1181 : $$1193;\n      $$1201 = $$2202;\n     }\n    } while (0);\n    $$0175 = $$3;\n    $$0178 = $$0178 + 1 | 0;\n    $$0180 = $$1181;\n    $$0192 = $$3195;\n    $$0200 = $$3203;\n   }\n   HEAP32[$5 >> 2] = $$0200;\n   HEAP32[$4 >> 2] = $$0192;\n   HEAPF64[$6 >> 3] = $$0175;\n   _free($12);\n   $$2 = 0;\n   break L1;\n   break;\n  }\n case 1:\n  {\n   $65 = Math_imul($3, $3) | 0;\n   $67 = _malloc($65 << 2) | 0;\n   if (!$67) {\n    _arLog(0, 3, 5051, $vararg_buffer1);\n    _exit(1);\n   }\n   $$1209 = 0;\n   $$3189 = 0;\n   while (1) {\n    if (($$3189 | 0) == ($65 | 0)) break;\n    $$1209 = $$1209 + (~HEAP8[$2 + $$3189 >> 0] & 255) | 0;\n    $$3189 = $$3189 + 1 | 0;\n   }\n   $75 = ($$1209 >>> 0) / ($65 >>> 0) | 0;\n   $$2212 = 0;\n   $$4190 = 0;\n   while (1) {\n    if (($$4190 | 0) == ($65 | 0)) break;\n    $80 = (~HEAP8[$2 + $$4190 >> 0] & 255) - $75 | 0;\n    HEAP32[$67 + ($$4190 << 2) >> 2] = $80;\n    $$2212 = (Math_imul($80, $80) | 0) + $$2212 | 0;\n    $$4190 = $$4190 + 1 | 0;\n   }\n   $86 = +Math_sqrt(+(+($$2212 | 0)));\n   if ($86 / +($3 | 0) < 15.0) {\n    HEAP32[$4 >> 2] = 0;\n    HEAP32[$5 >> 2] = 0;\n    HEAPF64[$6 >> 3] = -1.0;\n    _free($67);\n    $$2 = -2;\n    break L1;\n   }\n   $90 = HEAP32[$0 >> 2] | 0;\n   $91 = $0 + 8 | 0;\n   $92 = $0 + 20 | 0;\n   $93 = $0 + 24 | 0;\n   $$1179 = 0;\n   $$2182 = -1;\n   $$4 = 0.0;\n   $$4196 = -1;\n   $$4204 = -1;\n   while (1) {\n    if (($$1179 | 0) >= ($90 | 0)) break;\n    $95 = HEAP32[$91 >> 2] | 0;\n    $$3183$in = $$2182;\n    L54 : while (1) {\n     $$3183 = $$3183$in + 1 | 0;\n     switch (HEAP32[$95 + ($$3183 << 2) >> 2] | 0) {\n     case 0:\n      {\n       $$3183$in = $$3183;\n       break;\n      }\n     case 2:\n      {\n       $$7 = $$4;\n       $$7199 = $$4196;\n       $$7207 = $$4204;\n       break L54;\n       break;\n      }\n     default:\n      {\n       label = 40;\n       break L54;\n      }\n     }\n    }\n    L56 : do if ((label | 0) == 40) {\n     label = 0;\n     $98 = $$3183 << 2;\n     $$1185 = 0;\n     $$5 = $$4;\n     $$5197 = $$4196;\n     $$5205 = $$4204;\n     while (1) {\n      if (($$1185 | 0) == 4) {\n       $$7 = $$5;\n       $$7199 = $$5197;\n       $$7207 = $$5205;\n       break L56;\n      }\n      $99 = $$1185 + $98 | 0;\n      $$3213 = 0;\n      $$5191 = 0;\n      while (1) {\n       if (($$5191 | 0) == ($65 | 0)) break;\n       $$3213 = (Math_imul(HEAP32[(HEAP32[(HEAP32[$92 >> 2] | 0) + ($99 << 2) >> 2] | 0) + ($$5191 << 2) >> 2] | 0, HEAP32[$67 + ($$5191 << 2) >> 2] | 0) | 0) + $$3213 | 0;\n       $$5191 = $$5191 + 1 | 0;\n      }\n      $115 = +($$3213 | 0) / +HEAPF64[(HEAP32[$93 >> 2] | 0) + ($99 << 3) >> 3] / $86;\n      $116 = $115 > $$5;\n      $$6206 = $116 ? $$1185 : $$5205;\n      $$1185 = $$1185 + 1 | 0;\n      $$5 = $116 ? $115 : $$5;\n      $$5197 = $116 ? $$3183 : $$5197;\n      $$5205 = $$6206;\n     }\n    } while (0);\n    $$1179 = $$1179 + 1 | 0;\n    $$2182 = $$3183;\n    $$4 = $$7;\n    $$4196 = $$7199;\n    $$4204 = $$7207;\n   }\n   HEAP32[$5 >> 2] = $$4204;\n   HEAP32[$4 >> 2] = $$4196;\n   HEAPF64[$6 >> 3] = $$4;\n   _free($67);\n   $$2 = 0;\n   break L1;\n   break;\n  }\n default:\n  {\n   $$2 = -1;\n   break L1;\n  }\n } while (0);\n STACKTOP = sp;\n return $$2 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_118parse_substitutionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$072 = 0, $$1 = 0, $$174 = 0, $$sroa$0102$0 = 0, $$sroa$096$0 = 0, $100 = 0, $104 = 0, $105 = 0, $106 = 0, $109 = 0, $12 = 0, $13 = 0, $14 = 0, $21 = 0, $22 = 0, $29 = 0, $3 = 0, $30 = 0, $37 = 0, $38 = 0, $45 = 0, $46 = 0, $53 = 0, $54 = 0, $62 = 0, $68 = 0, $69 = 0, $70 = 0, $73 = 0, $84 = 0, $85 = 0, $92 = 0, $96 = 0, $isdigit = 0, $isdigit81 = 0, $isdigittmp = 0, $isdigittmp80 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp;\n L1 : do if (($1 - $0 | 0) > 1) if ((HEAP8[$0 >> 0] | 0) == 83) {\n  $12 = HEAP8[$0 + 1 >> 0] | 0;\n  switch ($12 | 0) {\n  case 97:\n   {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj15EEERAT__Kc($3, 16445);\n    $13 = $2 + 4 | 0;\n    $14 = HEAP32[$13 >> 2] | 0;\n    if ($14 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($14, $3);\n     HEAP32[$13 >> 2] = (HEAP32[$13 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    $$1 = $0 + 2 | 0;\n    break L1;\n    break;\n   }\n  case 98:\n   {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj18EEERAT__Kc($3, 16460);\n    $21 = $2 + 4 | 0;\n    $22 = HEAP32[$21 >> 2] | 0;\n    if ($22 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($22, $3);\n     HEAP32[$21 >> 2] = (HEAP32[$21 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    $$1 = $0 + 2 | 0;\n    break L1;\n    break;\n   }\n  case 115:\n   {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj12EEERAT__Kc($3, 15939);\n    $29 = $2 + 4 | 0;\n    $30 = HEAP32[$29 >> 2] | 0;\n    if ($30 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($30, $3);\n     HEAP32[$29 >> 2] = (HEAP32[$29 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    $$1 = $0 + 2 | 0;\n    break L1;\n    break;\n   }\n  case 105:\n   {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj13EEERAT__Kc($3, 16035);\n    $37 = $2 + 4 | 0;\n    $38 = HEAP32[$37 >> 2] | 0;\n    if ($38 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($38, $3);\n     HEAP32[$37 >> 2] = (HEAP32[$37 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    $$1 = $0 + 2 | 0;\n    break L1;\n    break;\n   }\n  case 111:\n   {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj13EEERAT__Kc($3, 16112);\n    $45 = $2 + 4 | 0;\n    $46 = HEAP32[$45 >> 2] | 0;\n    if ($46 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($46, $3);\n     HEAP32[$45 >> 2] = (HEAP32[$45 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    $$1 = $0 + 2 | 0;\n    break L1;\n    break;\n   }\n  case 100:\n   {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj14EEERAT__Kc($3, 16189);\n    $53 = $2 + 4 | 0;\n    $54 = HEAP32[$53 >> 2] | 0;\n    if ($54 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($54, $3);\n     HEAP32[$53 >> 2] = (HEAP32[$53 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    $$1 = $0 + 2 | 0;\n    break L1;\n    break;\n   }\n  case 95:\n   {\n    $62 = HEAP32[$2 + 16 >> 2] | 0;\n    if (($62 | 0) == (HEAP32[$2 + 20 >> 2] | 0)) {\n     $$1 = $0;\n     break L1;\n    }\n    $68 = HEAP32[$62 + 4 >> 2] | 0;\n    $69 = $2 + 4 | 0;\n    $70 = $2 + 8 | 0;\n    $$sroa$0102$0 = HEAP32[$62 >> 2] | 0;\n    while (1) {\n     if (($$sroa$0102$0 | 0) == ($68 | 0)) break;\n     $73 = HEAP32[$69 >> 2] | 0;\n     if (($73 | 0) == (HEAP32[$70 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($2, $$sroa$0102$0); else {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($73, $$sroa$0102$0);\n      HEAP32[$69 >> 2] = (HEAP32[$69 >> 2] | 0) + 24;\n     }\n     $$sroa$0102$0 = $$sroa$0102$0 + 24 | 0;\n    }\n    $$1 = $0 + 2 | 0;\n    break L1;\n    break;\n   }\n  default:\n   {\n    $isdigittmp = $12 + -48 | 0;\n    $isdigit = $isdigittmp >>> 0 < 10;\n    if (!$isdigit) if (!(_isupper($12) | 0)) {\n     $$1 = $0;\n     break L1;\n    }\n    $$072 = $0 + 2 | 0;\n    $$174 = $isdigit ? $isdigittmp : $12 + -55 | 0;\n    while (1) {\n     if (($$072 | 0) == ($1 | 0)) {\n      $$1 = $0;\n      break L1;\n     }\n     $84 = HEAP8[$$072 >> 0] | 0;\n     $85 = $84 << 24 >> 24;\n     $isdigittmp80 = $85 + -48 | 0;\n     $isdigit81 = $isdigittmp80 >>> 0 < 10;\n     if (!$isdigit81) if (!(_isupper($85) | 0)) break;\n     $$072 = $$072 + 1 | 0;\n     $$174 = ($isdigit81 ? $isdigittmp80 : $85 + -55 | 0) + ($$174 * 36 | 0) | 0;\n    }\n    if ($84 << 24 >> 24 != 95) {\n     $$1 = $0;\n     break L1;\n    }\n    $92 = $$174 + 1 | 0;\n    $96 = HEAP32[$2 + 16 >> 2] | 0;\n    $100 = $96;\n    if ($92 >>> 0 >= (HEAP32[$2 + 20 >> 2] | 0) - $96 >> 4 >>> 0) {\n     $$1 = $0;\n     break L1;\n    }\n    $104 = HEAP32[$100 + ($92 << 4) + 4 >> 2] | 0;\n    $105 = $2 + 4 | 0;\n    $106 = $2 + 8 | 0;\n    $$sroa$096$0 = HEAP32[$100 + ($92 << 4) >> 2] | 0;\n    while (1) {\n     if (($$sroa$096$0 | 0) == ($104 | 0)) break;\n     $109 = HEAP32[$105 >> 2] | 0;\n     if (($109 | 0) == (HEAP32[$106 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($2, $$sroa$096$0); else {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($109, $$sroa$096$0);\n      HEAP32[$105 >> 2] = (HEAP32[$105 >> 2] | 0) + 24;\n     }\n     $$sroa$096$0 = $$sroa$096$0 + 24 | 0;\n    }\n    $$1 = $$072 + 1 | 0;\n    break L1;\n   }\n  }\n } else $$1 = $0; else $$1 = $0; while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZN46EmscriptenBindingInitializer_constant_bindingsC2Ev($0) {\n $0 = $0 | 0;\n var $1 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n __ZN10emscripten8functionIiJiiiEJEEEvPKcPFT_DpT0_EDpT1_(5638, 7);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(5644, 3);\n __ZN10emscripten8functionIiJiNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEJEEEvPKcPFT_DpT0_EDpT1_(5653, 2);\n __ZN10emscripten8functionIiJiNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEJEEEvPKcPFT_DpT0_EDpT1_(5664, 3);\n __ZN10emscripten8functionIiJiiEJEEEvPKcPFT_DpT0_EDpT1_(5680, 4);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(5698, 4);\n __ZN10emscripten8functionIiJNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEJEEEvPKcPFT_DpT0_EDpT1_(5718, 5);\n __ZN10emscripten8functionIiJiiiEJEEEvPKcPFT_DpT0_EDpT1_(5730, 8);\n __ZN10emscripten8functionIiJiiEJEEEvPKcPFT_DpT0_EDpT1_(5747, 5);\n __ZN10emscripten8functionIiJiiiEJEEEvPKcPFT_DpT0_EDpT1_(5767, 9);\n __ZN10emscripten8functionIiJiiiEJEEEvPKcPFT_DpT0_EDpT1_(5785, 10);\n __ZN10emscripten8functionIiJiiEJEEEvPKcPFT_DpT0_EDpT1_(5807, 6);\n __ZN10emscripten8functionIiJiiEJEEEvPKcPFT_DpT0_EDpT1_(5830, 7);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(5859, 6);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(5872, 7);\n __ZN10emscripten8functionIiJiiiEJEEEvPKcPFT_DpT0_EDpT1_(5885, 11);\n __ZN10emscripten8functionIiJiiEJEEEvPKcPFT_DpT0_EDpT1_(5904, 8);\n __ZN10emscripten8functionIiJiiEJEEEvPKcPFT_DpT0_EDpT1_(5914, 9);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(5927, 8);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(5940, 9);\n __ZN10emscripten8functionIvJiEJEEEvPKcPFT_DpT0_EDpT1_(5959, 11);\n __ZN10emscripten8functionIiJEJEEEvPKcPFT_DpT0_EDpT1_(5971, 1);\n __ZN10emscripten8functionIvJidEJEEEvPKcPFT_DpT0_EDpT1_(5983, 1);\n __ZN10emscripten8functionIdJiEJEEEvPKcPFT_DpT0_EDpT1_(6006, 1);\n __ZN10emscripten8functionIvJidEJEEEvPKcPFT_DpT0_EDpT1_(6029, 2);\n __ZN10emscripten8functionIdJiEJEEEvPKcPFT_DpT0_EDpT1_(6051, 2);\n __ZN10emscripten8functionIvJiiEJEEEvPKcPFT_DpT0_EDpT1_(6073, 1);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(6090, 10);\n __ZN10emscripten8functionIvJiiEJEEEvPKcPFT_DpT0_EDpT1_(6107, 2);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(6120, 11);\n __ZN10emscripten8functionIvJiiEJEEEvPKcPFT_DpT0_EDpT1_(6133, 3);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(6157, 12);\n __ZN10emscripten8functionIvJifEJEEEvPKcPFT_DpT0_EDpT1_(6181, 3);\n __ZN10emscripten8functionIdJiEJEEEvPKcPFT_DpT0_EDpT1_(6194, 3);\n __ZN10emscripten8functionIvJiiEJEEEvPKcPFT_DpT0_EDpT1_(6207, 4);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(6225, 13);\n __ZN10emscripten8functionIvJiiEJEEEvPKcPFT_DpT0_EDpT1_(6243, 5);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(6259, 14);\n __ZN10emscripten8functionIvJiiEJEEEvPKcPFT_DpT0_EDpT1_(6275, 6);\n __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_(6292, 15);\n __ZN10emscripten8constantIiEEvPKcRKT_(6309, 1956);\n __ZN10emscripten8constantIiEEvPKcRKT_(6338, 1960);\n __ZN10emscripten8constantIiEEvPKcRKT_(6366, 1964);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(6399, $1);\n HEAP32[$1 >> 2] = 1;\n __ZN10emscripten8constantIiEEvPKcRKT_(6416, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(6432, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(6454, $1);\n HEAP32[$1 >> 2] = 1;\n __ZN10emscripten8constantIiEEvPKcRKT_(6479, $1);\n HEAP32[$1 >> 2] = 1;\n __ZN10emscripten8constantIiEEvPKcRKT_(6504, $1);\n HEAP32[$1 >> 2] = 100;\n __ZN10emscripten8constantIiEEvPKcRKT_(6529, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(6556, $1);\n HEAP32[$1 >> 2] = 1;\n __ZN10emscripten8constantIiEEvPKcRKT_(6582, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(6608, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(6635, $1);\n HEAP32[$1 >> 2] = 1;\n __ZN10emscripten8constantIiEEvPKcRKT_(6662, $1);\n HEAP32[$1 >> 2] = 2;\n __ZN10emscripten8constantIiEEvPKcRKT_(6688, $1);\n HEAP32[$1 >> 2] = 3;\n __ZN10emscripten8constantIiEEvPKcRKT_(6713, $1);\n HEAP32[$1 >> 2] = 4;\n __ZN10emscripten8constantIiEEvPKcRKT_(6751, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(6788, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(6822, $1);\n HEAP32[$1 >> 2] = 1;\n __ZN10emscripten8constantIiEEvPKcRKT_(6846, $1);\n HEAP32[$1 >> 2] = 2;\n __ZN10emscripten8constantIiEEvPKcRKT_(6872, $1);\n HEAP32[$1 >> 2] = 2;\n __ZN10emscripten8constantIiEEvPKcRKT_(6899, $1);\n HEAP32[$1 >> 2] = 5;\n __ZN10emscripten8constantIiEEvPKcRKT_(6933, $1);\n HEAPF64[$1 >> 3] = .5;\n __ZN10emscripten8constantIdEEvPKcRKT_(6951, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(6972, $1);\n HEAP32[$1 >> 2] = 1;\n __ZN10emscripten8constantIiEEvPKcRKT_(6991, $1);\n HEAP32[$1 >> 2] = 2;\n __ZN10emscripten8constantIiEEvPKcRKT_(7009, $1);\n HEAP32[$1 >> 2] = 3;\n __ZN10emscripten8constantIiEEvPKcRKT_(7027, $1);\n HEAP32[$1 >> 2] = 4;\n __ZN10emscripten8constantIiEEvPKcRKT_(7046, $1);\n HEAP32[$1 >> 2] = 3;\n __ZN10emscripten8constantIiEEvPKcRKT_(7068, $1);\n HEAP32[$1 >> 2] = 515;\n __ZN10emscripten8constantIiEEvPKcRKT_(7087, $1);\n HEAP32[$1 >> 2] = 259;\n __ZN10emscripten8constantIiEEvPKcRKT_(7116, $1);\n HEAP32[$1 >> 2] = 4;\n __ZN10emscripten8constantIiEEvPKcRKT_(7144, $1);\n HEAP32[$1 >> 2] = 772;\n __ZN10emscripten8constantIiEEvPKcRKT_(7163, $1);\n HEAP32[$1 >> 2] = 1028;\n __ZN10emscripten8constantIiEEvPKcRKT_(7193, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(7223, $1);\n HEAP32[$1 >> 2] = 1;\n __ZN10emscripten8constantIiEEvPKcRKT_(7254, $1);\n HEAP32[$1 >> 2] = 2;\n __ZN10emscripten8constantIiEEvPKcRKT_(7290, $1);\n HEAP32[$1 >> 2] = 3;\n __ZN10emscripten8constantIiEEvPKcRKT_(7324, $1);\n HEAP32[$1 >> 2] = 0;\n __ZN10emscripten8constantIiEEvPKcRKT_(7362, $1);\n HEAP32[$1 >> 2] = 1;\n __ZN10emscripten8constantIiEEvPKcRKT_(7395, $1);\n HEAP32[$1 >> 2] = 2;\n __ZN10emscripten8constantIiEEvPKcRKT_(7442, $1);\n HEAP32[$1 >> 2] = 3;\n __ZN10emscripten8constantIiEEvPKcRKT_(7484, $1);\n HEAP32[$1 >> 2] = 4;\n __ZN10emscripten8constantIiEEvPKcRKT_(7527, $1);\n HEAP32[$1 >> 2] = 5;\n __ZN10emscripten8constantIiEEvPKcRKT_(7579, $1);\n HEAP32[$1 >> 2] = 6;\n __ZN10emscripten8constantIiEEvPKcRKT_(7630, $1);\n HEAP32[$1 >> 2] = 7;\n __ZN10emscripten8constantIiEEvPKcRKT_(7675, $1);\n HEAP32[$1 >> 2] = 8;\n __ZN10emscripten8constantIiEEvPKcRKT_(7714, $1);\n HEAP32[$1 >> 2] = 9;\n __ZN10emscripten8constantIiEEvPKcRKT_(7759, $1);\n STACKTOP = sp;\n return;\n}\n\nfunction _icpPointRobust($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$0205 = 0, $$0207 = 0, $$0209 = 0.0, $$0211 = 0.0, $$0212 = 0, $$0213 = 0.0, $$1 = 0, $$1206 = 0, $$1208 = 0, $$2 = 0, $$3 = 0, $$pn = 0.0, $$pre = 0, $100 = 0, $106 = 0.0, $107 = 0.0, $111 = 0, $115 = 0, $119 = 0, $123 = 0, $127 = 0, $131 = 0, $135 = 0, $139 = 0, $143 = 0, $147 = 0, $151 = 0, $154 = 0, $16 = 0, $19 = 0, $22 = 0, $24 = 0, $25 = 0, $27 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $47 = 0, $5 = 0, $51 = 0.0, $55 = 0.0, $56 = 0, $6 = 0, $62 = 0.0, $67 = 0.0, $69 = 0, $7 = 0, $70 = 0.0, $73 = 0.0, $76 = 0.0, $8 = 0, $83 = 0.0, $9 = 0, $95 = 0, $97 = 0.0, $99 = 0, $spec$store$select = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer3 = 0, $vararg_buffer5 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 192 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(192);\n $vararg_buffer5 = sp + 184 | 0;\n $vararg_buffer3 = sp + 176 | 0;\n $vararg_buffer1 = sp + 168 | 0;\n $vararg_buffer = sp + 160 | 0;\n $5 = sp + 144 | 0;\n $6 = sp + 48 | 0;\n $7 = sp;\n $8 = $1 + 8 | 0;\n $9 = HEAP32[$8 >> 2] | 0;\n do if (($9 | 0) < 4) $$0212 = -1; else {\n  $16 = ~~(+HEAPF64[$0 + 128 >> 3] * +($9 | 0)) + -1 | 0;\n  $spec$store$select = ($16 | 0) > 3 ? $16 : 3;\n  $19 = _malloc($9 * 96 | 0) | 0;\n  if (!$19) {\n   _arLog(0, 3, 4689, $vararg_buffer);\n   $$0212 = -1;\n   break;\n  }\n  $22 = _malloc($9 << 4) | 0;\n  if (!$22) {\n   _arLog(0, 3, 4689, $vararg_buffer1);\n   _free($19);\n   $$0212 = -1;\n   break;\n  }\n  $24 = $9 << 3;\n  $25 = _malloc($24) | 0;\n  if (!$25) {\n   _arLog(0, 3, 4689, $vararg_buffer3);\n   _free($19);\n   _free($22);\n   $$0212 = -1;\n   break;\n  }\n  $27 = _malloc($24) | 0;\n  if (!$27) {\n   _arLog(0, 3, 4689, $vararg_buffer5);\n   _free($19);\n   _free($22);\n   _free($25);\n   $$0212 = -1;\n   break;\n  }\n  $$0205 = 0;\n  while (1) {\n   if (($$0205 | 0) == 3) break;\n   $$0207 = 0;\n   while (1) {\n    if (($$0207 | 0) == 4) break;\n    HEAPF64[$3 + ($$0205 << 5) + ($$0207 << 3) >> 3] = +HEAPF64[$2 + ($$0205 << 5) + ($$0207 << 3) >> 3];\n    $$0207 = $$0207 + 1 | 0;\n   }\n   $$0205 = $$0205 + 1 | 0;\n  }\n  $34 = $1 + 4 | 0;\n  $35 = $5 + 8 | 0;\n  $36 = $27 + ($spec$store$select << 3) | 0;\n  $37 = $0 + 104 | 0;\n  $38 = $0 + 96 | 0;\n  $39 = $0 + 120 | 0;\n  $40 = $0 + 112 | 0;\n  $$0211 = 0.0;\n  $$1208 = 0;\n  L23 : while (1) {\n   _arUtilMatMul($0, $3, $6) | 0;\n   $$1206 = 0;\n   while (1) {\n    $41 = HEAP32[$8 >> 2] | 0;\n    if (($$1206 | 0) >= ($41 | 0)) break;\n    if ((_icpGetU_from_X_by_MatX2U($5, $6, (HEAP32[$34 >> 2] | 0) + ($$1206 * 24 | 0) | 0) | 0) < 0) {\n     label = 20;\n     break L23;\n    }\n    $47 = HEAP32[$1 >> 2] | 0;\n    $51 = +HEAPF64[$47 + ($$1206 << 4) >> 3] - +HEAPF64[$5 >> 3];\n    $55 = +HEAPF64[$47 + ($$1206 << 4) + 8 >> 3] - +HEAPF64[$35 >> 3];\n    $56 = $$1206 << 1;\n    HEAPF64[$22 + ($56 << 3) >> 3] = $51;\n    HEAPF64[$22 + (($56 | 1) << 3) >> 3] = $55;\n    $62 = $51 * $51 + $55 * $55;\n    HEAPF64[$27 + ($$1206 << 3) >> 3] = $62;\n    HEAPF64[$25 + ($$1206 << 3) >> 3] = $62;\n    $$1206 = $$1206 + 1 | 0;\n   }\n   _qsort($27, $41, 8, 1);\n   $67 = +HEAPF64[$36 >> 3] * 4.0;\n   $$0213 = $67 < 16.0 ? 16.0 : $67;\n   $69 = HEAP32[$8 >> 2] | 0;\n   $70 = $$0213 / 6.0;\n   $$0209 = 0.0;\n   $$2 = 0;\n   while (1) {\n    if (($$2 | 0) >= ($69 | 0)) break;\n    $73 = +HEAPF64[$27 + ($$2 << 3) >> 3];\n    if ($73 > $$0213) $$pn = $70; else {\n     $76 = 1.0 - $73 / $$0213;\n     $$pn = $70 * (1.0 - $76 * ($76 * $76));\n    }\n    $$0209 = $$0209 + $$pn;\n    $$2 = $$2 + 1 | 0;\n   }\n   $83 = $$0209 / +($69 | 0);\n   if ($83 < +HEAPF64[$37 >> 3]) {\n    label = 44;\n    break;\n   }\n   if ($$1208 | 0) if ($83 < +HEAPF64[$39 >> 3]) if ($83 / $$0211 > +HEAPF64[$40 >> 3]) {\n    label = 44;\n    break;\n   }\n   if (($$1208 | 0) == (HEAP32[$38 >> 2] | 0)) {\n    label = 44;\n    break;\n   }\n   $$0 = 0;\n   $$3 = 0;\n   $95 = $69;\n   while (1) {\n    if (($$3 | 0) >= ($95 | 0)) break;\n    $97 = +HEAPF64[$25 + ($$3 << 3) >> 3];\n    if (!($97 <= $$0213)) {\n     $$1 = $$0;\n     $$pre = $95;\n    } else {\n     $99 = $$0 * 6 | 0;\n     $100 = $19 + ($99 << 3) | 0;\n     if ((_icpGetJ_U_S($100, $0, $3, (HEAP32[$34 >> 2] | 0) + ($$3 * 24 | 0) | 0) | 0) < 0) {\n      label = 36;\n      break L23;\n     }\n     $106 = 1.0 - $97 / $$0213;\n     $107 = $106 * $106;\n     HEAPF64[$100 >> 3] = $107 * +HEAPF64[$100 >> 3];\n     $111 = $19 + (($99 | 1) << 3) | 0;\n     HEAPF64[$111 >> 3] = $107 * +HEAPF64[$111 >> 3];\n     $115 = $19 + ($99 + 2 << 3) | 0;\n     HEAPF64[$115 >> 3] = $107 * +HEAPF64[$115 >> 3];\n     $119 = $19 + ($99 + 3 << 3) | 0;\n     HEAPF64[$119 >> 3] = $107 * +HEAPF64[$119 >> 3];\n     $123 = $19 + ($99 + 4 << 3) | 0;\n     HEAPF64[$123 >> 3] = $107 * +HEAPF64[$123 >> 3];\n     $127 = $19 + ($99 + 5 << 3) | 0;\n     HEAPF64[$127 >> 3] = $107 * +HEAPF64[$127 >> 3];\n     $131 = $19 + ($99 + 6 << 3) | 0;\n     HEAPF64[$131 >> 3] = $107 * +HEAPF64[$131 >> 3];\n     $135 = $19 + ($99 + 7 << 3) | 0;\n     HEAPF64[$135 >> 3] = $107 * +HEAPF64[$135 >> 3];\n     $139 = $19 + ($99 + 8 << 3) | 0;\n     HEAPF64[$139 >> 3] = $107 * +HEAPF64[$139 >> 3];\n     $143 = $19 + ($99 + 9 << 3) | 0;\n     HEAPF64[$143 >> 3] = $107 * +HEAPF64[$143 >> 3];\n     $147 = $19 + ($99 + 10 << 3) | 0;\n     HEAPF64[$147 >> 3] = $107 * +HEAPF64[$147 >> 3];\n     $151 = $19 + ($99 + 11 << 3) | 0;\n     HEAPF64[$151 >> 3] = $107 * +HEAPF64[$151 >> 3];\n     $154 = $$3 << 1;\n     HEAPF64[$22 + ($$0 << 3) >> 3] = $107 * +HEAPF64[$22 + ($154 << 3) >> 3];\n     HEAPF64[$22 + ($$0 + 1 << 3) >> 3] = $107 * +HEAPF64[$22 + (($154 | 1) << 3) >> 3];\n     $$1 = $$0 + 2 | 0;\n     $$pre = HEAP32[$8 >> 2] | 0;\n    }\n    $$0 = $$1;\n    $$3 = $$3 + 1 | 0;\n    $95 = $$pre;\n   }\n   if (($$0 | 0) < 6) {\n    label = 40;\n    break;\n   }\n   if ((_icpGetDeltaS($7, $22, $19, $$0) | 0) < 0) {\n    label = 42;\n    break;\n   }\n   _icpUpdateMat($3, $7) | 0;\n   $$0211 = $83;\n   $$1208 = $$1208 + 1 | 0;\n  }\n  if ((label | 0) == 20) {\n   _icpGetXw2XcCleanup_221($19, $22, $25, $27);\n   $$0212 = -1;\n   break;\n  } else if ((label | 0) == 36) {\n   _icpGetXw2XcCleanup_221($19, $22, $25, $27);\n   $$0212 = -1;\n   break;\n  } else if ((label | 0) == 40) {\n   _icpGetXw2XcCleanup_221($19, $22, $25, $27);\n   $$0212 = -1;\n   break;\n  } else if ((label | 0) == 42) {\n   _icpGetXw2XcCleanup_221($19, $22, $25, $27);\n   $$0212 = -1;\n   break;\n  } else if ((label | 0) == 44) {\n   HEAPF64[$4 >> 3] = $83;\n   _free($19);\n   _free($22);\n   _free($25);\n   _free($27);\n   $$0212 = 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$0212 | 0;\n}\n\nfunction _arParamObserv2Ideal($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = +$1;\n $2 = +$2;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $$0 = 0, $$0342 = 0.0, $$0343 = 0.0, $$0345 = 0, $$0346 = 0.0, $$0348 = 0.0, $$0350 = 0.0, $$0351 = 0.0, $$0352 = 0, $$0353 = 0.0, $$0355 = 0.0, $$0357 = 0.0, $$0358 = 0.0, $$0359 = 0, $$0360 = 0.0, $$0361 = 0.0, $$0362 = 0.0, $$0363 = 0, $$0364 = 0.0, $$0365 = 0.0, $$0367 = 0.0, $$1 = 0.0, $$1344 = 0.0, $$1347 = 0.0, $$1349 = 0.0, $$1354 = 0.0, $$1356 = 0.0, $$1366 = 0.0, $$1368 = 0.0, $$sink = 0.0, $10 = 0.0, $105 = 0.0, $107 = 0.0, $108 = 0, $110 = 0.0, $113 = 0.0, $117 = 0.0, $12 = 0.0, $120 = 0.0, $121 = 0.0, $122 = 0.0, $123 = 0.0, $138 = 0.0, $14 = 0.0, $140 = 0.0, $142 = 0.0, $146 = 0.0, $149 = 0, $157 = 0.0, $158 = 0.0, $159 = 0, $16 = 0.0, $161 = 0.0, $164 = 0.0, $168 = 0.0, $171 = 0.0, $172 = 0.0, $173 = 0.0, $174 = 0.0, $18 = 0.0, $189 = 0.0, $191 = 0.0, $193 = 0.0, $197 = 0.0, $20 = 0.0, $200 = 0, $208 = 0.0, $209 = 0.0, $210 = 0, $212 = 0.0, $215 = 0.0, $218 = 0.0, $219 = 0.0, $22 = 0.0, $220 = 0.0, $229 = 0.0, $231 = 0.0, $233 = 0.0, $237 = 0.0, $24 = 0.0, $240 = 0, $26 = 0.0, $29 = 0.0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $35 = 0.0, $40 = 0.0, $50 = 0.0, $56 = 0.0, $6 = 0.0, $67 = 0.0, $73 = 0.0, $8 = 0.0, $92 = 0.0, label = 0;\n switch ($5 | 0) {\n case 4:\n  {\n   $6 = +HEAPF64[$0 >> 3];\n   $8 = +HEAPF64[$0 + 8 >> 3];\n   $10 = +HEAPF64[$0 + 16 >> 3];\n   $12 = +HEAPF64[$0 + 24 >> 3];\n   $14 = +HEAPF64[$0 + 32 >> 3];\n   $16 = +HEAPF64[$0 + 40 >> 3];\n   $18 = +HEAPF64[$0 + 48 >> 3];\n   $20 = +HEAPF64[$0 + 56 >> 3];\n   $22 = +HEAPF64[$0 + 64 >> 3];\n   $24 = ($1 - $18) / $14;\n   $26 = ($2 - $20) / $16;\n   $29 = $10 * 2.0;\n   $30 = $12 * 6.0;\n   $31 = $12 * 2.0;\n   $32 = $10 * 6.0;\n   $$0346 = $24;\n   $$0348 = $26;\n   $$0357 = $24 * $24;\n   $$0358 = $26 * $26;\n   $$0359 = 1;\n   while (1) {\n    if (!($$0358 != 0.0 | $$0357 != 0.0)) {\n     $$1347 = 0.0;\n     $$1349 = 0.0;\n     break;\n    }\n    $35 = $$0358 + $$0357;\n    $40 = $6 * $35 + 1.0 + $35 * ($8 * $35);\n    $50 = $$0357 * 3.0;\n    $56 = $$0358 * $50;\n    $67 = $$0346 - ($12 * ($35 + $$0357 * 2.0) + ($$0348 * ($29 * $$0346) + $$0346 * $40) - $24) / ($30 * $$0346 + ($29 * $$0348 + ($6 * ($$0358 + $50) + 1.0 + $8 * ($$0358 * $$0358 + ($$0357 * ($$0357 * 5.0) + $56)))));\n    $73 = $31 * $67;\n    $92 = $$0348 - ($10 * ($$0358 * 2.0 + $35) + $$0348 * $40 + $$0348 * $73 - $26) / ($32 * $$0348 + ($6 * ($$0357 + $$0358 * 3.0) + 1.0 + $8 * ($$0358 * ($$0358 * 5.0) + ($$0357 * $$0357 + $56))) + $73);\n    if (($$0359 | 0) == 4) {\n     $$1347 = $67;\n     $$1349 = $92;\n     break;\n    }\n    $$0346 = $67;\n    $$0348 = $92;\n    $$0357 = $67 * $67;\n    $$0358 = $92 * $92;\n    $$0359 = $$0359 + 1 | 0;\n   }\n   HEAPF64[$3 >> 3] = $18 + $14 * $$1347 / $22;\n   $$sink = $20 + $16 * $$1349 / $22;\n   label = 22;\n   break;\n  }\n case 3:\n  {\n   $105 = +HEAPF64[$0 >> 3];\n   $107 = ($1 - $105) / +HEAPF64[$0 + 24 >> 3];\n   $108 = $0 + 8 | 0;\n   $110 = $2 - +HEAPF64[$108 >> 3];\n   $113 = +HEAPF64[$0 + 32 >> 3] / 1.0e8;\n   $117 = +HEAPF64[$0 + 40 >> 3] / 1.0e8 / 1.0e5;\n   $120 = $107 * $107 + $110 * $110;\n   $121 = +Math_sqrt(+$120);\n   $122 = $113 * 3.0;\n   $123 = $117 * 5.0;\n   $$0360 = $120;\n   $$0363 = 1;\n   $$0364 = $121;\n   $$0365 = $110;\n   $$0367 = $107;\n   while (1) {\n    if (!($$0364 != 0.0)) {\n     $$1366 = 0.0;\n     $$1368 = 0.0;\n     break;\n    }\n    $138 = $$0364 - ($$0364 * (1.0 - $113 * $$0360 - $$0360 * ($117 * $$0360)) - $121) / (1.0 - $122 * $$0360 - $$0360 * ($123 * $$0360));\n    $140 = $$0367 * $138 / $$0364;\n    $142 = $$0365 * $138 / $$0364;\n    if (($$0363 | 0) == 3) {\n     $$1366 = $142;\n     $$1368 = $140;\n     break;\n    }\n    $146 = $140 * $140 + $142 * $142;\n    $$0360 = $146;\n    $$0363 = $$0363 + 1 | 0;\n    $$0364 = +Math_sqrt(+$146);\n    $$0365 = $142;\n    $$0367 = $140;\n   }\n   $149 = $0 + 16 | 0;\n   HEAPF64[$3 >> 3] = $105 + $$1368 / +HEAPF64[$149 >> 3];\n   $$sink = $$1366 / +HEAPF64[$149 >> 3] + +HEAPF64[$108 >> 3];\n   label = 22;\n   break;\n  }\n case 2:\n  {\n   $157 = +HEAPF64[$0 >> 3];\n   $158 = $1 - $157;\n   $159 = $0 + 8 | 0;\n   $161 = $2 - +HEAPF64[$159 >> 3];\n   $164 = +HEAPF64[$0 + 24 >> 3] / 1.0e8;\n   $168 = +HEAPF64[$0 + 32 >> 3] / 1.0e8 / 1.0e5;\n   $171 = $158 * $158 + $161 * $161;\n   $172 = +Math_sqrt(+$171);\n   $173 = $164 * 3.0;\n   $174 = $168 * 5.0;\n   $$0352 = 1;\n   $$0353 = $161;\n   $$0355 = $158;\n   $$0361 = $172;\n   $$0362 = $171;\n   while (1) {\n    if (!($$0361 != 0.0)) {\n     $$1354 = 0.0;\n     $$1356 = 0.0;\n     break;\n    }\n    $189 = $$0361 - ($$0361 * (1.0 - $164 * $$0362 - $$0362 * ($168 * $$0362)) - $172) / (1.0 - $173 * $$0362 - $$0362 * ($174 * $$0362));\n    $191 = $$0355 * $189 / $$0361;\n    $193 = $$0353 * $189 / $$0361;\n    if (($$0352 | 0) == 3) {\n     $$1354 = $193;\n     $$1356 = $191;\n     break;\n    }\n    $197 = $191 * $191 + $193 * $193;\n    $$0352 = $$0352 + 1 | 0;\n    $$0353 = $193;\n    $$0355 = $191;\n    $$0361 = +Math_sqrt(+$197);\n    $$0362 = $197;\n   }\n   $200 = $0 + 16 | 0;\n   HEAPF64[$3 >> 3] = $157 + $$1356 / +HEAPF64[$200 >> 3];\n   $$sink = $$1354 / +HEAPF64[$200 >> 3] + +HEAPF64[$159 >> 3];\n   label = 22;\n   break;\n  }\n case 1:\n  {\n   $208 = +HEAPF64[$0 >> 3];\n   $209 = $1 - $208;\n   $210 = $0 + 8 | 0;\n   $212 = $2 - +HEAPF64[$210 >> 3];\n   $215 = +HEAPF64[$0 + 24 >> 3] / 1.0e8;\n   $218 = $209 * $209 + $212 * $212;\n   $219 = +Math_sqrt(+$218);\n   $220 = $215 * 3.0;\n   $$0 = 1;\n   $$0342 = $212;\n   $$0343 = $209;\n   $$0350 = $219;\n   $$0351 = $218;\n   while (1) {\n    if (!($$0350 != 0.0)) {\n     $$1 = 0.0;\n     $$1344 = 0.0;\n     break;\n    }\n    $229 = $$0350 - ($$0350 * (1.0 - $215 * $$0351) - $219) / (1.0 - $220 * $$0351);\n    $231 = $$0343 * $229 / $$0350;\n    $233 = $$0342 * $229 / $$0350;\n    if (($$0 | 0) == 3) {\n     $$1 = $233;\n     $$1344 = $231;\n     break;\n    }\n    $237 = $231 * $231 + $233 * $233;\n    $$0 = $$0 + 1 | 0;\n    $$0342 = $233;\n    $$0343 = $231;\n    $$0350 = +Math_sqrt(+$237);\n    $$0351 = $237;\n   }\n   $240 = $0 + 16 | 0;\n   HEAPF64[$3 >> 3] = $208 + $$1344 / +HEAPF64[$240 >> 3];\n   $$sink = $$1 / +HEAPF64[$240 >> 3] + +HEAPF64[$210 >> 3];\n   label = 22;\n   break;\n  }\n default:\n  $$0345 = -1;\n }\n if ((label | 0) == 22) {\n  HEAPF64[$4 >> 3] = $$sink;\n  $$0345 = 0;\n }\n return $$0345 | 0;\n}\nfunction __ZN10__cxxabiv112_GLOBAL__N_119parse_function_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0$i$i$add$i = 0, $$0$i$i$add$i116 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i115 = 0, $$0105$ph = 0, $$0105$ph$ph = 0, $$0111 = 0, $$088 = 0, $$1112 = 0, $$1112$be = 0, $$1112$ph = 0, $$1112$ph$ph = 0, $$8 = 0, $12 = 0, $14 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $23 = 0, $27 = 0, $29 = 0, $3 = 0, $33 = 0, $4 = 0, $40 = 0, $41 = 0, $45 = 0, $49 = 0, $57 = 0, $58 = 0, $66 = 0, $71 = 0, $76 = 0, $77 = 0, $8 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp + 12 | 0;\n $4 = sp;\n do if (($0 | 0) == ($1 | 0)) $$8 = $0; else if ((HEAP8[$0 >> 0] | 0) == 70) {\n  $8 = $0 + 1 | 0;\n  if (($8 | 0) == ($1 | 0)) $$8 = $0; else {\n   if ((HEAP8[$8 >> 0] | 0) == 89) {\n    $12 = $0 + 2 | 0;\n    if (($12 | 0) == ($1 | 0)) {\n     $$8 = $0;\n     break;\n    } else $$0111 = $12;\n   } else $$0111 = $8;\n   $14 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($$0111, $1, $2) | 0;\n   if (($14 | 0) == ($$0111 | 0)) $$8 = $0; else {\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15119, __ZNSt3__211char_traitsIcE6lengthEPKc(15119) | 0);\n    $17 = $2 + 4 | 0;\n    $18 = $3 + 11 | 0;\n    $19 = $3 + 4 | 0;\n    $20 = $4 + 11 | 0;\n    $21 = $4 + 4 | 0;\n    $$0105$ph = 0;\n    $$1112$ph = $14;\n    L9 : while (1) {\n     $$1112 = $$1112$ph;\n     L11 : while (1) {\n      if (($$1112 | 0) == ($1 | 0)) {\n       label = 11;\n       break L9;\n      }\n      switch (HEAP8[$$1112 >> 0] | 0) {\n      case 69:\n       {\n        label = 16;\n        break L9;\n        break;\n       }\n      case 118:\n       {\n        $$1112$be = $$1112 + 1 | 0;\n        break;\n       }\n      case 82:\n       {\n        $29 = $$1112 + 1 | 0;\n        if (($29 | 0) == ($1 | 0)) label = 23; else if ((HEAP8[$29 >> 0] | 0) == 69) {\n         $$0105$ph$ph = 1;\n         $$1112$ph$ph = $29;\n         break L11;\n        } else label = 23;\n        break;\n       }\n      case 79:\n       {\n        $33 = $$1112 + 1 | 0;\n        if (($33 | 0) == ($1 | 0)) label = 23; else if ((HEAP8[$33 >> 0] | 0) == 69) {\n         $$0105$ph$ph = 2;\n         $$1112$ph$ph = $33;\n         break L11;\n        } else label = 23;\n        break;\n       }\n      default:\n       label = 23;\n      }\n      L20 : do if ((label | 0) == 23) {\n       label = 0;\n       $40 = ((HEAP32[$17 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n       $41 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($$1112, $1, $2) | 0;\n       $45 = ((HEAP32[$17 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n       if (($41 | 0) == ($$1112 | 0) | ($41 | 0) == ($1 | 0)) break L9;\n       $$088 = $40;\n       while (1) {\n        if ($$088 >>> 0 >= $45 >>> 0) break;\n        $49 = HEAP8[$18 >> 0] | 0;\n        if (($49 << 24 >> 24 < 0 ? HEAP32[$19 >> 2] | 0 : $49 & 255) >>> 0 > 1) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($3, 15341) | 0;\n        __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, (HEAP32[$2 >> 2] | 0) + ($$088 * 24 | 0) | 0);\n        $57 = HEAP8[$20 >> 0] | 0;\n        $58 = $57 << 24 >> 24 < 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($3, $58 ? HEAP32[$4 >> 2] | 0 : $4, $58 ? HEAP32[$21 >> 2] | 0 : $57 & 255) | 0;\n        __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n        $$088 = $$088 + 1 | 0;\n       }\n       $$0 = $40;\n       while (1) {\n        if ($$0 >>> 0 >= $45 >>> 0) {\n         $$1112$be = $41;\n         break L20;\n        }\n        $66 = HEAP32[$17 >> 2] | 0;\n        $$0$i$i$idx$i115 = 0;\n        while (1) {\n         if (($$0$i$i$idx$i115 | 0) == -1) break;\n         $$0$i$i$add$i116 = $$0$i$i$idx$i115 + -1 | 0;\n         __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($66 + ($$0$i$i$add$i116 * 24 | 0) | 0);\n         $$0$i$i$idx$i115 = $$0$i$i$add$i116;\n        }\n        HEAP32[$17 >> 2] = $66 + -24;\n        $$0 = $$0 + 1 | 0;\n       }\n      } while (0);\n      $$1112 = $$1112$be;\n     }\n     $$0105$ph = $$0105$ph$ph;\n     $$1112$ph = $$1112$ph$ph;\n    }\n    if ((label | 0) == 11) {\n     $23 = HEAP32[$17 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($23 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$17 >> 2] = $23 + -24;\n    } else if ((label | 0) == 16) {\n     $27 = $$1112 + 1 | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($3, 15117) | 0;\n     switch ($$0105$ph & 3) {\n     case 1:\n      {\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($3, 16545) | 0;\n       break;\n      }\n     case 2:\n      {\n       __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($3, 16548) | 0;\n       break;\n      }\n     default:\n      {}\n     }\n     $71 = HEAP32[$17 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) != ($71 | 0)) {\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($71 + -24 | 0, 15151) | 0;\n      $76 = HEAP8[$18 >> 0] | 0;\n      $77 = $76 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKcj((HEAP32[$17 >> 2] | 0) + -12 | 0, 0, $77 ? HEAP32[$3 >> 2] | 0 : $3, $77 ? HEAP32[$19 >> 2] | 0 : $76 & 255) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$8 = $27;\n      break;\n     }\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$8 = $0;\n   }\n  }\n } else $$8 = $0; while (0);\n STACKTOP = sp;\n return $$8 | 0;\n}\n\nfunction _QRM($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$0213 = 0, $$0215 = 0, $$0216 = 0, $$0219 = 0, $$0220 = 0, $$0221 = 0, $$0222 = 0, $$0223 = 0.0, $$0224 = 0.0, $$0224$be = 0.0, $$0227 = 0.0, $$0227$be = 0.0, $$0232 = 0.0, $$1 = 0, $$1214 = 0, $$1217 = 0, $$1225 = 0.0, $$1228 = 0.0, $$1231 = 0.0, $$2218 = 0, $$pre = 0, $106 = 0.0, $111 = 0, $112 = 0, $113 = 0, $115 = 0, $116 = 0.0, $118 = 0, $119 = 0.0, $12 = 0, $128 = 0.0, $130 = 0, $131 = 0.0, $136 = 0.0, $138 = 0.0, $14 = 0, $144 = 0, $145 = 0, $146 = 0.0, $147 = 0, $150 = 0.0, $151 = 0, $154 = 0, $159 = 0.0, $2 = 0, $20 = 0, $25 = 0.0, $26 = 0, $27 = 0, $30 = 0.0, $38 = 0, $4 = 0, $40 = 0, $43 = 0, $44 = 0, $46 = 0, $47 = 0.0, $49 = 0.0, $50 = 0.0, $51 = 0.0, $54 = 0.0, $65 = 0.0, $70 = 0.0, $74 = 0.0, $77 = 0.0, $81 = 0.0, $83 = 0, $84 = 0.0, $85 = 0, $86 = 0, $87 = 0.0, $88 = 0.0, $91 = 0, $95 = 0.0, $99 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $4 = HEAP32[$0 + 4 >> 2] | 0;\n do if (($4 | 0) < 2 ? 1 : ($4 | 0) != (HEAP32[$0 + 8 >> 2] | 0)) $$0220 = -1; else if ((HEAP32[$1 + 4 >> 2] | 0) == ($4 | 0)) {\n  $12 = _arVecAlloc($4) | 0;\n  if (!$12) $$0220 = -1; else {\n   $14 = $4 + -1 | 0;\n   HEAP32[$2 + 4 >> 2] = $14;\n   HEAP32[$2 >> 2] = (HEAP32[$12 >> 2] | 0) + 8;\n   if ((_arVecTridiagonalize($0, $1, $2) | 0) < 0) {\n    _arVecFree($12) | 0;\n    $$0220 = -1;\n    break;\n   }\n   $20 = HEAP32[$12 >> 2] | 0;\n   HEAPF64[$20 >> 3] = 0.0;\n   $$0 = $14;\n   while (1) {\n    if (($$0 | 0) <= 0) break;\n    $$0215 = $$0;\n    while (1) {\n     if (($$0215 | 0) <= 0) break;\n     $25 = +Math_abs(+(+HEAPF64[$20 + ($$0215 << 3) >> 3]));\n     $26 = HEAP32[$1 >> 2] | 0;\n     $27 = $$0215 + -1 | 0;\n     $30 = +Math_abs(+(+HEAPF64[$26 + ($27 << 3) >> 3]));\n     if ($25 > ($30 + +Math_abs(+(+HEAPF64[$26 + ($$0215 << 3) >> 3]))) * 1.0e-06) $$0215 = $27; else break;\n    }\n    $$pre = $$0 + -1 | 0;\n    L15 : do if (($$0215 | 0) != ($$0 | 0)) {\n     $38 = $20 + ($$0 << 3) | 0;\n     $40 = $20 + ($$0215 + 1 << 3) | 0;\n     $$0219 = 0;\n     do {\n      if ($$0219 >>> 0 > 99) break L15;\n      $$0219 = $$0219 + 1 | 0;\n      $43 = HEAP32[$1 >> 2] | 0;\n      $44 = $43 + ($$pre << 3) | 0;\n      $46 = $43 + ($$0 << 3) | 0;\n      $47 = +HEAPF64[$46 >> 3];\n      $49 = (+HEAPF64[$44 >> 3] - $47) * .5;\n      $50 = +HEAPF64[$38 >> 3];\n      $51 = $50 * $50;\n      $54 = +Math_sqrt(+($51 + $49 * $49));\n      $$0213 = $$0215;\n      $$0224 = +HEAPF64[$40 >> 3];\n      $$0227 = +HEAPF64[$43 + ($$0215 << 3) >> 3] - $47 + $51 / ($49 + ($49 < 0.0 ? -$54 : $54));\n      while (1) {\n       if (($$0213 | 0) >= ($$0 | 0)) break;\n       $65 = +Math_abs(+$$0227);\n       if (!($65 >= +Math_abs(+$$0224))) {\n        $77 = -$$0227 / $$0224;\n        $81 = 1.0 / +Math_sqrt(+($77 * $77 + 1.0));\n        $$0223 = $77 * $81;\n        $$1231 = $81;\n       } else if ($65 > 1.0e-16) {\n        $70 = -$$0224 / $$0227;\n        $74 = 1.0 / +Math_sqrt(+($70 * $70 + 1.0));\n        $$0223 = $74;\n        $$1231 = $70 * $74;\n       } else {\n        $$0223 = 1.0;\n        $$1231 = 0.0;\n       }\n       $83 = $43 + ($$0213 << 3) | 0;\n       $84 = +HEAPF64[$83 >> 3];\n       $85 = $$0213 + 1 | 0;\n       $86 = $43 + ($85 << 3) | 0;\n       $87 = +HEAPF64[$86 >> 3];\n       $88 = $84 - $87;\n       $91 = $20 + ($85 << 3) | 0;\n       $95 = $$1231 * ($$1231 * $88 + $$0223 * 2.0 * +HEAPF64[$91 >> 3]);\n       HEAPF64[$83 >> 3] = $84 - $95;\n       HEAPF64[$86 >> 3] = $87 + $95;\n       $99 = $20 + ($$0213 << 3) | 0;\n       if (($$0213 | 0) > ($$0215 | 0)) HEAPF64[$99 >> 3] = $$0223 * +HEAPF64[$99 >> 3] - $$0224 * $$1231;\n       $106 = +HEAPF64[$91 >> 3];\n       HEAPF64[$91 >> 3] = $106 + $$1231 * ($$0223 * $88 - $$1231 * 2.0 * $106);\n       $111 = Math_imul($$0213, $4) | 0;\n       $112 = Math_imul($85, $4) | 0;\n       $$0216 = 0;\n       $$1225 = $$0224;\n       $$1228 = $$0227;\n       while (1) {\n        if (($$0216 | 0) == ($4 | 0)) break;\n        $113 = HEAP32[$0 >> 2] | 0;\n        $115 = $113 + ($$0216 + $111 << 3) | 0;\n        $116 = +HEAPF64[$115 >> 3];\n        $118 = $113 + ($$0216 + $112 << 3) | 0;\n        $119 = +HEAPF64[$118 >> 3];\n        HEAPF64[$115 >> 3] = $$0223 * $116 - $$1231 * $119;\n        HEAPF64[$118 >> 3] = $$1231 * $116 + $$0223 * $119;\n        $$0216 = $$0216 + 1 | 0;\n        $$1225 = $119;\n        $$1228 = $116;\n       }\n       if (($$0213 | 0) < ($$pre | 0)) {\n        $128 = +HEAPF64[$91 >> 3];\n        $130 = $20 + ($$0213 + 2 << 3) | 0;\n        $131 = +HEAPF64[$130 >> 3];\n        HEAPF64[$130 >> 3] = $$0223 * $131;\n        $$0224$be = -($$1231 * $131);\n        $$0227$be = $128;\n       } else {\n        $$0224$be = $$1225;\n        $$0227$be = $$1228;\n       }\n       $$0213 = $85;\n       $$0224 = $$0224$be;\n       $$0227 = $$0227$be;\n      }\n      $136 = +Math_abs(+(+HEAPF64[$38 >> 3]));\n      $138 = +Math_abs(+(+HEAPF64[$44 >> 3]));\n     } while ($136 > ($138 + +Math_abs(+(+HEAPF64[$46 >> 3]))) * 1.0e-06);\n    } while (0);\n    $$0 = $$pre;\n   }\n   $$1214 = 0;\n   while (1) {\n    if (($$1214 | 0) == ($14 | 0)) break;\n    $144 = HEAP32[$1 >> 2] | 0;\n    $145 = $144 + ($$1214 << 3) | 0;\n    $146 = +HEAPF64[$145 >> 3];\n    $147 = $$1214 + 1 | 0;\n    $$0232 = $146;\n    $$1 = $$1214;\n    $$1217 = $147;\n    while (1) {\n     if (($$1217 | 0) >= ($4 | 0)) break;\n     $150 = +HEAPF64[$144 + ($$1217 << 3) >> 3];\n     $151 = $150 > $$0232;\n     $$0232 = $151 ? $150 : $$0232;\n     $$1 = $151 ? $$1217 : $$1;\n     $$1217 = $$1217 + 1 | 0;\n    }\n    HEAPF64[$144 + ($$1 << 3) >> 3] = $146;\n    HEAPF64[$145 >> 3] = $$0232;\n    $154 = HEAP32[$0 >> 2] | 0;\n    $$0221 = $154 + ((Math_imul($$1214, $4) | 0) << 3) | 0;\n    $$0222 = $154 + ((Math_imul($$1, $4) | 0) << 3) | 0;\n    $$2218 = 0;\n    while (1) {\n     if (($$2218 | 0) == ($4 | 0)) break;\n     $159 = +HEAPF64[$$0222 >> 3];\n     HEAPF64[$$0222 >> 3] = +HEAPF64[$$0221 >> 3];\n     HEAPF64[$$0221 >> 3] = $159;\n     $$0221 = $$0221 + 8 | 0;\n     $$0222 = $$0222 + 8 | 0;\n     $$2218 = $$2218 + 1 | 0;\n    }\n    $$1214 = $147;\n   }\n   _arVecFree($12) | 0;\n   $$0220 = 0;\n  }\n } else $$0220 = -1; while (0);\n STACKTOP = sp;\n return $$0220 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_121parse_conversion_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$i107 = 0, $$0$i$i$i110 = 0, $$0$i$i$i113 = 0, $$0$i$i$idx$i = 0, $$10 = 0, $$1100 = 0, $$4103 = 0, $$5104 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $27 = 0, $29 = 0, $3 = 0, $31 = 0, $33 = 0, $34 = 0, $4 = 0, $41 = 0, $42 = 0, $46 = 0, $47 = 0, $5 = 0, $54 = 0, $6 = 0, $65 = 0, $66 = 0, $7 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 112 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112);\n $3 = sp + 88 | 0;\n $4 = sp + 64 | 0;\n $5 = sp + 36 | 0;\n $6 = sp + 48 | 0;\n $7 = sp + 24 | 0;\n $8 = sp + 12 | 0;\n $9 = sp;\n L1 : do if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 99) if ((HEAP8[$0 + 1 >> 0] | 0) == 118) {\n  $19 = $2 + 63 | 0;\n  $20 = HEAP8[$19 >> 0] | 0;\n  HEAP8[$19 >> 0] = 0;\n  $21 = $0 + 2 | 0;\n  $22 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($21, $1, $2) | 0;\n  HEAP8[$19 >> 0] = $20;\n  if (($22 | 0) == ($21 | 0) | ($22 | 0) == ($1 | 0)) $$10 = $0; else {\n   if ((HEAP8[$22 >> 0] | 0) == 95) {\n    $29 = $22 + 1 | 0;\n    if (($29 | 0) == ($1 | 0)) {\n     $$10 = $0;\n     break;\n    }\n    $31 = HEAP8[$29 >> 0] | 0;\n    L9 : do if ($31 << 24 >> 24 == 69) {\n     $33 = $2 + 4 | 0;\n     $34 = HEAP32[$33 >> 2] | 0;\n     if ($34 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      HEAP32[$34 >> 2] = 0;\n      HEAP32[$34 + 4 >> 2] = 0;\n      HEAP32[$34 + 8 >> 2] = 0;\n      HEAP32[$34 + 12 >> 2] = 0;\n      HEAP32[$34 + 16 >> 2] = 0;\n      HEAP32[$34 + 20 >> 2] = 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2Ev($34);\n      HEAP32[$33 >> 2] = (HEAP32[$33 >> 2] | 0) + 24;\n      $$4103 = $29;\n      break;\n     } else {\n      __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE24__emplace_back_slow_pathIJEEEvDpOT_($2);\n      $$4103 = $29;\n      break;\n     }\n    } else {\n     $$1100 = $29;\n     $41 = $31;\n     while (1) {\n      if ($41 << 24 >> 24 == 69) {\n       $$4103 = $$1100;\n       break L9;\n      }\n      $42 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($$1100, $1, $2) | 0;\n      if (($42 | 0) == ($$1100 | 0) | ($42 | 0) == ($1 | 0)) {\n       $$10 = $0;\n       break L1;\n      }\n      $$1100 = $42;\n      $41 = HEAP8[$42 >> 0] | 0;\n     }\n    } while (0);\n    $$5104 = $$4103 + 1 | 0;\n   } else {\n    $27 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($22, $1, $2) | 0;\n    if (($27 | 0) == ($22 | 0)) {\n     $$10 = $0;\n     break;\n    } else $$5104 = $27;\n   }\n   $46 = $2 + 4 | 0;\n   $47 = HEAP32[$46 >> 2] | 0;\n   if ((($47 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$10 = $0; else {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $47 + -24 | 0);\n    $54 = HEAP32[$46 >> 2] | 0;\n    $$0$i$i$idx$i = 0;\n    while (1) {\n     if (($$0$i$i$idx$i | 0) == -1) break;\n     $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($54 + ($$0$i$i$add$i * 24 | 0) | 0);\n     $$0$i$i$idx$i = $$0$i$i$add$i;\n    }\n    HEAP32[$46 >> 2] = $54 + -24;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($9, $54 + -48 | 0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($9, 0, 15119) | 0;\n    HEAP32[$8 >> 2] = HEAP32[$9 >> 2];\n    HEAP32[$8 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n    HEAP32[$8 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$9 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($8, 16283) | 0;\n    HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n    HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n    HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n    $$0$i$i$i107 = 0;\n    while (1) {\n     if (($$0$i$i$i107 | 0) == 3) break;\n     HEAP32[$8 + ($$0$i$i$i107 << 2) >> 2] = 0;\n     $$0$i$i$i107 = $$0$i$i$i107 + 1 | 0;\n    }\n    $65 = HEAP8[$3 + 11 >> 0] | 0;\n    $66 = $65 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($7, $66 ? HEAP32[$3 >> 2] | 0 : $3, $66 ? HEAP32[$3 + 4 >> 2] | 0 : $65 & 255) | 0;\n    HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n    HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n    HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n    $$0$i$i$i110 = 0;\n    while (1) {\n     if (($$0$i$i$i110 | 0) == 3) break;\n     HEAP32[$7 + ($$0$i$i$i110 << 2) >> 2] = 0;\n     $$0$i$i$i110 = $$0$i$i$i110 + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15117) | 0;\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i113 = 0;\n    while (1) {\n     if (($$0$i$i$i113 | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i113 << 2) >> 2] = 0;\n     $$0$i$i$i113 = $$0$i$i$i113 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $5);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$46 >> 2] | 0) + -24 | 0, $4);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$10 = $$5104;\n   }\n  }\n } else $$10 = $0; else $$10 = $0; else $$10 = $0; while (0);\n STACKTOP = sp;\n return $$10 | 0;\n}\n\nfunction _try_realloc_chunk($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$1271 = 0, $$1271$be = 0, $$1271$ph = 0, $$1274 = 0, $$1274$be = 0, $$1274$ph = 0, $$2 = 0, $$3 = 0, $$pre$phiZ2D = 0, $101 = 0, $103 = 0, $106 = 0, $108 = 0, $11 = 0, $111 = 0, $114 = 0, $115 = 0, $116 = 0, $118 = 0, $12 = 0, $120 = 0, $121 = 0, $123 = 0, $124 = 0, $129 = 0, $130 = 0, $139 = 0, $144 = 0, $147 = 0, $148 = 0, $154 = 0, $165 = 0, $168 = 0, $175 = 0, $2 = 0, $24 = 0, $26 = 0, $3 = 0, $37 = 0, $39 = 0, $4 = 0, $40 = 0, $49 = 0, $5 = 0, $51 = 0, $53 = 0, $54 = 0, $6 = 0, $60 = 0, $67 = 0, $73 = 0, $75 = 0, $76 = 0, $79 = 0, $8 = 0, $81 = 0, $83 = 0, $96 = 0, $storemerge = 0, $storemerge3 = 0;\n $2 = $0 + 4 | 0;\n $3 = HEAP32[$2 >> 2] | 0;\n $4 = $3 & -8;\n $5 = $0 + $4 | 0;\n $6 = HEAP32[4355] | 0;\n $8 = $3 & 3;\n if (!(($8 | 0) != 1 & $6 >>> 0 <= $0 >>> 0 & $5 >>> 0 > $0 >>> 0)) _abort();\n $11 = $5 + 4 | 0;\n $12 = HEAP32[$11 >> 2] | 0;\n if (!($12 & 1)) _abort();\n if (!$8) {\n  if ($1 >>> 0 < 256) {\n   $$2 = 0;\n   return $$2 | 0;\n  }\n  if ($4 >>> 0 >= ($1 + 4 | 0) >>> 0) if (($4 - $1 | 0) >>> 0 <= HEAP32[4471] << 1 >>> 0) {\n   $$2 = $0;\n   return $$2 | 0;\n  }\n  $$2 = 0;\n  return $$2 | 0;\n }\n if ($4 >>> 0 >= $1 >>> 0) {\n  $24 = $4 - $1 | 0;\n  if ($24 >>> 0 <= 15) {\n   $$2 = $0;\n   return $$2 | 0;\n  }\n  $26 = $0 + $1 | 0;\n  HEAP32[$2 >> 2] = $3 & 1 | $1 | 2;\n  HEAP32[$26 + 4 >> 2] = $24 | 3;\n  HEAP32[$11 >> 2] = HEAP32[$11 >> 2] | 1;\n  _dispose_chunk($26, $24);\n  $$2 = $0;\n  return $$2 | 0;\n }\n if ((HEAP32[4357] | 0) == ($5 | 0)) {\n  $37 = (HEAP32[4354] | 0) + $4 | 0;\n  $39 = $37 - $1 | 0;\n  $40 = $0 + $1 | 0;\n  if ($37 >>> 0 <= $1 >>> 0) {\n   $$2 = 0;\n   return $$2 | 0;\n  }\n  HEAP32[$2 >> 2] = $3 & 1 | $1 | 2;\n  HEAP32[$40 + 4 >> 2] = $39 | 1;\n  HEAP32[4357] = $40;\n  HEAP32[4354] = $39;\n  $$2 = $0;\n  return $$2 | 0;\n }\n if ((HEAP32[4356] | 0) == ($5 | 0)) {\n  $49 = (HEAP32[4353] | 0) + $4 | 0;\n  if ($49 >>> 0 < $1 >>> 0) {\n   $$2 = 0;\n   return $$2 | 0;\n  }\n  $51 = $49 - $1 | 0;\n  if ($51 >>> 0 > 15) {\n   $53 = $0 + $1 | 0;\n   $54 = $0 + $49 | 0;\n   HEAP32[$2 >> 2] = $3 & 1 | $1 | 2;\n   HEAP32[$53 + 4 >> 2] = $51 | 1;\n   HEAP32[$54 >> 2] = $51;\n   $60 = $54 + 4 | 0;\n   HEAP32[$60 >> 2] = HEAP32[$60 >> 2] & -2;\n   $storemerge = $53;\n   $storemerge3 = $51;\n  } else {\n   HEAP32[$2 >> 2] = $3 & 1 | $49 | 2;\n   $67 = $0 + $49 + 4 | 0;\n   HEAP32[$67 >> 2] = HEAP32[$67 >> 2] | 1;\n   $storemerge = 0;\n   $storemerge3 = 0;\n  }\n  HEAP32[4353] = $storemerge3;\n  HEAP32[4356] = $storemerge;\n  $$2 = $0;\n  return $$2 | 0;\n }\n if ($12 & 2 | 0) {\n  $$2 = 0;\n  return $$2 | 0;\n }\n $73 = ($12 & -8) + $4 | 0;\n if ($73 >>> 0 < $1 >>> 0) {\n  $$2 = 0;\n  return $$2 | 0;\n }\n $75 = $73 - $1 | 0;\n $76 = $12 >>> 3;\n L49 : do if ($12 >>> 0 < 256) {\n  $79 = HEAP32[$5 + 8 >> 2] | 0;\n  $81 = HEAP32[$5 + 12 >> 2] | 0;\n  $83 = 17444 + ($76 << 1 << 2) | 0;\n  if (($79 | 0) != ($83 | 0)) {\n   if ($6 >>> 0 > $79 >>> 0) _abort();\n   if ((HEAP32[$79 + 12 >> 2] | 0) != ($5 | 0)) _abort();\n  }\n  if (($81 | 0) == ($79 | 0)) {\n   HEAP32[4351] = HEAP32[4351] & ~(1 << $76);\n   break;\n  }\n  if (($81 | 0) == ($83 | 0)) $$pre$phiZ2D = $81 + 8 | 0; else {\n   if ($6 >>> 0 > $81 >>> 0) _abort();\n   $96 = $81 + 8 | 0;\n   if ((HEAP32[$96 >> 2] | 0) == ($5 | 0)) $$pre$phiZ2D = $96; else _abort();\n  }\n  HEAP32[$79 + 12 >> 2] = $81;\n  HEAP32[$$pre$phiZ2D >> 2] = $79;\n } else {\n  $101 = HEAP32[$5 + 24 >> 2] | 0;\n  $103 = HEAP32[$5 + 12 >> 2] | 0;\n  do if (($103 | 0) == ($5 | 0)) {\n   $114 = $5 + 16 | 0;\n   $115 = $114 + 4 | 0;\n   $116 = HEAP32[$115 >> 2] | 0;\n   if (!$116) {\n    $118 = HEAP32[$114 >> 2] | 0;\n    if (!$118) {\n     $$3 = 0;\n     break;\n    } else {\n     $$1271$ph = $118;\n     $$1274$ph = $114;\n    }\n   } else {\n    $$1271$ph = $116;\n    $$1274$ph = $115;\n   }\n   $$1271 = $$1271$ph;\n   $$1274 = $$1274$ph;\n   while (1) {\n    $120 = $$1271 + 20 | 0;\n    $121 = HEAP32[$120 >> 2] | 0;\n    if (!$121) {\n     $123 = $$1271 + 16 | 0;\n     $124 = HEAP32[$123 >> 2] | 0;\n     if (!$124) break; else {\n      $$1271$be = $124;\n      $$1274$be = $123;\n     }\n    } else {\n     $$1271$be = $121;\n     $$1274$be = $120;\n    }\n    $$1271 = $$1271$be;\n    $$1274 = $$1274$be;\n   }\n   if ($6 >>> 0 > $$1274 >>> 0) _abort(); else {\n    HEAP32[$$1274 >> 2] = 0;\n    $$3 = $$1271;\n    break;\n   }\n  } else {\n   $106 = HEAP32[$5 + 8 >> 2] | 0;\n   if ($6 >>> 0 > $106 >>> 0) _abort();\n   $108 = $106 + 12 | 0;\n   if ((HEAP32[$108 >> 2] | 0) != ($5 | 0)) _abort();\n   $111 = $103 + 8 | 0;\n   if ((HEAP32[$111 >> 2] | 0) == ($5 | 0)) {\n    HEAP32[$108 >> 2] = $103;\n    HEAP32[$111 >> 2] = $106;\n    $$3 = $103;\n    break;\n   } else _abort();\n  } while (0);\n  if ($101 | 0) {\n   $129 = HEAP32[$5 + 28 >> 2] | 0;\n   $130 = 17708 + ($129 << 2) | 0;\n   do if ((HEAP32[$130 >> 2] | 0) == ($5 | 0)) {\n    HEAP32[$130 >> 2] = $$3;\n    if (!$$3) {\n     HEAP32[4352] = HEAP32[4352] & ~(1 << $129);\n     break L49;\n    }\n   } else if ((HEAP32[4355] | 0) >>> 0 > $101 >>> 0) _abort(); else {\n    $139 = $101 + 16 | 0;\n    HEAP32[((HEAP32[$139 >> 2] | 0) == ($5 | 0) ? $139 : $101 + 20 | 0) >> 2] = $$3;\n    if (!$$3) break L49; else break;\n   } while (0);\n   $144 = HEAP32[4355] | 0;\n   if ($144 >>> 0 > $$3 >>> 0) _abort();\n   HEAP32[$$3 + 24 >> 2] = $101;\n   $147 = $5 + 16 | 0;\n   $148 = HEAP32[$147 >> 2] | 0;\n   do if ($148 | 0) if ($144 >>> 0 > $148 >>> 0) _abort(); else {\n    HEAP32[$$3 + 16 >> 2] = $148;\n    HEAP32[$148 + 24 >> 2] = $$3;\n    break;\n   } while (0);\n   $154 = HEAP32[$147 + 4 >> 2] | 0;\n   if ($154 | 0) if ((HEAP32[4355] | 0) >>> 0 > $154 >>> 0) _abort(); else {\n    HEAP32[$$3 + 20 >> 2] = $154;\n    HEAP32[$154 + 24 >> 2] = $$3;\n    break;\n   }\n  }\n } while (0);\n if ($75 >>> 0 < 16) {\n  HEAP32[$2 >> 2] = $3 & 1 | $73 | 2;\n  $165 = $0 + $73 + 4 | 0;\n  HEAP32[$165 >> 2] = HEAP32[$165 >> 2] | 1;\n  $$2 = $0;\n  return $$2 | 0;\n } else {\n  $168 = $0 + $1 | 0;\n  HEAP32[$2 >> 2] = $3 & 1 | $1 | 2;\n  HEAP32[$168 + 4 >> 2] = $75 | 3;\n  $175 = $0 + $73 + 4 | 0;\n  HEAP32[$175 >> 2] = HEAP32[$175 >> 2] | 1;\n  _dispose_chunk($168, $75);\n  $$2 = $0;\n  return $$2 | 0;\n }\n return 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$idx$i = 0, $$067 = 0, $$1 = 0, $101 = 0, $103 = 0, $12 = 0, $13 = 0, $14 = 0, $17 = 0, $21 = 0, $23 = 0, $24 = 0, $29 = 0, $3 = 0, $30 = 0, $34 = 0, $36 = 0, $4 = 0, $43 = 0, $44 = 0, $46 = 0, $50 = 0, $53 = 0, $54 = 0, $59 = 0, $60 = 0, $64 = 0, $66 = 0, $71 = 0, $8 = 0, $80 = 0, $81 = 0, $84 = 0, $85 = 0, $89 = 0, $90 = 0, $91 = 0, $96 = 0, $97 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp + 8 | 0;\n $4 = sp;\n L1 : do if (($0 | 0) == ($1 | 0)) $$1 = $0; else switch (HEAP8[$0 >> 0] | 0) {\n case 84:\n  {\n   $8 = $2 + 4 | 0;\n   $12 = ((HEAP32[$8 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n   $13 = __ZN10__cxxabiv112_GLOBAL__N_120parse_template_paramINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   $14 = HEAP32[$8 >> 2] | 0;\n   $17 = ($14 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n   $21 = $14;\n   if (($13 | 0) != ($0 | 0) & ($17 | 0) == ($12 + 1 | 0)) {\n    HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n    __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $21 + -24 | 0, $4);\n    $23 = $2 + 20 | 0;\n    $24 = HEAP32[$23 >> 2] | 0;\n    if ($24 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n     HEAP32[$24 >> 2] = 0;\n     $29 = $24 + 4 | 0;\n     HEAP32[$29 >> 2] = 0;\n     $30 = $24 + 8 | 0;\n     HEAP32[$30 >> 2] = 0;\n     HEAP32[$24 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n     HEAP32[$24 >> 2] = HEAP32[$3 >> 2];\n     $34 = $3 + 4 | 0;\n     HEAP32[$29 >> 2] = HEAP32[$34 >> 2];\n     $36 = $3 + 8 | 0;\n     HEAP32[$30 >> 2] = HEAP32[$36 >> 2];\n     HEAP32[$36 >> 2] = 0;\n     HEAP32[$34 >> 2] = 0;\n     HEAP32[$3 >> 2] = 0;\n     HEAP32[$23 >> 2] = (HEAP32[$23 >> 2] | 0) + 16;\n    } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n    __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n    $$1 = $13;\n    break L1;\n   }\n   $$067 = $17;\n   $43 = $21;\n   while (1) {\n    if (($$067 | 0) == ($12 | 0)) {\n     $$1 = $0;\n     break L1;\n    }\n    $$0$i$i$idx$i = 0;\n    while (1) {\n     if (($$0$i$i$idx$i | 0) == -1) break;\n     $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($43 + ($$0$i$i$add$i * 24 | 0) | 0);\n     $$0$i$i$idx$i = $$0$i$i$add$i;\n    }\n    $44 = $43 + -24 | 0;\n    HEAP32[$8 >> 2] = $44;\n    $$067 = $$067 + -1 | 0;\n    $43 = $44;\n   }\n   break;\n  }\n case 68:\n  {\n   $46 = __ZN10__cxxabiv112_GLOBAL__N_114parse_decltypeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   if (($46 | 0) == ($0 | 0)) {\n    $$1 = $0;\n    break L1;\n   }\n   $50 = HEAP32[$2 + 4 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($50 | 0)) {\n    $$1 = $0;\n    break L1;\n   }\n   HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n   __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $50 + -24 | 0, $4);\n   $53 = $2 + 20 | 0;\n   $54 = HEAP32[$53 >> 2] | 0;\n   if ($54 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n    HEAP32[$54 >> 2] = 0;\n    $59 = $54 + 4 | 0;\n    HEAP32[$59 >> 2] = 0;\n    $60 = $54 + 8 | 0;\n    HEAP32[$60 >> 2] = 0;\n    HEAP32[$54 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n    HEAP32[$54 >> 2] = HEAP32[$3 >> 2];\n    $64 = $3 + 4 | 0;\n    HEAP32[$59 >> 2] = HEAP32[$64 >> 2];\n    $66 = $3 + 8 | 0;\n    HEAP32[$60 >> 2] = HEAP32[$66 >> 2];\n    HEAP32[$66 >> 2] = 0;\n    HEAP32[$64 >> 2] = 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$53 >> 2] = (HEAP32[$53 >> 2] | 0) + 16;\n   } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n   __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n   $$1 = $46;\n   break L1;\n   break;\n  }\n case 83:\n  {\n   $71 = __ZN10__cxxabiv112_GLOBAL__N_118parse_substitutionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   if (($71 | 0) != ($0 | 0)) {\n    $$1 = $71;\n    break L1;\n   }\n   if (($1 - $0 | 0) <= 2) {\n    $$1 = $0;\n    break L1;\n   }\n   if ((HEAP8[$0 + 1 >> 0] | 0) != 116) {\n    $$1 = $0;\n    break L1;\n   }\n   $80 = $0 + 2 | 0;\n   $81 = __ZN10__cxxabiv112_GLOBAL__N_122parse_unqualified_nameINS0_2DbEEEPKcS4_S4_RT_($80, $1, $2) | 0;\n   if (($81 | 0) == ($80 | 0)) {\n    $$1 = $0;\n    break L1;\n   }\n   $84 = $2 + 4 | 0;\n   $85 = HEAP32[$84 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($85 | 0)) {\n    $$1 = $0;\n    break L1;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($85 + -24 | 0, 0, 15413) | 0;\n   $89 = (HEAP32[$84 >> 2] | 0) + -24 | 0;\n   HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n   __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $89, $4);\n   $90 = $2 + 20 | 0;\n   $91 = HEAP32[$90 >> 2] | 0;\n   if ($91 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n    HEAP32[$91 >> 2] = 0;\n    $96 = $91 + 4 | 0;\n    HEAP32[$96 >> 2] = 0;\n    $97 = $91 + 8 | 0;\n    HEAP32[$97 >> 2] = 0;\n    HEAP32[$91 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n    HEAP32[$91 >> 2] = HEAP32[$3 >> 2];\n    $101 = $3 + 4 | 0;\n    HEAP32[$96 >> 2] = HEAP32[$101 >> 2];\n    $103 = $3 + 8 | 0;\n    HEAP32[$97 >> 2] = HEAP32[$103 >> 2];\n    HEAP32[$103 >> 2] = 0;\n    HEAP32[$101 >> 2] = 0;\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$90 >> 2] = (HEAP32[$90 >> 2] | 0) + 16;\n   } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n   __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n   $$1 = $81;\n   break L1;\n   break;\n  }\n default:\n  {\n   $$1 = $0;\n   break L1;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction ___floatscan($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0102 = 0, $$0103 = 0, $$0104122 = 0, $$0110 = 0, $$0111 = 0.0, $$1$lcssa = 0, $$1105118 = 0, $$1123 = 0, $$2 = 0, $$2106120 = 0, $$3107 = 0, $$3121 = 0, $$4 = 0, $$4108 = 0, $$5 = 0, $$6 = 0, $$in = 0, $103 = 0, $106 = 0, $117 = 0, $119 = 0, $12 = 0, $127 = 0, $18 = 0, $19 = 0, $3 = 0, $32 = 0, $4 = 0, $42 = 0, $45 = 0, $5 = 0, $64 = 0, $73 = 0, $81 = 0, $86 = 0, $94 = 0, $trunc = 0, label = 0;\n switch ($1 | 0) {\n case 0:\n  {\n   $$0102 = -149;\n   $$0103 = 24;\n   label = 4;\n   break;\n  }\n case 1:\n  {\n   $$0102 = -1074;\n   $$0103 = 53;\n   label = 4;\n   break;\n  }\n case 2:\n  {\n   $$0102 = -1074;\n   $$0103 = 53;\n   label = 4;\n   break;\n  }\n default:\n  $$0111 = 0.0;\n }\n L4 : do if ((label | 0) == 4) {\n  $3 = $0 + 4 | 0;\n  $4 = $0 + 100 | 0;\n  do {\n   $5 = HEAP32[$3 >> 2] | 0;\n   if ($5 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n    HEAP32[$3 >> 2] = $5 + 1;\n    $12 = HEAPU8[$5 >> 0] | 0;\n   } else $12 = ___shgetc($0) | 0;\n  } while ((_isspace($12) | 0) != 0);\n  L13 : do switch ($12 | 0) {\n  case 43:\n  case 45:\n   {\n    $18 = 1 - ((($12 | 0) == 45 & 1) << 1) | 0;\n    $19 = HEAP32[$3 >> 2] | 0;\n    if ($19 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n     HEAP32[$3 >> 2] = $19 + 1;\n     $$0 = HEAPU8[$19 >> 0] | 0;\n     $$0110 = $18;\n     break L13;\n    } else {\n     $$0 = ___shgetc($0) | 0;\n     $$0110 = $18;\n     break L13;\n    }\n    break;\n   }\n  default:\n   {\n    $$0 = $12;\n    $$0110 = 1;\n   }\n  } while (0);\n  $$0104122 = 0;\n  $$1123 = $$0;\n  while (1) {\n   if (($$1123 | 32 | 0) != (HEAP8[11763 + $$0104122 >> 0] | 0)) {\n    $$1$lcssa = $$1123;\n    $trunc = $$0104122;\n    break;\n   }\n   do if ($$0104122 >>> 0 < 7) {\n    $32 = HEAP32[$3 >> 2] | 0;\n    if ($32 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n     HEAP32[$3 >> 2] = $32 + 1;\n     $$2 = HEAPU8[$32 >> 0] | 0;\n     break;\n    } else {\n     $$2 = ___shgetc($0) | 0;\n     break;\n    }\n   } else $$2 = $$1123; while (0);\n   $$0104122 = $$0104122 + 1 | 0;\n   if ($$0104122 >>> 0 >= 8) {\n    $$1$lcssa = $$2;\n    $trunc = 8;\n    break;\n   } else $$1123 = $$2;\n  }\n  L29 : do switch ($trunc & 2147483647 | 0) {\n  case 8:\n   break;\n  case 3:\n   {\n    label = 23;\n    break;\n   }\n  default:\n   {\n    $42 = ($2 | 0) != 0;\n    if ($42 & $trunc >>> 0 > 3) if (($trunc | 0) == 8) break L29; else {\n     label = 23;\n     break L29;\n    }\n    L34 : do if (!$trunc) {\n     $$2106120 = 0;\n     $$3121 = $$1$lcssa;\n     while (1) {\n      if (($$3121 | 32 | 0) != (HEAP8[12546 + $$2106120 >> 0] | 0)) {\n       $$3107 = $$2106120;\n       $$5 = $$3121;\n       break L34;\n      }\n      do if ($$2106120 >>> 0 < 2) {\n       $64 = HEAP32[$3 >> 2] | 0;\n       if ($64 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n        HEAP32[$3 >> 2] = $64 + 1;\n        $$4 = HEAPU8[$64 >> 0] | 0;\n        break;\n       } else {\n        $$4 = ___shgetc($0) | 0;\n        break;\n       }\n      } else $$4 = $$3121; while (0);\n      $$2106120 = $$2106120 + 1 | 0;\n      if ($$2106120 >>> 0 >= 3) {\n       $$3107 = 3;\n       $$5 = $$4;\n       break;\n      } else $$3121 = $$4;\n     }\n    } else {\n     $$3107 = $trunc;\n     $$5 = $$1$lcssa;\n    } while (0);\n    switch ($$3107 | 0) {\n    case 3:\n     {\n      $73 = HEAP32[$3 >> 2] | 0;\n      if ($73 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n       HEAP32[$3 >> 2] = $73 + 1;\n       $81 = HEAPU8[$73 >> 0] | 0;\n      } else $81 = ___shgetc($0) | 0;\n      if (($81 | 0) != 40) {\n       if (!(HEAP32[$4 >> 2] | 0)) {\n        $$0111 = nan;\n        break L4;\n       }\n       HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;\n       $$0111 = nan;\n       break L4;\n      }\n      $$4108 = 1;\n      while (1) {\n       $86 = HEAP32[$3 >> 2] | 0;\n       if ($86 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n        HEAP32[$3 >> 2] = $86 + 1;\n        $94 = HEAPU8[$86 >> 0] | 0;\n       } else $94 = ___shgetc($0) | 0;\n       if (!(($94 + -48 | 0) >>> 0 < 10 | ($94 + -65 | 0) >>> 0 < 26)) if (!(($94 | 0) == 95 | ($94 + -97 | 0) >>> 0 < 26)) break;\n       $$4108 = $$4108 + 1 | 0;\n      }\n      if (($94 | 0) == 41) {\n       $$0111 = nan;\n       break L4;\n      }\n      $103 = (HEAP32[$4 >> 2] | 0) == 0;\n      if (!$103) HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;\n      if (!$42) {\n       $106 = ___errno_location() | 0;\n       HEAP32[$106 >> 2] = 22;\n       ___shlim($0, 0);\n       $$0111 = 0.0;\n       break L4;\n      }\n      if (!$$4108) {\n       $$0111 = nan;\n       break L4;\n      }\n      $$in = $$4108;\n      while (1) {\n       $$in = $$in + -1 | 0;\n       if (!$103) HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;\n       if (!$$in) {\n        $$0111 = nan;\n        break L4;\n       }\n      }\n      break;\n     }\n    case 0:\n     {\n      if (($$5 | 0) == 48) {\n       $119 = HEAP32[$3 >> 2] | 0;\n       if ($119 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n        HEAP32[$3 >> 2] = $119 + 1;\n        $127 = HEAPU8[$119 >> 0] | 0;\n       } else $127 = ___shgetc($0) | 0;\n       if (($127 | 32 | 0) == 120) {\n        $$0111 = +_hexfloat($0, $$0103, $$0102, $$0110, $2);\n        break L4;\n       }\n       if (!(HEAP32[$4 >> 2] | 0)) $$6 = 48; else {\n        HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;\n        $$6 = 48;\n       }\n      } else $$6 = $$5;\n      $$0111 = +_decfloat($0, $$6, $$0103, $$0102, $$0110, $2);\n      break L4;\n      break;\n     }\n    default:\n     {\n      if (HEAP32[$4 >> 2] | 0) HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;\n      $117 = ___errno_location() | 0;\n      HEAP32[$117 >> 2] = 22;\n      ___shlim($0, 0);\n      $$0111 = 0.0;\n      break L4;\n     }\n    }\n   }\n  } while (0);\n  if ((label | 0) == 23) {\n   $45 = (HEAP32[$4 >> 2] | 0) == 0;\n   if (!$45) HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;\n   if (($2 | 0) != 0 & $trunc >>> 0 > 3) {\n    $$1105118 = $trunc;\n    do {\n     if (!$45) HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + -1;\n     $$1105118 = $$1105118 + -1 | 0;\n    } while ($$1105118 >>> 0 > 3);\n   }\n  }\n  $$0111 = +($$0110 | 0) * inf;\n } while (0);\n return +$$0111;\n}\n\nfunction _fmod($0, $1) {\n $0 = +$0;\n $1 = +$1;\n var $$070 = 0.0, $$071$lcssa = 0, $$07194 = 0, $$073$lcssa = 0, $$073100 = 0, $$172 = 0, $$174 = 0, $$275$lcssa = 0, $$27585 = 0, $$376$lcssa = 0, $$37682 = 0, $$lcssa = 0, $101 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $11 = 0, $110 = 0, $111 = 0, $116 = 0, $118 = 0, $12 = 0, $120 = 0, $124 = 0, $126 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $14 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $150 = 0, $153 = 0, $154 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $160 = 0, $18 = 0, $2 = 0, $20 = 0, $27 = 0.0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $41 = 0, $42 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $59 = 0, $6 = 0, $64 = 0, $65 = 0, $71 = 0, $72 = 0, $73 = 0, $8 = 0, $82 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $97 = 0, $99 = 0, label = 0;\n HEAPF64[tempDoublePtr >> 3] = $0;\n $2 = HEAP32[tempDoublePtr >> 2] | 0;\n $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;\n HEAPF64[tempDoublePtr >> 3] = $1;\n $4 = HEAP32[tempDoublePtr >> 2] | 0;\n $5 = HEAP32[tempDoublePtr + 4 >> 2] | 0;\n $6 = _bitshift64Lshr($2 | 0, $3 | 0, 52) | 0;\n $8 = $6 & 2047;\n $9 = _bitshift64Lshr($4 | 0, $5 | 0, 52) | 0;\n $11 = $9 & 2047;\n $12 = $3 & -2147483648;\n $13 = _bitshift64Shl($4 | 0, $5 | 0, 1) | 0;\n $14 = tempRet0;\n L1 : do if (($13 | 0) == 0 & ($14 | 0) == 0) label = 3; else {\n  $18 = ___DOUBLE_BITS_563($1) | 0;\n  $20 = tempRet0 & 2147483647;\n  if (($8 | 0) == 2047 | ($20 >>> 0 > 2146435072 | ($20 | 0) == 2146435072 & $18 >>> 0 > 0)) label = 3; else {\n   $29 = _bitshift64Shl($2 | 0, $3 | 0, 1) | 0;\n   $30 = tempRet0;\n   if (!($30 >>> 0 > $14 >>> 0 | ($30 | 0) == ($14 | 0) & $29 >>> 0 > $13 >>> 0)) return +(($29 | 0) == ($13 | 0) & ($30 | 0) == ($14 | 0) ? $0 * 0.0 : $0);\n   if (!$8) {\n    $41 = _bitshift64Shl($2 | 0, $3 | 0, 12) | 0;\n    $42 = tempRet0;\n    if (($42 | 0) > -1 | ($42 | 0) == -1 & $41 >>> 0 > 4294967295) {\n     $$073100 = 0;\n     $49 = $41;\n     $50 = $42;\n     while (1) {\n      $48 = $$073100 + -1 | 0;\n      $49 = _bitshift64Shl($49 | 0, $50 | 0, 1) | 0;\n      $50 = tempRet0;\n      if (!(($50 | 0) > -1 | ($50 | 0) == -1 & $49 >>> 0 > 4294967295)) {\n       $$073$lcssa = $48;\n       break;\n      } else $$073100 = $48;\n     }\n    } else $$073$lcssa = 0;\n    $59 = _bitshift64Shl($2 | 0, $3 | 0, 1 - $$073$lcssa | 0) | 0;\n    $$174 = $$073$lcssa;\n    $87 = $59;\n    $88 = tempRet0;\n   } else {\n    $$174 = $8;\n    $87 = $2;\n    $88 = $3 & 1048575 | 1048576;\n   }\n   if (!$11) {\n    $64 = _bitshift64Shl($4 | 0, $5 | 0, 12) | 0;\n    $65 = tempRet0;\n    if (($65 | 0) > -1 | ($65 | 0) == -1 & $64 >>> 0 > 4294967295) {\n     $$07194 = 0;\n     $72 = $64;\n     $73 = $65;\n     while (1) {\n      $71 = $$07194 + -1 | 0;\n      $72 = _bitshift64Shl($72 | 0, $73 | 0, 1) | 0;\n      $73 = tempRet0;\n      if (!(($73 | 0) > -1 | ($73 | 0) == -1 & $72 >>> 0 > 4294967295)) {\n       $$071$lcssa = $71;\n       break;\n      } else $$07194 = $71;\n     }\n    } else $$071$lcssa = 0;\n    $82 = _bitshift64Shl($4 | 0, $5 | 0, 1 - $$071$lcssa | 0) | 0;\n    $$172 = $$071$lcssa;\n    $89 = $82;\n    $90 = tempRet0;\n   } else {\n    $$172 = $11;\n    $89 = $4;\n    $90 = $5 & 1048575 | 1048576;\n   }\n   $91 = _i64Subtract($87 | 0, $88 | 0, $89 | 0, $90 | 0) | 0;\n   $92 = tempRet0;\n   $97 = ($92 | 0) > -1 | ($92 | 0) == -1 & $91 >>> 0 > 4294967295;\n   L25 : do if (($$174 | 0) > ($$172 | 0)) {\n    $$27585 = $$174;\n    $101 = $92;\n    $158 = $97;\n    $159 = $87;\n    $160 = $88;\n    $99 = $91;\n    while (1) {\n     if ($158) if (($99 | 0) == 0 & ($101 | 0) == 0) break; else {\n      $104 = $99;\n      $105 = $101;\n     } else {\n      $104 = $159;\n      $105 = $160;\n     }\n     $106 = _bitshift64Shl($104 | 0, $105 | 0, 1) | 0;\n     $107 = tempRet0;\n     $108 = $$27585 + -1 | 0;\n     $110 = _i64Subtract($106 | 0, $107 | 0, $89 | 0, $90 | 0) | 0;\n     $111 = tempRet0;\n     $116 = ($111 | 0) > -1 | ($111 | 0) == -1 & $110 >>> 0 > 4294967295;\n     if (($108 | 0) > ($$172 | 0)) {\n      $$27585 = $108;\n      $101 = $111;\n      $158 = $116;\n      $159 = $106;\n      $160 = $107;\n      $99 = $110;\n     } else {\n      $$275$lcssa = $108;\n      $$lcssa = $116;\n      $118 = $110;\n      $120 = $111;\n      $156 = $106;\n      $157 = $107;\n      break L25;\n     }\n    }\n    $$070 = $0 * 0.0;\n    break L1;\n   } else {\n    $$275$lcssa = $$174;\n    $$lcssa = $97;\n    $118 = $91;\n    $120 = $92;\n    $156 = $87;\n    $157 = $88;\n   } while (0);\n   if ($$lcssa) if (($118 | 0) == 0 & ($120 | 0) == 0) {\n    $$070 = $0 * 0.0;\n    break;\n   } else {\n    $124 = $120;\n    $126 = $118;\n   } else {\n    $124 = $157;\n    $126 = $156;\n   }\n   if ($124 >>> 0 < 1048576 | ($124 | 0) == 1048576 & $126 >>> 0 < 0) {\n    $$37682 = $$275$lcssa;\n    $130 = $126;\n    $131 = $124;\n    while (1) {\n     $132 = _bitshift64Shl($130 | 0, $131 | 0, 1) | 0;\n     $133 = tempRet0;\n     $134 = $$37682 + -1 | 0;\n     if ($133 >>> 0 < 1048576 | ($133 | 0) == 1048576 & $132 >>> 0 < 0) {\n      $$37682 = $134;\n      $130 = $132;\n      $131 = $133;\n     } else {\n      $$376$lcssa = $134;\n      $141 = $132;\n      $142 = $133;\n      break;\n     }\n    }\n   } else {\n    $$376$lcssa = $$275$lcssa;\n    $141 = $126;\n    $142 = $124;\n   }\n   if (($$376$lcssa | 0) > 0) {\n    $143 = _i64Add($141 | 0, $142 | 0, 0, -1048576) | 0;\n    $144 = tempRet0;\n    $145 = _bitshift64Shl($$376$lcssa | 0, 0, 52) | 0;\n    $153 = $144 | tempRet0;\n    $154 = $143 | $145;\n   } else {\n    $150 = _bitshift64Lshr($141 | 0, $142 | 0, 1 - $$376$lcssa | 0) | 0;\n    $153 = tempRet0;\n    $154 = $150;\n   }\n   HEAP32[tempDoublePtr >> 2] = $154;\n   HEAP32[tempDoublePtr + 4 >> 2] = $153 | $12;\n   $$070 = +HEAPF64[tempDoublePtr >> 3];\n  }\n } while (0);\n if ((label | 0) == 3) {\n  $27 = $0 * $1;\n  $$070 = $27 / $27;\n }\n return +$$070;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_19base_nameINSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEEEET_RS9_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$0$i$i = 0, $$032$ph = 0, $$032$ph$be = 0, $$034 = 0, $$034$ph = 0, $$1 = 0, $$2 = 0, $$2$pn = 0, $$pre = 0, $$pre$phiZ2D = 0, $10 = 0, $11 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $30 = 0, $31 = 0, $40 = 0, $41 = 0, $43 = 0, $44 = 0, $5 = 0, $50 = 0, $51 = 0, $53 = 0, $55 = 0, $56 = 0, $60 = 0, $66 = 0, label = 0;\n $2 = $1 + 11 | 0;\n $3 = HEAP8[$2 >> 0] | 0;\n $5 = $1 + 4 | 0;\n L1 : do if (!(($3 << 24 >> 24 < 0 ? HEAP32[$5 >> 2] | 0 : $3 & 255) | 0)) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_($0, $1); else {\n  $10 = __ZNSt3__211char_traitsIcE6lengthEPKc(15939) | 0;\n  $11 = HEAP8[$2 >> 0] | 0;\n  if (($10 | 0) == (($11 << 24 >> 24 < 0 ? HEAP32[$5 >> 2] | 0 : $11 & 255) | 0)) if (!(__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($1, 15939, $10) | 0)) {\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKc($1, 15951);\n   HEAP32[$0 >> 2] = 0;\n   HEAP32[$0 + 4 >> 2] = 0;\n   HEAP32[$0 + 8 >> 2] = 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 16022, __ZNSt3__211char_traitsIcE6lengthEPKc(16022) | 0);\n   break;\n  }\n  $20 = __ZNSt3__211char_traitsIcE6lengthEPKc(16035) | 0;\n  $21 = HEAP8[$2 >> 0] | 0;\n  if (($20 | 0) == (($21 << 24 >> 24 < 0 ? HEAP32[$5 >> 2] | 0 : $21 & 255) | 0)) if (!(__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($1, 16035, $20) | 0)) {\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKc($1, 16048);\n   HEAP32[$0 >> 2] = 0;\n   HEAP32[$0 + 4 >> 2] = 0;\n   HEAP32[$0 + 8 >> 2] = 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 16098, __ZNSt3__211char_traitsIcE6lengthEPKc(16098) | 0);\n   break;\n  }\n  $30 = __ZNSt3__211char_traitsIcE6lengthEPKc(16112) | 0;\n  $31 = HEAP8[$2 >> 0] | 0;\n  if (($30 | 0) == (($31 << 24 >> 24 < 0 ? HEAP32[$5 >> 2] | 0 : $31 & 255) | 0)) if (!(__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($1, 16112, $30) | 0)) {\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKc($1, 16125);\n   HEAP32[$0 >> 2] = 0;\n   HEAP32[$0 + 4 >> 2] = 0;\n   HEAP32[$0 + 8 >> 2] = 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 16175, __ZNSt3__211char_traitsIcE6lengthEPKc(16175) | 0);\n   break;\n  }\n  $40 = __ZNSt3__211char_traitsIcE6lengthEPKc(16189) | 0;\n  $41 = HEAP8[$2 >> 0] | 0;\n  $43 = HEAP32[$5 >> 2] | 0;\n  $44 = $41 & 255;\n  do if (($40 | 0) == (($41 << 24 >> 24 < 0 ? $43 : $44) | 0)) if (!(__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($1, 16189, $40) | 0)) {\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKc($1, 16203);\n   HEAP32[$0 >> 2] = 0;\n   HEAP32[$0 + 4 >> 2] = 0;\n   HEAP32[$0 + 8 >> 2] = 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 16254, __ZNSt3__211char_traitsIcE6lengthEPKc(16254) | 0);\n   break L1;\n  } else {\n   $$pre = HEAP8[$2 >> 0] | 0;\n   $$pre$phiZ2D = $$pre & 255;\n   $51 = $$pre;\n   $55 = HEAP32[$5 >> 2] | 0;\n   break;\n  } else {\n   $$pre$phiZ2D = $44;\n   $51 = $41;\n   $55 = $43;\n  } while (0);\n  $50 = $51 << 24 >> 24 < 0;\n  $53 = $50 ? HEAP32[$1 >> 2] | 0 : $1;\n  $56 = $53 + ($50 ? $55 : $$pre$phiZ2D) | 0;\n  do if ((HEAP8[$56 + -1 >> 0] | 0) == 62) {\n   $$032$ph = 1;\n   $$034$ph = $56;\n   L24 : while (1) {\n    $$034 = $$034$ph;\n    L26 : while (1) {\n     $60 = $$034 + -1 | 0;\n     if (($60 | 0) == ($53 | 0)) break L24;\n     switch (HEAP8[$$034 + -2 >> 0] | 0) {\n     case 60:\n      {\n       label = 24;\n       break L26;\n       break;\n      }\n     case 62:\n      {\n       label = 25;\n       break L26;\n       break;\n      }\n     default:\n      $$034 = $60;\n     }\n    }\n    if ((label | 0) == 24) {\n     label = 0;\n     $66 = $$032$ph + -1 | 0;\n     if (!$66) {\n      label = 27;\n      break;\n     } else $$032$ph$be = $66;\n    } else if ((label | 0) == 25) {\n     label = 0;\n     $$032$ph$be = $$032$ph + 1 | 0;\n    }\n    $$032$ph = $$032$ph$be;\n    $$034$ph = $60;\n   }\n   if ((label | 0) == 27) {\n    $$2 = $$034 + -2 | 0;\n    break;\n   };\n   HEAP32[$0 >> 2] = 0;\n   HEAP32[$0 + 4 >> 2] = 0;\n   HEAP32[$0 + 8 >> 2] = 0;\n   $$0$i$i = 0;\n   while (1) {\n    if (($$0$i$i | 0) == 3) break L1;\n    HEAP32[$0 + ($$0$i$i << 2) >> 2] = 0;\n    $$0$i$i = $$0$i$i + 1 | 0;\n   }\n  } else $$2 = $56; while (0);\n  $$2$pn = $$2;\n  while (1) {\n   $$0 = $$2$pn + -1 | 0;\n   if (($$0 | 0) == ($53 | 0)) {\n    $$1 = $53;\n    break;\n   }\n   if ((HEAP8[$$0 >> 0] | 0) == 58) {\n    $$1 = $$2$pn;\n    break;\n   } else $$2$pn = $$0;\n  }\n  HEAP32[$0 >> 2] = 0;\n  HEAP32[$0 + 4 >> 2] = 0;\n  HEAP32[$0 + 8 >> 2] = 0;\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($0, $$1, $$2);\n } while (0);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_116parse_local_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$add$i79 = 0, $$0$i$i$add$i83 = 0, $$0$i$i$add$i88 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i78 = 0, $$0$i$i$idx$i82 = 0, $$0$i$i$idx$i87 = 0, $$4 = 0, $13 = 0, $18 = 0, $21 = 0, $24 = 0, $26 = 0, $3 = 0, $30 = 0, $31 = 0, $33 = 0, $34 = 0, $41 = 0, $48 = 0, $49 = 0, $56 = 0, $59 = 0, $61 = 0, $62 = 0, $63 = 0, $7 = 0, $70 = 0, $77 = 0, $78 = 0, $8 = 0, $85 = 0, $86 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n L1 : do if (($0 | 0) == ($1 | 0)) $$4 = $0; else if ((HEAP8[$0 >> 0] | 0) == 90) {\n  $7 = $0 + 1 | 0;\n  $8 = __ZN10__cxxabiv112_GLOBAL__N_114parse_encodingINS0_2DbEEEPKcS4_S4_RT_($7, $1, $2) | 0;\n  if (($8 | 0) == ($7 | 0) | ($8 | 0) == ($1 | 0)) $$4 = $0; else if ((HEAP8[$8 >> 0] | 0) == 69) {\n   $13 = $8 + 1 | 0;\n   if (($13 | 0) == ($1 | 0)) $$4 = $0; else switch (HEAP8[$13 >> 0] | 0) {\n   case 115:\n    {\n     $18 = __ZN10__cxxabiv112_GLOBAL__N_119parse_discriminatorEPKcS2_($8 + 2 | 0, $1) | 0;\n     $21 = HEAP32[$2 + 4 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($21 | 0)) {\n      $$4 = $18;\n      break L1;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($21 + -24 | 0, 16478) | 0;\n     $$4 = $18;\n     break L1;\n     break;\n    }\n   case 100:\n    {\n     $24 = $8 + 2 | 0;\n     if (($24 | 0) == ($1 | 0)) {\n      $$4 = $0;\n      break L1;\n     }\n     $26 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($24, $1) | 0;\n     if (($26 | 0) == ($1 | 0)) {\n      $$4 = $0;\n      break L1;\n     }\n     if ((HEAP8[$26 >> 0] | 0) != 95) {\n      $$4 = $0;\n      break L1;\n     }\n     $30 = $26 + 1 | 0;\n     $31 = __ZN10__cxxabiv112_GLOBAL__N_110parse_nameINS0_2DbEEEPKcS4_S4_RT_($30, $1, $2) | 0;\n     $33 = $2 + 4 | 0;\n     if (($31 | 0) == ($30 | 0)) {\n      $56 = HEAP32[$33 >> 2] | 0;\n      $$0$i$i$idx$i78 = 0;\n      while (1) {\n       if (($$0$i$i$idx$i78 | 0) == -1) break;\n       $$0$i$i$add$i79 = $$0$i$i$idx$i78 + -1 | 0;\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($56 + ($$0$i$i$add$i79 * 24 | 0) | 0);\n       $$0$i$i$idx$i78 = $$0$i$i$add$i79;\n      }\n      HEAP32[$33 >> 2] = $56 + -24;\n      $$4 = $0;\n      break L1;\n     }\n     $34 = HEAP32[$33 >> 2] | 0;\n     if ((($34 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$4 = $0;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $34 + -24 | 0);\n     $41 = HEAP32[$33 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($41 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$33 >> 2] = $41 + -24;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($41 + -48 | 0, 15191) | 0;\n     $48 = HEAP8[$3 + 11 >> 0] | 0;\n     $49 = $48 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$33 >> 2] | 0) + -24 | 0, $49 ? HEAP32[$3 >> 2] | 0 : $3, $49 ? HEAP32[$3 + 4 >> 2] | 0 : $48 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$4 = $31;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $59 = __ZN10__cxxabiv112_GLOBAL__N_110parse_nameINS0_2DbEEEPKcS4_S4_RT_($13, $1, $2) | 0;\n     if (($59 | 0) == ($13 | 0)) {\n      $85 = $2 + 4 | 0;\n      $86 = HEAP32[$85 >> 2] | 0;\n      $$0$i$i$idx$i87 = 0;\n      while (1) {\n       if (($$0$i$i$idx$i87 | 0) == -1) break;\n       $$0$i$i$add$i88 = $$0$i$i$idx$i87 + -1 | 0;\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($86 + ($$0$i$i$add$i88 * 24 | 0) | 0);\n       $$0$i$i$idx$i87 = $$0$i$i$add$i88;\n      }\n      HEAP32[$85 >> 2] = $86 + -24;\n      $$4 = $0;\n      break L1;\n     }\n     $61 = __ZN10__cxxabiv112_GLOBAL__N_119parse_discriminatorEPKcS2_($59, $1) | 0;\n     $62 = $2 + 4 | 0;\n     $63 = HEAP32[$62 >> 2] | 0;\n     if ((($63 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$4 = $61;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $63 + -24 | 0);\n     $70 = HEAP32[$62 >> 2] | 0;\n     $$0$i$i$idx$i82 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i82 | 0) == -1) break;\n      $$0$i$i$add$i83 = $$0$i$i$idx$i82 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($70 + ($$0$i$i$add$i83 * 24 | 0) | 0);\n      $$0$i$i$idx$i82 = $$0$i$i$add$i83;\n     }\n     HEAP32[$62 >> 2] = $70 + -24;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($70 + -48 | 0, 15191) | 0;\n     $77 = HEAP8[$3 + 11 >> 0] | 0;\n     $78 = $77 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$62 >> 2] | 0) + -24 | 0, $78 ? HEAP32[$3 >> 2] | 0 : $3, $78 ? HEAP32[$3 + 4 >> 2] | 0 : $77 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$4 = $61;\n     break L1;\n    }\n   }\n  } else $$4 = $0;\n } else $$4 = $0; while (0);\n STACKTOP = sp;\n return $$4 | 0;\n}\n\nfunction _arVecTridiagonalize($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0158 = 0, $$0160 = 0, $$0164 = 0, $$0165 = 0.0, $$1 = 0, $$1$in = 0, $$1$in$ph = 0, $$1159 = 0, $$1161 = 0, $$1161$in = 0, $$1166 = 0.0, $$2 = 0, $$2162 = 0, $$3 = 0, $$3163 = 0, $$pre$phiZ2D = 0, $$sink = 0.0, $$sink171 = 0, $106 = 0, $107 = 0, $110 = 0, $114 = 0, $117 = 0, $118 = 0, $121 = 0, $124 = 0.0, $131 = 0, $17 = 0, $18 = 0, $19 = 0, $23 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0.0, $4 = 0, $41 = 0, $46 = 0.0, $48 = 0, $57 = 0.0, $6 = 0, $65 = 0.0, $68 = 0.0, $70 = 0, $71 = 0, $73 = 0.0, $74 = 0, $85 = 0, $90 = 0, $91 = 0, $95 = 0, $97 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp + 8 | 0;\n $4 = sp;\n $6 = HEAP32[$0 + 8 >> 2] | 0;\n L1 : do if (($6 | 0) == (HEAP32[$0 + 4 >> 2] | 0)) if (($6 | 0) == (HEAP32[$1 + 4 >> 2] | 0)) if (($6 | 0) == ((HEAP32[$2 + 4 >> 2] | 0) + 1 | 0)) {\n  $17 = $6 + -2 | 0;\n  $18 = $3 + 4 | 0;\n  $19 = $4 + 4 | 0;\n  $$0 = 0;\n  while (1) {\n   if (($$0 | 0) >= ($17 | 0)) break;\n   $23 = (HEAP32[$0 >> 2] | 0) + ((Math_imul($$0, $6) | 0) << 3) | 0;\n   HEAPF64[(HEAP32[$1 >> 2] | 0) + ($$0 << 3) >> 3] = +HEAPF64[$23 + ($$0 << 3) >> 3];\n   $29 = $6 - $$0 + -1 | 0;\n   HEAP32[$18 >> 2] = $29;\n   $30 = $$0 + 1 | 0;\n   $31 = $23 + ($30 << 3) | 0;\n   HEAP32[$3 >> 2] = $31;\n   $32 = +_arVecHousehold($3);\n   HEAPF64[(HEAP32[$2 >> 2] | 0) + ($$0 << 3) >> 3] = $32;\n   L8 : do if (!($32 == 0.0)) {\n    $$0160 = $30;\n    while (1) {\n     if (($$0160 | 0) >= ($6 | 0)) break;\n     $$0158 = $30;\n     $$0165 = 0.0;\n     while (1) {\n      if ($$0158 >>> 0 >= $$0160 >>> 0) break;\n      $41 = (HEAP32[$0 >> 2] | 0) + ((Math_imul($$0158, $6) | 0) + $$0160 << 3) | 0;\n      $46 = $$0165 + +HEAPF64[$41 >> 3] * +HEAPF64[$23 + ($$0158 << 3) >> 3];\n      $$0158 = $$0158 + 1 | 0;\n      $$0165 = $46;\n     }\n     $48 = Math_imul($$0160, $6) | 0;\n     $$1159 = $$0160;\n     $$1166 = $$0165;\n     while (1) {\n      if (($$1159 | 0) >= ($6 | 0)) break;\n      $57 = $$1166 + +HEAPF64[(HEAP32[$0 >> 2] | 0) + ($$1159 + $48 << 3) >> 3] * +HEAPF64[$23 + ($$1159 << 3) >> 3];\n      $$1159 = $$1159 + 1 | 0;\n      $$1166 = $57;\n     }\n     HEAPF64[(HEAP32[$1 >> 2] | 0) + ($$0160 << 3) >> 3] = $$1166;\n     $$0160 = $$0160 + 1 | 0;\n    }\n    HEAP32[$19 >> 2] = $29;\n    HEAP32[$18 >> 2] = $29;\n    HEAP32[$3 >> 2] = $31;\n    HEAP32[$4 >> 2] = (HEAP32[$1 >> 2] | 0) + ($30 << 3);\n    $65 = +_arVecInnerproduct($3, $4) * .5;\n    $$1161$in = $6;\n    while (1) {\n     $$1161 = $$1161$in + -1 | 0;\n     if (($$1161 | 0) <= ($$0 | 0)) break L8;\n     $68 = +HEAPF64[$23 + ($$1161 << 3) >> 3];\n     $70 = HEAP32[$1 >> 2] | 0;\n     $71 = $70 + ($$1161 << 3) | 0;\n     $73 = +HEAPF64[$71 >> 3] - $65 * $68;\n     HEAPF64[$71 >> 3] = $73;\n     $74 = Math_imul($$1161, $6) | 0;\n     $$2 = $$1161;\n     while (1) {\n      if (($$2 | 0) >= ($6 | 0)) break;\n      $85 = (HEAP32[$0 >> 2] | 0) + ($$2 + $74 << 3) | 0;\n      HEAPF64[$85 >> 3] = +HEAPF64[$85 >> 3] - ($68 * +HEAPF64[$70 + ($$2 << 3) >> 3] + $73 * +HEAPF64[$23 + ($$2 << 3) >> 3]);\n      $$2 = $$2 + 1 | 0;\n     }\n     $$1161$in = $$1161;\n    }\n   } while (0);\n   $$0 = $30;\n  }\n  if (($6 | 0) > 1) {\n   $90 = HEAP32[$0 >> 2] | 0;\n   $91 = Math_imul($17, $6) | 0;\n   $95 = HEAP32[$1 >> 2] | 0;\n   HEAPF64[$95 + ($17 << 3) >> 3] = +HEAPF64[$90 + ($91 + $17 << 3) >> 3];\n   $97 = $6 + -1 | 0;\n   HEAPF64[(HEAP32[$2 >> 2] | 0) + ($17 << 3) >> 3] = +HEAPF64[$90 + ($97 + $91 << 3) >> 3];\n   $$pre$phiZ2D = $97;\n   $107 = $90;\n   $110 = $95;\n   label = 27;\n  } else if (($6 | 0) == 1) {\n   $$pre$phiZ2D = 0;\n   $107 = HEAP32[$0 >> 2] | 0;\n   $110 = HEAP32[$1 >> 2] | 0;\n   label = 27;\n  } else $$1$in = $6;\n  if ((label | 0) == 27) {\n   $106 = $107 + ((Math_imul($$pre$phiZ2D, $6) | 0) + $$pre$phiZ2D << 3) | 0;\n   $$1$in$ph = $6;\n   $$sink = +HEAPF64[$106 >> 3];\n   $$sink171 = $110 + ($$pre$phiZ2D << 3) | 0;\n   label = 28;\n  }\n  while (1) {\n   if ((label | 0) == 28) {\n    label = 0;\n    HEAPF64[$$sink171 >> 3] = $$sink;\n    $$1$in = $$1$in$ph;\n   }\n   $$1 = $$1$in + -1 | 0;\n   if (($$1$in | 0) <= 0) {\n    $$0164 = 0;\n    break L1;\n   }\n   $114 = (HEAP32[$0 >> 2] | 0) + ((Math_imul($$1, $6) | 0) << 3) | 0;\n   L42 : do if (($$1$in | 0) <= ($17 | 0)) {\n    $117 = $6 - $$1 + -1 | 0;\n    $118 = $114 + ($$1$in << 3) | 0;\n    $$2162 = $$1$in;\n    while (1) {\n     if (($$2162 | 0) >= ($6 | 0)) break L42;\n     HEAP32[$19 >> 2] = $117;\n     HEAP32[$18 >> 2] = $117;\n     HEAP32[$3 >> 2] = $118;\n     $121 = Math_imul($$2162, $6) | 0;\n     HEAP32[$4 >> 2] = (HEAP32[$0 >> 2] | 0) + ($121 + $$1$in << 3);\n     $124 = +_arVecInnerproduct($3, $4);\n     $$3 = $$1$in;\n     while (1) {\n      if (($$3 | 0) >= ($6 | 0)) break;\n      $131 = (HEAP32[$0 >> 2] | 0) + ($$3 + $121 << 3) | 0;\n      HEAPF64[$131 >> 3] = +HEAPF64[$131 >> 3] - $124 * +HEAPF64[$114 + ($$3 << 3) >> 3];\n      $$3 = $$3 + 1 | 0;\n     }\n     $$2162 = $$2162 + 1 | 0;\n    }\n   } while (0);\n   $$3163 = 0;\n   while (1) {\n    if (($$3163 | 0) >= ($6 | 0)) break;\n    HEAPF64[$114 + ($$3163 << 3) >> 3] = 0.0;\n    $$3163 = $$3163 + 1 | 0;\n   }\n   $$1$in$ph = $$1;\n   $$sink = 1.0;\n   $$sink171 = $114 + ($$1 << 3) | 0;\n   label = 28;\n  }\n } else $$0164 = -1; else $$0164 = -1; else $$0164 = -1; while (0);\n STACKTOP = sp;\n return $$0164 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_110parse_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$add$i91 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i90 = 0, $$3 = 0, $14 = 0, $16 = 0, $18 = 0, $24 = 0, $25 = 0, $28 = 0, $29 = 0, $3 = 0, $34 = 0, $35 = 0, $39 = 0, $4 = 0, $41 = 0, $46 = 0, $48 = 0, $55 = 0, $60 = 0, $61 = 0, $68 = 0, $73 = 0, $75 = 0, $76 = 0, $83 = 0, $88 = 0, $89 = 0, $spec$select = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp + 8 | 0;\n $4 = sp;\n L1 : do if (($1 - $0 | 0) > 1) {\n  $spec$select = (HEAP8[$0 >> 0] | 0) == 76 ? $0 + 1 | 0 : $0;\n  switch (HEAP8[$spec$select >> 0] | 0) {\n  case 78:\n   {\n    $14 = __ZN10__cxxabiv112_GLOBAL__N_117parse_nested_nameINS0_2DbEEEPKcS4_S4_RT_($spec$select, $1, $2) | 0;\n    $$3 = ($14 | 0) == ($spec$select | 0) ? $0 : $14;\n    break L1;\n    break;\n   }\n  case 90:\n   {\n    $16 = __ZN10__cxxabiv112_GLOBAL__N_116parse_local_nameINS0_2DbEEEPKcS4_S4_RT_($spec$select, $1, $2) | 0;\n    $$3 = ($16 | 0) == ($spec$select | 0) ? $0 : $16;\n    break L1;\n    break;\n   }\n  default:\n   {\n    $18 = __ZN10__cxxabiv112_GLOBAL__N_119parse_unscoped_nameINS0_2DbEEEPKcS4_S4_RT_($spec$select, $1, $2) | 0;\n    if (($18 | 0) == ($spec$select | 0)) {\n     $68 = __ZN10__cxxabiv112_GLOBAL__N_118parse_substitutionINS0_2DbEEEPKcS4_S4_RT_($spec$select, $1, $2) | 0;\n     if (($68 | 0) == ($spec$select | 0) | ($68 | 0) == ($1 | 0)) {\n      $$3 = $0;\n      break L1;\n     }\n     if ((HEAP8[$68 >> 0] | 0) != 73) {\n      $$3 = $0;\n      break L1;\n     }\n     $73 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($68, $1, $2) | 0;\n     if (($73 | 0) == ($68 | 0)) {\n      $$3 = $0;\n      break L1;\n     }\n     $75 = $2 + 4 | 0;\n     $76 = HEAP32[$75 >> 2] | 0;\n     if ((($76 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$3 = $0;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $76 + -24 | 0);\n     $83 = HEAP32[$75 >> 2] | 0;\n     $$0$i$i$idx$i90 = 0;\n     while (1) {\n      if (($$0$i$i$idx$i90 | 0) == -1) break;\n      $$0$i$i$add$i91 = $$0$i$i$idx$i90 + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($83 + ($$0$i$i$add$i91 * 24 | 0) | 0);\n      $$0$i$i$idx$i90 = $$0$i$i$add$i91;\n     }\n     HEAP32[$75 >> 2] = $83 + -24;\n     $88 = HEAP8[$3 + 11 >> 0] | 0;\n     $89 = $88 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($83 + -48 | 0, $89 ? HEAP32[$3 >> 2] | 0 : $3, $89 ? HEAP32[$3 + 4 >> 2] | 0 : $88 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$3 = $73;\n     break L1;\n    }\n    if (($18 | 0) == ($1 | 0)) {\n     $$3 = $1;\n     break L1;\n    }\n    if ((HEAP8[$18 >> 0] | 0) != 73) {\n     $$3 = $18;\n     break L1;\n    }\n    $24 = $2 + 4 | 0;\n    $25 = HEAP32[$24 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($25 | 0)) {\n     $$3 = $0;\n     break L1;\n    }\n    HEAP32[$4 >> 2] = HEAP32[$2 + 12 >> 2];\n    __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($3, $25 + -24 | 0, $4);\n    $28 = $2 + 20 | 0;\n    $29 = HEAP32[$28 >> 2] | 0;\n    if ($29 >>> 0 < (HEAP32[$2 + 24 >> 2] | 0) >>> 0) {\n     HEAP32[$29 >> 2] = 0;\n     $34 = $29 + 4 | 0;\n     HEAP32[$34 >> 2] = 0;\n     $35 = $29 + 8 | 0;\n     HEAP32[$35 >> 2] = 0;\n     HEAP32[$29 + 12 >> 2] = HEAP32[$3 + 12 >> 2];\n     HEAP32[$29 >> 2] = HEAP32[$3 >> 2];\n     $39 = $3 + 4 | 0;\n     HEAP32[$34 >> 2] = HEAP32[$39 >> 2];\n     $41 = $3 + 8 | 0;\n     HEAP32[$35 >> 2] = HEAP32[$41 >> 2];\n     HEAP32[$41 >> 2] = 0;\n     HEAP32[$39 >> 2] = 0;\n     HEAP32[$3 >> 2] = 0;\n     HEAP32[$28 >> 2] = (HEAP32[$28 >> 2] | 0) + 16;\n    } else __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($2 + 16 | 0, $3);\n    __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($3);\n    $46 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($18, $1, $2) | 0;\n    if (($46 | 0) == ($18 | 0)) {\n     $$3 = $0;\n     break L1;\n    }\n    $48 = HEAP32[$24 >> 2] | 0;\n    if ((($48 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n     $$3 = $0;\n     break L1;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $48 + -24 | 0);\n    $55 = HEAP32[$24 >> 2] | 0;\n    $$0$i$i$idx$i = 0;\n    while (1) {\n     if (($$0$i$i$idx$i | 0) == -1) break;\n     $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($55 + ($$0$i$i$add$i * 24 | 0) | 0);\n     $$0$i$i$idx$i = $$0$i$i$add$i;\n    }\n    HEAP32[$24 >> 2] = $55 + -24;\n    $60 = HEAP8[$3 + 11 >> 0] | 0;\n    $61 = $60 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($55 + -48 | 0, $61 ? HEAP32[$3 >> 2] | 0 : $3, $61 ? HEAP32[$3 + 4 >> 2] | 0 : $60 & 255) | 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$3 = $46;\n    break L1;\n   }\n  }\n } else $$3 = $0; while (0);\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction _arGetContour($0, $1, $2, $3, $4, $5, $6) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n var $$0 = 0, $$0137 = 0, $$0138 = 0, $$0140 = 0, $$0141 = 0, $$0143 = 0, $$1 = 0, $$1144 = 0, $$1144$in = 0, $$2 = 0, $$3 = 0, $$4 = 0, $$5 = 0, $10 = 0, $103 = 0, $11 = 0, $12 = 0, $16 = 0, $18 = 0, $28 = 0, $29 = 0, $30 = 0, $32 = 0, $34 = 0, $35 = 0, $39 = 0, $40 = 0, $42 = 0, $51 = 0, $53 = 0, $54 = 0, $59 = 0, $61 = 0, $62 = 0, $68 = 0, $7 = 0, $73 = 0, $74 = 0, $77 = 0, $79 = 0, $8 = 0, $80 = 0, $91 = 0, $94 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer3 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 80032 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80032);\n $vararg_buffer3 = sp + 16 | 0;\n $vararg_buffer1 = sp + 8 | 0;\n $vararg_buffer = sp;\n $7 = sp + 40024 | 0;\n $8 = sp + 24 | 0;\n $10 = HEAP32[$5 + 8 >> 2] | 0;\n $11 = Math_imul($10, $1) | 0;\n $12 = HEAP32[$5 >> 2] | 0;\n $16 = HEAP32[$5 + 4 >> 2] | 0;\n $$0137 = $12;\n $$0140 = $0 + ($11 + $12 << 1) | 0;\n while (1) {\n  if (($$0137 | 0) > ($16 | 0)) {\n   label = 7;\n   break;\n  }\n  $18 = HEAP16[$$0140 >> 1] | 0;\n  if ($18 << 16 >> 16 > 0) if ((HEAP32[$3 + (($18 << 16 >> 16) + -1 << 2) >> 2] | 0) == ($4 | 0)) {\n   label = 6;\n   break;\n  }\n  $$0137 = $$0137 + 1 | 0;\n  $$0140 = $$0140 + 2 | 0;\n }\n do if ((label | 0) == 6) if (($$0137 | 0) == -1) label = 7; else {\n  $28 = $6 + 24 | 0;\n  HEAP32[$28 >> 2] = 1;\n  $29 = $6 + 28 | 0;\n  HEAP32[$29 >> 2] = $$0137;\n  $30 = $6 + 40028 | 0;\n  HEAP32[$30 >> 2] = $10;\n  $$0143 = 5;\n  $32 = $10;\n  $34 = $$0137;\n  $53 = 1;\n  while (1) {\n   $35 = $0 + ((Math_imul($32, $1) | 0) + $34 << 1) | 0;\n   $$1 = 0;\n   $$1144$in = $$0143 + 5 | 0;\n   while (1) {\n    $$1144 = ($$1144$in | 0) % 8 | 0;\n    if ($$1 >>> 0 >= 8) {\n     label = 13;\n     break;\n    }\n    $39 = HEAP32[444 + ($$1144 << 2) >> 2] | 0;\n    $40 = Math_imul($39, $1) | 0;\n    $42 = HEAP32[476 + ($$1144 << 2) >> 2] | 0;\n    if ((HEAP16[$35 + ($40 + $42 << 1) >> 1] | 0) > 0) {\n     $51 = $42;\n     $59 = $39;\n     break;\n    }\n    $$1 = $$1 + 1 | 0;\n    $$1144$in = $$1144 + 1 | 0;\n   }\n   if ((label | 0) == 13) {\n    label = 0;\n    if (($$1 | 0) == 8) {\n     label = 15;\n     break;\n    }\n    $51 = HEAP32[476 + ($$1144 << 2) >> 2] | 0;\n    $59 = HEAP32[444 + ($$1144 << 2) >> 2] | 0;\n   }\n   HEAP32[$6 + 28 + ($53 << 2) >> 2] = $51 + $34;\n   $54 = HEAP32[$28 >> 2] | 0;\n   HEAP32[$6 + 40028 + ($54 << 2) >> 2] = $59 + (HEAP32[$6 + 40028 + ($54 + -1 << 2) >> 2] | 0);\n   $61 = HEAP32[$28 >> 2] | 0;\n   $62 = $6 + 28 + ($61 << 2) | 0;\n   if ((HEAP32[$62 >> 2] | 0) == ($$0137 | 0)) if ((HEAP32[$6 + 40028 + ($61 << 2) >> 2] | 0) == ($10 | 0)) {\n    label = 18;\n    break;\n   }\n   $68 = $61 + 1 | 0;\n   HEAP32[$28 >> 2] = $68;\n   if (($68 | 0) == 9999) {\n    label = 21;\n    break;\n   }\n   $$0143 = $$1144;\n   $32 = HEAP32[$6 + 40028 + ($61 << 2) >> 2] | 0;\n   $34 = HEAP32[$62 >> 2] | 0;\n   $53 = $68;\n  }\n  if ((label | 0) == 15) {\n   _arLog(0, 3, 3968, $vararg_buffer1);\n   $$0 = -1;\n   break;\n  } else if ((label | 0) == 18) {\n   $$0138 = 0;\n   $$0141 = 0;\n   $$2 = 1;\n   while (1) {\n    if (($$2 | 0) >= ($61 | 0)) break;\n    $73 = (HEAP32[$6 + 28 + ($$2 << 2) >> 2] | 0) - $$0137 | 0;\n    $74 = Math_imul($73, $73) | 0;\n    $77 = (HEAP32[$6 + 40028 + ($$2 << 2) >> 2] | 0) - $10 | 0;\n    $79 = (Math_imul($77, $77) | 0) + $74 | 0;\n    $80 = ($79 | 0) > ($$0141 | 0);\n    $$0138 = $80 ? $$2 : $$0138;\n    $$0141 = $80 ? $79 : $$0141;\n    $$2 = $$2 + 1 | 0;\n   }\n   $$3 = 0;\n   while (1) {\n    if (($$3 | 0) >= ($$0138 | 0)) break;\n    HEAP32[$7 + ($$3 << 2) >> 2] = HEAP32[$6 + 28 + ($$3 << 2) >> 2];\n    HEAP32[$8 + ($$3 << 2) >> 2] = HEAP32[$6 + 40028 + ($$3 << 2) >> 2];\n    $$3 = $$3 + 1 | 0;\n   }\n   $$4 = $$0138;\n   $91 = $61;\n   while (1) {\n    if (($$4 | 0) >= ($91 | 0)) break;\n    $94 = $$4 - $$0138 | 0;\n    HEAP32[$6 + 28 + ($94 << 2) >> 2] = HEAP32[$6 + 28 + ($$4 << 2) >> 2];\n    HEAP32[$6 + 40028 + ($94 << 2) >> 2] = HEAP32[$6 + 40028 + ($$4 << 2) >> 2];\n    $$4 = $$4 + 1 | 0;\n    $91 = HEAP32[$28 >> 2] | 0;\n   }\n   $$5 = 0;\n   while (1) {\n    if (($$5 | 0) >= ($$0138 | 0)) break;\n    $103 = $$5 - $$0138 | 0;\n    HEAP32[$6 + 28 + ((HEAP32[$28 >> 2] | 0) + $103 << 2) >> 2] = HEAP32[$7 + ($$5 << 2) >> 2];\n    HEAP32[$6 + 40028 + ((HEAP32[$28 >> 2] | 0) + $103 << 2) >> 2] = HEAP32[$8 + ($$5 << 2) >> 2];\n    $$5 = $$5 + 1 | 0;\n   }\n   HEAP32[$6 + 28 + (HEAP32[$28 >> 2] << 2) >> 2] = HEAP32[$29 >> 2];\n   HEAP32[$6 + 40028 + (HEAP32[$28 >> 2] << 2) >> 2] = HEAP32[$30 >> 2];\n   HEAP32[$28 >> 2] = (HEAP32[$28 >> 2] | 0) + 1;\n   $$0 = 0;\n   break;\n  } else if ((label | 0) == 21) {\n   _arLog(0, 3, 3975, $vararg_buffer3);\n   $$0 = -1;\n   break;\n  }\n } while (0);\n if ((label | 0) == 7) {\n  _arLog(0, 3, 3961, $vararg_buffer);\n  $$0 = -1;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\nfunction _arPattLoadFromBuffer($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$0140 = 0, $$0141 = 0, $$0143 = 0, $$0146 = 0, $$0149 = 0, $$0150 = 0, $$0151 = 0, $$0152 = 0, $$1 = 0, $$1142 = 0, $$1144 = 0, $$1147 = 0, $$2 = 0, $$2145 = 0, $$2148 = 0, $$3 = 0, $14 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $24 = 0, $26 = 0, $27 = 0, $29 = 0, $31 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $44 = 0, $47 = 0, $51 = 0, $57 = 0, $6 = 0, $64 = 0, $67 = 0, $69 = 0, $75 = 0, $77 = 0, $79 = 0, $82 = 0.0, $87 = 0, $92 = 0, $94 = 0, $96 = 0, $99 = 0.0, $vararg_buffer1 = 0, $vararg_buffer3 = 0, $vararg_buffer5 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $vararg_buffer5 = sp + 24 | 0;\n $vararg_buffer3 = sp + 16 | 0;\n $vararg_buffer1 = sp + 8 | 0;\n do if (!$0) {\n  _arLog(0, 3, 4208, sp);\n  $$0 = -1;\n } else {\n  if (!$1) {\n   _arLog(0, 3, 4233, $vararg_buffer1);\n   $$0 = -1;\n   break;\n  }\n  $4 = $0 + 8 | 0;\n  $6 = HEAP32[$0 + 4 >> 2] | 0;\n  $$0146 = 0;\n  while (1) {\n   if (($$0146 | 0) >= ($6 | 0)) break;\n   if (!(HEAP32[(HEAP32[$4 >> 2] | 0) + ($$0146 << 2) >> 2] | 0)) break;\n   $$0146 = $$0146 + 1 | 0;\n  }\n  if (($$0146 | 0) == ($6 | 0)) $$0 = -1; else {\n   $14 = ___strdup($1) | 0;\n   if (!$14) {\n    _arLog(0, 3, 4278, $vararg_buffer3);\n    $$0 = -1;\n    break;\n   }\n   $17 = $0 + 28 | 0;\n   $18 = $0 + 12 | 0;\n   $19 = $$0146 << 2;\n   $20 = $0 + 20 | 0;\n   $21 = $0 + 16 | 0;\n   $22 = $0 + 24 | 0;\n   $$0140 = _strtok($14, 4301) | 0;\n   $$0152 = 0;\n   L16 : while (1) {\n    if ($$0152 >>> 0 >= 4) {\n     label = 36;\n     break;\n    }\n    $24 = $$0152 + $19 | 0;\n    $$0143 = 0;\n    $$0149 = 0;\n    $$1 = $$0140;\n    while (1) {\n     if ($$0149 >>> 0 >= 3) break;\n     $26 = ($$0149 | 0) == 0;\n     $27 = ($$0149 | 0) == 2;\n     $$0150 = 0;\n     $$1144 = $$0143;\n     $$2 = $$1;\n     $29 = HEAP32[$17 >> 2] | 0;\n     while (1) {\n      if (($$0150 | 0) >= ($29 | 0)) break;\n      $$0151 = 0;\n      $$2145 = $$1144;\n      $$3 = $$2;\n      $31 = $29;\n      while (1) {\n       if (($$0151 | 0) >= ($31 | 0)) break;\n       if (!$$3) {\n        label = 21;\n        break L16;\n       }\n       $33 = _atoi($$3) | 0;\n       $34 = _strtok(0, 4301) | 0;\n       $35 = 255 - $33 | 0;\n       $44 = (HEAP32[(HEAP32[$18 >> 2] | 0) + ($24 << 2) >> 2] | 0) + ((((Math_imul(HEAP32[$17 >> 2] | 0, $$0150) | 0) + $$0151 | 0) * 3 | 0) + $$0149 << 2) | 0;\n       HEAP32[$44 >> 2] = $35;\n       $47 = HEAP32[(HEAP32[$20 >> 2] | 0) + ($24 << 2) >> 2] | 0;\n       $51 = $47 + ((Math_imul(HEAP32[$17 >> 2] | 0, $$0150) | 0) + $$0151 << 2) | 0;\n       if ($26) HEAP32[$51 >> 2] = $35; else {\n        HEAP32[$51 >> 2] = (HEAP32[$51 >> 2] | 0) + $35;\n        if ($27) {\n         $57 = $47 + ((Math_imul(HEAP32[$17 >> 2] | 0, $$0150) | 0) + $$0151 << 2) | 0;\n         HEAP32[$57 >> 2] = (HEAP32[$57 >> 2] | 0) / 3 | 0;\n        }\n       }\n       $$0151 = $$0151 + 1 | 0;\n       $$2145 = $35 + $$2145 | 0;\n       $$3 = $34;\n       $31 = HEAP32[$17 >> 2] | 0;\n      }\n      $$0150 = $$0150 + 1 | 0;\n      $$1144 = $$2145;\n      $$2 = $$3;\n      $29 = $31;\n     }\n     $$0143 = $$1144;\n     $$0149 = $$0149 + 1 | 0;\n     $$1 = $$2;\n    }\n    $64 = HEAP32[$17 >> 2] | 0;\n    $67 = ($$0143 | 0) / (Math_imul($64 * 3 | 0, $64) | 0) | 0;\n    $$0141 = 0;\n    $$1147 = 0;\n    $69 = $64;\n    while (1) {\n     if ($$1147 >>> 0 >= (Math_imul($69 * 3 | 0, $69) | 0) >>> 0) break;\n     $75 = (HEAP32[(HEAP32[$18 >> 2] | 0) + ($24 << 2) >> 2] | 0) + ($$1147 << 2) | 0;\n     $77 = (HEAP32[$75 >> 2] | 0) - $67 | 0;\n     HEAP32[$75 >> 2] = $77;\n     $79 = (Math_imul($77, $77) | 0) + $$0141 | 0;\n     $$0141 = $79;\n     $$1147 = $$1147 + 1 | 0;\n     $69 = HEAP32[$17 >> 2] | 0;\n    }\n    $82 = +Math_sqrt(+(+($$0141 | 0)));\n    HEAPF64[(HEAP32[$21 >> 2] | 0) + ($24 << 3) >> 3] = $82 == 0.0 ? 1.0e-07 : $82;\n    $$1142 = 0;\n    $$2148 = 0;\n    $87 = $69;\n    while (1) {\n     if ($$2148 >>> 0 >= (Math_imul($87, $87) | 0) >>> 0) break;\n     $92 = (HEAP32[(HEAP32[$20 >> 2] | 0) + ($24 << 2) >> 2] | 0) + ($$2148 << 2) | 0;\n     $94 = (HEAP32[$92 >> 2] | 0) - $67 | 0;\n     HEAP32[$92 >> 2] = $94;\n     $96 = (Math_imul($94, $94) | 0) + $$1142 | 0;\n     $$1142 = $96;\n     $$2148 = $$2148 + 1 | 0;\n     $87 = HEAP32[$17 >> 2] | 0;\n    }\n    $99 = +Math_sqrt(+(+($$1142 | 0)));\n    HEAPF64[(HEAP32[$22 >> 2] | 0) + ($24 << 3) >> 3] = $99 == 0.0 ? 1.0e-07 : $99;\n    $$0140 = $$1;\n    $$0152 = $$0152 + 1 | 0;\n   }\n   if ((label | 0) == 21) {\n    _arLog(0, 3, 4306, $vararg_buffer5);\n    _free($14);\n    $$0 = -1;\n    break;\n   } else if ((label | 0) == 36) {\n    _free($14);\n    HEAP32[(HEAP32[$4 >> 2] | 0) + ($$0146 << 2) >> 2] = 1;\n    HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + 1;\n    $$0 = $$0146;\n    break;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_128parse_sizeof_param_pack_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i = 0, $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$idx$i = 0, $$045 = 0, $$045$in = 0, $$046 = 0, $$148 = 0, $16 = 0, $19 = 0, $23 = 0, $24 = 0, $28 = 0, $3 = 0, $35 = 0, $36 = 0, $4 = 0, $43 = 0, $44 = 0, $5 = 0, $51 = 0, $52 = 0, $59 = 0, $6 = 0, $65 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 48 | 0;\n $4 = sp + 24 | 0;\n $5 = sp;\n $6 = sp + 12 | 0;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 115) if ((HEAP8[$0 + 1 >> 0] | 0) == 90) {\n  $16 = $0 + 2 | 0;\n  if ((HEAP8[$16 >> 0] | 0) == 84) {\n   $19 = $2 + 4 | 0;\n   $23 = ((HEAP32[$19 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n   $24 = __ZN10__cxxabiv112_GLOBAL__N_120parse_template_paramINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0;\n   $28 = ((HEAP32[$19 >> 2] | 0) - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0;\n   if (($24 | 0) == ($16 | 0)) $$148 = $0; else {\n    HEAP32[$3 >> 2] = 0;\n    HEAP32[$3 + 4 >> 2] = 0;\n    HEAP32[$3 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, 15330, __ZNSt3__211char_traitsIcE6lengthEPKc(15330) | 0);\n    L7 : do if (($23 | 0) != ($28 | 0)) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($4, (HEAP32[$2 >> 2] | 0) + ($23 * 24 | 0) | 0);\n     $35 = HEAP8[$4 + 11 >> 0] | 0;\n     $36 = $35 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($3, $36 ? HEAP32[$4 >> 2] | 0 : $4, $36 ? HEAP32[$4 + 4 >> 2] | 0 : $35 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     $43 = $4 + 11 | 0;\n     $44 = $4 + 4 | 0;\n     $$045$in = $23;\n     while (1) {\n      $$045 = $$045$in + 1 | 0;\n      if (($$045 | 0) == ($28 | 0)) break L7;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, (HEAP32[$2 >> 2] | 0) + ($$045 * 24 | 0) | 0);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($5, 0, 15341) | 0;\n      HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n      HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n      HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n      $$0$i$i$i = 0;\n      while (1) {\n       if (($$0$i$i$i | 0) == 3) break;\n       HEAP32[$5 + ($$0$i$i$i << 2) >> 2] = 0;\n       $$0$i$i$i = $$0$i$i$i + 1 | 0;\n      }\n      $51 = HEAP8[$43 >> 0] | 0;\n      $52 = $51 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($3, $52 ? HEAP32[$4 >> 2] | 0 : $4, $52 ? HEAP32[$44 >> 2] | 0 : $51 & 255) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n      $$045$in = $$045;\n     }\n    } while (0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($3, 15117) | 0;\n    $$046 = $28;\n    while (1) {\n     if (($$046 | 0) == ($23 | 0)) break;\n     $59 = HEAP32[$19 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($59 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$19 >> 2] = $59 + -24;\n     $$046 = $$046 + -1 | 0;\n    }\n    HEAP32[$6 >> 2] = HEAP32[$3 >> 2];\n    HEAP32[$6 + 4 >> 2] = HEAP32[$3 + 4 >> 2];\n    HEAP32[$6 + 8 >> 2] = HEAP32[$3 + 8 >> 2];\n    $$0$i$i = 0;\n    while (1) {\n     if (($$0$i$i | 0) == 3) break;\n     HEAP32[$3 + ($$0$i$i << 2) >> 2] = 0;\n     $$0$i$i = $$0$i$i + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $6);\n    $65 = HEAP32[$19 >> 2] | 0;\n    if ($65 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($65, $4);\n     HEAP32[$19 >> 2] = (HEAP32[$19 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $4);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n    $$148 = $24;\n   }\n  } else $$148 = $0;\n } else $$148 = $0; else $$148 = $0; else $$148 = $0;\n STACKTOP = sp;\n return $$148 | 0;\n}\n\nfunction ___cxa_demangle($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$0$i$i$i = 0, $$0$i$i$i55 = 0, $$158 = 0, $$2 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $26 = 0, $29 = 0, $30 = 0, $34 = 0, $4 = 0, $41 = 0, $42 = 0, $45 = 0, $47 = 0, $48 = 0, $5 = 0, $51 = 0, $55 = 0, $56 = 0, $59 = 0, $6 = 0, $60 = 0, $62 = 0, $63 = 0, $66 = 0, $67 = 0, $70 = 0, $71 = 0, $79 = 0, $8 = 0, $84 = 0, $87 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 4192 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(4192);\n $4 = sp + 4176 | 0;\n $5 = sp;\n $6 = sp + 4112 | 0;\n if (!$0) label = 3; else {\n  $8 = ($1 | 0) != 0;\n  $9 = ($2 | 0) == 0;\n  if ($8 & $9) label = 3; else {\n   if ($8) $62 = HEAP32[$2 >> 2] | 0; else $62 = 0;\n   __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EEC2Ev($5);\n   __ZN10__cxxabiv112_GLOBAL__N_12DbC2ILj4096EEERNS0_5arenaIXT_EEE($6, $5);\n   $12 = $6 + 48 | 0;\n   $13 = $6 + 61 | 0;\n   HEAP32[$12 >> 2] = 0;\n   HEAP32[$12 + 4 >> 2] = 0;\n   HEAP32[$12 + 8 >> 2] = 0;\n   HEAP8[$12 + 12 >> 0] = 0;\n   HEAP8[$13 >> 0] = 1;\n   $14 = $6 + 32 | 0;\n   $15 = $6 + 36 | 0;\n   $16 = HEAP32[$15 >> 2] | 0;\n   if ($16 >>> 0 < (HEAP32[$6 + 40 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EEC2ERNS0_5arenaILj4096EEE($4, $5);\n    HEAP32[$16 >> 2] = 0;\n    HEAP32[$16 + 4 >> 2] = 0;\n    HEAP32[$16 + 8 >> 2] = 0;\n    HEAP32[$16 + 12 >> 2] = HEAP32[$4 >> 2];\n    HEAP32[$15 >> 2] = (HEAP32[$15 >> 2] | 0) + 16;\n   } else __ZNSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE24__emplace_back_slow_pathIJRNS2_5arenaILj4096EEEEEEvDpOT_($14, $5);\n   $26 = $6 + 62 | 0;\n   HEAP8[$26 >> 0] = 0;\n   HEAP8[$6 + 63 >> 0] = 1;\n   HEAP32[$4 >> 2] = 0;\n   $29 = $0 + (_strlen($0) | 0) | 0;\n   __ZN10__cxxabiv112_GLOBAL__N_18demangleINS0_2DbEEEvPKcS4_RT_Ri($0, $29, $6, $4);\n   $30 = HEAP32[$4 >> 2] | 0;\n   do if (($30 | 0) != 0 | (HEAP8[$26 >> 0] | 0) == 0) {\n    $55 = $30;\n    label = 22;\n   } else {\n    $34 = HEAP32[$14 >> 2] | 0;\n    if (($34 | 0) == (HEAP32[$15 >> 2] | 0)) label = 23; else if ((HEAP32[$34 >> 2] | 0) == (HEAP32[$34 + 4 >> 2] | 0)) label = 23; else {\n     HEAP8[$26 >> 0] = 0;\n     HEAP8[$13 >> 0] = 0;\n     $41 = HEAP32[$6 >> 2] | 0;\n     $42 = $6 + 4 | 0;\n     $$0$i$i$i = HEAP32[$42 >> 2] | 0;\n     while (1) {\n      if (($$0$i$i$i | 0) == ($41 | 0)) break;\n      $45 = $$0$i$i$i + -24 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($45);\n      $$0$i$i$i = $45;\n     }\n     HEAP32[$42 >> 2] = $41;\n     $47 = HEAP32[$6 + 16 >> 2] | 0;\n     $48 = $6 + 20 | 0;\n     $$0$i$i$i55 = HEAP32[$48 >> 2] | 0;\n     while (1) {\n      if (($$0$i$i$i55 | 0) == ($47 | 0)) break;\n      $51 = $$0$i$i$i55 + -16 | 0;\n      __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($51);\n      $$0$i$i$i55 = $51;\n     }\n     HEAP32[$48 >> 2] = $47;\n     __ZN10__cxxabiv112_GLOBAL__N_18demangleINS0_2DbEEEvPKcS4_RT_Ri($0, $29, $6, $4);\n     if (!(HEAP8[$26 >> 0] | 0)) {\n      $55 = HEAP32[$4 >> 2] | 0;\n      label = 22;\n      break;\n     } else {\n      HEAP32[$4 >> 2] = -2;\n      $$2 = 0;\n      $87 = -2;\n      break;\n     }\n    }\n   } while (0);\n   if ((label | 0) == 22) if (!$55) label = 23; else {\n    $$2 = 0;\n    $87 = $55;\n   }\n   do if ((label | 0) == 23) {\n    $56 = $6 + 4 | 0;\n    $59 = __ZNK10__cxxabiv112_GLOBAL__N_111string_pair4sizeEv((HEAP32[$56 >> 2] | 0) + -24 | 0) | 0;\n    $60 = $59 + 1 | 0;\n    if ($60 >>> 0 > $62 >>> 0) {\n     $63 = _realloc($1, $60) | 0;\n     if (!$63) {\n      HEAP32[$4 >> 2] = -1;\n      $$2 = 0;\n      $87 = -1;\n      break;\n     }\n     if ($9) $$158 = $63; else {\n      HEAP32[$2 >> 2] = $60;\n      $$158 = $63;\n     }\n    } else if (!$1) {\n     $$2 = 0;\n     $87 = 0;\n     break;\n    } else $$158 = $1;\n    $66 = HEAP32[$56 >> 2] | 0;\n    $67 = $66 + -12 | 0;\n    $70 = HEAP8[$67 + 11 >> 0] | 0;\n    $71 = $70 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($66 + -24 | 0, $71 ? HEAP32[$67 >> 2] | 0 : $67, $71 ? HEAP32[$66 + -8 >> 2] | 0 : $70 & 255) | 0;\n    $79 = (HEAP32[$56 >> 2] | 0) + -24 | 0;\n    if ((HEAP8[$79 + 11 >> 0] | 0) < 0) $84 = HEAP32[$79 >> 2] | 0; else $84 = $79;\n    _memcpy($$158 | 0, $84 | 0, $59 | 0) | 0;\n    HEAP8[$$158 + $59 >> 0] = 0;\n    $$2 = $$158;\n    $87 = 0;\n   } while (0);\n   if ($3 | 0) HEAP32[$3 >> 2] = $87;\n   __ZN10__cxxabiv112_GLOBAL__N_12DbD2Ev($6);\n   __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EED2Ev($5);\n   $$0 = $$2;\n  }\n }\n if ((label | 0) == 3) if (!$3) $$0 = 0; else {\n  HEAP32[$3 >> 2] = -3;\n  $$0 = 0;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_120parse_template_paramINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$067 = 0, $$068 = 0, $$1 = 0, $$sroa$077$0 = 0, $$sroa$083$0 = 0, $12 = 0, $17 = 0, $20 = 0, $26 = 0, $27 = 0, $28 = 0, $3 = 0, $31 = 0, $37 = 0, $38 = 0, $4 = 0, $49 = 0, $58 = 0, $60 = 0, $64 = 0, $68 = 0, $72 = 0, $73 = 0, $74 = 0, $77 = 0, $83 = 0, $84 = 0, $85 = 0, $isdigittmp = 0, $isdigittmp71 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $3 = sp + 16 | 0;\n $4 = sp;\n L1 : do if (($1 - $0 | 0) > 1) if ((HEAP8[$0 >> 0] | 0) == 84) {\n  $12 = HEAP8[$0 + 1 >> 0] | 0;\n  if ($12 << 24 >> 24 == 95) {\n   $17 = HEAP32[$2 + 36 >> 2] | 0;\n   if ((HEAP32[$2 + 32 >> 2] | 0) == ($17 | 0)) {\n    $$1 = $0;\n    break;\n   }\n   $20 = HEAP32[$17 + -16 >> 2] | 0;\n   if (($20 | 0) == (HEAP32[$17 + -12 >> 2] | 0)) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj3EEERAT__Kc($3);\n    $37 = $2 + 4 | 0;\n    $38 = HEAP32[$37 >> 2] | 0;\n    if ($38 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($38, $3);\n     HEAP32[$37 >> 2] = (HEAP32[$37 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    HEAP8[$2 + 62 >> 0] = 1;\n    $$1 = $0 + 2 | 0;\n    break;\n   }\n   $26 = HEAP32[$20 + 4 >> 2] | 0;\n   $27 = $2 + 4 | 0;\n   $28 = $2 + 8 | 0;\n   $$sroa$083$0 = HEAP32[$20 >> 2] | 0;\n   while (1) {\n    if (($$sroa$083$0 | 0) == ($26 | 0)) break;\n    $31 = HEAP32[$27 >> 2] | 0;\n    if (($31 | 0) == (HEAP32[$28 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($2, $$sroa$083$0); else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($31, $$sroa$083$0);\n     HEAP32[$27 >> 2] = (HEAP32[$27 >> 2] | 0) + 24;\n    }\n    $$sroa$083$0 = $$sroa$083$0 + 24 | 0;\n   }\n   $$1 = $0 + 2 | 0;\n   break;\n  }\n  $isdigittmp = ($12 << 24 >> 24) + -48 | 0;\n  if ($isdigittmp >>> 0 < 10) {\n   $$067 = $isdigittmp;\n   $$068 = $0 + 2 | 0;\n   while (1) {\n    if (($$068 | 0) == ($1 | 0)) {\n     $$1 = $0;\n     break L1;\n    }\n    $49 = HEAP8[$$068 >> 0] | 0;\n    $isdigittmp71 = ($49 << 24 >> 24) + -48 | 0;\n    if ($isdigittmp71 >>> 0 >= 10) break;\n    $$067 = $isdigittmp71 + ($$067 * 10 | 0) | 0;\n    $$068 = $$068 + 1 | 0;\n   }\n   if ($49 << 24 >> 24 == 95) {\n    $58 = HEAP32[$2 + 36 >> 2] | 0;\n    if ((HEAP32[$2 + 32 >> 2] | 0) == ($58 | 0)) $$1 = $0; else {\n     $60 = $$067 + 1 | 0;\n     $64 = HEAP32[$58 + -16 >> 2] | 0;\n     $68 = $64;\n     if ($60 >>> 0 >= (HEAP32[$58 + -12 >> 2] | 0) - $64 >> 4 >>> 0) {\n      $83 = $$068 + 1 | 0;\n      HEAP32[$4 >> 2] = 0;\n      HEAP32[$4 + 4 >> 2] = 0;\n      HEAP32[$4 + 8 >> 2] = 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($4, $0, $83);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $4);\n      $84 = $2 + 4 | 0;\n      $85 = HEAP32[$84 >> 2] | 0;\n      if ($85 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($85, $3);\n       HEAP32[$84 >> 2] = (HEAP32[$84 >> 2] | 0) + 24;\n      } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n      HEAP8[$2 + 62 >> 0] = 1;\n      $$1 = $83;\n      break;\n     }\n     $72 = HEAP32[$68 + ($60 << 4) + 4 >> 2] | 0;\n     $73 = $2 + 4 | 0;\n     $74 = $2 + 8 | 0;\n     $$sroa$077$0 = HEAP32[$68 + ($60 << 4) >> 2] | 0;\n     while (1) {\n      if (($$sroa$077$0 | 0) == ($72 | 0)) break;\n      $77 = HEAP32[$73 >> 2] | 0;\n      if (($77 | 0) == (HEAP32[$74 >> 2] | 0)) __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($2, $$sroa$077$0); else {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($77, $$sroa$077$0);\n       HEAP32[$73 >> 2] = (HEAP32[$73 >> 2] | 0) + 24;\n      }\n      $$sroa$077$0 = $$sroa$077$0 + 24 | 0;\n     }\n     $$1 = $$068 + 1 | 0;\n    }\n   } else $$1 = $0;\n  } else $$1 = $0;\n } else $$1 = $0; else $$1 = $0; while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_115parse_call_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0$i$i = 0, $$0$i$i$add$i = 0, $$0$i$i$i$i = 0, $$0$i$i$idx$i = 0, $$063 = 0, $$066 = 0, $$1 = 0, $$164 = 0, $$6 = 0, $14 = 0, $15 = 0, $19 = 0, $20 = 0, $22 = 0, $25 = 0, $26 = 0, $3 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $40 = 0, $46 = 0, $47 = 0, $50 = 0, $54 = 0, $57 = 0, $59 = 0, $60 = 0, $61 = 0, $64 = 0, $72 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp + 12 | 0;\n $4 = sp;\n L1 : do if (($1 - $0 | 0) > 3) if ((HEAP8[$0 >> 0] | 0) == 99) if ((HEAP8[$0 + 1 >> 0] | 0) == 108) {\n  $14 = $0 + 2 | 0;\n  $15 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($14, $1, $2) | 0;\n  if (($15 | 0) == ($14 | 0) | ($15 | 0) == ($1 | 0)) $$6 = $0; else {\n   $19 = $2 + 4 | 0;\n   $20 = HEAP32[$19 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($20 | 0)) $$6 = $0; else {\n    $22 = $20 + -12 | 0;\n    $25 = HEAP8[$22 + 11 >> 0] | 0;\n    $26 = $25 << 24 >> 24 < 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($20 + -24 | 0, $26 ? HEAP32[$22 >> 2] | 0 : $22, $26 ? HEAP32[$20 + -8 >> 2] | 0 : $25 & 255) | 0;\n    HEAP32[$4 >> 2] = 0;\n    HEAP32[$4 + 4 >> 2] = 0;\n    HEAP32[$4 + 8 >> 2] = 0;\n    $$0$i$i = 0;\n    while (1) {\n     if (($$0$i$i | 0) == 3) break;\n     HEAP32[$4 + ($$0$i$i << 2) >> 2] = 0;\n     $$0$i$i = $$0$i$i + 1 | 0;\n    }\n    $35 = HEAP32[$19 >> 2] | 0;\n    $36 = $35 + -12 | 0;\n    $37 = $36 + 11 | 0;\n    if ((HEAP8[$37 >> 0] | 0) < 0) {\n     $40 = HEAP32[$36 >> 2] | 0;\n     HEAP8[$3 >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($40, $3);\n     HEAP32[$35 + -8 >> 2] = 0;\n    } else {\n     HEAP8[$3 >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($36, $3);\n     HEAP8[$37 >> 0] = 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($36);\n    HEAP32[$36 >> 2] = HEAP32[$4 >> 2];\n    HEAP32[$36 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n    HEAP32[$36 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n    $$0$i$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i$i | 0) == 3) break;\n     HEAP32[$4 + ($$0$i$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc((HEAP32[$19 >> 2] | 0) + -24 | 0, 15119) | 0;\n    $46 = $3 + 11 | 0;\n    $47 = $3 + 4 | 0;\n    $$0 = 0;\n    $$063 = $15;\n    while (1) {\n     if ((HEAP8[$$063 >> 0] | 0) == 69) break;\n     $50 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($$063, $1, $2) | 0;\n     if (($50 | 0) == ($$063 | 0) | ($50 | 0) == ($1 | 0)) {\n      $$6 = $0;\n      break L1;\n     }\n     $54 = HEAP32[$19 >> 2] | 0;\n     if ((HEAP32[$2 >> 2] | 0) == ($54 | 0)) {\n      $$6 = $0;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $54 + -24 | 0);\n     $57 = HEAP32[$19 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($57 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     $59 = $57 + -24 | 0;\n     HEAP32[$19 >> 2] = $59;\n     $60 = HEAP8[$46 >> 0] | 0;\n     $61 = $60 << 24 >> 24 < 0;\n     $64 = $61 ? HEAP32[$47 >> 2] | 0 : $60 & 255;\n     if (!$64) {\n      $$066 = 1;\n      $$1 = $$0;\n      $$164 = $50;\n     } else if ((HEAP32[$2 >> 2] | 0) == ($59 | 0)) {\n      $$066 = 0;\n      $$1 = $0;\n      $$164 = $$063;\n     } else {\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($57 + -48 | 0, $61 ? HEAP32[$3 >> 2] | 0 : $3, $64) | 0;\n      $$066 = 1;\n      $$1 = $$0;\n      $$164 = $50;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     if ($$066) {\n      $$0 = $$1;\n      $$063 = $$164;\n     } else {\n      $$6 = $$1;\n      break L1;\n     }\n    }\n    $72 = HEAP32[$19 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($72 | 0)) $$6 = $0; else {\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($72 + -24 | 0, 15117) | 0;\n     $$6 = $$063 + 1 | 0;\n    }\n   }\n  }\n } else $$6 = $0; else $$6 = $0; else $$6 = $0; while (0);\n STACKTOP = sp;\n return $$6 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_127parse_reinterpret_cast_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$i47 = 0, $$0$i$i$i50 = 0, $$0$i$i$i53 = 0, $$0$i$i$idx$i = 0, $$341 = 0, $19 = 0, $20 = 0, $22 = 0, $24 = 0, $25 = 0, $3 = 0, $32 = 0, $4 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 112 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112);\n $3 = sp + 88 | 0;\n $4 = sp + 64 | 0;\n $5 = sp + 36 | 0;\n $6 = sp + 48 | 0;\n $7 = sp + 24 | 0;\n $8 = sp + 12 | 0;\n $9 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 114) if ((HEAP8[$0 + 1 >> 0] | 0) == 99) {\n  $19 = $0 + 2 | 0;\n  $20 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($19, $1, $2) | 0;\n  if (($20 | 0) == ($19 | 0)) $$341 = $0; else {\n   $22 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($20, $1, $2) | 0;\n   if (($22 | 0) == ($20 | 0)) $$341 = $0; else {\n    $24 = $2 + 4 | 0;\n    $25 = HEAP32[$24 >> 2] | 0;\n    if ((($25 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$341 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $25 + -24 | 0);\n     $32 = HEAP32[$24 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($32 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$24 >> 2] = $32 + -24;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($9, $32 + -48 | 0);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($9, 0, 15369) | 0;\n     HEAP32[$8 >> 2] = HEAP32[$9 >> 2];\n     HEAP32[$8 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n     HEAP32[$8 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n     $$0$i$i$i = 0;\n     while (1) {\n      if (($$0$i$i$i | 0) == 3) break;\n      HEAP32[$9 + ($$0$i$i$i << 2) >> 2] = 0;\n      $$0$i$i$i = $$0$i$i$i + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($8, 15366) | 0;\n     HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n     HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n     HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n     $$0$i$i$i47 = 0;\n     while (1) {\n      if (($$0$i$i$i47 | 0) == 3) break;\n      HEAP32[$8 + ($$0$i$i$i47 << 2) >> 2] = 0;\n      $$0$i$i$i47 = $$0$i$i$i47 + 1 | 0;\n     }\n     $43 = HEAP8[$3 + 11 >> 0] | 0;\n     $44 = $43 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($7, $44 ? HEAP32[$3 >> 2] | 0 : $3, $44 ? HEAP32[$3 + 4 >> 2] | 0 : $43 & 255) | 0;\n     HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n     HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n     HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n     $$0$i$i$i50 = 0;\n     while (1) {\n      if (($$0$i$i$i50 | 0) == 3) break;\n      HEAP32[$7 + ($$0$i$i$i50 << 2) >> 2] = 0;\n      $$0$i$i$i50 = $$0$i$i$i50 + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15117) | 0;\n     HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n     HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n     HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n     $$0$i$i$i53 = 0;\n     while (1) {\n      if (($$0$i$i$i53 | 0) == 3) break;\n      HEAP32[$6 + ($$0$i$i$i53 << 2) >> 2] = 0;\n      $$0$i$i$i53 = $$0$i$i$i53 + 1 | 0;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $5);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$24 >> 2] | 0) + -24 | 0, $4);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$341 = $22;\n    }\n   }\n  }\n } else $$341 = $0; else $$341 = $0; else $$341 = $0;\n STACKTOP = sp;\n return $$341 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_123parse_dynamic_cast_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$i47 = 0, $$0$i$i$i50 = 0, $$0$i$i$i53 = 0, $$0$i$i$idx$i = 0, $$341 = 0, $19 = 0, $20 = 0, $22 = 0, $24 = 0, $25 = 0, $3 = 0, $32 = 0, $4 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 112 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112);\n $3 = sp + 88 | 0;\n $4 = sp + 64 | 0;\n $5 = sp + 36 | 0;\n $6 = sp + 48 | 0;\n $7 = sp + 24 | 0;\n $8 = sp + 12 | 0;\n $9 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 100) if ((HEAP8[$0 + 1 >> 0] | 0) == 99) {\n  $19 = $0 + 2 | 0;\n  $20 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($19, $1, $2) | 0;\n  if (($20 | 0) == ($19 | 0)) $$341 = $0; else {\n   $22 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($20, $1, $2) | 0;\n   if (($22 | 0) == ($20 | 0)) $$341 = $0; else {\n    $24 = $2 + 4 | 0;\n    $25 = HEAP32[$24 >> 2] | 0;\n    if ((($25 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$341 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $25 + -24 | 0);\n     $32 = HEAP32[$24 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($32 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$24 >> 2] = $32 + -24;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($9, $32 + -48 | 0);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($9, 0, 16269) | 0;\n     HEAP32[$8 >> 2] = HEAP32[$9 >> 2];\n     HEAP32[$8 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n     HEAP32[$8 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n     $$0$i$i$i = 0;\n     while (1) {\n      if (($$0$i$i$i | 0) == 3) break;\n      HEAP32[$9 + ($$0$i$i$i << 2) >> 2] = 0;\n      $$0$i$i$i = $$0$i$i$i + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($8, 15366) | 0;\n     HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n     HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n     HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n     $$0$i$i$i47 = 0;\n     while (1) {\n      if (($$0$i$i$i47 | 0) == 3) break;\n      HEAP32[$8 + ($$0$i$i$i47 << 2) >> 2] = 0;\n      $$0$i$i$i47 = $$0$i$i$i47 + 1 | 0;\n     }\n     $43 = HEAP8[$3 + 11 >> 0] | 0;\n     $44 = $43 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($7, $44 ? HEAP32[$3 >> 2] | 0 : $3, $44 ? HEAP32[$3 + 4 >> 2] | 0 : $43 & 255) | 0;\n     HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n     HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n     HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n     $$0$i$i$i50 = 0;\n     while (1) {\n      if (($$0$i$i$i50 | 0) == 3) break;\n      HEAP32[$7 + ($$0$i$i$i50 << 2) >> 2] = 0;\n      $$0$i$i$i50 = $$0$i$i$i50 + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15117) | 0;\n     HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n     HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n     HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n     $$0$i$i$i53 = 0;\n     while (1) {\n      if (($$0$i$i$i53 | 0) == 3) break;\n      HEAP32[$6 + ($$0$i$i$i53 << 2) >> 2] = 0;\n      $$0$i$i$i53 = $$0$i$i$i53 + 1 | 0;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $5);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$24 >> 2] | 0) + -24 | 0, $4);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$341 = $22;\n    }\n   }\n  }\n } else $$341 = $0; else $$341 = $0; else $$341 = $0;\n STACKTOP = sp;\n return $$341 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_122parse_static_cast_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$i47 = 0, $$0$i$i$i50 = 0, $$0$i$i$i53 = 0, $$0$i$i$idx$i = 0, $$341 = 0, $19 = 0, $20 = 0, $22 = 0, $24 = 0, $25 = 0, $3 = 0, $32 = 0, $4 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 112 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112);\n $3 = sp + 88 | 0;\n $4 = sp + 64 | 0;\n $5 = sp + 36 | 0;\n $6 = sp + 48 | 0;\n $7 = sp + 24 | 0;\n $8 = sp + 12 | 0;\n $9 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 115) if ((HEAP8[$0 + 1 >> 0] | 0) == 99) {\n  $19 = $0 + 2 | 0;\n  $20 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($19, $1, $2) | 0;\n  if (($20 | 0) == ($19 | 0)) $$341 = $0; else {\n   $22 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($20, $1, $2) | 0;\n   if (($22 | 0) == ($20 | 0)) $$341 = $0; else {\n    $24 = $2 + 4 | 0;\n    $25 = HEAP32[$24 >> 2] | 0;\n    if ((($25 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$341 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $25 + -24 | 0);\n     $32 = HEAP32[$24 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($32 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$24 >> 2] = $32 + -24;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($9, $32 + -48 | 0);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($9, 0, 15353) | 0;\n     HEAP32[$8 >> 2] = HEAP32[$9 >> 2];\n     HEAP32[$8 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n     HEAP32[$8 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n     $$0$i$i$i = 0;\n     while (1) {\n      if (($$0$i$i$i | 0) == 3) break;\n      HEAP32[$9 + ($$0$i$i$i << 2) >> 2] = 0;\n      $$0$i$i$i = $$0$i$i$i + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($8, 15366) | 0;\n     HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n     HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n     HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n     $$0$i$i$i47 = 0;\n     while (1) {\n      if (($$0$i$i$i47 | 0) == 3) break;\n      HEAP32[$8 + ($$0$i$i$i47 << 2) >> 2] = 0;\n      $$0$i$i$i47 = $$0$i$i$i47 + 1 | 0;\n     }\n     $43 = HEAP8[$3 + 11 >> 0] | 0;\n     $44 = $43 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($7, $44 ? HEAP32[$3 >> 2] | 0 : $3, $44 ? HEAP32[$3 + 4 >> 2] | 0 : $43 & 255) | 0;\n     HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n     HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n     HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n     $$0$i$i$i50 = 0;\n     while (1) {\n      if (($$0$i$i$i50 | 0) == 3) break;\n      HEAP32[$7 + ($$0$i$i$i50 << 2) >> 2] = 0;\n      $$0$i$i$i50 = $$0$i$i$i50 + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15117) | 0;\n     HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n     HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n     HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n     $$0$i$i$i53 = 0;\n     while (1) {\n      if (($$0$i$i$i53 | 0) == 3) break;\n      HEAP32[$6 + ($$0$i$i$i53 << 2) >> 2] = 0;\n      $$0$i$i$i53 = $$0$i$i$i53 + 1 | 0;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $5);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$24 >> 2] | 0) + -24 | 0, $4);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$341 = $22;\n    }\n   }\n  }\n } else $$341 = $0; else $$341 = $0; else $$341 = $0;\n STACKTOP = sp;\n return $$341 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_121parse_const_cast_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$i = 0, $$0$i$i$i47 = 0, $$0$i$i$i50 = 0, $$0$i$i$i53 = 0, $$0$i$i$idx$i = 0, $$341 = 0, $19 = 0, $20 = 0, $22 = 0, $24 = 0, $25 = 0, $3 = 0, $32 = 0, $4 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 112 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112);\n $3 = sp + 88 | 0;\n $4 = sp + 64 | 0;\n $5 = sp + 36 | 0;\n $6 = sp + 48 | 0;\n $7 = sp + 24 | 0;\n $8 = sp + 12 | 0;\n $9 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 99) if ((HEAP8[$0 + 1 >> 0] | 0) == 99) {\n  $19 = $0 + 2 | 0;\n  $20 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($19, $1, $2) | 0;\n  if (($20 | 0) == ($19 | 0)) $$341 = $0; else {\n   $22 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($20, $1, $2) | 0;\n   if (($22 | 0) == ($20 | 0)) $$341 = $0; else {\n    $24 = $2 + 4 | 0;\n    $25 = HEAP32[$24 >> 2] | 0;\n    if ((($25 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$341 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $25 + -24 | 0);\n     $32 = HEAP32[$24 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($32 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$24 >> 2] = $32 + -24;\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($9, $32 + -48 | 0);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($9, 0, 16286) | 0;\n     HEAP32[$8 >> 2] = HEAP32[$9 >> 2];\n     HEAP32[$8 + 4 >> 2] = HEAP32[$9 + 4 >> 2];\n     HEAP32[$8 + 8 >> 2] = HEAP32[$9 + 8 >> 2];\n     $$0$i$i$i = 0;\n     while (1) {\n      if (($$0$i$i$i | 0) == 3) break;\n      HEAP32[$9 + ($$0$i$i$i << 2) >> 2] = 0;\n      $$0$i$i$i = $$0$i$i$i + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($8, 15366) | 0;\n     HEAP32[$7 >> 2] = HEAP32[$8 >> 2];\n     HEAP32[$7 + 4 >> 2] = HEAP32[$8 + 4 >> 2];\n     HEAP32[$7 + 8 >> 2] = HEAP32[$8 + 8 >> 2];\n     $$0$i$i$i47 = 0;\n     while (1) {\n      if (($$0$i$i$i47 | 0) == 3) break;\n      HEAP32[$8 + ($$0$i$i$i47 << 2) >> 2] = 0;\n      $$0$i$i$i47 = $$0$i$i$i47 + 1 | 0;\n     }\n     $43 = HEAP8[$3 + 11 >> 0] | 0;\n     $44 = $43 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($7, $44 ? HEAP32[$3 >> 2] | 0 : $3, $44 ? HEAP32[$3 + 4 >> 2] | 0 : $43 & 255) | 0;\n     HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n     HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n     HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n     $$0$i$i$i50 = 0;\n     while (1) {\n      if (($$0$i$i$i50 | 0) == 3) break;\n      HEAP32[$7 + ($$0$i$i$i50 << 2) >> 2] = 0;\n      $$0$i$i$i50 = $$0$i$i$i50 + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15117) | 0;\n     HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n     HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n     HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n     $$0$i$i$i53 = 0;\n     while (1) {\n      if (($$0$i$i$i53 | 0) == 3) break;\n      HEAP32[$6 + ($$0$i$i$i53 << 2) >> 2] = 0;\n      $$0$i$i$i53 = $$0$i$i$i53 + 1 | 0;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $5);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$24 >> 2] | 0) + -24 | 0, $4);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($9);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$341 = $22;\n    }\n   }\n  }\n } else $$341 = $0; else $$341 = $0; else $$341 = $0;\n STACKTOP = sp;\n return $$341 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_120parse_function_paramINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0$i$i$i = 0, $$0$i$i$i56 = 0, $$2 = 0, $$3 = 0, $17 = 0, $18 = 0, $25 = 0, $26 = 0, $3 = 0, $34 = 0, $39 = 0, $4 = 0, $40 = 0, $47 = 0, $48 = 0, $5 = 0, $6 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 80 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80);\n $3 = sp + 64 | 0;\n $4 = sp + 40 | 0;\n $5 = sp + 12 | 0;\n $6 = sp + 24 | 0;\n $7 = sp;\n L1 : do if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 102) {\n  switch (HEAP8[$0 + 1 >> 0] | 0) {\n  case 112:\n   {\n    $17 = __ZN10__cxxabiv112_GLOBAL__N_119parse_cv_qualifiersEPKcS2_Rj($0 + 2 | 0, $1, $3) | 0;\n    $18 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($17, $1) | 0;\n    if (($18 | 0) == ($1 | 0)) $$0 = $0; else if ((HEAP8[$18 >> 0] | 0) == 95) {\n     HEAP32[$6 >> 2] = 0;\n     HEAP32[$6 + 4 >> 2] = 0;\n     HEAP32[$6 + 8 >> 2] = 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($6, $17, $18);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 16308) | 0;\n     HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n     HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n     HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n     $$0$i$i$i = 0;\n     while (1) {\n      if (($$0$i$i$i | 0) == 3) break;\n      HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n      $$0$i$i$i = $$0$i$i$i + 1 | 0;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $5);\n     $25 = $2 + 4 | 0;\n     $26 = HEAP32[$25 >> 2] | 0;\n     if ($26 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($26, $4);\n      HEAP32[$25 >> 2] = (HEAP32[$25 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $4);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n     $$0 = $18 + 1 | 0;\n    } else $$0 = $0;\n    $$3 = $$0;\n    break L1;\n    break;\n   }\n  case 76:\n   break;\n  default:\n   {\n    $$3 = $0;\n    break L1;\n   }\n  }\n  $34 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($0 + 2 | 0, $1) | 0;\n  if (($34 | 0) == ($1 | 0)) $$2 = $0; else if ((HEAP8[$34 >> 0] | 0) == 112) {\n   $39 = __ZN10__cxxabiv112_GLOBAL__N_119parse_cv_qualifiersEPKcS2_Rj($34 + 1 | 0, $1, $3) | 0;\n   $40 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($39, $1) | 0;\n   if (($40 | 0) == ($1 | 0)) $$2 = $0; else if ((HEAP8[$40 >> 0] | 0) == 95) {\n    HEAP32[$6 >> 2] = 0;\n    HEAP32[$6 + 4 >> 2] = 0;\n    HEAP32[$6 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($6, $39, $40);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 16308) | 0;\n    HEAP32[$7 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$7 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$7 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i56 = 0;\n    while (1) {\n     if (($$0$i$i$i56 | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i56 << 2) >> 2] = 0;\n     $$0$i$i$i56 = $$0$i$i$i56 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $7);\n    $47 = $2 + 4 | 0;\n    $48 = HEAP32[$47 >> 2] | 0;\n    if ($48 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($48, $4);\n     HEAP32[$47 >> 2] = (HEAP32[$47 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $4);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    $$2 = $40 + 1 | 0;\n   } else $$2 = $0;\n  } else $$2 = $0;\n  $$3 = $$2;\n } else $$3 = $0; else $$3 = $0; while (0);\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction __ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$081$off0 = 0, $$084 = 0, $$085$off0 = 0, $$1 = 0, $$182$off0 = 0, $$186$off0 = 0, $$2 = 0, $$283$off0 = 0, $13 = 0, $19 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $47 = 0, $55 = 0, $58 = 0, $59 = 0, $60 = 0, $63 = 0, $66 = 0, $69 = 0, $76 = 0, $77 = 0, $86 = 0, label = 0;\n L1 : do if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 + 8 >> 2] | 0, $4) | 0) __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi(0, $1, $2, $3); else {\n  if (!(__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 >> 2] | 0, $4) | 0)) {\n   $58 = HEAP32[$0 + 12 >> 2] | 0;\n   $59 = $0 + 16 + ($58 << 3) | 0;\n   __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($0 + 16 | 0, $1, $2, $3, $4);\n   $60 = $0 + 24 | 0;\n   if (($58 | 0) <= 1) break;\n   $63 = HEAP32[$0 + 8 >> 2] | 0;\n   if (!($63 & 2)) {\n    $66 = $1 + 36 | 0;\n    if ((HEAP32[$66 >> 2] | 0) != 1) {\n     if (!($63 & 1)) {\n      $86 = $1 + 54 | 0;\n      $$2 = $60;\n      while (1) {\n       if (HEAP8[$86 >> 0] | 0) break L1;\n       if ((HEAP32[$66 >> 2] | 0) == 1) break L1;\n       __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($$2, $1, $2, $3, $4);\n       $$2 = $$2 + 8 | 0;\n       if ($$2 >>> 0 >= $59 >>> 0) break L1;\n      }\n     }\n     $76 = $1 + 24 | 0;\n     $77 = $1 + 54 | 0;\n     $$1 = $60;\n     while (1) {\n      if (HEAP8[$77 >> 0] | 0) break L1;\n      if ((HEAP32[$66 >> 2] | 0) == 1) if ((HEAP32[$76 >> 2] | 0) == 1) break L1;\n      __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($$1, $1, $2, $3, $4);\n      $$1 = $$1 + 8 | 0;\n      if ($$1 >>> 0 >= $59 >>> 0) break L1;\n     }\n    }\n   }\n   $69 = $1 + 54 | 0;\n   $$0 = $60;\n   while (1) {\n    if (HEAP8[$69 >> 0] | 0) break L1;\n    __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($$0, $1, $2, $3, $4);\n    $$0 = $$0 + 8 | 0;\n    if ($$0 >>> 0 >= $59 >>> 0) break L1;\n   }\n  }\n  if ((HEAP32[$1 + 16 >> 2] | 0) != ($2 | 0)) {\n   $13 = $1 + 20 | 0;\n   if ((HEAP32[$13 >> 2] | 0) != ($2 | 0)) {\n    HEAP32[$1 + 32 >> 2] = $3;\n    $19 = $1 + 44 | 0;\n    if ((HEAP32[$19 >> 2] | 0) == 4) break;\n    $25 = $0 + 16 + (HEAP32[$0 + 12 >> 2] << 3) | 0;\n    $26 = $1 + 52 | 0;\n    $27 = $1 + 53 | 0;\n    $28 = $1 + 54 | 0;\n    $29 = $0 + 8 | 0;\n    $30 = $1 + 24 | 0;\n    $$081$off0 = 0;\n    $$084 = $0 + 16 | 0;\n    $$085$off0 = 0;\n    L32 : while (1) {\n     if ($$084 >>> 0 >= $25 >>> 0) {\n      $$283$off0 = $$081$off0;\n      label = 18;\n      break;\n     }\n     HEAP8[$26 >> 0] = 0;\n     HEAP8[$27 >> 0] = 0;\n     __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($$084, $1, $2, $2, 1, $4);\n     if (HEAP8[$28 >> 0] | 0) {\n      $$283$off0 = $$081$off0;\n      label = 18;\n      break;\n     }\n     do if (!(HEAP8[$27 >> 0] | 0)) {\n      $$182$off0 = $$081$off0;\n      $$186$off0 = $$085$off0;\n     } else {\n      if (!(HEAP8[$26 >> 0] | 0)) if (!(HEAP32[$29 >> 2] & 1)) {\n       $$283$off0 = 1;\n       label = 18;\n       break L32;\n      } else {\n       $$182$off0 = 1;\n       $$186$off0 = $$085$off0;\n       break;\n      }\n      if ((HEAP32[$30 >> 2] | 0) == 1) {\n       label = 23;\n       break L32;\n      }\n      if (!(HEAP32[$29 >> 2] & 2)) {\n       label = 23;\n       break L32;\n      } else {\n       $$182$off0 = 1;\n       $$186$off0 = 1;\n      }\n     } while (0);\n     $$081$off0 = $$182$off0;\n     $$084 = $$084 + 8 | 0;\n     $$085$off0 = $$186$off0;\n    }\n    do if ((label | 0) == 18) {\n     if (!$$085$off0) {\n      HEAP32[$13 >> 2] = $2;\n      $47 = $1 + 40 | 0;\n      HEAP32[$47 >> 2] = (HEAP32[$47 >> 2] | 0) + 1;\n      if ((HEAP32[$1 + 36 >> 2] | 0) == 1) if ((HEAP32[$30 >> 2] | 0) == 2) {\n       HEAP8[$28 >> 0] = 1;\n       if ($$283$off0) {\n        label = 23;\n        break;\n       } else {\n        $55 = 4;\n        break;\n       }\n      }\n     }\n     if ($$283$off0) label = 23; else $55 = 4;\n    } while (0);\n    if ((label | 0) == 23) $55 = 3;\n    HEAP32[$19 >> 2] = $55;\n    break;\n   }\n  }\n  if (($3 | 0) == 1) HEAP32[$1 + 32 >> 2] = 1;\n } while (0);\n return;\n}\n\nfunction _arDetectMarker2($0, $1, $2, $3, $4, $5, $6, $7, $8) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = +$6;\n $7 = $7 | 0;\n $8 = $8 | 0;\n var $$0 = 0, $$0127 = 0, $$0128 = 0, $$0131 = 0, $$0132 = 0, $$0133 = 0, $$0134 = 0, $$1 = 0, $$1$in = 0, $$1129 = 0, $$2 = 0, $$2130 = 0, $$3 = 0, $$ph = 0, $$pre136 = 0, $102 = 0, $105 = 0, $108 = 0, $113 = 0, $116 = 0, $122 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $20 = 0, $21 = 0, $24 = 0, $52 = 0, $57 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $67 = 0, $71 = 0.0, $76 = 0.0, $78 = 0.0, $79 = 0, $80 = 0, $81 = 0, $9 = 0, $91 = 0, $96 = 0, $99 = 0, label = 0;\n $9 = ($3 | 0) == 1;\n if ($9) {\n  $$0 = ($0 | 0) / 2 | 0;\n  $$0132 = ($1 | 0) / 2 | 0;\n  $$0133 = ($4 | 0) / 4 | 0;\n  $$0134 = ($5 | 0) / 4 | 0;\n } else {\n  $$0 = $0;\n  $$0132 = $1;\n  $$0133 = $4;\n  $$0134 = $5;\n }\n HEAP32[$8 >> 2] = 0;\n $14 = $2 + 8 | 0;\n $15 = $$0 + -2 | 0;\n $16 = $$0132 + -2 | 0;\n $17 = $2 + 1179664 | 0;\n $$0128 = 0;\n while (1) {\n  if (($$0128 | 0) >= (HEAP32[$14 >> 2] | 0)) {\n   label = 5;\n   break;\n  }\n  $20 = $2 + 12 + ($$0128 << 2) | 0;\n  $21 = HEAP32[$20 >> 2] | 0;\n  if (!(($21 | 0) < ($$0134 | 0) | ($21 | 0) > ($$0133 | 0))) {\n   $24 = $2 + 131084 + ($$0128 << 4) | 0;\n   if ((HEAP32[$24 >> 2] | 0) != 1) if ((HEAP32[$2 + 131084 + ($$0128 << 4) + 4 >> 2] | 0) != ($15 | 0)) if ((HEAP32[$2 + 131084 + ($$0128 << 4) + 8 >> 2] | 0) != 1) if ((HEAP32[$2 + 131084 + ($$0128 << 4) + 12 >> 2] | 0) != ($16 | 0)) if ((_arGetContour(HEAP32[$2 >> 2] | 0, $$0, 0, $17, $$0128 + 1 | 0, $24, $7 + ((HEAP32[$8 >> 2] | 0) * 80048 | 0) | 0) | 0) >= 0) if ((_check_square(HEAP32[$20 >> 2] | 0, $7 + ((HEAP32[$8 >> 2] | 0) * 80048 | 0) | 0, $6) | 0) >= 0) {\n    HEAP32[$7 + ((HEAP32[$8 >> 2] | 0) * 80048 | 0) >> 2] = HEAP32[$20 >> 2];\n    $52 = HEAP32[$8 >> 2] | 0;\n    HEAPF64[$7 + ($52 * 80048 | 0) + 8 >> 3] = +HEAPF64[$2 + 655376 + ($$0128 << 4) >> 3];\n    HEAPF64[$7 + ($52 * 80048 | 0) + 16 >> 3] = +HEAPF64[$2 + 655376 + ($$0128 << 4) + 8 >> 3];\n    $57 = $52 + 1 | 0;\n    HEAP32[$8 >> 2] = $57;\n    if (($57 | 0) == 60) {\n     $$ph = 60;\n     break;\n    }\n   }\n  }\n  $$0128 = $$0128 + 1 | 0;\n }\n if ((label | 0) == 5) $$ph = HEAP32[$8 >> 2] | 0;\n $$1129 = 0;\n $61 = $$ph;\n while (1) {\n  if (($$1129 | 0) >= ($61 | 0)) break;\n  $62 = $$1129 + 1 | 0;\n  $63 = $7 + ($$1129 * 80048 | 0) + 8 | 0;\n  $64 = $7 + ($$1129 * 80048 | 0) + 16 | 0;\n  $65 = $7 + ($$1129 * 80048 | 0) | 0;\n  $$0127 = $62;\n  $67 = $61;\n  while (1) {\n   if (($$0127 | 0) >= ($67 | 0)) break;\n   $71 = +HEAPF64[$63 >> 3] - +HEAPF64[$7 + ($$0127 * 80048 | 0) + 8 >> 3];\n   $76 = +HEAPF64[$64 >> 3] - +HEAPF64[$7 + ($$0127 * 80048 | 0) + 16 >> 3];\n   $78 = $71 * $71 + $76 * $76;\n   $79 = HEAP32[$65 >> 2] | 0;\n   $80 = $7 + ($$0127 * 80048 | 0) | 0;\n   $81 = HEAP32[$80 >> 2] | 0;\n   if (($79 | 0) > ($81 | 0)) {\n    if ($78 < +(($79 | 0) / 4 | 0 | 0)) HEAP32[$80 >> 2] = 0;\n   } else if ($78 < +(($81 | 0) / 4 | 0 | 0)) HEAP32[$65 >> 2] = 0;\n   $$0127 = $$0127 + 1 | 0;\n   $67 = HEAP32[$8 >> 2] | 0;\n  }\n  $$1129 = $62;\n  $61 = $67;\n }\n $$2130 = 0;\n $91 = $61;\n while (1) {\n  if (($$2130 | 0) >= ($91 | 0)) break;\n  if (!(HEAP32[$7 + ($$2130 * 80048 | 0) >> 2] | 0)) {\n   $$1$in = $$2130;\n   $96 = $91;\n   while (1) {\n    $$1 = $$1$in + 1 | 0;\n    if (($$1 | 0) >= ($96 | 0)) break;\n    _memcpy($7 + ($$1$in * 80048 | 0) | 0, $7 + ($$1 * 80048 | 0) | 0, 80048) | 0;\n    $$1$in = $$1;\n    $96 = HEAP32[$8 >> 2] | 0;\n   }\n   $99 = $96 + -1 | 0;\n   HEAP32[$8 >> 2] = $99;\n   $122 = $99;\n  } else $122 = $91;\n  $$2130 = $$2130 + 1 | 0;\n  $91 = $122;\n }\n L44 : do if ($9) {\n  $$0131 = $7;\n  $$3 = 0;\n  $102 = $91;\n  while (1) {\n   if (($$3 | 0) >= ($102 | 0)) break L44;\n   HEAP32[$$0131 >> 2] = HEAP32[$$0131 >> 2] << 2;\n   $105 = $$0131 + 8 | 0;\n   HEAPF64[$105 >> 3] = +HEAPF64[$105 >> 3] * 2.0;\n   $108 = $$0131 + 16 | 0;\n   HEAPF64[$108 >> 3] = +HEAPF64[$108 >> 3] * 2.0;\n   $$pre136 = HEAP32[$$0131 + 24 >> 2] | 0;\n   $$2 = 0;\n   while (1) {\n    if (($$2 | 0) >= ($$pre136 | 0)) break;\n    $113 = $$0131 + 28 + ($$2 << 2) | 0;\n    HEAP32[$113 >> 2] = HEAP32[$113 >> 2] << 1;\n    $116 = $$0131 + 40028 + ($$2 << 2) | 0;\n    HEAP32[$116 >> 2] = HEAP32[$116 >> 2] << 1;\n    $$2 = $$2 + 1 | 0;\n   }\n   $$0131 = $$0131 + 80048 | 0;\n   $$3 = $$3 + 1 | 0;\n   $102 = HEAP32[$8 >> 2] | 0;\n  }\n } while (0);\n return 0;\n}\n\nfunction _arParamLoad($0, $1, $2, $varargs) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $varargs = $varargs | 0;\n var $$05254 = 0, $$053 = 0, $$056 = 0, $$059 = 0, $$1 = 0, $$pre$phi64Z2D = 0, $10 = 0, $12 = 0, $14 = 0, $17 = 0, $19 = 0, $21 = 0, $22 = 0, $25 = 0, $28 = 0, $3 = 0, $30 = 0, $33 = 0, $35 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0.0, $42 = 0, $44 = 0, $51 = 0, $52 = 0, $61 = 0.0, $8 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer15 = 0, $vararg_buffer18 = 0, $vararg_buffer2 = 0, $vararg_buffer6 = 0, $vararg_buffer9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 256 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(256);\n $vararg_buffer18 = sp + 232 | 0;\n $vararg_buffer15 = sp + 224 | 0;\n $vararg_buffer13 = sp + 216 | 0;\n $vararg_buffer9 = sp + 208 | 0;\n $vararg_buffer6 = sp + 200 | 0;\n $vararg_buffer2 = sp + 192 | 0;\n $vararg_buffer = sp + 184 | 0;\n $3 = sp + 240 | 0;\n $4 = sp;\n do if (($0 | 0) != 0 & ($1 | 0) > 0 & ($2 | 0) != 0) {\n  $8 = _fopen($0, 5635) | 0;\n  if (!$8) {\n   $10 = ___errno_location() | 0;\n   HEAP32[$vararg_buffer >> 2] = HEAP32[$10 >> 2];\n   HEAP32[$vararg_buffer + 4 >> 2] = $0;\n   _arLog(0, 3, 4367, $vararg_buffer);\n   $12 = ___errno_location() | 0;\n   $14 = _strerror(HEAP32[$12 >> 2] | 0) | 0;\n   HEAP32[$vararg_buffer2 >> 2] = 19061;\n   HEAP32[$vararg_buffer2 + 4 >> 2] = $14;\n   _arLog(0, 3, 4941, $vararg_buffer2);\n   $$056 = -1;\n   break;\n  }\n  _fseek($8, 0, 2) | 0;\n  L6 : do if (!(_ferror($8) | 0)) {\n   $22 = _ftell($8) | 0;\n   _rewind($8);\n   $$053 = 0;\n   while (1) {\n    if ($$053 >>> 0 >= 4) {\n     label = 9;\n     break;\n    }\n    $25 = HEAP32[1904 + ($$053 << 3) + 4 >> 2] | 0;\n    $28 = $$053 + 1 | 0;\n    if (!(($22 | 0) % ($25 | 0) | 0)) {\n     $$05254 = $28;\n     $30 = $25;\n     break;\n    } else $$053 = $28;\n   }\n   do if ((label | 0) == 9) if (($$053 | 0) == 4) {\n    _arLog(0, 3, 4481, $vararg_buffer13);\n    $$059 = -1;\n    break L6;\n   } else {\n    $$05254 = 0;\n    $30 = HEAP32[1904 + (0 << 3) + 4 >> 2] | 0;\n    break;\n   } while (0);\n   if ((_fread($4, $30, 1, $8) | 0) != 1) {\n    $33 = ___errno_location() | 0;\n    HEAP32[$vararg_buffer15 >> 2] = HEAP32[$33 >> 2];\n    _arLog(0, 3, 4561, $vararg_buffer15);\n    $35 = ___errno_location() | 0;\n    $37 = _strerror(HEAP32[$35 >> 2] | 0) | 0;\n    HEAP32[$vararg_buffer18 >> 2] = 19061;\n    HEAP32[$vararg_buffer18 + 4 >> 2] = $37;\n    _arLog(0, 3, 4941, $vararg_buffer18);\n    $$059 = -1;\n    break;\n   }\n   $38 = $4 + 176 | 0;\n   HEAP32[$38 >> 2] = $$05254;\n   _byteswap($4);\n   $39 = ($$05254 | 0) == 1;\n   $40 = $4 + 120 | 0;\n   if ($39) {\n    $41 = +HEAPF64[$40 >> 3];\n    $42 = $4 + 128 | 0;\n    HEAPF64[$40 >> 3] = +HEAPF64[$42 >> 3];\n    HEAPF64[$42 >> 3] = $41;\n    $$pre$phi64Z2D = $42;\n   } else $$pre$phi64Z2D = $4 + 128 | 0;\n   _memcpy($2 | 0, $4 | 0, 184) | 0;\n   HEAP32[$3 >> 2] = $varargs;\n   $44 = $2 + 176 | 0;\n   $$1 = 1;\n   while (1) {\n    if (($$1 | 0) >= ($1 | 0)) {\n     $$059 = 0;\n     break L6;\n    }\n    $51 = (HEAP32[$3 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n    $52 = HEAP32[$51 >> 2] | 0;\n    HEAP32[$3 >> 2] = $51 + 4;\n    HEAP32[$52 + 176 >> 2] = HEAP32[$44 >> 2];\n    if ((_fread($4, HEAP32[1904 + ((HEAP32[$44 >> 2] | 0) + -1 << 3) + 4 >> 2] | 0, 1, $8) | 0) != 1) {\n     $$059 = -1;\n     break L6;\n    }\n    HEAP32[$38 >> 2] = $$05254;\n    _byteswap($4);\n    if ($39) {\n     $61 = +HEAPF64[$40 >> 3];\n     HEAPF64[$40 >> 3] = +HEAPF64[$$pre$phi64Z2D >> 3];\n     HEAPF64[$$pre$phi64Z2D >> 3] = $61;\n    }\n    _memcpy($52 | 0, $4 | 0, 184) | 0;\n    $$1 = $$1 + 1 | 0;\n   }\n  } else {\n   $17 = ___errno_location() | 0;\n   HEAP32[$vararg_buffer6 >> 2] = HEAP32[$17 >> 2];\n   _arLog(0, 3, 4436, $vararg_buffer6);\n   $19 = ___errno_location() | 0;\n   $21 = _strerror(HEAP32[$19 >> 2] | 0) | 0;\n   HEAP32[$vararg_buffer9 >> 2] = 19061;\n   HEAP32[$vararg_buffer9 + 4 >> 2] = $21;\n   _arLog(0, 3, 4941, $vararg_buffer9);\n   $$059 = -1;\n  } while (0);\n  _fclose($8) | 0;\n  $$056 = $$059;\n } else $$056 = -1; while (0);\n STACKTOP = sp;\n return $$056 | 0;\n}\n\nfunction _minv($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0128 = 0.0, $$0129 = 0, $$0131 = 0, $$0133 = 0, $$0136 = 0, $$0140 = 0, $$0143 = 0, $$1130 = 0, $$1134 = 0, $$1137 = 0, $$1141 = 0, $$1144 = 0, $$2 = 0, $$2135 = 0, $$2138 = 0, $$2142 = 0, $$2145 = 0, $$3 = 0, $$3139 = 0, $$4 = 0, $13 = 0, $15 = 0.0, $16 = 0, $21 = 0, $22 = 0, $23 = 0, $27 = 0.0, $3 = 0, $32 = 0.0, $33 = 0, $40 = 0, $41 = 0.0, $42 = 0, $56 = 0, $65 = 0.0, $indvars$iv = 0, $indvars$iv152 = 0, $scevgep = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 2e3 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(2e3);\n $3 = sp;\n L1 : do if (($1 | 0) > 500) $$0 = 0; else {\n  switch ($1 | 0) {\n  case 0:\n   {\n    $$0 = 0;\n    break L1;\n    break;\n   }\n  case 1:\n   {\n    HEAPF64[$0 >> 3] = 1.0 / +HEAPF64[$0 >> 3];\n    $$0 = $0;\n    break L1;\n    break;\n   }\n  default:\n   {}\n  }\n  $$0133 = 0;\n  while (1) {\n   if (($$0133 | 0) >= ($1 | 0)) break;\n   HEAP32[$3 + ($$0133 << 2) >> 2] = $$0133;\n   $$0133 = $$0133 + 1 | 0;\n  }\n  $scevgep = $0 + ($1 + -1 << 3) | 0;\n  $$1134 = 0;\n  $indvars$iv = $scevgep;\n  while (1) {\n   if (($$1134 | 0) >= ($1 | 0)) break;\n   $13 = $0 + ((Math_imul($$1134, $2) | 0) << 3) | 0;\n   $$0128 = 0.0;\n   $$0129 = $13;\n   $$0131 = -1;\n   $$0140 = $$1134;\n   while (1) {\n    if (($$0140 | 0) == ($1 | 0)) break;\n    $15 = +Math_abs(+(+HEAPF64[$$0129 >> 3]));\n    $16 = $$0128 < $15;\n    $$0128 = $16 ? $15 : $$0128;\n    $$0129 = $$0129 + ($2 << 3) | 0;\n    $$0131 = $16 ? $$0140 : $$0131;\n    $$0140 = $$0140 + 1 | 0;\n   }\n   if (($$0131 | 0) == -1 | $$0128 <= 1.0e-10) {\n    $$0 = 0;\n    break L1;\n   }\n   $21 = $3 + ($$0131 << 2) | 0;\n   $22 = HEAP32[$21 >> 2] | 0;\n   $23 = $3 + ($$1134 << 2) | 0;\n   HEAP32[$21 >> 2] = HEAP32[$23 >> 2];\n   HEAP32[$23 >> 2] = $22;\n   $$0136 = 0;\n   $$0143 = $13;\n   $$1130 = $0 + ((Math_imul($$0131, $2) | 0) << 3) | 0;\n   while (1) {\n    if (($$0136 | 0) == ($1 | 0)) break;\n    $27 = +HEAPF64[$$1130 >> 3];\n    HEAPF64[$$1130 >> 3] = +HEAPF64[$$0143 >> 3];\n    HEAPF64[$$0143 >> 3] = $27;\n    $$0136 = $$0136 + 1 | 0;\n    $$0143 = $$0143 + 8 | 0;\n    $$1130 = $$1130 + 8 | 0;\n   }\n   $32 = +HEAPF64[$13 >> 3];\n   $$1137 = 1;\n   $$2 = $13;\n   while (1) {\n    if (($$1137 | 0) == ($1 | 0)) break;\n    $33 = $$2 + 8 | 0;\n    HEAPF64[$$2 >> 3] = +HEAPF64[$33 >> 3] / $32;\n    $$1137 = $$1137 + 1 | 0;\n    $$2 = $33;\n   }\n   HEAPF64[$indvars$iv >> 3] = 1.0 / $32;\n   $$1141 = 0;\n   $indvars$iv152 = $scevgep;\n   while (1) {\n    if (($$1141 | 0) == ($1 | 0)) break;\n    if (($$1141 | 0) != ($$1134 | 0)) {\n     $40 = $0 + ((Math_imul($$1141, $2) | 0) << 3) | 0;\n     $41 = +HEAPF64[$40 >> 3];\n     $$1144 = $13;\n     $$2138 = 1;\n     $$3 = $40;\n     while (1) {\n      if (($$2138 | 0) == ($1 | 0)) break;\n      $42 = $$3 + 8 | 0;\n      HEAPF64[$$3 >> 3] = +HEAPF64[$42 >> 3] - $41 * +HEAPF64[$$1144 >> 3];\n      $$1144 = $$1144 + 8 | 0;\n      $$2138 = $$2138 + 1 | 0;\n      $$3 = $42;\n     }\n     HEAPF64[$indvars$iv152 >> 3] = -($41 * +HEAPF64[$indvars$iv >> 3]);\n    }\n    $$1141 = $$1141 + 1 | 0;\n    $indvars$iv152 = $indvars$iv152 + ($2 << 3) | 0;\n   }\n   $$1134 = $$1134 + 1 | 0;\n   $indvars$iv = $indvars$iv + ($2 << 3) | 0;\n  }\n  $$2135 = 0;\n  while (1) {\n   if (($$2135 | 0) >= ($1 | 0)) {\n    $$0 = $0;\n    break L1;\n   }\n   $$3139 = $$2135;\n   while (1) {\n    $56 = $3 + ($$3139 << 2) | 0;\n    if (($$3139 | 0) >= ($1 | 0)) break;\n    if ((HEAP32[$56 >> 2] | 0) == ($$2135 | 0)) break;\n    $$3139 = $$3139 + 1 | 0;\n   }\n   HEAP32[$56 >> 2] = HEAP32[$3 + ($$2135 << 2) >> 2];\n   $$2142 = 0;\n   $$2145 = $0 + ($$2135 << 3) | 0;\n   $$4 = $0 + ($$3139 << 3) | 0;\n   while (1) {\n    if (($$2142 | 0) >= ($1 | 0)) break;\n    $65 = +HEAPF64[$$4 >> 3];\n    HEAPF64[$$4 >> 3] = +HEAPF64[$$2145 >> 3];\n    HEAPF64[$$2145 >> 3] = $65;\n    $$2142 = $$2142 + 1 | 0;\n    $$2145 = $$2145 + ($2 << 3) | 0;\n    $$4 = $$4 + ($2 << 3) | 0;\n   }\n   $$2135 = $$2135 + 1 | 0;\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arParamDecompMat($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$0117 = 0, $$1 = 0, $$1118 = 0, $$2 = 0, $$2119 = 0, $$3 = 0, $$3120 = 0, $101 = 0.0, $102 = 0.0, $113 = 0.0, $117 = 0.0, $131 = 0, $22 = 0.0, $24 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0, $29 = 0.0, $3 = 0, $30 = 0, $32 = 0.0, $33 = 0, $35 = 0.0, $36 = 0, $41 = 0, $43 = 0.0, $45 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0, $52 = 0.0, $55 = 0.0, $58 = 0.0, $59 = 0.0, $60 = 0, $62 = 0, $65 = 0, $68 = 0, $72 = 0.0, $74 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0, $82 = 0.0, $83 = 0, $89 = 0.0, $95 = 0.0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 96 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96);\n $3 = sp;\n L1 : do if (!(+HEAPF64[$0 + 88 >> 3] >= 0.0)) {\n  $$1 = 0;\n  while (1) {\n   if (($$1 | 0) == 3) break L1;\n   $$1118 = 0;\n   while (1) {\n    if (($$1118 | 0) == 4) break;\n    HEAPF64[$3 + ($$1 << 5) + ($$1118 << 3) >> 3] = -+HEAPF64[$0 + ($$1 << 5) + ($$1118 << 3) >> 3];\n    $$1118 = $$1118 + 1 | 0;\n   }\n   $$1 = $$1 + 1 | 0;\n  }\n } else {\n  $$0 = 0;\n  while (1) {\n   if (($$0 | 0) == 3) break L1;\n   $$0117 = 0;\n   while (1) {\n    if (($$0117 | 0) == 4) break;\n    HEAPF64[$3 + ($$0 << 5) + ($$0117 << 3) >> 3] = +HEAPF64[$0 + ($$0 << 5) + ($$0117 << 3) >> 3];\n    $$0117 = $$0117 + 1 | 0;\n   }\n   $$0 = $$0 + 1 | 0;\n  }\n } while (0);\n $$2 = 0;\n while (1) {\n  if (($$2 | 0) == 3) break;\n  $$2119 = 0;\n  while (1) {\n   if (($$2119 | 0) == 4) break;\n   HEAPF64[$1 + ($$2 << 5) + ($$2119 << 3) >> 3] = 0.0;\n   $$2119 = $$2119 + 1 | 0;\n  }\n  $$2 = $$2 + 1 | 0;\n }\n $22 = +HEAPF64[$3 + 64 >> 3];\n $24 = +HEAPF64[$3 + 72 >> 3];\n $26 = +HEAPF64[$3 + 80 >> 3];\n $27 = +_norm($22, $24, $26);\n $28 = $1 + 80 | 0;\n HEAPF64[$28 >> 3] = $27;\n $29 = $22 / $27;\n $30 = $2 + 64 | 0;\n HEAPF64[$30 >> 3] = $29;\n $32 = $24 / +HEAPF64[$28 >> 3];\n $33 = $2 + 72 | 0;\n HEAPF64[$33 >> 3] = $32;\n $35 = $26 / +HEAPF64[$28 >> 3];\n $36 = $2 + 80 | 0;\n HEAPF64[$36 >> 3] = $35;\n $41 = $2 + 88 | 0;\n HEAPF64[$41 >> 3] = +HEAPF64[$3 + 88 >> 3] / +HEAPF64[$28 >> 3];\n $43 = +HEAPF64[$3 + 32 >> 3];\n $45 = +HEAPF64[$3 + 40 >> 3];\n $47 = +HEAPF64[$3 + 48 >> 3];\n $48 = +_dot($29, $32, $35, $43, $45, $47);\n $49 = $1 + 48 | 0;\n HEAPF64[$49 >> 3] = $48;\n $52 = $43 - $48 * +HEAPF64[$30 >> 3];\n $55 = $45 - $48 * +HEAPF64[$33 >> 3];\n $58 = $47 - $48 * +HEAPF64[$36 >> 3];\n $59 = +_norm($52, $55, $58);\n $60 = $1 + 40 | 0;\n HEAPF64[$60 >> 3] = $59;\n $62 = $2 + 32 | 0;\n HEAPF64[$62 >> 3] = $52 / $59;\n $65 = $2 + 40 | 0;\n HEAPF64[$65 >> 3] = $55 / +HEAPF64[$60 >> 3];\n $68 = $2 + 48 | 0;\n HEAPF64[$68 >> 3] = $58 / +HEAPF64[$60 >> 3];\n $72 = +HEAPF64[$3 >> 3];\n $74 = +HEAPF64[$3 + 8 >> 3];\n $76 = +HEAPF64[$3 + 16 >> 3];\n $77 = +_dot(+HEAPF64[$30 >> 3], +HEAPF64[$33 >> 3], +HEAPF64[$36 >> 3], $72, $74, $76);\n $78 = $1 + 16 | 0;\n HEAPF64[$78 >> 3] = $77;\n $82 = +_dot(+HEAPF64[$62 >> 3], +HEAPF64[$65 >> 3], +HEAPF64[$68 >> 3], $72, $74, $76);\n $83 = $1 + 8 | 0;\n HEAPF64[$83 >> 3] = $82;\n $89 = $72 - $82 * +HEAPF64[$62 >> 3] - $77 * +HEAPF64[$30 >> 3];\n $95 = $74 - $82 * +HEAPF64[$65 >> 3] - $77 * +HEAPF64[$33 >> 3];\n $101 = $76 - $82 * +HEAPF64[$68 >> 3] - $77 * +HEAPF64[$36 >> 3];\n $102 = +_norm($89, $95, $101);\n HEAPF64[$1 >> 3] = $102;\n HEAPF64[$2 >> 3] = $89 / $102;\n HEAPF64[$2 + 8 >> 3] = $95 / +HEAPF64[$1 >> 3];\n HEAPF64[$2 + 16 >> 3] = $101 / +HEAPF64[$1 >> 3];\n $113 = +HEAPF64[$41 >> 3];\n $117 = (+HEAPF64[$3 + 56 >> 3] - +HEAPF64[$49 >> 3] * $113) / +HEAPF64[$60 >> 3];\n HEAPF64[$2 + 56 >> 3] = $117;\n HEAPF64[$2 + 24 >> 3] = (+HEAPF64[$3 + 24 >> 3] - $117 * +HEAPF64[$83 >> 3] - $113 * +HEAPF64[$78 >> 3]) / +HEAPF64[$1 >> 3];\n $$3 = 0;\n while (1) {\n  if (($$3 | 0) == 3) break;\n  $$3120 = 0;\n  while (1) {\n   if (($$3120 | 0) == 3) break;\n   $131 = $1 + ($$3 << 5) + ($$3120 << 3) | 0;\n   HEAPF64[$131 >> 3] = +HEAPF64[$131 >> 3] / +HEAPF64[$28 >> 3];\n   $$3120 = $$3120 + 1 | 0;\n  }\n  $$3 = $$3 + 1 | 0;\n }\n STACKTOP = sp;\n return 0;\n}\n\nfunction __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i = 0, $$053$i = 0, $$054$i = 0, $$1$i = 0, $$155$i = 0, $$pn$i = 0, $$pre$phi$iZ2D = 0, $11 = 0, $17 = 0, $18 = 0, $2 = 0, $22 = 0, $28 = 0, $3 = 0, $32 = 0, $35 = 0.0, $38 = 0.0, $4 = 0, $48 = 0, $5 = 0, $51 = 0, $53 = 0, $54 = 0, $6 = 0, $62 = 0, $64 = 0, $7 = 0, $70 = 0, $71 = 0, $74 = 0, $75 = 0, $8 = 0, $83 = 0, $87 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp + 4 | 0;\n $3 = sp;\n $4 = sp + 16 | 0;\n HEAP32[$3 >> 2] = $1;\n $5 = HEAP32[$1 >> 2] | 0;\n $6 = $0 + 4 | 0;\n $7 = HEAP32[$6 >> 2] | 0;\n $8 = ($7 | 0) == 0;\n L1 : do if ($8) {\n  $$054$i = 0;\n  label = 16;\n } else {\n  $9 = $7 + -1 | 0;\n  $11 = ($9 & $7 | 0) == 0;\n  if ($11) $17 = $9 & $5; else if ($5 >>> 0 < $7 >>> 0) $17 = $5; else $17 = ($5 >>> 0) % ($7 >>> 0) | 0;\n  $18 = HEAP32[(HEAP32[$0 >> 2] | 0) + ($17 << 2) >> 2] | 0;\n  if (!$18) {\n   $$054$i = $17;\n   label = 16;\n  } else {\n   $$pn$i = $18;\n   while (1) {\n    $$053$i = HEAP32[$$pn$i >> 2] | 0;\n    if (!$$053$i) {\n     $$054$i = $17;\n     label = 16;\n     break L1;\n    }\n    $22 = HEAP32[$$053$i + 4 >> 2] | 0;\n    if (($22 | 0) != ($5 | 0)) {\n     if ($11) $28 = $22 & $9; else if ($22 >>> 0 < $7 >>> 0) $28 = $22; else $28 = ($22 >>> 0) % ($7 >>> 0) | 0;\n     if (($28 | 0) != ($17 | 0)) {\n      $$054$i = $17;\n      label = 16;\n      break L1;\n     }\n    }\n    if ((HEAP32[$$053$i + 8 >> 2] | 0) == ($5 | 0)) {\n     $$1$i = $$053$i;\n     break;\n    } else $$pn$i = $$053$i;\n   }\n  }\n } while (0);\n if ((label | 0) == 16) {\n  __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE21__construct_node_hashIRKNS_21piecewise_construct_tEJNS_5tupleIJRKiEEENSJ_IJEEEEEENS_10unique_ptrINS_11__hash_nodeIS3_PvEENS_22__hash_node_destructorINSC_ISR_EEEEEEjOT_DpOT0_($2, $0, $5, 18020, $3, $4);\n  $32 = $0 + 12 | 0;\n  $35 = +(((HEAP32[$32 >> 2] | 0) + 1 | 0) >>> 0);\n  $38 = +HEAPF32[$0 + 16 >> 2];\n  do if ($8 | $38 * +($7 >>> 0) < $35) {\n   $48 = $7 << 1 | ($7 >>> 0 < 3 | ($7 + -1 & $7 | 0) != 0) & 1;\n   $51 = ~~+Math_ceil(+($35 / $38)) >>> 0;\n   __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE6rehashEj($0, $48 >>> 0 < $51 >>> 0 ? $51 : $48);\n   $53 = HEAP32[$6 >> 2] | 0;\n   $54 = $53 + -1 | 0;\n   if (!($54 & $53)) {\n    $$0$i = $53;\n    $$155$i = $54 & $5;\n    break;\n   }\n   if ($5 >>> 0 < $53 >>> 0) {\n    $$0$i = $53;\n    $$155$i = $5;\n   } else {\n    $$0$i = $53;\n    $$155$i = ($5 >>> 0) % ($53 >>> 0) | 0;\n   }\n  } else {\n   $$0$i = $7;\n   $$155$i = $$054$i;\n  } while (0);\n  $62 = HEAP32[(HEAP32[$0 >> 2] | 0) + ($$155$i << 2) >> 2] | 0;\n  if (!$62) {\n   $64 = $0 + 8 | 0;\n   HEAP32[HEAP32[$2 >> 2] >> 2] = HEAP32[$64 >> 2];\n   HEAP32[$64 >> 2] = HEAP32[$2 >> 2];\n   HEAP32[(HEAP32[$0 >> 2] | 0) + ($$155$i << 2) >> 2] = $64;\n   $70 = HEAP32[$2 >> 2] | 0;\n   $71 = HEAP32[$70 >> 2] | 0;\n   if (!$71) $$pre$phi$iZ2D = $2; else {\n    $74 = HEAP32[$71 + 4 >> 2] | 0;\n    $75 = $$0$i + -1 | 0;\n    if (!($75 & $$0$i)) $83 = $74 & $75; else if ($74 >>> 0 < $$0$i >>> 0) $83 = $74; else $83 = ($74 >>> 0) % ($$0$i >>> 0) | 0;\n    HEAP32[(HEAP32[$0 >> 2] | 0) + ($83 << 2) >> 2] = $70;\n    $$pre$phi$iZ2D = $2;\n   }\n  } else {\n   HEAP32[HEAP32[$2 >> 2] >> 2] = HEAP32[$62 >> 2];\n   HEAP32[$62 >> 2] = HEAP32[$2 >> 2];\n   $$pre$phi$iZ2D = $2;\n  }\n  $87 = HEAP32[$$pre$phi$iZ2D >> 2] | 0;\n  HEAP32[$32 >> 2] = (HEAP32[$32 >> 2] | 0) + 1;\n  HEAP32[$$pre$phi$iZ2D >> 2] = 0;\n  $$1$i = $87;\n }\n STACKTOP = sp;\n return $$1$i + 16 | 0;\n}\n\nfunction __ZNSt3__213unordered_mapIi7ARParamNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i = 0, $$053$i = 0, $$054$i = 0, $$1$i = 0, $$155$i = 0, $$pn$i = 0, $$pre$phi$iZ2D = 0, $11 = 0, $17 = 0, $18 = 0, $2 = 0, $22 = 0, $28 = 0, $3 = 0, $32 = 0, $35 = 0.0, $38 = 0.0, $4 = 0, $48 = 0, $5 = 0, $51 = 0, $53 = 0, $54 = 0, $6 = 0, $62 = 0, $64 = 0, $7 = 0, $70 = 0, $71 = 0, $74 = 0, $75 = 0, $8 = 0, $83 = 0, $87 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp + 4 | 0;\n $3 = sp;\n $4 = sp + 16 | 0;\n HEAP32[$3 >> 2] = $1;\n $5 = HEAP32[$1 >> 2] | 0;\n $6 = $0 + 4 | 0;\n $7 = HEAP32[$6 >> 2] | 0;\n $8 = ($7 | 0) == 0;\n L1 : do if ($8) {\n  $$054$i = 0;\n  label = 16;\n } else {\n  $9 = $7 + -1 | 0;\n  $11 = ($9 & $7 | 0) == 0;\n  if ($11) $17 = $9 & $5; else if ($5 >>> 0 < $7 >>> 0) $17 = $5; else $17 = ($5 >>> 0) % ($7 >>> 0) | 0;\n  $18 = HEAP32[(HEAP32[$0 >> 2] | 0) + ($17 << 2) >> 2] | 0;\n  if (!$18) {\n   $$054$i = $17;\n   label = 16;\n  } else {\n   $$pn$i = $18;\n   while (1) {\n    $$053$i = HEAP32[$$pn$i >> 2] | 0;\n    if (!$$053$i) {\n     $$054$i = $17;\n     label = 16;\n     break L1;\n    }\n    $22 = HEAP32[$$053$i + 4 >> 2] | 0;\n    if (($22 | 0) != ($5 | 0)) {\n     if ($11) $28 = $22 & $9; else if ($22 >>> 0 < $7 >>> 0) $28 = $22; else $28 = ($22 >>> 0) % ($7 >>> 0) | 0;\n     if (($28 | 0) != ($17 | 0)) {\n      $$054$i = $17;\n      label = 16;\n      break L1;\n     }\n    }\n    if ((HEAP32[$$053$i + 8 >> 2] | 0) == ($5 | 0)) {\n     $$1$i = $$053$i;\n     break;\n    } else $$pn$i = $$053$i;\n   }\n  }\n } while (0);\n if ((label | 0) == 16) {\n  __ZNSt3__212__hash_tableINS_17__hash_value_typeIi7ARParamEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE21__construct_node_hashIRKNS_21piecewise_construct_tEJNS_5tupleIJRKiEEENSJ_IJEEEEEENS_10unique_ptrINS_11__hash_nodeIS3_PvEENS_22__hash_node_destructorINSC_ISR_EEEEEEjOT_DpOT0_($2, $0, $5, 18020, $3, $4);\n  $32 = $0 + 12 | 0;\n  $35 = +(((HEAP32[$32 >> 2] | 0) + 1 | 0) >>> 0);\n  $38 = +HEAPF32[$0 + 16 >> 2];\n  do if ($8 | $38 * +($7 >>> 0) < $35) {\n   $48 = $7 << 1 | ($7 >>> 0 < 3 | ($7 + -1 & $7 | 0) != 0) & 1;\n   $51 = ~~+Math_ceil(+($35 / $38)) >>> 0;\n   __ZNSt3__212__hash_tableINS_17__hash_value_typeIi7ARParamEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE6rehashEj($0, $48 >>> 0 < $51 >>> 0 ? $51 : $48);\n   $53 = HEAP32[$6 >> 2] | 0;\n   $54 = $53 + -1 | 0;\n   if (!($54 & $53)) {\n    $$0$i = $53;\n    $$155$i = $54 & $5;\n    break;\n   }\n   if ($5 >>> 0 < $53 >>> 0) {\n    $$0$i = $53;\n    $$155$i = $5;\n   } else {\n    $$0$i = $53;\n    $$155$i = ($5 >>> 0) % ($53 >>> 0) | 0;\n   }\n  } else {\n   $$0$i = $7;\n   $$155$i = $$054$i;\n  } while (0);\n  $62 = HEAP32[(HEAP32[$0 >> 2] | 0) + ($$155$i << 2) >> 2] | 0;\n  if (!$62) {\n   $64 = $0 + 8 | 0;\n   HEAP32[HEAP32[$2 >> 2] >> 2] = HEAP32[$64 >> 2];\n   HEAP32[$64 >> 2] = HEAP32[$2 >> 2];\n   HEAP32[(HEAP32[$0 >> 2] | 0) + ($$155$i << 2) >> 2] = $64;\n   $70 = HEAP32[$2 >> 2] | 0;\n   $71 = HEAP32[$70 >> 2] | 0;\n   if (!$71) $$pre$phi$iZ2D = $2; else {\n    $74 = HEAP32[$71 + 4 >> 2] | 0;\n    $75 = $$0$i + -1 | 0;\n    if (!($75 & $$0$i)) $83 = $74 & $75; else if ($74 >>> 0 < $$0$i >>> 0) $83 = $74; else $83 = ($74 >>> 0) % ($$0$i >>> 0) | 0;\n    HEAP32[(HEAP32[$0 >> 2] | 0) + ($83 << 2) >> 2] = $70;\n    $$pre$phi$iZ2D = $2;\n   }\n  } else {\n   HEAP32[HEAP32[$2 >> 2] >> 2] = HEAP32[$62 >> 2];\n   HEAP32[$62 >> 2] = HEAP32[$2 >> 2];\n   $$pre$phi$iZ2D = $2;\n  }\n  $87 = HEAP32[$$pre$phi$iZ2D >> 2] | 0;\n  HEAP32[$32 >> 2] = (HEAP32[$32 >> 2] | 0) + 1;\n  HEAP32[$$pre$phi$iZ2D >> 2] = 0;\n  $$1$i = $87;\n }\n STACKTOP = sp;\n return $$1$i + 16 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_126parse_base_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$add$i69 = 0, $$0$i$i$idx$i = 0, $$0$i$i$idx$i68 = 0, $$2 = 0, $13 = 0, $14 = 0, $16 = 0, $18 = 0, $19 = 0, $26 = 0, $3 = 0, $31 = 0, $32 = 0, $39 = 0, $41 = 0, $43 = 0, $45 = 0, $47 = 0, $48 = 0, $55 = 0, $60 = 0, $61 = 0, $8 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n L1 : do if (($1 - $0 | 0) > 1) {\n  $8 = HEAP8[$0 >> 0] | 0;\n  switch ($8 << 24 >> 24) {\n  case 100:\n  case 111:\n   {\n    if ((HEAP8[$0 + 1 >> 0] | 0) == 110) {\n     $13 = $0 + 2 | 0;\n     if ($8 << 24 >> 24 != 111) {\n      $39 = __ZN10__cxxabiv112_GLOBAL__N_121parse_destructor_nameINS0_2DbEEEPKcS4_S4_RT_($13, $1, $2) | 0;\n      $$2 = ($39 | 0) == ($13 | 0) ? $0 : $39;\n      break L1;\n     }\n     $14 = __ZN10__cxxabiv112_GLOBAL__N_119parse_operator_nameINS0_2DbEEEPKcS4_S4_RT_($13, $1, $2) | 0;\n     if (($14 | 0) == ($13 | 0)) {\n      $$2 = $0;\n      break L1;\n     }\n     $16 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($14, $1, $2) | 0;\n     if (($16 | 0) == ($14 | 0)) {\n      $$2 = $14;\n      break L1;\n     }\n     $18 = $2 + 4 | 0;\n     $19 = HEAP32[$18 >> 2] | 0;\n     if ((($19 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) {\n      $$2 = $16;\n      break L1;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $19 + -24 | 0);\n     $26 = HEAP32[$18 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($26 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$18 >> 2] = $26 + -24;\n     $31 = HEAP8[$3 + 11 >> 0] | 0;\n     $32 = $31 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($26 + -48 | 0, $32 ? HEAP32[$3 >> 2] | 0 : $3, $32 ? HEAP32[$3 + 4 >> 2] | 0 : $31 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$2 = $16;\n     break L1;\n    }\n    break;\n   }\n  default:\n   {}\n  }\n  $41 = __ZN10__cxxabiv112_GLOBAL__N_115parse_simple_idINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n  if (($41 | 0) == ($0 | 0)) {\n   $43 = __ZN10__cxxabiv112_GLOBAL__N_119parse_operator_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   if (($43 | 0) == ($0 | 0)) $$2 = $0; else {\n    $45 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($43, $1, $2) | 0;\n    if (($45 | 0) == ($43 | 0)) $$2 = $43; else {\n     $47 = $2 + 4 | 0;\n     $48 = HEAP32[$47 >> 2] | 0;\n     if ((($48 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$2 = $45; else {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $48 + -24 | 0);\n      $55 = HEAP32[$47 >> 2] | 0;\n      $$0$i$i$idx$i68 = 0;\n      while (1) {\n       if (($$0$i$i$idx$i68 | 0) == -1) break;\n       $$0$i$i$add$i69 = $$0$i$i$idx$i68 + -1 | 0;\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($55 + ($$0$i$i$add$i69 * 24 | 0) | 0);\n       $$0$i$i$idx$i68 = $$0$i$i$add$i69;\n      }\n      HEAP32[$47 >> 2] = $55 + -24;\n      $60 = HEAP8[$3 + 11 >> 0] | 0;\n      $61 = $60 << 24 >> 24 < 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($55 + -48 | 0, $61 ? HEAP32[$3 >> 2] | 0 : $3, $61 ? HEAP32[$3 + 4 >> 2] | 0 : $60 & 255) | 0;\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n      $$2 = $45;\n     }\n    }\n   }\n  } else $$2 = $41;\n } else $$2 = $0; while (0);\n STACKTOP = sp;\n return $$2 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_117parse_source_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i = 0, $$0$i$i = 0, $$038 = 0, $$040$in = 0, $$3 = 0, $12 = 0, $20 = 0, $22 = 0, $3 = 0, $31 = 0, $32 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $9 = 0, $isdigittmp = 0, $isdigittmp47 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 40 | 0;\n $4 = sp + 16 | 0;\n $5 = sp;\n L1 : do if (($0 | 0) == ($1 | 0)) $$3 = $0; else {\n  $isdigittmp = (HEAP8[$0 >> 0] | 0) + -48 | 0;\n  if ($isdigittmp >>> 0 < 10) {\n   $9 = $0 + 1 | 0;\n   if (($9 | 0) == ($1 | 0)) $$3 = $0; else {\n    $$038 = $isdigittmp;\n    $$040$in = $9;\n    while (1) {\n     $isdigittmp47 = (HEAP8[$$040$in >> 0] | 0) + -48 | 0;\n     if ($isdigittmp47 >>> 0 >= 10) break;\n     $12 = $$040$in + 1 | 0;\n     if (($12 | 0) == ($1 | 0)) {\n      $$3 = $0;\n      break L1;\n     }\n     $$038 = $isdigittmp47 + ($$038 * 10 | 0) | 0;\n     $$040$in = $12;\n    }\n    if (($1 - $$040$in | 0) >>> 0 < $$038 >>> 0) $$3 = $0; else {\n     HEAP32[$3 >> 2] = 0;\n     HEAP32[$3 + 4 >> 2] = 0;\n     HEAP32[$3 + 8 >> 2] = 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($3, $$040$in, $$038);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($4, $3, 10);\n     $20 = __ZNSt3__211char_traitsIcE6lengthEPKc(16499) | 0;\n     $22 = HEAP8[$4 + 11 >> 0] | 0;\n     if (($20 | 0) == (($22 << 24 >> 24 < 0 ? HEAP32[$4 + 4 >> 2] | 0 : $22 & 255) | 0)) $$0$i = (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($4, 16499, $20) | 0) == 0; else $$0$i = 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     if ($$0$i) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj22EEERAT__Kc($4);\n      $31 = $2 + 4 | 0;\n      $32 = HEAP32[$31 >> 2] | 0;\n      if ($32 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($32, $4);\n       HEAP32[$31 >> 2] = (HEAP32[$31 >> 2] | 0) + 24;\n      } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $4);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n     } else {\n      HEAP32[$5 >> 2] = HEAP32[$3 >> 2];\n      HEAP32[$5 + 4 >> 2] = HEAP32[$3 + 4 >> 2];\n      HEAP32[$5 + 8 >> 2] = HEAP32[$3 + 8 >> 2];\n      $$0$i$i = 0;\n      while (1) {\n       if (($$0$i$i | 0) == 3) break;\n       HEAP32[$3 + ($$0$i$i << 2) >> 2] = 0;\n       $$0$i$i = $$0$i$i + 1 | 0;\n      }\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $5);\n      $40 = $2 + 4 | 0;\n      $41 = HEAP32[$40 >> 2] | 0;\n      if ($41 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n       __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($41, $4);\n       HEAP32[$40 >> 2] = (HEAP32[$40 >> 2] | 0) + 24;\n      } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $4);\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n      __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$3 = $$040$in + $$038 | 0;\n    }\n   }\n  } else $$3 = $0;\n } while (0);\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_121parse_integer_literalINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0$i$i$i = 0, $$025 = 0, $$1 = 0, $12 = 0, $13 = 0, $15 = 0, $23 = 0, $24 = 0, $30 = 0, $31 = 0, $39 = 0, $4 = 0, $45 = 0, $46 = 0, $49 = 0, $5 = 0, $6 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $4 = sp + 24 | 0;\n $5 = sp;\n $6 = sp + 12 | 0;\n $7 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($0, $1) | 0;\n if (($7 | 0) == ($0 | 0) | ($7 | 0) == ($1 | 0)) $$1 = $0; else if ((HEAP8[$7 >> 0] | 0) == 69) {\n  $12 = $2 + 11 | 0;\n  $13 = HEAP8[$12 >> 0] | 0;\n  $15 = $2 + 4 | 0;\n  do if (($13 << 24 >> 24 < 0 ? HEAP32[$15 >> 2] | 0 : $13 & 255) >>> 0 > 3) {\n   __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($6, 15119, $2);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15117) | 0;\n   HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n   HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n   HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n   $$0$i$i$i = 0;\n   while (1) {\n    if (($$0$i$i$i | 0) == 3) break;\n    HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n    $$0$i$i$i = $$0$i$i$i + 1 | 0;\n   }\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($4, $5);\n   $23 = $3 + 4 | 0;\n   $24 = HEAP32[$23 >> 2] | 0;\n   if ($24 >>> 0 < (HEAP32[$3 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($24, $4);\n    HEAP32[$23 >> 2] = (HEAP32[$23 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($3, $4);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($4);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n  } else {\n   $30 = $3 + 4 | 0;\n   $31 = HEAP32[$30 >> 2] | 0;\n   if ($31 >>> 0 < (HEAP32[$3 + 8 >> 2] | 0) >>> 0) {\n    HEAP32[$31 >> 2] = 0;\n    HEAP32[$31 + 4 >> 2] = 0;\n    HEAP32[$31 + 8 >> 2] = 0;\n    HEAP32[$31 + 12 >> 2] = 0;\n    HEAP32[$31 + 16 >> 2] = 0;\n    HEAP32[$31 + 20 >> 2] = 0;\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2Ev($31);\n    HEAP32[$30 >> 2] = (HEAP32[$30 >> 2] | 0) + 24;\n    break;\n   } else {\n    __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE24__emplace_back_slow_pathIJEEEvDpOT_($3);\n    break;\n   }\n  } while (0);\n  $39 = $3 + 4 | 0;\n  if ((HEAP8[$0 >> 0] | 0) == 110) {\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9push_backEc((HEAP32[$39 >> 2] | 0) + -24 | 0, 45);\n   $$025 = $0 + 1 | 0;\n  } else $$025 = $0;\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE23__append_forward_unsafeIPKcEERS7_T_SC_((HEAP32[$39 >> 2] | 0) + -24 | 0, $$025, $7);\n  $45 = HEAP8[$12 >> 0] | 0;\n  $46 = $45 << 24 >> 24 < 0;\n  $49 = $46 ? HEAP32[$15 >> 2] | 0 : $45 & 255;\n  if ($49 >>> 0 < 4) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$39 >> 2] | 0) + -24 | 0, $46 ? HEAP32[$2 >> 2] | 0 : $2, $49) | 0;\n  $$1 = $7 + 1 | 0;\n } else $$1 = $0;\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertIPKcEENS_9enable_ifIXaasr21__is_forward_iteratorIT_EE5valuesr38__libcpp_string_gets_noexcept_iteratorISC_EE5valueENS_11__wrap_iterIPcEEE4typeENSD_ISA_EESC_SC_($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$059 = 0, $$1 = 0, $$byval_copy = 0, $$sroa$0$1 = 0, $11 = 0, $12 = 0, $13 = 0, $16 = 0, $23 = 0, $24 = 0, $27 = 0, $28 = 0, $33 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $46 = 0, $47 = 0, $5 = 0, $50 = 0, $52 = 0, $53 = 0, $58 = 0, $6 = 0, $69 = 0, $7 = 0, $72 = 0, $8 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $$byval_copy = sp + 16 | 0;\n $4 = sp + 4 | 0;\n $5 = sp;\n $6 = $0 + 11 | 0;\n $7 = HEAP8[$6 >> 0] | 0;\n $8 = $7 << 24 >> 24 < 0;\n if ($8) $11 = HEAP32[$0 >> 2] | 0; else $11 = $0;\n $12 = HEAP32[$1 >> 2] | 0;\n $13 = $12 - $11 | 0;\n $16 = $3 - $2 | 0;\n do if (!$16) {\n  $69 = $7;\n  label = 27;\n } else {\n  if ($8) {\n   $23 = HEAP32[$0 >> 2] | 0;\n   $24 = HEAP32[$0 + 4 >> 2] | 0;\n  } else {\n   $23 = $0;\n   $24 = $7 & 255;\n  }\n  if (__ZNSt3__214__ptr_in_rangeIcEEbPKT_S3_S3_($2, $23, $23 + $24 | 0) | 0) {\n   HEAP32[$4 >> 2] = 0;\n   HEAP32[$4 + 4 >> 2] = 0;\n   HEAP32[$4 + 8 >> 2] = 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($4, $2, $3);\n   HEAP32[$5 >> 2] = $12;\n   $27 = HEAP8[$4 + 11 >> 0] | 0;\n   $28 = $27 << 24 >> 24 < 0;\n   $33 = $28 ? HEAP32[$4 >> 2] | 0 : $4;\n   $35 = $33 + ($28 ? HEAP32[$4 + 4 >> 2] | 0 : $27 & 255) | 0;\n   HEAP32[$$byval_copy >> 2] = HEAP32[$5 >> 2];\n   $36 = __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertIPKcEENS_9enable_ifIXaasr21__is_forward_iteratorIT_EE5valuesr38__libcpp_string_gets_noexcept_iteratorISC_EE5valueENS_11__wrap_iterIPcEEE4typeENSD_ISA_EESC_SC_($0, $$byval_copy, $33, $35) | 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n   $$sroa$0$1 = $36;\n   break;\n  }\n  $37 = HEAP8[$6 >> 0] | 0;\n  $38 = $37 << 24 >> 24 < 0;\n  if ($38) {\n   $46 = (HEAP32[$0 + 8 >> 2] & 2147483647) + -1 | 0;\n   $47 = HEAP32[$0 + 4 >> 2] | 0;\n  } else {\n   $46 = 10;\n   $47 = $37 & 255;\n  }\n  if (($46 - $47 | 0) >>> 0 < $16 >>> 0) {\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9__grow_byEjjjjjj($0, $46, $47 + $16 - $46 | 0, $47, $13, $16);\n   $$0 = HEAP32[$0 >> 2] | 0;\n  } else {\n   if ($38) $53 = HEAP32[$0 >> 2] | 0; else $53 = $0;\n   $50 = $47 - $13 | 0;\n   if (!$50) $$0 = $53; else {\n    $52 = $53 + $13 | 0;\n    __ZNSt3__211char_traitsIcE4moveEPcPKcj($52 + $16 | 0, $52, $50) | 0;\n    $$0 = $53;\n   }\n  }\n  $58 = $47 + $16 | 0;\n  if ((HEAP8[$6 >> 0] | 0) < 0) HEAP32[$0 + 4 >> 2] = $58; else HEAP8[$6 >> 0] = $58;\n  HEAP8[$$byval_copy >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($$0 + $58 | 0, $$byval_copy);\n  $$059 = $2;\n  $$1 = $$0 + $13 | 0;\n  while (1) {\n   if (($$059 | 0) == ($3 | 0)) break;\n   __ZNSt3__211char_traitsIcE6assignERcRKc($$1, $$059);\n   $$059 = $$059 + 1 | 0;\n   $$1 = $$1 + 1 | 0;\n  }\n  $69 = HEAP8[$6 >> 0] | 0;\n  label = 27;\n } while (0);\n if ((label | 0) == 27) {\n  if ($69 << 24 >> 24 < 0) $72 = HEAP32[$0 >> 2] | 0; else $72 = $0;\n  $$sroa$0$1 = $72 + $13 | 0;\n }\n STACKTOP = sp;\n return $$sroa$0$1 | 0;\n}\n\nfunction _icpGetJ_Xc_S($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$0108 = 0, $$0109 = 0, $104 = 0.0, $11 = 0, $111 = 0.0, $118 = 0.0, $12 = 0.0, $128 = 0, $134 = 0.0, $135 = 0.0, $15 = 0, $17 = 0, $18 = 0.0, $24 = 0, $26 = 0.0, $28 = 0, $32 = 0, $4 = 0, $40 = 0, $43 = 0, $45 = 0.0, $48 = 0, $5 = 0, $56 = 0.0, $60 = 0.0, $63 = 0.0, $70 = 0.0, $80 = 0.0, $87 = 0.0, $9 = 0, $94 = 0.0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 864 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(864);\n $4 = sp + 576 | 0;\n $5 = sp;\n $9 = $2 + 8 | 0;\n $11 = $3 + 8 | 0;\n $12 = +HEAPF64[$11 >> 3];\n $15 = $2 + 16 | 0;\n $17 = $3 + 16 | 0;\n $18 = +HEAPF64[$17 >> 3];\n HEAPF64[$1 >> 3] = +HEAPF64[$2 + 24 >> 3] + (+HEAPF64[$2 >> 3] * +HEAPF64[$3 >> 3] + +HEAPF64[$9 >> 3] * $12 + +HEAPF64[$15 >> 3] * $18);\n $24 = $2 + 32 | 0;\n $26 = +HEAPF64[$3 >> 3];\n $28 = $2 + 40 | 0;\n $32 = $2 + 48 | 0;\n HEAPF64[$1 + 8 >> 3] = +HEAPF64[$2 + 56 >> 3] + (+HEAPF64[$24 >> 3] * $26 + $12 * +HEAPF64[$28 >> 3] + $18 * +HEAPF64[$32 >> 3]);\n $40 = $2 + 64 | 0;\n $43 = $2 + 72 | 0;\n $45 = +HEAPF64[$11 >> 3];\n $48 = $2 + 80 | 0;\n HEAPF64[$1 + 16 >> 3] = +HEAPF64[$2 + 88 >> 3] + ($26 * +HEAPF64[$40 >> 3] + +HEAPF64[$43 >> 3] * $45 + $18 * +HEAPF64[$48 >> 3]);\n $56 = +HEAPF64[$2 >> 3];\n HEAPF64[$4 >> 3] = $26 * $56;\n HEAPF64[$4 + 8 >> 3] = $45 * $56;\n $60 = +HEAPF64[$17 >> 3];\n HEAPF64[$4 + 16 >> 3] = $56 * $60;\n $63 = +HEAPF64[$9 >> 3];\n HEAPF64[$4 + 24 >> 3] = $26 * $63;\n HEAPF64[$4 + 32 >> 3] = $45 * $63;\n HEAPF64[$4 + 40 >> 3] = $60 * $63;\n $70 = +HEAPF64[$15 >> 3];\n HEAPF64[$4 + 48 >> 3] = $26 * $70;\n HEAPF64[$4 + 56 >> 3] = $45 * $70;\n HEAPF64[$4 + 64 >> 3] = $60 * $70;\n HEAPF64[$4 + 72 >> 3] = $56;\n HEAPF64[$4 + 80 >> 3] = $63;\n HEAPF64[$4 + 88 >> 3] = $70;\n $80 = +HEAPF64[$24 >> 3];\n HEAPF64[$4 + 96 >> 3] = $26 * $80;\n HEAPF64[$4 + 104 >> 3] = $45 * $80;\n HEAPF64[$4 + 112 >> 3] = $60 * $80;\n $87 = +HEAPF64[$28 >> 3];\n HEAPF64[$4 + 120 >> 3] = $26 * $87;\n HEAPF64[$4 + 128 >> 3] = $45 * $87;\n HEAPF64[$4 + 136 >> 3] = $60 * $87;\n $94 = +HEAPF64[$32 >> 3];\n HEAPF64[$4 + 144 >> 3] = $26 * $94;\n HEAPF64[$4 + 152 >> 3] = $45 * $94;\n HEAPF64[$4 + 160 >> 3] = $60 * $94;\n HEAPF64[$4 + 168 >> 3] = $80;\n HEAPF64[$4 + 176 >> 3] = $87;\n HEAPF64[$4 + 184 >> 3] = $94;\n $104 = +HEAPF64[$40 >> 3];\n HEAPF64[$4 + 192 >> 3] = $26 * $104;\n HEAPF64[$4 + 200 >> 3] = $45 * $104;\n HEAPF64[$4 + 208 >> 3] = $60 * $104;\n $111 = +HEAPF64[$43 >> 3];\n HEAPF64[$4 + 216 >> 3] = $26 * $111;\n HEAPF64[$4 + 224 >> 3] = $45 * $111;\n HEAPF64[$4 + 232 >> 3] = $60 * $111;\n $118 = +HEAPF64[$48 >> 3];\n HEAPF64[$4 + 240 >> 3] = $26 * $118;\n HEAPF64[$4 + 248 >> 3] = $45 * $118;\n HEAPF64[$4 + 256 >> 3] = $60 * $118;\n HEAPF64[$4 + 264 >> 3] = $104;\n HEAPF64[$4 + 272 >> 3] = $111;\n HEAPF64[$4 + 280 >> 3] = $118;\n _icpGetJ_T_S($5);\n $$0108 = 0;\n while (1) {\n  if (($$0108 | 0) == 3) break;\n  $$0109 = 0;\n  while (1) {\n   if (($$0109 | 0) == 6) break;\n   $128 = $0 + ($$0108 * 48 | 0) + ($$0109 << 3) | 0;\n   HEAPF64[$128 >> 3] = 0.0;\n   $$0 = 0;\n   $135 = 0.0;\n   while (1) {\n    if (($$0 | 0) == 12) break;\n    $134 = $135 + +HEAPF64[$4 + ($$0108 * 96 | 0) + ($$0 << 3) >> 3] * +HEAPF64[$5 + ($$0 * 48 | 0) + ($$0109 << 3) >> 3];\n    HEAPF64[$128 >> 3] = $134;\n    $$0 = $$0 + 1 | 0;\n    $135 = $134;\n   }\n   $$0109 = $$0109 + 1 | 0;\n  }\n  $$0108 = $$0108 + 1 | 0;\n }\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_120parse_ctor_dtor_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$023 = 0, $12 = 0, $13 = 0, $21 = 0, $3 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 40 | 0;\n $4 = sp + 24 | 0;\n $5 = sp;\n $6 = sp + 12 | 0;\n L1 : do if (($1 - $0 | 0) > 1) {\n  $12 = $2 + 4 | 0;\n  $13 = HEAP32[$12 >> 2] | 0;\n  if ((HEAP32[$2 >> 2] | 0) == ($13 | 0)) $$023 = $0; else {\n   switch (HEAP8[$0 >> 0] | 0) {\n   case 67:\n    {\n     switch (HEAP8[$0 + 1 >> 0] | 0) {\n     case 53:\n     case 51:\n     case 50:\n     case 49:\n      break;\n     default:\n      {\n       $$023 = $0;\n       break L1;\n      }\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_19base_nameINSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEEEET_RS9_($4, $13 + -24 | 0);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $4);\n     $21 = HEAP32[$12 >> 2] | 0;\n     if ($21 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($21, $3);\n      HEAP32[$12 >> 2] = (HEAP32[$12 >> 2] | 0) + 24;\n     } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     HEAP8[$2 + 60 >> 0] = 1;\n     $$023 = $0 + 2 | 0;\n     break L1;\n     break;\n    }\n   case 68:\n    break;\n   default:\n    {\n     $$023 = $0;\n     break L1;\n    }\n   }\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 53:\n   case 50:\n   case 49:\n   case 48:\n    break;\n   default:\n    {\n     $$023 = $0;\n     break L1;\n    }\n   }\n   __ZN10__cxxabiv112_GLOBAL__N_19base_nameINSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEEEET_RS9_($6, $13 + -24 | 0);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 15189) | 0;\n   HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n   HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n   HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n   $$0$i$i$i = 0;\n   while (1) {\n    if (($$0$i$i$i | 0) == 3) break;\n    HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n    $$0$i$i$i = $$0$i$i$i + 1 | 0;\n   }\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $5);\n   $36 = HEAP32[$12 >> 2] | 0;\n   if ($36 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($36, $3);\n    HEAP32[$12 >> 2] = (HEAP32[$12 >> 2] | 0) + 24;\n   } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $3);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n   HEAP8[$2 + 60 >> 0] = 1;\n   $$023 = $0 + 2 | 0;\n  }\n } else $$023 = $0; while (0);\n STACKTOP = sp;\n return $$023 | 0;\n}\n\nfunction _icpPoint($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $$088 = 0, $$090 = 0.0, $$091 = 0.0, $$092 = 0, $$1 = 0, $$189 = 0, $$2 = 0, $12 = 0, $15 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $34 = 0, $38 = 0.0, $42 = 0.0, $47 = 0, $5 = 0, $53 = 0.0, $6 = 0, $65 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 176 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(176);\n $vararg_buffer1 = sp + 168 | 0;\n $vararg_buffer = sp + 160 | 0;\n $5 = sp + 144 | 0;\n $6 = sp + 48 | 0;\n $7 = sp;\n $8 = $1 + 8 | 0;\n $9 = HEAP32[$8 >> 2] | 0;\n do if (($9 | 0) < 3) $$092 = -1; else {\n  $12 = _malloc($9 * 96 | 0) | 0;\n  if (!$12) {\n   _arLog(0, 3, 4689, $vararg_buffer);\n   $$092 = -1;\n   break;\n  }\n  $15 = _malloc($9 << 4) | 0;\n  if (!$15) {\n   _arLog(0, 3, 4689, $vararg_buffer1);\n   _free($12);\n   $$092 = -1;\n   break;\n  }\n  $$0 = 0;\n  while (1) {\n   if (($$0 | 0) == 3) break;\n   $$088 = 0;\n   while (1) {\n    if (($$088 | 0) == 4) break;\n    HEAPF64[$3 + ($$0 << 5) + ($$088 << 3) >> 3] = +HEAPF64[$2 + ($$0 << 5) + ($$088 << 3) >> 3];\n    $$088 = $$088 + 1 | 0;\n   }\n   $$0 = $$0 + 1 | 0;\n  }\n  $22 = $1 + 4 | 0;\n  $23 = $5 + 8 | 0;\n  $24 = $0 + 104 | 0;\n  $25 = $0 + 96 | 0;\n  $26 = $0 + 120 | 0;\n  $27 = $0 + 112 | 0;\n  $$091 = 0.0;\n  $$189 = 0;\n  L17 : while (1) {\n   _arUtilMatMul($0, $3, $6) | 0;\n   $$090 = 0.0;\n   $$1 = 0;\n   while (1) {\n    $28 = HEAP32[$8 >> 2] | 0;\n    if (($$1 | 0) >= ($28 | 0)) break;\n    if ((_icpGetU_from_X_by_MatX2U($5, $6, (HEAP32[$22 >> 2] | 0) + ($$1 * 24 | 0) | 0) | 0) < 0) {\n     label = 16;\n     break L17;\n    }\n    $34 = HEAP32[$1 >> 2] | 0;\n    $38 = +HEAPF64[$34 + ($$1 << 4) >> 3] - +HEAPF64[$5 >> 3];\n    $42 = +HEAPF64[$34 + ($$1 << 4) + 8 >> 3] - +HEAPF64[$23 >> 3];\n    $47 = $$1 << 1;\n    HEAPF64[$15 + ($47 << 3) >> 3] = $38;\n    HEAPF64[$15 + (($47 | 1) << 3) >> 3] = $42;\n    $$090 = $$090 + ($38 * $38 + $42 * $42);\n    $$1 = $$1 + 1 | 0;\n   }\n   $53 = $$090 / +($28 | 0);\n   if ($53 < +HEAPF64[$24 >> 3]) {\n    label = 31;\n    break;\n   }\n   if ($$189 | 0) if ($53 < +HEAPF64[$26 >> 3]) if ($53 / $$091 > +HEAPF64[$27 >> 3]) {\n    label = 31;\n    break;\n   }\n   if (($$189 | 0) == (HEAP32[$25 >> 2] | 0)) {\n    label = 31;\n    break;\n   }\n   $$2 = 0;\n   $65 = $28;\n   while (1) {\n    if (($$2 | 0) >= ($65 | 0)) break;\n    if ((_icpGetJ_U_S($12 + ($$2 * 12 << 3) | 0, $0, $3, (HEAP32[$22 >> 2] | 0) + ($$2 * 24 | 0) | 0) | 0) < 0) {\n     label = 27;\n     break L17;\n    }\n    $$2 = $$2 + 1 | 0;\n    $65 = HEAP32[$8 >> 2] | 0;\n   }\n   if ((_icpGetDeltaS($7, $15, $12, $65 << 1) | 0) < 0) {\n    label = 29;\n    break;\n   }\n   _icpUpdateMat($3, $7) | 0;\n   $$091 = $53;\n   $$189 = $$189 + 1 | 0;\n  }\n  if ((label | 0) == 16) {\n   _icpGetXw2XcCleanup($12, $15);\n   $$092 = -1;\n   break;\n  } else if ((label | 0) == 27) {\n   _icpGetXw2XcCleanup($12, $15);\n   $$092 = -1;\n   break;\n  } else if ((label | 0) == 29) {\n   _icpGetXw2XcCleanup($12, $15);\n   $$092 = -1;\n   break;\n  } else if ((label | 0) == 31) {\n   HEAPF64[$4 >> 3] = $53;\n   _free($12);\n   _free($15);\n   $$092 = 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$092 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_123parse_prefix_expressionINS0_2DbEEEPKcS4_S4_RKNT_6StringERS5_($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i20 = 0, $$018 = 0, $12 = 0, $18 = 0, $19 = 0, $32 = 0, $33 = 0, $34 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $4 = sp + 48 | 0;\n $5 = sp + 36 | 0;\n $6 = sp + 24 | 0;\n $7 = sp + 12 | 0;\n $8 = sp;\n $9 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $3) | 0;\n if (($9 | 0) == ($0 | 0)) $$018 = $0; else {\n  $12 = $3 + 4 | 0;\n  if ((HEAP32[$3 >> 2] | 0) == (HEAP32[$12 >> 2] | 0)) $$018 = $0; else {\n   __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EERKSB_PKS8_($7, $2, 15119);\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($8, (HEAP32[$12 >> 2] | 0) + -24 | 0);\n   $18 = HEAP8[$8 + 11 >> 0] | 0;\n   $19 = $18 << 24 >> 24 < 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($7, $19 ? HEAP32[$8 >> 2] | 0 : $8, $19 ? HEAP32[$8 + 4 >> 2] | 0 : $18 & 255) | 0;\n   HEAP32[$6 >> 2] = HEAP32[$7 >> 2];\n   HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2];\n   HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2];\n   $$0$i$i$i = 0;\n   while (1) {\n    if (($$0$i$i$i | 0) == 3) break;\n    HEAP32[$7 + ($$0$i$i$i << 2) >> 2] = 0;\n    $$0$i$i$i = $$0$i$i$i + 1 | 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($6, 15117) | 0;\n   HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n   HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n   HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n   $$0$i$i$i20 = 0;\n   while (1) {\n    if (($$0$i$i$i20 | 0) == 3) break;\n    HEAP32[$6 + ($$0$i$i$i20 << 2) >> 2] = 0;\n    $$0$i$i$i20 = $$0$i$i$i20 + 1 | 0;\n   }\n   $32 = HEAP32[$12 >> 2] | 0;\n   $33 = $32 + -24 | 0;\n   $34 = $33 + 11 | 0;\n   if ((HEAP8[$34 >> 0] | 0) < 0) {\n    $37 = HEAP32[$33 >> 2] | 0;\n    HEAP8[$4 >> 0] = 0;\n    __ZNSt3__211char_traitsIcE6assignERcRKc($37, $4);\n    HEAP32[$32 + -20 >> 2] = 0;\n   } else {\n    HEAP8[$4 >> 0] = 0;\n    __ZNSt3__211char_traitsIcE6assignERcRKc($33, $4);\n    HEAP8[$34 >> 0] = 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($33);\n   HEAP32[$33 >> 2] = HEAP32[$5 >> 2];\n   HEAP32[$33 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n   HEAP32[$33 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n   $$0$i$i$i$i = 0;\n   while (1) {\n    if (($$0$i$i$i$i | 0) == 3) break;\n    HEAP32[$5 + ($$0$i$i$i$i << 2) >> 2] = 0;\n    $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($8);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($7);\n   $$018 = $9;\n  }\n }\n STACKTOP = sp;\n return $$018 | 0;\n}\n\nfunction _scanexp($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$04858 = 0, $$049 = 0, $$157 = 0, $$251 = 0, $$pre$phi69Z2D = 0, $100 = 0, $11 = 0, $13 = 0, $14 = 0, $2 = 0, $21 = 0, $22 = 0, $3 = 0, $36 = 0, $4 = 0, $43 = 0, $44 = 0, $49 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $57 = 0, $61 = 0, $68 = 0, $69 = 0, $78 = 0, $86 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $99 = 0, label = 0;\n $2 = $0 + 4 | 0;\n $3 = HEAP32[$2 >> 2] | 0;\n $4 = $0 + 100 | 0;\n if ($3 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n  HEAP32[$2 >> 2] = $3 + 1;\n  $11 = HEAPU8[$3 >> 0] | 0;\n } else $11 = ___shgetc($0) | 0;\n switch ($11 | 0) {\n case 43:\n case 45:\n  {\n   $13 = ($11 | 0) == 45 & 1;\n   $14 = HEAP32[$2 >> 2] | 0;\n   if ($14 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n    HEAP32[$2 >> 2] = $14 + 1;\n    $22 = HEAPU8[$14 >> 0] | 0;\n   } else $22 = ___shgetc($0) | 0;\n   $21 = $22 + -48 | 0;\n   if (($1 | 0) != 0 & $21 >>> 0 > 9) if (!(HEAP32[$4 >> 2] | 0)) {\n    $100 = 0;\n    $99 = -2147483648;\n   } else {\n    HEAP32[$2 >> 2] = (HEAP32[$2 >> 2] | 0) + -1;\n    label = 14;\n   } else {\n    $$0 = $13;\n    $$049 = $22;\n    $$pre$phi69Z2D = $21;\n    label = 12;\n   }\n   break;\n  }\n default:\n  {\n   $$0 = 0;\n   $$049 = $11;\n   $$pre$phi69Z2D = $11 + -48 | 0;\n   label = 12;\n  }\n }\n if ((label | 0) == 12) if ($$pre$phi69Z2D >>> 0 > 9) label = 14; else {\n  $$04858 = 0;\n  $$157 = $$049;\n  while (1) {\n   $$04858 = $$157 + -48 + ($$04858 * 10 | 0) | 0;\n   $36 = HEAP32[$2 >> 2] | 0;\n   if ($36 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n    HEAP32[$2 >> 2] = $36 + 1;\n    $44 = HEAPU8[$36 >> 0] | 0;\n   } else $44 = ___shgetc($0) | 0;\n   $43 = $44 + -48 | 0;\n   if (!($43 >>> 0 < 10 & ($$04858 | 0) < 214748364)) break; else $$157 = $44;\n  }\n  $49 = (($$04858 | 0) < 0) << 31 >> 31;\n  if ($43 >>> 0 < 10) {\n   $$251 = $44;\n   $51 = $$04858;\n   $52 = $49;\n   while (1) {\n    $53 = ___muldi3($51 | 0, $52 | 0, 10, 0) | 0;\n    $54 = tempRet0;\n    $57 = _i64Add($$251 | 0, (($$251 | 0) < 0) << 31 >> 31 | 0, -48, -1) | 0;\n    $51 = _i64Add($57 | 0, tempRet0 | 0, $53 | 0, $54 | 0) | 0;\n    $52 = tempRet0;\n    $61 = HEAP32[$2 >> 2] | 0;\n    if ($61 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n     HEAP32[$2 >> 2] = $61 + 1;\n     $69 = HEAPU8[$61 >> 0] | 0;\n    } else $69 = ___shgetc($0) | 0;\n    $68 = $69 + -48 | 0;\n    if (!($68 >>> 0 < 10 & (($52 | 0) < 21474836 | ($52 | 0) == 21474836 & $51 >>> 0 < 2061584302))) break; else $$251 = $69;\n   }\n   if ($68 >>> 0 < 10) {\n    do {\n     $78 = HEAP32[$2 >> 2] | 0;\n     if ($78 >>> 0 < (HEAP32[$4 >> 2] | 0) >>> 0) {\n      HEAP32[$2 >> 2] = $78 + 1;\n      $86 = HEAPU8[$78 >> 0] | 0;\n     } else $86 = ___shgetc($0) | 0;\n    } while (($86 + -48 | 0) >>> 0 < 10);\n    $93 = $51;\n    $94 = $52;\n   } else {\n    $93 = $51;\n    $94 = $52;\n   }\n  } else {\n   $93 = $$04858;\n   $94 = $49;\n  }\n  if (HEAP32[$4 >> 2] | 0) HEAP32[$2 >> 2] = (HEAP32[$2 >> 2] | 0) + -1;\n  $92 = ($$0 | 0) == 0;\n  $95 = _i64Subtract(0, 0, $93 | 0, $94 | 0) | 0;\n  $100 = $92 ? $93 : $95;\n  $99 = $92 ? $94 : tempRet0;\n }\n if ((label | 0) == 14) if (!(HEAP32[$4 >> 2] | 0)) {\n  $100 = 0;\n  $99 = -2147483648;\n } else {\n  HEAP32[$2 >> 2] = (HEAP32[$2 >> 2] | 0) + -1;\n  $100 = 0;\n  $99 = -2147483648;\n }\n tempRet0 = $99;\n return $100 | 0;\n}\n\nfunction _arParamIdeal2Observ($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = +$1;\n $2 = +$2;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $$0 = 0, $10 = 0.0, $100 = 0.0, $101 = 0, $104 = 0.0, $110 = 0.0, $12 = 0.0, $122 = 0.0, $128 = 0.0, $131 = 0.0, $132 = 0.0, $133 = 0, $136 = 0.0, $14 = 0.0, $147 = 0.0, $16 = 0.0, $18 = 0.0, $20 = 0.0, $22 = 0.0, $25 = 0.0, $28 = 0.0, $31 = 0.0, $36 = 0.0, $61 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0, $69 = 0.0, $77 = 0.0, $89 = 0.0, $96 = 0.0, $99 = 0.0, $storemerge$sink = 0.0, label = 0;\n L1 : do switch ($5 | 0) {\n case 4:\n  {\n   $10 = +HEAPF64[$0 + 16 >> 3];\n   $12 = +HEAPF64[$0 + 24 >> 3];\n   $14 = +HEAPF64[$0 + 32 >> 3];\n   $16 = +HEAPF64[$0 + 40 >> 3];\n   $18 = +HEAPF64[$0 + 48 >> 3];\n   $20 = +HEAPF64[$0 + 56 >> 3];\n   $22 = +HEAPF64[$0 + 64 >> 3];\n   $25 = ($1 - $18) * $22 / $14;\n   $28 = ($2 - $20) * $22 / $16;\n   $31 = $25 * $25 + $28 * $28;\n   $36 = +HEAPF64[$0 >> 3] * $31 + 1.0 + $31 * (+HEAPF64[$0 + 8 >> 3] * $31);\n   HEAPF64[$3 >> 3] = $18 + $14 * ($12 * ($31 + $25 * ($25 * 2.0)) + ($28 * ($10 * 2.0 * $25) + $25 * $36));\n   $storemerge$sink = $20 + $16 * ($28 * ($12 * 2.0 * $25) + ($10 * ($31 + $28 * ($28 * 2.0)) + $28 * $36));\n   label = 12;\n   break;\n  }\n case 3:\n  {\n   $61 = +HEAPF64[$0 >> 3];\n   $64 = +HEAPF64[$0 + 16 >> 3];\n   $65 = ($1 - $61) * $64;\n   $66 = $0 + 8 | 0;\n   $69 = $64 * ($2 - +HEAPF64[$66 >> 3]);\n   if ($65 == 0.0 & $69 == 0.0) {\n    HEAPF64[$3 >> 3] = $61;\n    $storemerge$sink = +HEAPF64[$66 >> 3];\n    label = 12;\n    break L1;\n   } else {\n    $77 = $65 * $65 + $69 * $69;\n    $89 = 1.0 - $77 * (+HEAPF64[$0 + 32 >> 3] / 1.0e8) - $77 * ($77 * (+HEAPF64[$0 + 40 >> 3] / 1.0e8 / 1.0e5));\n    HEAPF64[$3 >> 3] = $61 + +HEAPF64[$0 + 24 >> 3] * ($65 * $89);\n    $storemerge$sink = +HEAPF64[$66 >> 3] + $69 * $89;\n    label = 12;\n    break L1;\n   }\n   break;\n  }\n case 2:\n  {\n   $96 = +HEAPF64[$0 >> 3];\n   $99 = +HEAPF64[$0 + 16 >> 3];\n   $100 = ($1 - $96) * $99;\n   $101 = $0 + 8 | 0;\n   $104 = $99 * ($2 - +HEAPF64[$101 >> 3]);\n   if ($100 == 0.0 & $104 == 0.0) {\n    HEAPF64[$3 >> 3] = $96;\n    $storemerge$sink = +HEAPF64[$101 >> 3];\n    label = 12;\n    break L1;\n   } else {\n    $110 = $100 * $100 + $104 * $104;\n    $122 = 1.0 - $110 * (+HEAPF64[$0 + 24 >> 3] / 1.0e8) - $110 * ($110 * (+HEAPF64[$0 + 32 >> 3] / 1.0e8 / 1.0e5));\n    HEAPF64[$3 >> 3] = $96 + $100 * $122;\n    $storemerge$sink = +HEAPF64[$101 >> 3] + $104 * $122;\n    label = 12;\n    break L1;\n   }\n   break;\n  }\n case 1:\n  {\n   $128 = +HEAPF64[$0 >> 3];\n   $131 = +HEAPF64[$0 + 16 >> 3];\n   $132 = ($1 - $128) * $131;\n   $133 = $0 + 8 | 0;\n   $136 = $131 * ($2 - +HEAPF64[$133 >> 3]);\n   if ($132 == 0.0 & $136 == 0.0) {\n    HEAPF64[$3 >> 3] = $128;\n    $storemerge$sink = +HEAPF64[$133 >> 3];\n    label = 12;\n    break L1;\n   } else {\n    $147 = 1.0 - ($132 * $132 + $136 * $136) * (+HEAPF64[$0 + 24 >> 3] / 1.0e8);\n    HEAPF64[$3 >> 3] = $128 + $132 * $147;\n    $storemerge$sink = +HEAPF64[$133 >> 3] + $136 * $147;\n    label = 12;\n    break L1;\n   }\n   break;\n  }\n default:\n  $$0 = -1;\n } while (0);\n if ((label | 0) == 12) {\n  HEAPF64[$4 >> 3] = $storemerge$sink;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction _arGetMarkerInfo($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n $7 = $7 | 0;\n $8 = $8 | 0;\n $9 = $9 | 0;\n $10 = +$10;\n $11 = $11 | 0;\n $12 = $12 | 0;\n $13 = $13 | 0;\n var $$0 = 0, $$0113 = 0, $$1 = 0, $$sink = 0, $$sink118 = 0, $$sink119$in = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $42 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $53 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $14 = sp + 4 | 0;\n $15 = sp;\n $16 = $8 >>> 0 < 2;\n $17 = ($8 | 0) == 2;\n $$0 = 0;\n $$0113 = 0;\n while (1) {\n  if (($$0 | 0) >= ($5 | 0)) break;\n  HEAP32[$11 + ($$0113 << 8) >> 2] = HEAP32[$4 + ($$0 * 80048 | 0) >> 2];\n  if ((_arParamObserv2IdealLTf($9, +HEAPF64[$4 + ($$0 * 80048 | 0) + 8 >> 3], +HEAPF64[$4 + ($$0 * 80048 | 0) + 16 >> 3], $14, $15) | 0) < 0) $$1 = $$0113; else {\n   HEAPF64[$11 + ($$0113 << 8) + 56 >> 3] = +HEAPF32[$14 >> 2];\n   HEAPF64[$11 + ($$0113 << 8) + 64 >> 3] = +HEAPF32[$15 >> 2];\n   $42 = $11 + ($$0113 << 8) + 168 | 0;\n   if ((_arGetLine($4 + ($$0 * 80048 | 0) + 28 | 0, $4 + ($$0 * 80048 | 0) + 40028 | 0, HEAP32[$4 + ($$0 * 80048 | 0) + 24 >> 2] | 0, $4 + ($$0 * 80048 | 0) + 80028 | 0, $9, $11 + ($$0113 << 8) + 72 | 0, $42) | 0) < 0) $$1 = $$0113; else {\n    $45 = $11 + ($$0113 << 8) + 8 | 0;\n    $46 = $11 + ($$0113 << 8) + 20 | 0;\n    $47 = $11 + ($$0113 << 8) + 40 | 0;\n    $48 = $11 + ($$0113 << 8) + 12 | 0;\n    $49 = $11 + ($$0113 << 8) + 24 | 0;\n    $50 = $11 + ($$0113 << 8) + 48 | 0;\n    $53 = _arPattGetIDGlobal($6, $7, $8, $0, $1, $2, $3, $9, $42, $10, $45, $46, $47, $48, $49, $50, $13, $11 + ($$0113 << 8) + 240 | 0, $11 + ($$0113 << 8) + 248 | 0) | 0;\n    switch ($53 | 0) {\n    case 0:\n     {\n      $$sink = $53;\n      label = 12;\n      break;\n     }\n    case -1:\n     {\n      $$sink = 2;\n      label = 12;\n      break;\n     }\n    case -2:\n     {\n      $$sink = 3;\n      label = 12;\n      break;\n     }\n    case -3:\n     {\n      $$sink = 4;\n      label = 12;\n      break;\n     }\n    case -4:\n     {\n      $$sink = 5;\n      label = 12;\n      break;\n     }\n    case -5:\n     {\n      $$sink = 9;\n      label = 12;\n      break;\n     }\n    case -6:\n     {\n      $$sink = 1;\n      label = 12;\n      break;\n     }\n    default:\n     {}\n    }\n    if ((label | 0) == 12) {\n     label = 0;\n     HEAP32[$11 + ($$0113 << 8) + 236 >> 2] = $$sink;\n    }\n    if ($16) {\n     HEAP32[$11 + ($$0113 << 8) + 4 >> 2] = HEAP32[$45 >> 2];\n     $$sink118 = $47;\n     $$sink119$in = $46;\n     label = 17;\n    } else if ($17) {\n     HEAP32[$11 + ($$0113 << 8) + 4 >> 2] = HEAP32[$48 >> 2];\n     $$sink118 = $50;\n     $$sink119$in = $49;\n     label = 17;\n    }\n    if ((label | 0) == 17) {\n     label = 0;\n     HEAP32[$11 + ($$0113 << 8) + 16 >> 2] = HEAP32[$$sink119$in >> 2];\n     HEAPF64[$11 + ($$0113 << 8) + 32 >> 3] = +HEAPF64[$$sink118 >> 3];\n    }\n    $$1 = $$0113 + 1 | 0;\n   }\n  }\n  $$0 = $$0 + 1 | 0;\n  $$0113 = $$1;\n }\n HEAP32[$12 >> 2] = $$0113;\n STACKTOP = sp;\n return 0;\n}\n\nfunction _check_square($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = +$2;\n var $$0 = 0, $$092 = 0, $$093 = 0, $$094 = 0, $$sroa$12$0 = 0, $$sroa$4$0 = 0, $$sroa$8$0 = 0, $10 = 0, $11 = 0, $13 = 0, $17 = 0, $18 = 0, $21 = 0, $23 = 0, $24 = 0, $29 = 0.0, $3 = 0, $36 = 0, $38 = 0, $4 = 0, $44 = 0, $5 = 0, $6 = 0, $60 = 0, $7 = 0, $8 = 0, $9 = 0, $spec$select = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 96 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96);\n $3 = sp + 56 | 0;\n $4 = sp + 48 | 0;\n $5 = sp + 8 | 0;\n $6 = sp;\n $7 = $1 + 28 | 0;\n $8 = HEAP32[$7 >> 2] | 0;\n $9 = $1 + 40028 | 0;\n $10 = HEAP32[$9 >> 2] | 0;\n $11 = $1 + 24 | 0;\n $13 = (HEAP32[$11 >> 2] | 0) + -1 | 0;\n $$0 = 1;\n $$093 = 0;\n $$094 = 0;\n while (1) {\n  if (($$0 | 0) >= ($13 | 0)) break;\n  $17 = (HEAP32[$1 + 28 + ($$0 << 2) >> 2] | 0) - $8 | 0;\n  $18 = Math_imul($17, $17) | 0;\n  $21 = (HEAP32[$1 + 40028 + ($$0 << 2) >> 2] | 0) - $10 | 0;\n  $23 = (Math_imul($21, $21) | 0) + $18 | 0;\n  $24 = ($23 | 0) > ($$093 | 0);\n  $spec$select = $24 ? $$0 : $$094;\n  $$0 = $$0 + 1 | 0;\n  $$093 = $24 ? $23 : $$093;\n  $$094 = $spec$select;\n }\n $29 = +($0 | 0) / .75 * .01 * $2;\n HEAP32[$4 >> 2] = 0;\n HEAP32[$6 >> 2] = 0;\n L5 : do if ((_get_vertex($7, $9, 0, $$094, $29, $3, $4) | 0) < 0) $$092 = -1; else if ((_get_vertex($7, $9, $$094, (HEAP32[$11 >> 2] | 0) + -1 | 0, $29, $5, $6) | 0) < 0) $$092 = -1; else {\n  $36 = HEAP32[$4 >> 2] | 0;\n  $38 = HEAP32[$6 >> 2] | 0;\n  do if (($36 | 0) == 1 & ($38 | 0) == 1) {\n   $$sroa$12$0 = HEAP32[$5 >> 2] | 0;\n   $$sroa$4$0 = HEAP32[$3 >> 2] | 0;\n   $$sroa$8$0 = $$094;\n  } else {\n   if (($36 | 0) > 1 & ($38 | 0) == 0) {\n    $44 = ($$094 | 0) / 2 | 0;\n    HEAP32[$6 >> 2] = 0;\n    HEAP32[$4 >> 2] = 0;\n    if ((_get_vertex($7, $9, 0, $44, $29, $3, $4) | 0) < 0) {\n     $$092 = -1;\n     break L5;\n    }\n    if ((_get_vertex($7, $9, $44, $$094, $29, $5, $6) | 0) < 0) {\n     $$092 = -1;\n     break L5;\n    }\n    if (!((HEAP32[$4 >> 2] | 0) == 1 & (HEAP32[$6 >> 2] | 0) == 1)) {\n     $$092 = -1;\n     break L5;\n    }\n    $$sroa$12$0 = $$094;\n    $$sroa$4$0 = HEAP32[$3 >> 2] | 0;\n    $$sroa$8$0 = HEAP32[$5 >> 2] | 0;\n    break;\n   }\n   if (!(($36 | 0) == 0 & ($38 | 0) > 1)) {\n    $$092 = -1;\n    break L5;\n   }\n   $60 = ($$094 + -1 + (HEAP32[$11 >> 2] | 0) | 0) / 2 | 0;\n   HEAP32[$6 >> 2] = 0;\n   HEAP32[$4 >> 2] = 0;\n   if ((_get_vertex($7, $9, $$094, $60, $29, $3, $4) | 0) < 0) {\n    $$092 = -1;\n    break L5;\n   }\n   if ((_get_vertex($7, $9, $60, (HEAP32[$11 >> 2] | 0) + -1 | 0, $29, $5, $6) | 0) < 0) {\n    $$092 = -1;\n    break L5;\n   }\n   if (!((HEAP32[$4 >> 2] | 0) == 1 & (HEAP32[$6 >> 2] | 0) == 1)) {\n    $$092 = -1;\n    break L5;\n   }\n   $$sroa$12$0 = HEAP32[$5 >> 2] | 0;\n   $$sroa$4$0 = $$094;\n   $$sroa$8$0 = HEAP32[$3 >> 2] | 0;\n  } while (0);\n  HEAP32[$1 + 80028 >> 2] = 0;\n  HEAP32[$1 + 80032 >> 2] = $$sroa$4$0;\n  HEAP32[$1 + 80036 >> 2] = $$sroa$8$0;\n  HEAP32[$1 + 80040 >> 2] = $$sroa$12$0;\n  HEAP32[$1 + 80044 >> 2] = (HEAP32[$11 >> 2] | 0) + -1;\n  $$092 = 0;\n } while (0);\n STACKTOP = sp;\n return $$092 | 0;\n}\n\nfunction _arGetLine($0, $1, $2, $3, $4, $5, $6) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n var $$0108 = 0, $$0109 = 0, $$0110 = 0, $$1 = 0, $10 = 0, $11 = 0, $13 = 0, $15 = 0, $17 = 0, $22 = 0.0, $25 = 0, $29 = 0, $31 = 0, $33 = 0, $44 = 0, $45 = 0, $54 = 0, $56 = 0.0, $59 = 0.0, $61 = 0, $7 = 0, $72 = 0, $73 = 0, $76 = 0.0, $78 = 0, $8 = 0, $81 = 0.0, $83 = 0.0, $86 = 0, $89 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $7 = sp + 4 | 0;\n $8 = sp;\n $9 = _arVecAlloc(2) | 0;\n $10 = _arVecAlloc(2) | 0;\n $11 = _arMatrixAlloc(2, 2) | 0;\n $$0109 = 0;\n L1 : while (1) {\n  if ($$0109 >>> 0 >= 4) {\n   label = 10;\n   break;\n  }\n  $13 = $$0109 + 1 | 0;\n  $15 = HEAP32[$3 + ($13 << 2) >> 2] | 0;\n  $17 = HEAP32[$3 + ($$0109 << 2) >> 2] | 0;\n  $22 = +($15 + 1 - $17 | 0) * .05 + .5;\n  $25 = ~~($22 + +($17 | 0));\n  $29 = ~~(+($15 | 0) - $22) - $25 | 0;\n  $31 = _arMatrixAlloc($29 + 1 | 0, 2) | 0;\n  $$0108 = 0;\n  while (1) {\n   if (($$0108 | 0) > ($29 | 0)) break;\n   $33 = $$0108 + $25 | 0;\n   if ((_arParamObserv2IdealLTf($4, +(HEAP32[$0 + ($33 << 2) >> 2] | 0), +(HEAP32[$1 + ($33 << 2) >> 2] | 0), $7, $8) | 0) < 0) {\n    label = 6;\n    break L1;\n   }\n   $44 = HEAP32[$31 >> 2] | 0;\n   $45 = $$0108 << 1;\n   HEAPF64[$44 + ($45 << 3) >> 3] = +HEAPF32[$7 >> 2];\n   HEAPF64[$44 + (($45 | 1) << 3) >> 3] = +HEAPF32[$8 >> 2];\n   $$0108 = $$0108 + 1 | 0;\n  }\n  if ((_arMatrixPCA($31, $11, $9, $10) | 0) < 0) {\n   label = 14;\n   break;\n  }\n  $54 = HEAP32[$11 >> 2] | 0;\n  $56 = +HEAPF64[$54 + 8 >> 3];\n  HEAPF64[$5 + ($$0109 * 24 | 0) >> 3] = $56;\n  $59 = -+HEAPF64[$54 >> 3];\n  HEAPF64[$5 + ($$0109 * 24 | 0) + 8 >> 3] = $59;\n  $61 = HEAP32[$10 >> 2] | 0;\n  HEAPF64[$5 + ($$0109 * 24 | 0) + 16 >> 3] = -($56 * +HEAPF64[$61 >> 3] + +HEAPF64[$61 + 8 >> 3] * $59);\n  _arMatrixFree($31) | 0;\n  $$0109 = $13;\n }\n L10 : do if ((label | 0) == 6) label = 14; else if ((label | 0) == 10) {\n  _arMatrixFree($11) | 0;\n  _arVecFree($10) | 0;\n  _arVecFree($9) | 0;\n  $$1 = 0;\n  while (1) {\n   if ($$1 >>> 0 >= 4) {\n    $$0110 = 0;\n    break L10;\n   }\n   $72 = $$1 + 3 & 3;\n   $73 = $5 + ($72 * 24 | 0) | 0;\n   $76 = +HEAPF64[$5 + ($$1 * 24 | 0) + 8 >> 3];\n   $78 = $5 + ($$1 * 24 | 0) | 0;\n   $81 = +HEAPF64[$5 + ($72 * 24 | 0) + 8 >> 3];\n   $83 = +HEAPF64[$73 >> 3] * $76 - +HEAPF64[$78 >> 3] * $81;\n   if (+Math_abs(+$83) < .0001) {\n    $$0110 = -1;\n    break L10;\n   }\n   $86 = $5 + ($$1 * 24 | 0) + 16 | 0;\n   $89 = $5 + ($72 * 24 | 0) + 16 | 0;\n   HEAPF64[$6 + ($$1 << 4) >> 3] = ($81 * +HEAPF64[$86 >> 3] - $76 * +HEAPF64[$89 >> 3]) / $83;\n   HEAPF64[$6 + ($$1 << 4) + 8 >> 3] = (+HEAPF64[$78 >> 3] * +HEAPF64[$89 >> 3] - +HEAPF64[$73 >> 3] * +HEAPF64[$86 >> 3]) / $83;\n   $$1 = $$1 + 1 | 0;\n  }\n } while (0);\n if ((label | 0) == 14) {\n  _arMatrixFree($31) | 0;\n  _arMatrixFree($11) | 0;\n  _arVecFree($10) | 0;\n  _arVecFree($9) | 0;\n  $$0110 = -1;\n }\n STACKTOP = sp;\n return $$0110 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_118parse_alignof_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i25 = 0, $$1 = 0, $16 = 0, $17 = 0, $20 = 0, $21 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $3 = sp + 36 | 0;\n $4 = sp + 24 | 0;\n $5 = sp + 12 | 0;\n $6 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 97) if ((HEAP8[$0 + 1 >> 0] | 0) == 122) {\n  $16 = $0 + 2 | 0;\n  $17 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0;\n  if (($17 | 0) == ($16 | 0)) $$1 = $0; else {\n   $20 = $2 + 4 | 0;\n   $21 = HEAP32[$20 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($21 | 0)) $$1 = $0; else {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $21 + -24 | 0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 16298) | 0;\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($5, 15117) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i25 = 0;\n    while (1) {\n     if (($$0$i$i$i25 | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i25 << 2) >> 2] = 0;\n     $$0$i$i$i25 = $$0$i$i$i25 + 1 | 0;\n    }\n    $30 = HEAP32[$20 >> 2] | 0;\n    $31 = $30 + -24 | 0;\n    $32 = $31 + 11 | 0;\n    if ((HEAP8[$32 >> 0] | 0) < 0) {\n     $35 = HEAP32[$31 >> 2] | 0;\n     HEAP8[$3 >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($35, $3);\n     HEAP32[$30 + -20 >> 2] = 0;\n    } else {\n     HEAP8[$3 >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($31, $3);\n     HEAP8[$32 >> 0] = 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($31);\n    HEAP32[$31 >> 2] = HEAP32[$4 >> 2];\n    HEAP32[$31 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n    HEAP32[$31 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n    $$0$i$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i$i | 0) == 3) break;\n     HEAP32[$4 + ($$0$i$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    $$1 = $17;\n   }\n  }\n } else $$1 = $0; else $$1 = $0; else $$1 = $0;\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_118parse_alignof_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i25 = 0, $$1 = 0, $16 = 0, $17 = 0, $20 = 0, $21 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $3 = sp + 36 | 0;\n $4 = sp + 24 | 0;\n $5 = sp + 12 | 0;\n $6 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 97) if ((HEAP8[$0 + 1 >> 0] | 0) == 116) {\n  $16 = $0 + 2 | 0;\n  $17 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0;\n  if (($17 | 0) == ($16 | 0)) $$1 = $0; else {\n   $20 = $2 + 4 | 0;\n   $21 = HEAP32[$20 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($21 | 0)) $$1 = $0; else {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $21 + -24 | 0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 16298) | 0;\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($5, 15117) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i25 = 0;\n    while (1) {\n     if (($$0$i$i$i25 | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i25 << 2) >> 2] = 0;\n     $$0$i$i$i25 = $$0$i$i$i25 + 1 | 0;\n    }\n    $30 = HEAP32[$20 >> 2] | 0;\n    $31 = $30 + -24 | 0;\n    $32 = $31 + 11 | 0;\n    if ((HEAP8[$32 >> 0] | 0) < 0) {\n     $35 = HEAP32[$31 >> 2] | 0;\n     HEAP8[$3 >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($35, $3);\n     HEAP32[$30 + -20 >> 2] = 0;\n    } else {\n     HEAP8[$3 >> 0] = 0;\n     __ZNSt3__211char_traitsIcE6assignERcRKc($31, $3);\n     HEAP8[$32 >> 0] = 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($31);\n    HEAP32[$31 >> 2] = HEAP32[$4 >> 2];\n    HEAP32[$31 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n    HEAP32[$31 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n    $$0$i$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i$i | 0) == 3) break;\n     HEAP32[$4 + ($$0$i$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    $$1 = $17;\n   }\n  }\n } else $$1 = $0; else $$1 = $0; else $$1 = $0;\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7replaceEjjPKcj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$014 = 0, $$069 = 0, $$070 = 0, $$074 = 0, $$215 = 0, $$3 = 0, $$316 = 0, $$373 = 0, $$377 = 0, $$4 = 0, $$sroa$speculated18 = 0, $15 = 0, $17 = 0, $2 = 0, $21 = 0, $25 = 0, $3 = 0, $34 = 0, $4 = 0, $41 = 0, $5 = 0, $6 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = $0 + 11 | 0;\n $4 = HEAP8[$3 >> 0] | 0;\n $5 = $4 << 24 >> 24 < 0;\n if ($5) {\n  $9 = HEAP32[$0 + 4 >> 2] | 0;\n  $$sroa$speculated18 = $9 >>> 0 < 11 ? $9 : 11;\n  $15 = $9;\n  $17 = (HEAP32[$0 + 8 >> 2] & 2147483647) + -1 | 0;\n } else {\n  $6 = $4 & 255;\n  $$sroa$speculated18 = $6 >>> 0 < 11 ? $6 : 11;\n  $15 = $6;\n  $17 = 10;\n }\n if (($$sroa$speculated18 - $15 + $17 | 0) >>> 0 < $1 >>> 0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE21__grow_by_and_replaceEjjjjjjPKc($0, $17, $1 - $$sroa$speculated18 + $15 - $17 | 0, $15, 0, $$sroa$speculated18, $1, 16538); else {\n  if ($5) $25 = HEAP32[$0 >> 2] | 0; else $25 = $0;\n  do if (($$sroa$speculated18 | 0) == ($1 | 0)) {\n   $$215 = $1;\n   $$3 = 0;\n   $$373 = 16538;\n   $$377 = $1;\n   label = 17;\n  } else {\n   $21 = $15 - $$sroa$speculated18 | 0;\n   if (!$21) {\n    $$215 = $$sroa$speculated18;\n    $$3 = 0;\n    $$373 = 16538;\n    $$377 = $1;\n    label = 17;\n   } else {\n    if ($$sroa$speculated18 >>> 0 > $1 >>> 0) {\n     __ZNSt3__211char_traitsIcE4moveEPcPKcj($25, 16538, $1) | 0;\n     __ZNSt3__211char_traitsIcE4moveEPcPKcj($25 + $1 | 0, $25 + $$sroa$speculated18 | 0, $21) | 0;\n     $$316 = $$sroa$speculated18;\n     $$4 = $1;\n     break;\n    }\n    do if ($25 >>> 0 < 16538 >>> 0 & ($25 + $15 | 0) >>> 0 > 16538 >>> 0) if (($25 + $$sroa$speculated18 | 0) >>> 0 > 16538 >>> 0) {\n     __ZNSt3__211char_traitsIcE4moveEPcPKcj($25, 16538, $$sroa$speculated18) | 0;\n     $$014 = 0;\n     $$069 = $$sroa$speculated18;\n     $$070 = 16538 + $1 | 0;\n     $$074 = $1 - $$sroa$speculated18 | 0;\n     break;\n    } else {\n     $$014 = $$sroa$speculated18;\n     $$069 = 0;\n     $$070 = 16538 + ($1 - $$sroa$speculated18) | 0;\n     $$074 = $1;\n     break;\n    } else {\n     $$014 = $$sroa$speculated18;\n     $$069 = 0;\n     $$070 = 16538;\n     $$074 = $1;\n    } while (0);\n    $34 = $25 + $$069 | 0;\n    __ZNSt3__211char_traitsIcE4moveEPcPKcj($34 + $$074 | 0, $34 + $$014 | 0, $21) | 0;\n    $$215 = $$014;\n    $$3 = $$069;\n    $$373 = $$070;\n    $$377 = $$074;\n    label = 17;\n   }\n  } while (0);\n  if ((label | 0) == 17) {\n   __ZNSt3__211char_traitsIcE4moveEPcPKcj($25 + $$3 | 0, $$373, $$377) | 0;\n   $$316 = $$215;\n   $$4 = $$377;\n  }\n  $41 = $$4 - $$316 + $15 | 0;\n  if ((HEAP8[$3 >> 0] | 0) < 0) HEAP32[$0 + 4 >> 2] = $41; else HEAP8[$3 >> 0] = $41;\n  HEAP8[$2 >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($25 + $41 | 0, $2);\n }\n STACKTOP = sp;\n return;\n}\n\nfunction _arglCameraFrustumRH($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = +$1;\n $2 = +$2;\n $3 = $3 | 0;\n var $$0 = 0, $$053 = 0, $$1 = 0, $$154 = 0, $$2 = 0, $10 = 0, $15 = 0.0, $19 = 0, $24 = 0.0, $34 = 0.0, $4 = 0, $48 = 0, $5 = 0, $6 = 0, $62 = 0, $64 = 0.0, $7 = 0, $71 = 0, $75 = 0.0, $77 = 0.0, $79 = 0.0, $8 = 0, $81 = 0.0, $82 = 0, $83 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 400 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(400);\n $4 = sp + 296 | 0;\n $5 = sp + 200 | 0;\n $6 = sp + 128 | 0;\n $7 = sp;\n $8 = HEAP32[$0 >> 2] | 0;\n $10 = HEAP32[$0 + 4 >> 2] | 0;\n L1 : do if ((_arParamDecompMat($0 + 8 | 0, $4, $5) | 0) < 0) _arLog(0, 3, 4599, sp + 392 | 0); else {\n  $15 = +($10 + -1 | 0);\n  $$053 = 0;\n  while (1) {\n   if (($$053 | 0) == 4) break;\n   $19 = $4 + 32 + ($$053 << 3) | 0;\n   HEAPF64[$19 >> 3] = +HEAPF64[$4 + 64 + ($$053 << 3) >> 3] * $15 - +HEAPF64[$19 >> 3];\n   $$053 = $$053 + 1 | 0;\n  }\n  $24 = +HEAPF64[$4 + 80 >> 3];\n  $$154 = 0;\n  while (1) {\n   if (($$154 | 0) == 3) break;\n   $$0 = 0;\n   while (1) {\n    if (($$0 | 0) == 3) break;\n    HEAPF64[$6 + ($$154 * 24 | 0) + ($$0 << 3) >> 3] = +HEAPF64[$4 + ($$154 << 5) + ($$0 << 3) >> 3] / $24;\n    $$0 = $$0 + 1 | 0;\n   }\n   $$154 = $$154 + 1 | 0;\n  }\n  $34 = +($8 + -1 | 0);\n  HEAPF64[$7 >> 3] = +HEAPF64[$6 >> 3] * 2.0 / $34;\n  HEAPF64[$7 + 8 >> 3] = +HEAPF64[$6 + 8 >> 3] * 2.0 / $34;\n  HEAPF64[$7 + 16 >> 3] = -(+HEAPF64[$6 + 16 >> 3] * 2.0 / $34 + -1.0);\n  $48 = $7 + 24 | 0;\n  HEAP32[$48 >> 2] = 0;\n  HEAP32[$48 + 4 >> 2] = 0;\n  HEAP32[$48 + 8 >> 2] = 0;\n  HEAP32[$48 + 12 >> 2] = 0;\n  HEAPF64[$7 + 40 >> 3] = -(+HEAPF64[$6 + 32 >> 3] * 2.0 / $15);\n  HEAPF64[$7 + 48 >> 3] = -(+HEAPF64[$6 + 40 >> 3] * 2.0 / $15 + -1.0);\n  $62 = $7 + 56 | 0;\n  $64 = $1 - $2;\n  HEAP32[$62 >> 2] = 0;\n  HEAP32[$62 + 4 >> 2] = 0;\n  HEAP32[$62 + 8 >> 2] = 0;\n  HEAP32[$62 + 12 >> 2] = 0;\n  HEAP32[$62 + 16 >> 2] = 0;\n  HEAP32[$62 + 20 >> 2] = 0;\n  HEAPF64[$7 + 80 >> 3] = ($1 + $2) / $64;\n  HEAPF64[$7 + 88 >> 3] = $2 * 2.0 * $1 / $64;\n  $71 = $7 + 96 | 0;\n  HEAP32[$71 >> 2] = 0;\n  HEAP32[$71 + 4 >> 2] = 0;\n  HEAP32[$71 + 8 >> 2] = 0;\n  HEAP32[$71 + 12 >> 2] = 0;\n  HEAPF64[$7 + 112 >> 3] = -1.0;\n  HEAPF64[$7 + 120 >> 3] = 0.0;\n  $75 = +HEAPF64[$5 + 24 >> 3];\n  $77 = +HEAPF64[$5 + 56 >> 3];\n  $79 = +HEAPF64[$5 + 88 >> 3];\n  $$2 = 0;\n  while (1) {\n   if (($$2 | 0) == 4) break L1;\n   $81 = +HEAPF64[$7 + ($$2 << 5) >> 3];\n   $82 = $7 + ($$2 << 5) + 8 | 0;\n   $83 = $7 + ($$2 << 5) + 16 | 0;\n   $$1 = 0;\n   while (1) {\n    if (($$1 | 0) == 3) break;\n    HEAPF64[$3 + (($$1 << 2) + $$2 << 3) >> 3] = $81 * +HEAPF64[$5 + ($$1 << 3) >> 3] + +HEAPF64[$82 >> 3] * +HEAPF64[$5 + 32 + ($$1 << 3) >> 3] + +HEAPF64[$83 >> 3] * +HEAPF64[$5 + 64 + ($$1 << 3) >> 3];\n    $$1 = $$1 + 1 | 0;\n   }\n   HEAPF64[$3 + ($$2 + 12 << 3) >> 3] = +HEAPF64[$7 + ($$2 << 5) + 24 >> 3] + ($81 * $75 + +HEAPF64[$82 >> 3] * $77 + +HEAPF64[$83 >> 3] * $79);\n   $$2 = $$2 + 1 | 0;\n  }\n } while (0);\n STACKTOP = sp;\n return;\n}\n\nfunction _qsort($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$067$lcssa = 0, $$06772 = 0, $$068$lcssa = 0, $$06871 = 0, $$1 = 0, $$169 = 0, $$169$be = 0, $$2 = 0, $$2$be = 0, $$be = 0, $12 = 0, $15 = 0, $15$phi = 0, $16 = 0, $17 = 0, $22 = 0, $24 = 0, $26 = 0, $29 = 0, $37 = 0, $38 = 0, $4 = 0, $40 = 0, $43 = 0, $47 = 0, $49 = 0, $5 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $7 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 208 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(208);\n $4 = sp + 8 | 0;\n $5 = sp;\n $6 = Math_imul($2, $1) | 0;\n $7 = $5;\n HEAP32[$7 >> 2] = 1;\n HEAP32[$7 + 4 >> 2] = 0;\n L1 : do if ($6 | 0) {\n  $12 = 0 - $2 | 0;\n  HEAP32[$4 + 4 >> 2] = $2;\n  HEAP32[$4 >> 2] = $2;\n  $$0 = 2;\n  $15 = $2;\n  $17 = $2;\n  while (1) {\n   $16 = $15 + $2 + $17 | 0;\n   HEAP32[$4 + ($$0 << 2) >> 2] = $16;\n   if ($16 >>> 0 < $6 >>> 0) {\n    $15$phi = $17;\n    $$0 = $$0 + 1 | 0;\n    $17 = $16;\n    $15 = $15$phi;\n   } else break;\n  }\n  $22 = $0 + $6 + $12 | 0;\n  if ($22 >>> 0 > $0 >>> 0) {\n   $24 = $22;\n   $$06772 = 1;\n   $$06871 = $0;\n   $26 = 1;\n   while (1) {\n    do if (($26 & 3 | 0) == 3) {\n     _sift($$06871, $2, $3, $$06772, $4);\n     _shr($5, 2);\n     $$1 = $$06772 + 2 | 0;\n    } else {\n     $29 = $$06772 + -1 | 0;\n     if ((HEAP32[$4 + ($29 << 2) >> 2] | 0) >>> 0 < ($24 - $$06871 | 0) >>> 0) _sift($$06871, $2, $3, $$06772, $4); else _trinkle($$06871, $2, $3, $5, $$06772, 0, $4);\n     if (($$06772 | 0) == 1) {\n      _shl($5, 1);\n      $$1 = 0;\n      break;\n     } else {\n      _shl($5, $29);\n      $$1 = 1;\n      break;\n     }\n    } while (0);\n    $37 = HEAP32[$5 >> 2] | 1;\n    HEAP32[$5 >> 2] = $37;\n    $38 = $$06871 + $2 | 0;\n    if ($38 >>> 0 < $22 >>> 0) {\n     $$06772 = $$1;\n     $$06871 = $38;\n     $26 = $37;\n    } else {\n     $$067$lcssa = $$1;\n     $$068$lcssa = $38;\n     $61 = $37;\n     break;\n    }\n   }\n  } else {\n   $$067$lcssa = 1;\n   $$068$lcssa = $0;\n   $61 = 1;\n  }\n  _trinkle($$068$lcssa, $2, $3, $5, $$067$lcssa, 0, $4);\n  $40 = $5 + 4 | 0;\n  $$169 = $$068$lcssa;\n  $$2 = $$067$lcssa;\n  $43 = $61;\n  while (1) {\n   if (($$2 | 0) == 1 & ($43 | 0) == 1) if (!(HEAP32[$40 >> 2] | 0)) break L1; else label = 19; else if (($$2 | 0) < 2) label = 19; else {\n    _shl($5, 2);\n    $49 = $$2 + -2 | 0;\n    HEAP32[$5 >> 2] = HEAP32[$5 >> 2] ^ 7;\n    _shr($5, 1);\n    _trinkle($$169 + (0 - (HEAP32[$4 + ($49 << 2) >> 2] | 0)) + $12 | 0, $2, $3, $5, $$2 + -1 | 0, 1, $4);\n    _shl($5, 1);\n    $59 = HEAP32[$5 >> 2] | 1;\n    HEAP32[$5 >> 2] = $59;\n    $60 = $$169 + $12 | 0;\n    _trinkle($60, $2, $3, $5, $49, 1, $4);\n    $$169$be = $60;\n    $$2$be = $49;\n    $$be = $59;\n   }\n   if ((label | 0) == 19) {\n    label = 0;\n    $47 = _pntz($5) | 0;\n    _shr($5, $47);\n    $$169$be = $$169 + $12 | 0;\n    $$2$be = $47 + $$2 | 0;\n    $$be = HEAP32[$5 >> 2] | 0;\n   }\n   $$169 = $$169$be;\n   $$2 = $$2$be;\n   $43 = $$be;\n  }\n } while (0);\n STACKTOP = sp;\n return;\n}\n\nfunction ___stpncpy($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$lcssa = 0, $$037$lcssa = 0, $$03754 = 0, $$038$lcssa = 0, $$03867 = 0, $$039$lcssa = 0, $$03966 = 0, $$042$lcssa = 0, $$04265 = 0, $$055 = 0, $$1$lcssa = 0, $$140 = 0, $$143 = 0, $$153 = 0, $$2 = 0, $$24147 = 0, $$24446 = 0, $$345 = 0, $$348 = 0, $$4 = 0, $$lcssa = 0, $10 = 0, $11 = 0, $13 = 0, $14 = 0, $15 = 0, $19 = 0, $22 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $33 = 0, $37 = 0, label = 0;\n $3 = $1;\n L1 : do if (!(($3 ^ $0) & 3)) {\n  $10 = ($2 | 0) != 0;\n  if ($10 & ($3 & 3 | 0) != 0) {\n   $$03867 = $2;\n   $$03966 = $1;\n   $$04265 = $0;\n   while (1) {\n    $11 = HEAP8[$$03966 >> 0] | 0;\n    HEAP8[$$04265 >> 0] = $11;\n    if (!($11 << 24 >> 24)) {\n     $$345 = $$04265;\n     $$4 = $$03867;\n     break L1;\n    }\n    $13 = $$03867 + -1 | 0;\n    $14 = $$03966 + 1 | 0;\n    $15 = $$04265 + 1 | 0;\n    $19 = ($13 | 0) != 0;\n    if ($19 & ($14 & 3 | 0) != 0) {\n     $$03867 = $13;\n     $$03966 = $14;\n     $$04265 = $15;\n    } else {\n     $$038$lcssa = $13;\n     $$039$lcssa = $14;\n     $$042$lcssa = $15;\n     $$lcssa = $19;\n     break;\n    }\n   }\n  } else {\n   $$038$lcssa = $2;\n   $$039$lcssa = $1;\n   $$042$lcssa = $0;\n   $$lcssa = $10;\n  }\n  if ($$lcssa) if (!(HEAP8[$$039$lcssa >> 0] | 0)) {\n   $$345 = $$042$lcssa;\n   $$4 = $$038$lcssa;\n  } else {\n   L11 : do if ($$038$lcssa >>> 0 > 3) {\n    $$03754 = $$042$lcssa;\n    $$055 = $$039$lcssa;\n    $$153 = $$038$lcssa;\n    while (1) {\n     $22 = HEAP32[$$055 >> 2] | 0;\n     if (($22 & -2139062144 ^ -2139062144) & $22 + -16843009 | 0) {\n      $$0$lcssa = $$055;\n      $$037$lcssa = $$03754;\n      $$1$lcssa = $$153;\n      break L11;\n     }\n     HEAP32[$$03754 >> 2] = $22;\n     $28 = $$153 + -4 | 0;\n     $29 = $$055 + 4 | 0;\n     $30 = $$03754 + 4 | 0;\n     if ($28 >>> 0 > 3) {\n      $$03754 = $30;\n      $$055 = $29;\n      $$153 = $28;\n     } else {\n      $$0$lcssa = $29;\n      $$037$lcssa = $30;\n      $$1$lcssa = $28;\n      break;\n     }\n    }\n   } else {\n    $$0$lcssa = $$039$lcssa;\n    $$037$lcssa = $$042$lcssa;\n    $$1$lcssa = $$038$lcssa;\n   } while (0);\n   $$140 = $$0$lcssa;\n   $$143 = $$037$lcssa;\n   $$2 = $$1$lcssa;\n   label = 13;\n  } else {\n   $$345 = $$042$lcssa;\n   $$4 = 0;\n  }\n } else {\n  $$140 = $1;\n  $$143 = $0;\n  $$2 = $2;\n  label = 13;\n } while (0);\n L17 : do if ((label | 0) == 13) if (!$$2) {\n  $$345 = $$143;\n  $$4 = 0;\n } else {\n  $$24147 = $$140;\n  $$24446 = $$143;\n  $$348 = $$2;\n  while (1) {\n   $33 = HEAP8[$$24147 >> 0] | 0;\n   HEAP8[$$24446 >> 0] = $33;\n   if (!($33 << 24 >> 24)) {\n    $$345 = $$24446;\n    $$4 = $$348;\n    break L17;\n   }\n   $$348 = $$348 + -1 | 0;\n   $37 = $$24446 + 1 | 0;\n   if (!$$348) {\n    $$345 = $37;\n    $$4 = 0;\n    break;\n   } else {\n    $$24147 = $$24147 + 1 | 0;\n    $$24446 = $37;\n   }\n  }\n } while (0);\n _memset($$345 | 0, 0, $$4 | 0) | 0;\n return $$345 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_121parse_floating_numberIeNS0_2DbEEEPKcS4_S4_RT0_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i = 0, $$049$idx = 0, $$050 = 0, $$07$i$i = 0, $$247$ph = 0, $$3 = 0, $11 = 0, $12 = 0, $17 = 0, $25 = 0, $27 = 0, $3 = 0, $31 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, dest = 0, label = 0, sp = 0, stop = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 96 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96);\n $vararg_buffer = sp + 8 | 0;\n $3 = sp;\n $4 = sp + 48 | 0;\n $5 = sp + 32 | 0;\n L1 : do if (($1 - $0 | 0) >>> 0 > 20) {\n  $$049$idx = 0;\n  $$050 = $3;\n  while (1) {\n   $11 = HEAP8[$0 + $$049$idx >> 0] | 0;\n   $12 = $11 << 24 >> 24;\n   if (($$049$idx | 0) == 20) {\n    label = 6;\n    break;\n   }\n   if (!(_isxdigit($12) | 0)) break;\n   $17 = HEAP8[$0 + ($$049$idx | 1) >> 0] | 0;\n   HEAP8[$$050 >> 0] = ((($12 + -48 | 0) >>> 0 < 10 ? 0 : 9) + $12 << 4) + $17 + (($17 + -48 | 0) >>> 0 < 10 ? 208 : 169);\n   $$049$idx = $$049$idx + 2 | 0;\n   $$050 = $$050 + 1 | 0;\n  }\n  do if ((label | 0) == 6) {\n   if ($11 << 24 >> 24 == 69) {\n    L11 : do if (($$050 | 0) != ($3 | 0)) {\n     $$0$i$i = $$050;\n     $$07$i$i = $3;\n     while (1) {\n      $25 = $$0$i$i + -1 | 0;\n      if ($$07$i$i >>> 0 >= $25 >>> 0) break L11;\n      $27 = HEAP8[$$07$i$i >> 0] | 0;\n      HEAP8[$$07$i$i >> 0] = HEAP8[$25 >> 0] | 0;\n      HEAP8[$25 >> 0] = $27;\n      $$0$i$i = $25;\n      $$07$i$i = $$07$i$i + 1 | 0;\n     }\n    } while (0);\n    dest = $4;\n    stop = dest + 40 | 0;\n    do {\n     HEAP8[dest >> 0] = 0;\n     dest = dest + 1 | 0;\n    } while ((dest | 0) < (stop | 0));\n    HEAPF64[$vararg_buffer >> 3] = +HEAPF64[$3 >> 3];\n    $31 = _snprintf($4, 40, 16423, $vararg_buffer) | 0;\n    if ($31 >>> 0 > 39) break;\n    HEAP32[$5 >> 2] = 0;\n    HEAP32[$5 + 4 >> 2] = 0;\n    HEAP32[$5 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($5, $4, $31);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($vararg_buffer, $5);\n    $33 = $2 + 4 | 0;\n    $34 = HEAP32[$33 >> 2] | 0;\n    if ($34 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($34, $vararg_buffer);\n     HEAP32[$33 >> 2] = (HEAP32[$33 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $vararg_buffer);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($vararg_buffer);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    $$247$ph = $0 + 21 | 0;\n   } else $$247$ph = $0;\n   $$3 = $$247$ph;\n   break L1;\n  } while (0);\n  $$3 = $0;\n } else $$3 = $0; while (0);\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_121parse_floating_numberIdNS0_2DbEEEPKcS4_S4_RT0_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i = 0, $$049$idx = 0, $$050 = 0, $$07$i$i = 0, $$247$ph = 0, $$3 = 0, $11 = 0, $12 = 0, $17 = 0, $25 = 0, $27 = 0, $3 = 0, $31 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, dest = 0, label = 0, sp = 0, stop = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 80 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80);\n $vararg_buffer = sp + 8 | 0;\n $3 = sp;\n $4 = sp + 48 | 0;\n $5 = sp + 32 | 0;\n L1 : do if (($1 - $0 | 0) >>> 0 > 16) {\n  $$049$idx = 0;\n  $$050 = $3;\n  while (1) {\n   $11 = HEAP8[$0 + $$049$idx >> 0] | 0;\n   $12 = $11 << 24 >> 24;\n   if (($$049$idx | 0) == 16) {\n    label = 6;\n    break;\n   }\n   if (!(_isxdigit($12) | 0)) break;\n   $17 = HEAP8[$0 + ($$049$idx | 1) >> 0] | 0;\n   HEAP8[$$050 >> 0] = ((($12 + -48 | 0) >>> 0 < 10 ? 0 : 9) + $12 << 4) + $17 + (($17 + -48 | 0) >>> 0 < 10 ? 208 : 169);\n   $$049$idx = $$049$idx + 2 | 0;\n   $$050 = $$050 + 1 | 0;\n  }\n  do if ((label | 0) == 6) {\n   if ($11 << 24 >> 24 == 69) {\n    L11 : do if (($$050 | 0) != ($3 | 0)) {\n     $$0$i$i = $$050;\n     $$07$i$i = $3;\n     while (1) {\n      $25 = $$0$i$i + -1 | 0;\n      if ($$07$i$i >>> 0 >= $25 >>> 0) break L11;\n      $27 = HEAP8[$$07$i$i >> 0] | 0;\n      HEAP8[$$07$i$i >> 0] = HEAP8[$25 >> 0] | 0;\n      HEAP8[$25 >> 0] = $27;\n      $$0$i$i = $25;\n      $$07$i$i = $$07$i$i + 1 | 0;\n     }\n    } while (0);\n    dest = $4;\n    stop = dest + 32 | 0;\n    do {\n     HEAP8[dest >> 0] = 0;\n     dest = dest + 1 | 0;\n    } while ((dest | 0) < (stop | 0));\n    HEAPF64[$vararg_buffer >> 3] = +HEAPF64[$3 >> 3];\n    $31 = _snprintf($4, 32, 16428, $vararg_buffer) | 0;\n    if ($31 >>> 0 > 31) break;\n    HEAP32[$5 >> 2] = 0;\n    HEAP32[$5 + 4 >> 2] = 0;\n    HEAP32[$5 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($5, $4, $31);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($vararg_buffer, $5);\n    $33 = $2 + 4 | 0;\n    $34 = HEAP32[$33 >> 2] | 0;\n    if ($34 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($34, $vararg_buffer);\n     HEAP32[$33 >> 2] = (HEAP32[$33 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $vararg_buffer);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($vararg_buffer);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    $$247$ph = $0 + 17 | 0;\n   } else $$247$ph = $0;\n   $$3 = $$247$ph;\n   break L1;\n  } while (0);\n  $$3 = $0;\n } else $$3 = $0; while (0);\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_121parse_floating_numberIfNS0_2DbEEEPKcS4_S4_RT0_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i = 0, $$049$idx = 0, $$050 = 0, $$07$i$i = 0, $$247$ph = 0, $$3 = 0, $11 = 0, $12 = 0, $17 = 0, $25 = 0, $27 = 0, $3 = 0, $32 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, dest = 0, label = 0, sp = 0, stop = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $vararg_buffer = sp;\n $3 = sp + 36 | 0;\n $4 = sp + 40 | 0;\n $5 = sp + 24 | 0;\n L1 : do if (($1 - $0 | 0) >>> 0 > 8) {\n  $$049$idx = 0;\n  $$050 = $3;\n  while (1) {\n   $11 = HEAP8[$0 + $$049$idx >> 0] | 0;\n   $12 = $11 << 24 >> 24;\n   if (($$049$idx | 0) == 8) {\n    label = 6;\n    break;\n   }\n   if (!(_isxdigit($12) | 0)) break;\n   $17 = HEAP8[$0 + ($$049$idx | 1) >> 0] | 0;\n   HEAP8[$$050 >> 0] = ((($12 + -48 | 0) >>> 0 < 10 ? 0 : 9) + $12 << 4) + $17 + (($17 + -48 | 0) >>> 0 < 10 ? 208 : 169);\n   $$049$idx = $$049$idx + 2 | 0;\n   $$050 = $$050 + 1 | 0;\n  }\n  do if ((label | 0) == 6) {\n   if ($11 << 24 >> 24 == 69) {\n    L11 : do if (($$050 | 0) != ($3 | 0)) {\n     $$0$i$i = $$050;\n     $$07$i$i = $3;\n     while (1) {\n      $25 = $$0$i$i + -1 | 0;\n      if ($$07$i$i >>> 0 >= $25 >>> 0) break L11;\n      $27 = HEAP8[$$07$i$i >> 0] | 0;\n      HEAP8[$$07$i$i >> 0] = HEAP8[$25 >> 0] | 0;\n      HEAP8[$25 >> 0] = $27;\n      $$0$i$i = $25;\n      $$07$i$i = $$07$i$i + 1 | 0;\n     }\n    } while (0);\n    dest = $4;\n    stop = dest + 24 | 0;\n    do {\n     HEAP8[dest >> 0] = 0;\n     dest = dest + 1 | 0;\n    } while ((dest | 0) < (stop | 0));\n    HEAPF64[$vararg_buffer >> 3] = +HEAPF32[$3 >> 2];\n    $32 = _snprintf($4, 24, 16431, $vararg_buffer) | 0;\n    if ($32 >>> 0 > 23) break;\n    HEAP32[$5 >> 2] = 0;\n    HEAP32[$5 + 4 >> 2] = 0;\n    HEAP32[$5 + 8 >> 2] = 0;\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($5, $4, $32);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($vararg_buffer, $5);\n    $34 = $2 + 4 | 0;\n    $35 = HEAP32[$34 >> 2] | 0;\n    if ($35 >>> 0 < (HEAP32[$2 + 8 >> 2] | 0) >>> 0) {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($35, $vararg_buffer);\n     HEAP32[$34 >> 2] = (HEAP32[$34 >> 2] | 0) + 24;\n    } else __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($2, $vararg_buffer);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($vararg_buffer);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    $$247$ph = $0 + 9 | 0;\n   } else $$247$ph = $0;\n   $$3 = $$247$ph;\n   break L1;\n  } while (0);\n  $$3 = $0;\n } else $$3 = $0; while (0);\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction _arPattGetIDGlobal($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n $7 = $7 | 0;\n $8 = $8 | 0;\n $9 = +$9;\n $10 = $10 | 0;\n $11 = $11 | 0;\n $12 = $12 | 0;\n $13 = $13 | 0;\n $14 = $14 | 0;\n $15 = $15 | 0;\n $16 = $16 | 0;\n $17 = $17 | 0;\n $18 = $18 | 0;\n var $$0 = 0, $$091 = 0, $$092 = 0, $19 = 0, $20 = 0, $24 = 0, $26 = 0, $28 = 0, $31 = 0, $41 = 0, $45 = 0, $49 = 0, $51 = 0, $56 = 0, $57 = 0, $58 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 12304 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(12304);\n $19 = sp + 8 | 0;\n $20 = sp;\n do if (($2 + -2 | 0) >>> 0 < 3) {\n  if (($16 | 0) != 2830) {\n   $45 = $16 & 255;\n   if ((_arPattGetImage2($1, 2, $45, $45 * 3 | 0, $3, $4, $5, $6, $7, $8, $9, $19) | 0) < 0) {\n    HEAP32[$13 >> 2] = -1;\n    $$091 = -6;\n    break;\n   }\n   $49 = _get_matrix_code($19, $45, $13, $14, $15, $16, $17) | 0;\n   if (!$18) {\n    $$091 = $49;\n    break;\n   }\n   $51 = $18;\n   HEAP32[$51 >> 2] = 0;\n   HEAP32[$51 + 4 >> 2] = 0;\n   $$091 = $49;\n   break;\n  }\n  if ((_arPattGetImage2($1, 2, 14, 42, $3, $4, $5, $6, $7, $8, .875, $19) | 0) < 0) {\n   HEAP32[$13 >> 2] = -1;\n   $$091 = -6;\n   break;\n  }\n  $24 = _get_global_id_code($19, $20, $14, $15, $17) | 0;\n  if (($24 | 0) < 0) {\n   HEAP32[$13 >> 2] = -1;\n   $$091 = $24;\n   break;\n  }\n  $26 = $20;\n  $28 = HEAP32[$26 >> 2] | 0;\n  $31 = HEAP32[$26 + 4 >> 2] | 0;\n  if (($28 | 0) == -1 & ($31 | 0) == -1) {\n   HEAP32[$13 >> 2] = -1;\n   $$091 = -5;\n   break;\n  }\n  HEAP32[$13 >> 2] = ($28 & -32768 | 0) == 0 & 0 == 0 ? $28 & 32767 : 0;\n  if (!$18) $$091 = $24; else {\n   $41 = $18;\n   HEAP32[$41 >> 2] = $28;\n   HEAP32[$41 + 4 >> 2] = $31;\n   $$091 = $24;\n  }\n } else $$091 = 1; while (0);\n L21 : do switch ($2 | 0) {\n case 0:\n case 1:\n case 3:\n case 4:\n  {\n   if (!$0) {\n    HEAP32[$10 >> 2] = -1;\n    $$0 = -1;\n    break L21;\n   }\n   $56 = $0 + 28 | 0;\n   $57 = HEAP32[$56 >> 2] | 0;\n   $58 = $57 << 2;\n   switch ($2 | 0) {\n   case 0:\n   case 3:\n    {\n     if ((_arPattGetImage2($1, 0, $57, $58, $3, $4, $5, $6, $7, $8, $9, $19) | 0) < 0) {\n      HEAP32[$10 >> 2] = -1;\n      $$0 = -6;\n      break L21;\n     } else {\n      $$0 = _pattern_match($0, 0, $19, HEAP32[$56 >> 2] | 0, $10, $11, $12) | 0;\n      break L21;\n     }\n     break;\n    }\n   default:\n    if ((_arPattGetImage2($1, 1, $57, $58, $3, $4, $5, $6, $7, $8, $9, $19) | 0) < 0) {\n     HEAP32[$10 >> 2] = -1;\n     $$0 = -6;\n     break L21;\n    } else {\n     $$0 = _pattern_match($0, 1, $19, HEAP32[$56 >> 2] | 0, $10, $11, $12) | 0;\n     break L21;\n    }\n   }\n   break;\n  }\n default:\n  $$0 = 1;\n } while (0);\n if (($$091 | 0) == 1) $$092 = $$0; else $$092 = ($$0 | 0) == 1 ? $$091 : ($$0 & $$091 | 0) < 0 ? $$0 : 0;\n STACKTOP = sp;\n return $$092 | 0;\n}\n\nfunction _setCamera($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$2 = 0, $10 = 0, $11 = 0, $12 = 0, $16 = 0, $17 = 0, $2 = 0, $22 = 0, $23 = 0, $25 = 0, $26 = 0, $3 = 0, $30 = 0, $6 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_buffer4 = 0, $vararg_buffer6 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $vararg_buffer6 = sp + 24 | 0;\n $vararg_buffer4 = sp + 16 | 0;\n $vararg_buffer2 = sp + 8 | 0;\n $vararg_buffer = sp;\n $2 = sp + 32 | 0;\n $3 = sp + 28 | 0;\n HEAP32[$2 >> 2] = $0;\n HEAP32[$3 >> 2] = $1;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0)) $$2 = -1; else {\n  $6 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0;\n  if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi7ARParamEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17376, $3) | 0)) $$2 = -1; else {\n   $10 = $6 + 8 | 0;\n   _memcpy($10 | 0, __ZNSt3__213unordered_mapIi7ARParamNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17376, $3) | 0, 184) | 0;\n   $11 = HEAP32[$10 >> 2] | 0;\n   $12 = $6 + 208 | 0;\n   $16 = HEAP32[$6 + 12 >> 2] | 0;\n   $17 = $6 + 212 | 0;\n   if (($11 | 0) == (HEAP32[$12 >> 2] | 0)) {\n    if (($16 | 0) != (HEAP32[$17 >> 2] | 0)) label = 5;\n   } else label = 5;\n   if ((label | 0) == 5) {\n    HEAP32[$vararg_buffer >> 2] = $11;\n    HEAP32[$vararg_buffer + 4 >> 2] = $16;\n    _arLog(0, 2, 10408, $vararg_buffer);\n    _arParamChangeSize($10, HEAP32[$12 >> 2] | 0, HEAP32[$17 >> 2] | 0, $10) | 0;\n   }\n   _deleteHandle($6);\n   $22 = _arParamLTCreate($10, 15) | 0;\n   $23 = $6 + 192 | 0;\n   HEAP32[$23 >> 2] = $22;\n   if (!$22) {\n    _arLog(0, 3, 10455, $vararg_buffer2);\n    $$2 = -1;\n    break;\n   }\n   $25 = _arCreateHandle($22) | 0;\n   $26 = $6 + 216 | 0;\n   HEAP32[$26 >> 2] = $25;\n   if (!$25) {\n    _arLog(0, 3, 10493, $vararg_buffer4);\n    $$2 = -1;\n    break;\n   }\n   _arSetPixelFormat($25, HEAP32[$6 + 392 >> 2] | 0) | 0;\n   $30 = _ar3DCreateHandle($10) | 0;\n   HEAP32[$6 + 228 >> 2] = $30;\n   if (!$30) {\n    _arLog(0, 3, 10530, $vararg_buffer6);\n    $$2 = -1;\n    break;\n   } else {\n    _arPattAttach(HEAP32[$26 >> 2] | 0, HEAP32[$6 + 220 >> 2] | 0) | 0;\n    _arglCameraFrustumRH(HEAP32[$23 >> 2] | 0, +HEAPF64[$6 + 232 >> 3], +HEAPF64[$6 + 240 >> 3], $6 + 264 | 0);\n    $$2 = 0;\n    break;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$2 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_125parse_noexcept_expressionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i$i = 0, $$0$i$i$i18 = 0, $$016 = 0, $10 = 0, $11 = 0, $20 = 0, $21 = 0, $22 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $3 = sp + 36 | 0;\n $4 = sp + 24 | 0;\n $5 = sp + 12 | 0;\n $6 = sp;\n $7 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n if (($7 | 0) == ($0 | 0)) $$016 = $0; else {\n  $10 = $2 + 4 | 0;\n  $11 = HEAP32[$10 >> 2] | 0;\n  if ((HEAP32[$2 >> 2] | 0) == ($11 | 0)) $$016 = $0; else {\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $11 + -24 | 0);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 15390) | 0;\n   HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n   HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n   HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n   $$0$i$i$i = 0;\n   while (1) {\n    if (($$0$i$i$i | 0) == 3) break;\n    HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n    $$0$i$i$i = $$0$i$i$i + 1 | 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($5, 15117) | 0;\n   HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n   HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n   HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n   $$0$i$i$i18 = 0;\n   while (1) {\n    if (($$0$i$i$i18 | 0) == 3) break;\n    HEAP32[$5 + ($$0$i$i$i18 << 2) >> 2] = 0;\n    $$0$i$i$i18 = $$0$i$i$i18 + 1 | 0;\n   }\n   $20 = HEAP32[$10 >> 2] | 0;\n   $21 = $20 + -24 | 0;\n   $22 = $21 + 11 | 0;\n   if ((HEAP8[$22 >> 0] | 0) < 0) {\n    $25 = HEAP32[$21 >> 2] | 0;\n    HEAP8[$3 >> 0] = 0;\n    __ZNSt3__211char_traitsIcE6assignERcRKc($25, $3);\n    HEAP32[$20 + -20 >> 2] = 0;\n   } else {\n    HEAP8[$3 >> 0] = 0;\n    __ZNSt3__211char_traitsIcE6assignERcRKc($21, $3);\n    HEAP8[$22 >> 0] = 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($21);\n   HEAP32[$21 >> 2] = HEAP32[$4 >> 2];\n   HEAP32[$21 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n   HEAP32[$21 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n   $$0$i$i$i$i = 0;\n   while (1) {\n    if (($$0$i$i$i$i | 0) == 3) break;\n    HEAP32[$4 + ($$0$i$i$i$i << 2) >> 2] = 0;\n    $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n   $$016 = $7;\n  }\n }\n STACKTOP = sp;\n return $$016 | 0;\n}\n\nfunction _pop_arg_673($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $10 = 0, $108 = 0, $109 = 0.0, $115 = 0, $116 = 0.0, $16 = 0, $17 = 0, $20 = 0, $29 = 0, $30 = 0, $31 = 0, $40 = 0, $41 = 0, $43 = 0, $46 = 0, $47 = 0, $56 = 0, $57 = 0, $59 = 0, $62 = 0, $71 = 0, $72 = 0, $73 = 0, $82 = 0, $83 = 0, $85 = 0, $88 = 0, $9 = 0, $97 = 0, $98 = 0, $99 = 0;\n L1 : do if ($1 >>> 0 <= 20) do switch ($1 | 0) {\n case 9:\n  {\n   $9 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n   $10 = HEAP32[$9 >> 2] | 0;\n   HEAP32[$2 >> 2] = $9 + 4;\n   HEAP32[$0 >> 2] = $10;\n   break L1;\n   break;\n  }\n case 10:\n  {\n   $16 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n   $17 = HEAP32[$16 >> 2] | 0;\n   HEAP32[$2 >> 2] = $16 + 4;\n   $20 = $0;\n   HEAP32[$20 >> 2] = $17;\n   HEAP32[$20 + 4 >> 2] = (($17 | 0) < 0) << 31 >> 31;\n   break L1;\n   break;\n  }\n case 11:\n  {\n   $29 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n   $30 = HEAP32[$29 >> 2] | 0;\n   HEAP32[$2 >> 2] = $29 + 4;\n   $31 = $0;\n   HEAP32[$31 >> 2] = $30;\n   HEAP32[$31 + 4 >> 2] = 0;\n   break L1;\n   break;\n  }\n case 12:\n  {\n   $40 = (HEAP32[$2 >> 2] | 0) + (8 - 1) & ~(8 - 1);\n   $41 = $40;\n   $43 = HEAP32[$41 >> 2] | 0;\n   $46 = HEAP32[$41 + 4 >> 2] | 0;\n   HEAP32[$2 >> 2] = $40 + 8;\n   $47 = $0;\n   HEAP32[$47 >> 2] = $43;\n   HEAP32[$47 + 4 >> 2] = $46;\n   break L1;\n   break;\n  }\n case 13:\n  {\n   $56 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n   $57 = HEAP32[$56 >> 2] | 0;\n   HEAP32[$2 >> 2] = $56 + 4;\n   $59 = ($57 & 65535) << 16 >> 16;\n   $62 = $0;\n   HEAP32[$62 >> 2] = $59;\n   HEAP32[$62 + 4 >> 2] = (($59 | 0) < 0) << 31 >> 31;\n   break L1;\n   break;\n  }\n case 14:\n  {\n   $71 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n   $72 = HEAP32[$71 >> 2] | 0;\n   HEAP32[$2 >> 2] = $71 + 4;\n   $73 = $0;\n   HEAP32[$73 >> 2] = $72 & 65535;\n   HEAP32[$73 + 4 >> 2] = 0;\n   break L1;\n   break;\n  }\n case 15:\n  {\n   $82 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n   $83 = HEAP32[$82 >> 2] | 0;\n   HEAP32[$2 >> 2] = $82 + 4;\n   $85 = ($83 & 255) << 24 >> 24;\n   $88 = $0;\n   HEAP32[$88 >> 2] = $85;\n   HEAP32[$88 + 4 >> 2] = (($85 | 0) < 0) << 31 >> 31;\n   break L1;\n   break;\n  }\n case 16:\n  {\n   $97 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n   $98 = HEAP32[$97 >> 2] | 0;\n   HEAP32[$2 >> 2] = $97 + 4;\n   $99 = $0;\n   HEAP32[$99 >> 2] = $98 & 255;\n   HEAP32[$99 + 4 >> 2] = 0;\n   break L1;\n   break;\n  }\n case 17:\n  {\n   $108 = (HEAP32[$2 >> 2] | 0) + (8 - 1) & ~(8 - 1);\n   $109 = +HEAPF64[$108 >> 3];\n   HEAP32[$2 >> 2] = $108 + 8;\n   HEAPF64[$0 >> 3] = $109;\n   break L1;\n   break;\n  }\n case 18:\n  {\n   $115 = (HEAP32[$2 >> 2] | 0) + (8 - 1) & ~(8 - 1);\n   $116 = +HEAPF64[$115 >> 3];\n   HEAP32[$2 >> 2] = $115 + 8;\n   HEAPF64[$0 >> 3] = $116;\n   break L1;\n   break;\n  }\n default:\n  break L1;\n } while (0); while (0);\n return;\n}\n\nfunction _trinkle($0, $1, $2, $3, $4, $5, $6) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n var $$0$lcssa = 0, $$045$lcssa = 0, $$04551 = 0, $$0455780 = 0, $$046$lcssa = 0, $$04653 = 0, $$0465681 = 0, $$047$lcssa = 0, $$0475582 = 0, $$049 = 0, $$05879 = 0, $$05879$phi = 0, $11 = 0, $12 = 0, $16 = 0, $20 = 0, $24 = 0, $27 = 0, $28 = 0, $35 = 0, $37 = 0, $38 = 0, $47 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 240 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(240);\n $7 = sp + 232 | 0;\n $8 = sp;\n $9 = HEAP32[$3 >> 2] | 0;\n HEAP32[$7 >> 2] = $9;\n $11 = HEAP32[$3 + 4 >> 2] | 0;\n $12 = $7 + 4 | 0;\n HEAP32[$12 >> 2] = $11;\n HEAP32[$8 >> 2] = $0;\n L1 : do if (($9 | 0) != 1 | ($11 | 0) != 0) {\n  $16 = 0 - $1 | 0;\n  $20 = $0 + (0 - (HEAP32[$6 + ($4 << 2) >> 2] | 0)) | 0;\n  if ((FUNCTION_TABLE_iii[$2 & 15]($20, $0) | 0) < 1) {\n   $$0$lcssa = $0;\n   $$045$lcssa = 1;\n   $$046$lcssa = $4;\n   $$047$lcssa = $5;\n   label = 9;\n  } else {\n   $$0455780 = 1;\n   $$0465681 = $4;\n   $$0475582 = ($5 | 0) == 0;\n   $$05879 = $0;\n   $28 = $20;\n   while (1) {\n    if ($$0475582 & ($$0465681 | 0) > 1) {\n     $24 = $$05879 + $16 | 0;\n     $27 = HEAP32[$6 + ($$0465681 + -2 << 2) >> 2] | 0;\n     if ((FUNCTION_TABLE_iii[$2 & 15]($24, $28) | 0) > -1) {\n      $$04551 = $$0455780;\n      $$04653 = $$0465681;\n      $$049 = $$05879;\n      label = 10;\n      break L1;\n     }\n     if ((FUNCTION_TABLE_iii[$2 & 15]($24 + (0 - $27) | 0, $28) | 0) > -1) {\n      $$04551 = $$0455780;\n      $$04653 = $$0465681;\n      $$049 = $$05879;\n      label = 10;\n      break L1;\n     }\n    }\n    $35 = $$0455780 + 1 | 0;\n    HEAP32[$8 + ($$0455780 << 2) >> 2] = $28;\n    $37 = _pntz($7) | 0;\n    _shr($7, $37);\n    $38 = $37 + $$0465681 | 0;\n    if (!((HEAP32[$7 >> 2] | 0) != 1 | (HEAP32[$12 >> 2] | 0) != 0)) {\n     $$04551 = $35;\n     $$04653 = $38;\n     $$049 = $28;\n     label = 10;\n     break L1;\n    }\n    $47 = $28 + (0 - (HEAP32[$6 + ($38 << 2) >> 2] | 0)) | 0;\n    if ((FUNCTION_TABLE_iii[$2 & 15]($47, HEAP32[$8 >> 2] | 0) | 0) < 1) {\n     $$0$lcssa = $28;\n     $$045$lcssa = $35;\n     $$046$lcssa = $38;\n     $$047$lcssa = 0;\n     label = 9;\n     break;\n    } else {\n     $$05879$phi = $28;\n     $$0455780 = $35;\n     $$0465681 = $38;\n     $$0475582 = 1;\n     $28 = $47;\n     $$05879 = $$05879$phi;\n    }\n   }\n  }\n } else {\n  $$0$lcssa = $0;\n  $$045$lcssa = 1;\n  $$046$lcssa = $4;\n  $$047$lcssa = $5;\n  label = 9;\n } while (0);\n if ((label | 0) == 9) if (!$$047$lcssa) {\n  $$04551 = $$045$lcssa;\n  $$04653 = $$046$lcssa;\n  $$049 = $$0$lcssa;\n  label = 10;\n }\n if ((label | 0) == 10) {\n  _cycle($1, $8, $$04551);\n  _sift($$049, $1, $2, $$04653, $6);\n }\n STACKTOP = sp;\n return;\n}\n\nfunction _mbrtowc($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$03952 = 0, $$03952$pn = 0, $$04051 = 0, $$04350 = 0, $$2 = 0, $$lcssa = 0, $$lcssa56 = 0, $12 = 0, $18 = 0, $22 = 0, $26 = 0, $30 = 0, $31 = 0, $34 = 0, $35 = 0, $4 = 0, $43 = 0, $44 = 0, $47 = 0, $49 = 0, $51 = 0, $52 = 0, $53 = 0, $6 = 0, $60 = 0, $spec$select = 0, $spec$select47 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $4 = sp;\n $spec$select = ($3 | 0) == 0 ? 17980 : $3;\n $6 = HEAP32[$spec$select >> 2] | 0;\n L1 : do if (!$1) if (!$6) $$0 = 0; else label = 19; else {\n  $spec$select47 = ($0 | 0) == 0 ? $4 : $0;\n  if (!$2) $$0 = -2; else {\n   if (!$6) {\n    $12 = HEAP8[$1 >> 0] | 0;\n    if ($12 << 24 >> 24 > -1) {\n     HEAP32[$spec$select47 >> 2] = $12 & 255;\n     $$0 = $12 << 24 >> 24 != 0 & 1;\n     break;\n    }\n    $18 = (___pthread_self_910() | 0) + 188 | 0;\n    $22 = HEAP8[$1 >> 0] | 0;\n    if (!(HEAP32[HEAP32[$18 >> 2] >> 2] | 0)) {\n     HEAP32[$spec$select47 >> 2] = $22 << 24 >> 24 & 57343;\n     $$0 = 1;\n     break;\n    }\n    $26 = ($22 & 255) + -194 | 0;\n    if ($26 >>> 0 > 50) {\n     label = 19;\n     break;\n    }\n    $30 = HEAP32[2336 + ($26 << 2) >> 2] | 0;\n    $31 = $2 + -1 | 0;\n    if (!$31) $$2 = $30; else {\n     $$03952 = $1 + 1 | 0;\n     $$04051 = $30;\n     $$04350 = $31;\n     label = 11;\n    }\n   } else {\n    $$03952 = $1;\n    $$04051 = $6;\n    $$04350 = $2;\n    label = 11;\n   }\n   L14 : do if ((label | 0) == 11) {\n    $34 = HEAPU8[$$03952 >> 0] | 0;\n    $35 = $34 >>> 3;\n    if (($35 + -16 | $35 + ($$04051 >> 26)) >>> 0 > 7) {\n     label = 19;\n     break L1;\n    }\n    $43 = $34 + -128 | $$04051 << 6;\n    $44 = $$04350 + -1 | 0;\n    if (($43 | 0) < 0) {\n     $$03952$pn = $$03952;\n     $47 = $43;\n     $53 = $44;\n     while (1) {\n      $$03952$pn = $$03952$pn + 1 | 0;\n      if (!$53) {\n       $$2 = $47;\n       break L14;\n      }\n      $49 = HEAP8[$$03952$pn >> 0] | 0;\n      if (($49 & -64) << 24 >> 24 != -128) {\n       label = 19;\n       break L1;\n      }\n      $51 = ($49 & 255) + -128 | $47 << 6;\n      $52 = $53 + -1 | 0;\n      if (($51 | 0) >= 0) {\n       $$lcssa = $52;\n       $$lcssa56 = $51;\n       break;\n      } else {\n       $47 = $51;\n       $53 = $52;\n      }\n     }\n    } else {\n     $$lcssa = $44;\n     $$lcssa56 = $43;\n    }\n    HEAP32[$spec$select >> 2] = 0;\n    HEAP32[$spec$select47 >> 2] = $$lcssa56;\n    $$0 = $2 - $$lcssa | 0;\n    break L1;\n   } while (0);\n   HEAP32[$spec$select >> 2] = $$2;\n   $$0 = -2;\n  }\n } while (0);\n if ((label | 0) == 19) {\n  HEAP32[$spec$select >> 2] = 0;\n  $60 = ___errno_location() | 0;\n  HEAP32[$60 >> 2] = 84;\n  $$0 = -1;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_117parse_typeid_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i30 = 0, $$025 = 0, $$127 = 0, $14 = 0, $16 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 40 | 0;\n $4 = sp + 12 | 0;\n $5 = sp + 24 | 0;\n $6 = sp;\n L1 : do if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 116) {\n  $14 = HEAP8[$0 + 1 >> 0] | 0;\n  switch ($14 << 24 >> 24) {\n  case 105:\n  case 101:\n   break;\n  default:\n   {\n    $$127 = $0;\n    break L1;\n   }\n  }\n  $16 = $0 + 2 | 0;\n  if ($14 << 24 >> 24 == 101) $$025 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0; else $$025 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0;\n  if (($$025 | 0) == ($16 | 0)) $$127 = $0; else {\n   $21 = $2 + 4 | 0;\n   $22 = HEAP32[$21 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($22 | 0)) $$127 = $0; else {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $22 + -24 | 0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 15322) | 0;\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($5, 15117) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i30 = 0;\n    while (1) {\n     if (($$0$i$i$i30 | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i30 << 2) >> 2] = 0;\n     $$0$i$i$i30 = $$0$i$i$i30 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $4);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$21 >> 2] | 0) + -24 | 0, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    $$127 = $$025;\n   }\n  }\n } else $$127 = $0; else $$127 = $0; while (0);\n STACKTOP = sp;\n return $$127 | 0;\n}\n\nfunction _arImageProcLumaHistAndBoxFilterWithBias($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$073 = 0, $$074 = 0, $$075 = 0, $$076 = 0, $$078 = 0, $$082 = 0, $$1 = 0, $$177 = 0, $$179 = 0, $$2 = 0, $$280 = 0, $$3 = 0, $$381 = 0, $$pre$phi86Z2D = 0, $$pre$phiZ2D = 0, $10 = 0, $13 = 0, $15 = 0, $16 = 0, $17 = 0, $19 = 0, $22 = 0, $26 = 0, $28 = 0, $4 = 0, $44 = 0, $50 = 0, $53 = 0, $8 = 0;\n $4 = _arImageProcLumaHist($0, $1) | 0;\n L1 : do if (($4 | 0) < 0) $$0 = $4; else {\n  if (!(HEAP32[$0 >> 2] | 0)) {\n   $8 = $0 + 4 | 0;\n   $10 = $0 + 8 | 0;\n   $13 = _malloc(Math_imul(HEAP32[$10 >> 2] | 0, HEAP32[$8 >> 2] | 0) | 0) | 0;\n   HEAP32[$0 >> 2] = $13;\n   if (!$13) {\n    $$0 = -1;\n    break;\n   } else {\n    $$pre$phi86Z2D = $8;\n    $$pre$phiZ2D = $10;\n   }\n  } else {\n   $$pre$phi86Z2D = $0 + 4 | 0;\n   $$pre$phiZ2D = $0 + 8 | 0;\n  }\n  $15 = $2 >> 1;\n  $16 = 0 - $15 | 0;\n  $$082 = 0;\n  while (1) {\n   $17 = HEAP32[$$pre$phiZ2D >> 2] | 0;\n   if (($$082 | 0) >= ($17 | 0)) break;\n   $$073 = 0;\n   while (1) {\n    $19 = HEAP32[$$pre$phi86Z2D >> 2] | 0;\n    if (($$073 | 0) >= ($19 | 0)) break;\n    $$074 = $16;\n    $$076 = 0;\n    $$078 = 0;\n    while (1) {\n     if (($$074 | 0) > ($15 | 0)) break;\n     $22 = $$074 + $$082 | 0;\n     L16 : do if (($22 | 0) < 0) {\n      $$3 = $$076;\n      $$381 = $$078;\n     } else if (($22 | 0) < (HEAP32[$$pre$phiZ2D >> 2] | 0)) {\n      $26 = Math_imul($22, $19) | 0;\n      $$075 = $16;\n      $$177 = $$076;\n      $$179 = $$078;\n      while (1) {\n       if (($$075 | 0) > ($15 | 0)) {\n        $$3 = $$177;\n        $$381 = $$179;\n        break L16;\n       }\n       $28 = $$075 + $$073 | 0;\n       if (($28 | 0) > -1 & ($28 | 0) < ($19 | 0)) {\n        $$2 = $$177 + 1 | 0;\n        $$280 = $$179 + (HEAPU8[$1 + ($28 + $26) >> 0] | 0) | 0;\n       } else {\n        $$2 = $$177;\n        $$280 = $$179;\n       }\n       $$075 = $$075 + 1 | 0;\n       $$177 = $$2;\n       $$179 = $$280;\n      }\n     } else {\n      $$3 = $$076;\n      $$381 = $$078;\n     } while (0);\n     $$074 = $$074 + 1 | 0;\n     $$076 = $$3;\n     $$078 = $$381;\n    }\n    $44 = (HEAP32[$0 >> 2] | 0) + ((Math_imul($19, $$082) | 0) + $$073) | 0;\n    HEAP8[$44 >> 0] = ($$078 | 0) / ($$076 | 0) | 0;\n    $$073 = $$073 + 1 | 0;\n   }\n   $$082 = $$082 + 1 | 0;\n  }\n  if (!$3) $$0 = 0; else {\n   $$1 = 0;\n   $50 = $17;\n   while (1) {\n    if (($$1 | 0) >= (Math_imul($50, HEAP32[$$pre$phi86Z2D >> 2] | 0) | 0)) {\n     $$0 = 0;\n     break L1;\n    }\n    $53 = (HEAP32[$0 >> 2] | 0) + $$1 | 0;\n    HEAP8[$53 >> 0] = (HEAPU8[$53 >> 0] | 0) + $3;\n    $$1 = $$1 + 1 | 0;\n    $50 = HEAP32[$$pre$phiZ2D >> 2] | 0;\n   }\n  }\n } while (0);\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_114parse_decltypeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i30 = 0, $$127 = 0, $16 = 0, $17 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 40 | 0;\n $4 = sp + 12 | 0;\n $5 = sp + 24 | 0;\n $6 = sp;\n L1 : do if (($1 - $0 | 0) > 3) if ((HEAP8[$0 >> 0] | 0) == 68) {\n  switch (HEAP8[$0 + 1 >> 0] | 0) {\n  case 84:\n  case 116:\n   break;\n  default:\n   {\n    $$127 = $0;\n    break L1;\n   }\n  }\n  $16 = $0 + 2 | 0;\n  $17 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0;\n  if (($17 | 0) == ($16 | 0) | ($17 | 0) == ($1 | 0)) $$127 = $0; else if ((HEAP8[$17 >> 0] | 0) == 69) {\n   $23 = $2 + 4 | 0;\n   $24 = HEAP32[$23 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($24 | 0)) $$127 = $0; else {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $24 + -24 | 0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 16435) | 0;\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($5, 15117) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i30 = 0;\n    while (1) {\n     if (($$0$i$i$i30 | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i30 << 2) >> 2] = 0;\n     $$0$i$i$i30 = $$0$i$i$i30 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $4);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$23 >> 2] | 0) + -24 | 0, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    $$127 = $17 + 1 | 0;\n   }\n  } else $$127 = $0;\n } else $$127 = $0; else $$127 = $0; while (0);\n STACKTOP = sp;\n return $$127 | 0;\n}\n\nfunction _arPattCreateHandle2($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$043 = 0, $$044 = 0, $12 = 0, $13 = 0, $16 = 0, $17 = 0, $19 = 0, $20 = 0, $23 = 0, $26 = 0, $27 = 0, $28 = 0, $31 = 0, $33 = 0, $34 = 0, $37 = 0, $4 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer11 = 0, $vararg_buffer13 = 0, $vararg_buffer3 = 0, $vararg_buffer5 = 0, $vararg_buffer7 = 0, $vararg_buffer9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $vararg_buffer13 = sp + 56 | 0;\n $vararg_buffer11 = sp + 48 | 0;\n $vararg_buffer9 = sp + 40 | 0;\n $vararg_buffer7 = sp + 32 | 0;\n $vararg_buffer5 = sp + 24 | 0;\n $vararg_buffer3 = sp + 16 | 0;\n $vararg_buffer1 = sp + 8 | 0;\n $vararg_buffer = sp;\n L1 : do if (($0 + -16 | 0) >>> 0 > 48 | ($1 | 0) < 1) $$044 = 0; else {\n  $4 = _malloc(32) | 0;\n  if (!$4) {\n   _arLog(0, 3, 5051, $vararg_buffer);\n   _exit(1);\n  }\n  HEAP32[$4 >> 2] = 0;\n  HEAP32[$4 + 4 >> 2] = $1;\n  HEAP32[$4 + 28 >> 2] = $0;\n  $9 = _malloc($1 << 2) | 0;\n  HEAP32[$4 + 8 >> 2] = $9;\n  if (!$9) {\n   _arLog(0, 3, 5051, $vararg_buffer1);\n   _exit(1);\n  }\n  $12 = $1 << 4;\n  $13 = _malloc($12) | 0;\n  HEAP32[$4 + 12 >> 2] = $13;\n  if (!$13) {\n   _arLog(0, 3, 5051, $vararg_buffer3);\n   _exit(1);\n  }\n  $16 = _malloc($12) | 0;\n  $17 = $4 + 20 | 0;\n  HEAP32[$17 >> 2] = $16;\n  if (!$16) {\n   _arLog(0, 3, 5051, $vararg_buffer5);\n   _exit(1);\n  }\n  $19 = $1 << 5;\n  $20 = _malloc($19) | 0;\n  HEAP32[$4 + 16 >> 2] = $20;\n  if (!$20) {\n   _arLog(0, 3, 5051, $vararg_buffer7);\n   _exit(1);\n  }\n  $23 = _malloc($19) | 0;\n  HEAP32[$4 + 24 >> 2] = $23;\n  if (!$23) {\n   _arLog(0, 3, 5051, $vararg_buffer9);\n   _exit(1);\n  }\n  $26 = Math_imul($0, $0) | 0;\n  $27 = $26 * 12 | 0;\n  $28 = $26 << 2;\n  $$043 = 0;\n  L21 : while (1) {\n   if (($$043 | 0) >= ($1 | 0)) {\n    $$044 = $4;\n    break L1;\n   }\n   HEAP32[$9 + ($$043 << 2) >> 2] = 0;\n   $31 = $$043 << 2;\n   $$0 = 0;\n   while (1) {\n    if ($$0 >>> 0 >= 4) break;\n    $33 = _malloc($27) | 0;\n    $34 = $$0 + $31 | 0;\n    HEAP32[$13 + ($34 << 2) >> 2] = $33;\n    if (!$33) {\n     label = 19;\n     break L21;\n    }\n    $37 = _malloc($28) | 0;\n    HEAP32[(HEAP32[$17 >> 2] | 0) + ($34 << 2) >> 2] = $37;\n    if (!$37) {\n     label = 21;\n     break L21;\n    } else $$0 = $$0 + 1 | 0;\n   }\n   $$043 = $$043 + 1 | 0;\n  }\n  if ((label | 0) == 19) {\n   _arLog(0, 3, 5051, $vararg_buffer11);\n   _exit(1);\n  } else if ((label | 0) == 21) {\n   _arLog(0, 3, 5051, $vararg_buffer13);\n   _exit(1);\n  }\n } while (0);\n STACKTOP = sp;\n return $$044 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_137parse_sizeof_function_param_pack_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i28 = 0, $$125 = 0, $16 = 0, $19 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 40 | 0;\n $4 = sp + 12 | 0;\n $5 = sp + 24 | 0;\n $6 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 115) if ((HEAP8[$0 + 1 >> 0] | 0) == 90) {\n  $16 = $0 + 2 | 0;\n  if ((HEAP8[$16 >> 0] | 0) == 102) {\n   $19 = __ZN10__cxxabiv112_GLOBAL__N_120parse_function_paramINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0;\n   if (($19 | 0) == ($16 | 0)) $$125 = $0; else {\n    $22 = $2 + 4 | 0;\n    $23 = HEAP32[$22 >> 2] | 0;\n    if ((HEAP32[$2 >> 2] | 0) == ($23 | 0)) $$125 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $23 + -24 | 0);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 15330) | 0;\n     HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n     HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n     HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n     $$0$i$i$i = 0;\n     while (1) {\n      if (($$0$i$i$i | 0) == 3) break;\n      HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n      $$0$i$i$i = $$0$i$i$i + 1 | 0;\n     }\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($5, 15117) | 0;\n     HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n     HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n     HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n     $$0$i$i$i28 = 0;\n     while (1) {\n      if (($$0$i$i$i28 | 0) == 3) break;\n      HEAP32[$5 + ($$0$i$i$i28 << 2) >> 2] = 0;\n      $$0$i$i$i28 = $$0$i$i$i28 + 1 | 0;\n     }\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $4);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$22 >> 2] | 0) + -24 | 0, $3);\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n     $$125 = $19;\n    }\n   }\n  } else $$125 = $0;\n } else $$125 = $0; else $$125 = $0; else $$125 = $0;\n STACKTOP = sp;\n return $$125 | 0;\n}\n\nfunction _memchr($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$lcssa = 0, $$035$lcssa = 0, $$035$lcssa65 = 0, $$03555 = 0, $$036$lcssa = 0, $$036$lcssa64 = 0, $$03654 = 0, $$046 = 0, $$137$lcssa = 0, $$137$lcssa66 = 0, $$13745 = 0, $$140 = 0, $$23839 = 0, $$in = 0, $$lcssa = 0, $11 = 0, $12 = 0, $16 = 0, $18 = 0, $20 = 0, $23 = 0, $29 = 0, $3 = 0, $30 = 0, $39 = 0, $7 = 0, $8 = 0, label = 0;\n $3 = $1 & 255;\n $7 = ($2 | 0) != 0;\n L1 : do if ($7 & ($0 & 3 | 0) != 0) {\n  $8 = $1 & 255;\n  $$03555 = $0;\n  $$03654 = $2;\n  while (1) {\n   if ((HEAP8[$$03555 >> 0] | 0) == $8 << 24 >> 24) {\n    $$035$lcssa65 = $$03555;\n    $$036$lcssa64 = $$03654;\n    label = 6;\n    break L1;\n   }\n   $11 = $$03555 + 1 | 0;\n   $12 = $$03654 + -1 | 0;\n   $16 = ($12 | 0) != 0;\n   if ($16 & ($11 & 3 | 0) != 0) {\n    $$03555 = $11;\n    $$03654 = $12;\n   } else {\n    $$035$lcssa = $11;\n    $$036$lcssa = $12;\n    $$lcssa = $16;\n    label = 5;\n    break;\n   }\n  }\n } else {\n  $$035$lcssa = $0;\n  $$036$lcssa = $2;\n  $$lcssa = $7;\n  label = 5;\n } while (0);\n if ((label | 0) == 5) if ($$lcssa) {\n  $$035$lcssa65 = $$035$lcssa;\n  $$036$lcssa64 = $$036$lcssa;\n  label = 6;\n } else label = 16;\n L8 : do if ((label | 0) == 6) {\n  $18 = $1 & 255;\n  if ((HEAP8[$$035$lcssa65 >> 0] | 0) == $18 << 24 >> 24) if (!$$036$lcssa64) {\n   label = 16;\n   break;\n  } else {\n   $39 = $$035$lcssa65;\n   break;\n  }\n  $20 = Math_imul($3, 16843009) | 0;\n  L13 : do if ($$036$lcssa64 >>> 0 > 3) {\n   $$046 = $$035$lcssa65;\n   $$13745 = $$036$lcssa64;\n   while (1) {\n    $23 = HEAP32[$$046 >> 2] ^ $20;\n    if (($23 & -2139062144 ^ -2139062144) & $23 + -16843009 | 0) {\n     $$137$lcssa66 = $$13745;\n     $$in = $$046;\n     break L13;\n    }\n    $29 = $$046 + 4 | 0;\n    $30 = $$13745 + -4 | 0;\n    if ($30 >>> 0 > 3) {\n     $$046 = $29;\n     $$13745 = $30;\n    } else {\n     $$0$lcssa = $29;\n     $$137$lcssa = $30;\n     label = 11;\n     break;\n    }\n   }\n  } else {\n   $$0$lcssa = $$035$lcssa65;\n   $$137$lcssa = $$036$lcssa64;\n   label = 11;\n  } while (0);\n  if ((label | 0) == 11) if (!$$137$lcssa) {\n   label = 16;\n   break;\n  } else {\n   $$137$lcssa66 = $$137$lcssa;\n   $$in = $$0$lcssa;\n  }\n  $$140 = $$in;\n  $$23839 = $$137$lcssa66;\n  while (1) {\n   if ((HEAP8[$$140 >> 0] | 0) == $18 << 24 >> 24) {\n    $39 = $$140;\n    break L8;\n   }\n   $$23839 = $$23839 + -1 | 0;\n   if (!$$23839) {\n    label = 16;\n    break;\n   } else $$140 = $$140 + 1 | 0;\n  }\n } while (0);\n if ((label | 0) == 16) $39 = 0;\n return $39 | 0;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE8__rehashEj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$054$ph$ph = 0, $$055 = 0, $$056$ph = 0, $$056$ph$ph = 0, $$058 = 0, $10 = 0, $11 = 0, $17 = 0, $18 = 0, $2 = 0, $20 = 0, $26 = 0, $29 = 0, $34 = 0, $36 = 0, $39 = 0, $40 = 0, $5 = 0, $54 = 0, $7 = 0, $8 = 0;\n $2 = $0 + 4 | 0;\n L1 : do if (!$1) {\n  $54 = HEAP32[$0 >> 2] | 0;\n  HEAP32[$0 >> 2] = 0;\n  if ($54 | 0) __ZdlPv($54);\n  HEAP32[$2 >> 2] = 0;\n } else {\n  if ($1 >>> 0 > 1073741823) {\n   $5 = ___cxa_allocate_exception(8) | 0;\n   __ZNSt11logic_errorC2EPKc($5, 7822);\n   HEAP32[$5 >> 2] = 3444;\n   ___cxa_throw($5 | 0, 272, 6);\n  }\n  $7 = __Znwj($1 << 2) | 0;\n  $8 = HEAP32[$0 >> 2] | 0;\n  HEAP32[$0 >> 2] = $7;\n  if ($8 | 0) __ZdlPv($8);\n  HEAP32[$2 >> 2] = $1;\n  $$058 = 0;\n  while (1) {\n   if (($$058 | 0) == ($1 | 0)) break;\n   HEAP32[(HEAP32[$0 >> 2] | 0) + ($$058 << 2) >> 2] = 0;\n   $$058 = $$058 + 1 | 0;\n  }\n  $10 = $0 + 8 | 0;\n  $11 = HEAP32[$10 >> 2] | 0;\n  if ($11 | 0) {\n   $17 = HEAP32[$11 + 4 >> 2] | 0;\n   $18 = $1 + -1 | 0;\n   $20 = ($18 & $1 | 0) == 0;\n   if ($20) $26 = $17 & $18; else if ($17 >>> 0 < $1 >>> 0) $26 = $17; else $26 = ($17 >>> 0) % ($1 >>> 0) | 0;\n   HEAP32[(HEAP32[$0 >> 2] | 0) + ($26 << 2) >> 2] = $10;\n   $$054$ph$ph = $26;\n   $$056$ph$ph = $11;\n   while (1) {\n    $$056$ph = $$056$ph$ph;\n    L25 : while (1) {\n     while (1) {\n      $$055 = HEAP32[$$056$ph >> 2] | 0;\n      if (!$$055) break L1;\n      $29 = HEAP32[$$055 + 4 >> 2] | 0;\n      if ($20) $34 = $29 & $18; else if ($29 >>> 0 < $1 >>> 0) $34 = $29; else $34 = ($29 >>> 0) % ($1 >>> 0) | 0;\n      if (($34 | 0) == ($$054$ph$ph | 0)) break;\n      $36 = (HEAP32[$0 >> 2] | 0) + ($34 << 2) | 0;\n      if (!(HEAP32[$36 >> 2] | 0)) break L25;\n      $39 = $$055 + 8 | 0;\n      $$0 = $$055;\n      while (1) {\n       $40 = HEAP32[$$0 >> 2] | 0;\n       if (!$40) break;\n       if ((HEAP32[$39 >> 2] | 0) == (HEAP32[$40 + 8 >> 2] | 0)) $$0 = $40; else break;\n      }\n      HEAP32[$$056$ph >> 2] = $40;\n      HEAP32[$$0 >> 2] = HEAP32[HEAP32[(HEAP32[$0 >> 2] | 0) + ($34 << 2) >> 2] >> 2];\n      HEAP32[HEAP32[(HEAP32[$0 >> 2] | 0) + ($34 << 2) >> 2] >> 2] = $$055;\n     }\n     $$056$ph = $$055;\n    }\n    HEAP32[$36 >> 2] = $$056$ph;\n    $$054$ph$ph = $34;\n    $$056$ph$ph = $$055;\n   }\n  }\n } while (0);\n return;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi7ARParamEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE8__rehashEj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$054$ph$ph = 0, $$055 = 0, $$056$ph = 0, $$056$ph$ph = 0, $$058 = 0, $10 = 0, $11 = 0, $17 = 0, $18 = 0, $2 = 0, $20 = 0, $26 = 0, $29 = 0, $34 = 0, $36 = 0, $39 = 0, $40 = 0, $5 = 0, $54 = 0, $7 = 0, $8 = 0;\n $2 = $0 + 4 | 0;\n L1 : do if (!$1) {\n  $54 = HEAP32[$0 >> 2] | 0;\n  HEAP32[$0 >> 2] = 0;\n  if ($54 | 0) __ZdlPv($54);\n  HEAP32[$2 >> 2] = 0;\n } else {\n  if ($1 >>> 0 > 1073741823) {\n   $5 = ___cxa_allocate_exception(8) | 0;\n   __ZNSt11logic_errorC2EPKc($5, 7822);\n   HEAP32[$5 >> 2] = 3444;\n   ___cxa_throw($5 | 0, 272, 6);\n  }\n  $7 = __Znwj($1 << 2) | 0;\n  $8 = HEAP32[$0 >> 2] | 0;\n  HEAP32[$0 >> 2] = $7;\n  if ($8 | 0) __ZdlPv($8);\n  HEAP32[$2 >> 2] = $1;\n  $$058 = 0;\n  while (1) {\n   if (($$058 | 0) == ($1 | 0)) break;\n   HEAP32[(HEAP32[$0 >> 2] | 0) + ($$058 << 2) >> 2] = 0;\n   $$058 = $$058 + 1 | 0;\n  }\n  $10 = $0 + 8 | 0;\n  $11 = HEAP32[$10 >> 2] | 0;\n  if ($11 | 0) {\n   $17 = HEAP32[$11 + 4 >> 2] | 0;\n   $18 = $1 + -1 | 0;\n   $20 = ($18 & $1 | 0) == 0;\n   if ($20) $26 = $17 & $18; else if ($17 >>> 0 < $1 >>> 0) $26 = $17; else $26 = ($17 >>> 0) % ($1 >>> 0) | 0;\n   HEAP32[(HEAP32[$0 >> 2] | 0) + ($26 << 2) >> 2] = $10;\n   $$054$ph$ph = $26;\n   $$056$ph$ph = $11;\n   while (1) {\n    $$056$ph = $$056$ph$ph;\n    L25 : while (1) {\n     while (1) {\n      $$055 = HEAP32[$$056$ph >> 2] | 0;\n      if (!$$055) break L1;\n      $29 = HEAP32[$$055 + 4 >> 2] | 0;\n      if ($20) $34 = $29 & $18; else if ($29 >>> 0 < $1 >>> 0) $34 = $29; else $34 = ($29 >>> 0) % ($1 >>> 0) | 0;\n      if (($34 | 0) == ($$054$ph$ph | 0)) break;\n      $36 = (HEAP32[$0 >> 2] | 0) + ($34 << 2) | 0;\n      if (!(HEAP32[$36 >> 2] | 0)) break L25;\n      $39 = $$055 + 8 | 0;\n      $$0 = $$055;\n      while (1) {\n       $40 = HEAP32[$$0 >> 2] | 0;\n       if (!$40) break;\n       if ((HEAP32[$39 >> 2] | 0) == (HEAP32[$40 + 8 >> 2] | 0)) $$0 = $40; else break;\n      }\n      HEAP32[$$056$ph >> 2] = $40;\n      HEAP32[$$0 >> 2] = HEAP32[HEAP32[(HEAP32[$0 >> 2] | 0) + ($34 << 2) >> 2] >> 2];\n      HEAP32[HEAP32[(HEAP32[$0 >> 2] | 0) + ($34 << 2) >> 2] >> 2] = $$055;\n     }\n     $$056$ph = $$055;\n    }\n    HEAP32[$36 >> 2] = $$056$ph;\n    $$054$ph$ph = $34;\n    $$056$ph$ph = $$055;\n   }\n  }\n } while (0);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_122parse_sizeof_expr_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i27 = 0, $$124 = 0, $16 = 0, $17 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 40 | 0;\n $4 = sp + 12 | 0;\n $5 = sp + 24 | 0;\n $6 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 115) if ((HEAP8[$0 + 1 >> 0] | 0) == 122) {\n  $16 = $0 + 2 | 0;\n  $17 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0;\n  if (($17 | 0) == ($16 | 0)) $$124 = $0; else {\n   $20 = $2 + 4 | 0;\n   $21 = HEAP32[$20 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($21 | 0)) $$124 = $0; else {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $21 + -24 | 0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 15344) | 0;\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($5, 15117) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i27 = 0;\n    while (1) {\n     if (($$0$i$i$i27 | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i27 << 2) >> 2] = 0;\n     $$0$i$i$i27 = $$0$i$i$i27 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $4);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$20 >> 2] | 0) + -24 | 0, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    $$124 = $17;\n   }\n  }\n } else $$124 = $0; else $$124 = $0; else $$124 = $0;\n STACKTOP = sp;\n return $$124 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_122parse_sizeof_type_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i27 = 0, $$124 = 0, $16 = 0, $17 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp + 40 | 0;\n $4 = sp + 12 | 0;\n $5 = sp + 24 | 0;\n $6 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 115) if ((HEAP8[$0 + 1 >> 0] | 0) == 116) {\n  $16 = $0 + 2 | 0;\n  $17 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($16, $1, $2) | 0;\n  if (($17 | 0) == ($16 | 0)) $$124 = $0; else {\n   $20 = $2 + 4 | 0;\n   $21 = HEAP32[$20 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($21 | 0)) $$124 = $0; else {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($6, $21 + -24 | 0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($6, 0, 15344) | 0;\n    HEAP32[$5 >> 2] = HEAP32[$6 >> 2];\n    HEAP32[$5 + 4 >> 2] = HEAP32[$6 + 4 >> 2];\n    HEAP32[$5 + 8 >> 2] = HEAP32[$6 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$6 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($5, 15117) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i27 = 0;\n    while (1) {\n     if (($$0$i$i$i27 | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i27 << 2) >> 2] = 0;\n     $$0$i$i$i27 = $$0$i$i$i27 + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $4);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$20 >> 2] | 0) + -24 | 0, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($6);\n    $$124 = $17;\n   }\n  }\n } else $$124 = $0; else $$124 = $0; else $$124 = $0;\n STACKTOP = sp;\n return $$124 | 0;\n}\n\nfunction _arParamChangeSize($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$0103 = 0, $12 = 0.0, $27 = 0, $7 = 0.0, label = 0;\n $7 = +($1 | 0) / +(HEAP32[$0 >> 2] | 0);\n $12 = +($2 | 0) / +(HEAP32[$0 + 4 >> 2] | 0);\n HEAP32[$3 >> 2] = $1;\n HEAP32[$3 + 4 >> 2] = $2;\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) == 4) break;\n  HEAPF64[$3 + 8 + ($$0 << 3) >> 3] = $7 * +HEAPF64[$0 + 8 + ($$0 << 3) >> 3];\n  HEAPF64[$3 + 40 + ($$0 << 3) >> 3] = $12 * +HEAPF64[$0 + 40 + ($$0 << 3) >> 3];\n  HEAPF64[$3 + 72 + ($$0 << 3) >> 3] = +HEAPF64[$0 + 72 + ($$0 << 3) >> 3];\n  $$0 = $$0 + 1 | 0;\n }\n $27 = HEAP32[$0 + 176 >> 2] | 0;\n switch ($27 | 0) {\n case 4:\n  {\n   HEAPF64[$3 + 104 >> 3] = +HEAPF64[$0 + 104 >> 3];\n   HEAPF64[$3 + 112 >> 3] = +HEAPF64[$0 + 112 >> 3];\n   HEAPF64[$3 + 120 >> 3] = +HEAPF64[$0 + 120 >> 3];\n   HEAPF64[$3 + 128 >> 3] = +HEAPF64[$0 + 128 >> 3];\n   HEAPF64[$3 + 136 >> 3] = $7 * +HEAPF64[$0 + 136 >> 3];\n   HEAPF64[$3 + 144 >> 3] = $12 * +HEAPF64[$0 + 144 >> 3];\n   HEAPF64[$3 + 152 >> 3] = $7 * +HEAPF64[$0 + 152 >> 3];\n   HEAPF64[$3 + 160 >> 3] = $12 * +HEAPF64[$0 + 160 >> 3];\n   HEAPF64[$3 + 168 >> 3] = +HEAPF64[$0 + 168 >> 3];\n   label = 9;\n   break;\n  }\n case 3:\n  {\n   HEAPF64[$3 + 104 >> 3] = $7 * +HEAPF64[$0 + 104 >> 3];\n   HEAPF64[$3 + 112 >> 3] = $12 * +HEAPF64[$0 + 112 >> 3];\n   HEAPF64[$3 + 120 >> 3] = +HEAPF64[$0 + 120 >> 3];\n   HEAPF64[$3 + 128 >> 3] = +HEAPF64[$0 + 128 >> 3];\n   HEAPF64[$3 + 136 >> 3] = +HEAPF64[$0 + 136 >> 3] / ($7 * $12);\n   HEAPF64[$3 + 144 >> 3] = +HEAPF64[$0 + 144 >> 3] / ($12 * ($7 * $7 * $12));\n   label = 9;\n   break;\n  }\n case 2:\n  {\n   HEAPF64[$3 + 104 >> 3] = $7 * +HEAPF64[$0 + 104 >> 3];\n   HEAPF64[$3 + 112 >> 3] = $12 * +HEAPF64[$0 + 112 >> 3];\n   HEAPF64[$3 + 120 >> 3] = +HEAPF64[$0 + 120 >> 3];\n   HEAPF64[$3 + 128 >> 3] = +HEAPF64[$0 + 128 >> 3] / ($7 * $12);\n   HEAPF64[$3 + 136 >> 3] = +HEAPF64[$0 + 136 >> 3] / ($12 * ($7 * $7 * $12));\n   label = 9;\n   break;\n  }\n case 1:\n  {\n   HEAPF64[$3 + 104 >> 3] = $7 * +HEAPF64[$0 + 104 >> 3];\n   HEAPF64[$3 + 112 >> 3] = $12 * +HEAPF64[$0 + 112 >> 3];\n   HEAPF64[$3 + 120 >> 3] = +HEAPF64[$0 + 120 >> 3];\n   HEAPF64[$3 + 128 >> 3] = +HEAPF64[$0 + 128 >> 3] / ($7 * $12);\n   label = 9;\n   break;\n  }\n default:\n  $$0103 = -1;\n }\n if ((label | 0) == 9) {\n  HEAP32[$3 + 176 >> 2] = $27;\n  $$0103 = 0;\n }\n return $$0103 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE23__append_forward_unsafeIPKcEERS7_T_SC_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$040 = 0, $15 = 0, $22 = 0, $23 = 0, $26 = 0, $27 = 0, $3 = 0, $35 = 0, $36 = 0, $4 = 0, $44 = 0, $49 = 0, $5 = 0, $6 = 0, $7 = 0, $scevgep5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = $1;\n $4 = sp;\n $5 = $0 + 11 | 0;\n $6 = HEAP8[$5 >> 0] | 0;\n $7 = $6 << 24 >> 24 < 0;\n if ($7) {\n  $35 = (HEAP32[$0 + 8 >> 2] & 2147483647) + -1 | 0;\n  $36 = HEAP32[$0 + 4 >> 2] | 0;\n } else {\n  $35 = 10;\n  $36 = $6 & 255;\n }\n $15 = $2 - $3 | 0;\n do if ($15 | 0) {\n  if ($7) {\n   $22 = HEAP32[$0 >> 2] | 0;\n   $23 = HEAP32[$0 + 4 >> 2] | 0;\n  } else {\n   $22 = $0;\n   $23 = $6 & 255;\n  }\n  if (__ZNSt3__214__ptr_in_rangeIcEEbPKT_S3_S3_($1, $22, $22 + $23 | 0) | 0) {\n   HEAP32[$4 >> 2] = 0;\n   HEAP32[$4 + 4 >> 2] = 0;\n   HEAP32[$4 + 8 >> 2] = 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($4, $1, $2);\n   $26 = HEAP8[$4 + 11 >> 0] | 0;\n   $27 = $26 << 24 >> 24 < 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($0, $27 ? HEAP32[$4 >> 2] | 0 : $4, $27 ? HEAP32[$4 + 4 >> 2] | 0 : $26 & 255) | 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n   break;\n  }\n  if (($35 - $36 | 0) >>> 0 < $15 >>> 0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9__grow_byEjjjjjj($0, $35, $36 + $15 - $35 | 0, $36, $36, 0);\n  if ((HEAP8[$5 >> 0] | 0) < 0) $44 = HEAP32[$0 >> 2] | 0; else $44 = $0;\n  $scevgep5 = $2 + ($36 - $3) | 0;\n  $$0 = $44 + $36 | 0;\n  $$040 = $1;\n  while (1) {\n   if (($$040 | 0) == ($2 | 0)) break;\n   __ZNSt3__211char_traitsIcE6assignERcRKc($$0, $$040);\n   $$0 = $$0 + 1 | 0;\n   $$040 = $$040 + 1 | 0;\n  }\n  HEAP8[$4 >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($44 + $scevgep5 | 0, $4);\n  $49 = $36 + $15 | 0;\n  if ((HEAP8[$5 >> 0] | 0) < 0) {\n   HEAP32[$0 + 4 >> 2] = $49;\n   break;\n  } else {\n   HEAP8[$5 >> 0] = $49;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN53EmscriptenBindingInitializer_native_and_builtin_typesC2Ev($0) {\n $0 = $0 | 0;\n __embind_register_void(__ZN10emscripten8internal6TypeIDIvE3getEv() | 0, 16556);\n __embind_register_bool(__ZN10emscripten8internal6TypeIDIbE3getEv() | 0, 16561, 1, 1, 0);\n __ZN12_GLOBAL__N_116register_integerIcEEvPKc();\n __ZN12_GLOBAL__N_116register_integerIaEEvPKc();\n __ZN12_GLOBAL__N_116register_integerIhEEvPKc();\n __ZN12_GLOBAL__N_116register_integerIsEEvPKc();\n __ZN12_GLOBAL__N_116register_integerItEEvPKc();\n __ZN12_GLOBAL__N_116register_integerIiEEvPKc();\n __ZN12_GLOBAL__N_116register_integerIjEEvPKc();\n __ZN12_GLOBAL__N_116register_integerIlEEvPKc();\n __ZN12_GLOBAL__N_116register_integerImEEvPKc();\n __ZN12_GLOBAL__N_114register_floatIfEEvPKc();\n __ZN12_GLOBAL__N_114register_floatIdEEvPKc();\n __embind_register_std_string(__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv() | 0, 15939);\n __embind_register_std_string(__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv() | 0, 10568);\n __embind_register_std_wstring(__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv() | 0, 4, 10601);\n __embind_register_emval(__ZN10emscripten8internal6TypeIDINS_3valEE3getEv() | 0, 10614);\n __ZN12_GLOBAL__N_120register_memory_viewIcEEvPKc();\n __ZN12_GLOBAL__N_120register_memory_viewIaEEvPKc(10630);\n __ZN12_GLOBAL__N_120register_memory_viewIhEEvPKc(10667);\n __ZN12_GLOBAL__N_120register_memory_viewIsEEvPKc(10706);\n __ZN12_GLOBAL__N_120register_memory_viewItEEvPKc(10737);\n __ZN12_GLOBAL__N_120register_memory_viewIiEEvPKc(10777);\n __ZN12_GLOBAL__N_120register_memory_viewIjEEvPKc(10806);\n __ZN12_GLOBAL__N_120register_memory_viewIlEEvPKc();\n __ZN12_GLOBAL__N_120register_memory_viewImEEvPKc();\n __ZN12_GLOBAL__N_120register_memory_viewIaEEvPKc(10844);\n __ZN12_GLOBAL__N_120register_memory_viewIhEEvPKc(10876);\n __ZN12_GLOBAL__N_120register_memory_viewIsEEvPKc(10909);\n __ZN12_GLOBAL__N_120register_memory_viewItEEvPKc(10942);\n __ZN12_GLOBAL__N_120register_memory_viewIiEEvPKc(10976);\n __ZN12_GLOBAL__N_120register_memory_viewIjEEvPKc(11009);\n __ZN12_GLOBAL__N_120register_memory_viewIfEEvPKc();\n __ZN12_GLOBAL__N_120register_memory_viewIdEEvPKc();\n __ZN12_GLOBAL__N_120register_memory_viewIeEEvPKc();\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_116parse_dot_suffixINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$0$i$i$i16 = 0, $$014 = 0, $10 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $3 = sp + 24 | 0;\n $4 = sp + 12 | 0;\n $5 = sp;\n if (($0 | 0) == ($1 | 0)) $$014 = $0; else if ((HEAP8[$0 >> 0] | 0) == 46) {\n  $10 = $2 + 4 | 0;\n  if ((HEAP32[$2 >> 2] | 0) == (HEAP32[$10 >> 2] | 0)) $$014 = $0; else {\n   HEAP32[$5 >> 2] = 0;\n   HEAP32[$5 + 4 >> 2] = 0;\n   HEAP32[$5 + 8 >> 2] = 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($5, $0, $1);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($5, 0, 15114) | 0;\n   HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n   HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n   HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n   $$0$i$i$i = 0;\n   while (1) {\n    if (($$0$i$i$i | 0) == 3) break;\n    HEAP32[$5 + ($$0$i$i$i << 2) >> 2] = 0;\n    $$0$i$i$i = $$0$i$i$i + 1 | 0;\n   }\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($4, 15117) | 0;\n   HEAP32[$3 >> 2] = HEAP32[$4 >> 2];\n   HEAP32[$3 + 4 >> 2] = HEAP32[$4 + 4 >> 2];\n   HEAP32[$3 + 8 >> 2] = HEAP32[$4 + 8 >> 2];\n   $$0$i$i$i16 = 0;\n   while (1) {\n    if (($$0$i$i$i16 | 0) == 3) break;\n    HEAP32[$4 + ($$0$i$i$i16 << 2) >> 2] = 0;\n    $$0$i$i$i16 = $$0$i$i$i16 + 1 | 0;\n   }\n   $22 = HEAP8[$3 + 11 >> 0] | 0;\n   $23 = $22 << 24 >> 24 < 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$10 >> 2] | 0) + -24 | 0, $23 ? HEAP32[$3 >> 2] | 0 : $3, $23 ? HEAP32[$3 + 4 >> 2] | 0 : $22 & 255) | 0;\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n   $$014 = $1;\n  }\n } else $$014 = $0;\n STACKTOP = sp;\n return $$014 | 0;\n}\n\nfunction ___stdio_write($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$04756 = 0, $$04855 = 0, $$04954 = 0, $$051 = 0, $$1 = 0, $$150 = 0, $12 = 0, $13 = 0, $17 = 0, $20 = 0, $25 = 0, $27 = 0, $3 = 0, $37 = 0, $38 = 0, $4 = 0, $44 = 0, $5 = 0, $7 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $vararg_buffer3 = sp + 16 | 0;\n $vararg_buffer = sp;\n $3 = sp + 32 | 0;\n $4 = $0 + 28 | 0;\n $5 = HEAP32[$4 >> 2] | 0;\n HEAP32[$3 >> 2] = $5;\n $7 = $0 + 20 | 0;\n $9 = (HEAP32[$7 >> 2] | 0) - $5 | 0;\n HEAP32[$3 + 4 >> 2] = $9;\n HEAP32[$3 + 8 >> 2] = $1;\n HEAP32[$3 + 12 >> 2] = $2;\n $12 = $9 + $2 | 0;\n $13 = $0 + 60 | 0;\n HEAP32[$vararg_buffer >> 2] = HEAP32[$13 >> 2];\n HEAP32[$vararg_buffer + 4 >> 2] = $3;\n HEAP32[$vararg_buffer + 8 >> 2] = 2;\n $17 = ___syscall_ret(___syscall146(146, $vararg_buffer | 0) | 0) | 0;\n L1 : do if (($12 | 0) == ($17 | 0)) label = 3; else {\n  $$04756 = 2;\n  $$04855 = $12;\n  $$04954 = $3;\n  $27 = $17;\n  while (1) {\n   if (($27 | 0) < 0) break;\n   $$04855 = $$04855 - $27 | 0;\n   $37 = HEAP32[$$04954 + 4 >> 2] | 0;\n   $38 = $27 >>> 0 > $37 >>> 0;\n   $$150 = $38 ? $$04954 + 8 | 0 : $$04954;\n   $$1 = $$04756 + ($38 << 31 >> 31) | 0;\n   $$0 = $27 - ($38 ? $37 : 0) | 0;\n   HEAP32[$$150 >> 2] = (HEAP32[$$150 >> 2] | 0) + $$0;\n   $44 = $$150 + 4 | 0;\n   HEAP32[$44 >> 2] = (HEAP32[$44 >> 2] | 0) - $$0;\n   HEAP32[$vararg_buffer3 >> 2] = HEAP32[$13 >> 2];\n   HEAP32[$vararg_buffer3 + 4 >> 2] = $$150;\n   HEAP32[$vararg_buffer3 + 8 >> 2] = $$1;\n   $27 = ___syscall_ret(___syscall146(146, $vararg_buffer3 | 0) | 0) | 0;\n   if (($$04855 | 0) == ($27 | 0)) {\n    label = 3;\n    break L1;\n   } else {\n    $$04756 = $$1;\n    $$04954 = $$150;\n   }\n  }\n  HEAP32[$0 + 16 >> 2] = 0;\n  HEAP32[$4 >> 2] = 0;\n  HEAP32[$7 >> 2] = 0;\n  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | 32;\n  if (($$04756 | 0) == 2) $$051 = 0; else $$051 = $2 - (HEAP32[$$04954 + 4 >> 2] | 0) | 0;\n } while (0);\n if ((label | 0) == 3) {\n  $20 = HEAP32[$0 + 44 >> 2] | 0;\n  HEAP32[$0 + 16 >> 2] = $20 + (HEAP32[$0 + 48 >> 2] | 0);\n  $25 = $20;\n  HEAP32[$4 >> 2] = $25;\n  HEAP32[$7 >> 2] = $25;\n  $$051 = $2;\n }\n STACKTOP = sp;\n return $$051 | 0;\n}\n\nfunction _getMarkerInfo($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$1 = 0, $2 = 0, $7 = 0, $8 = 0, $spec$select = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0)) $$1 = HEAP32[489] | 0; else {\n  $7 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 216 | 0;\n  $8 = HEAP32[$7 >> 2] | 0;\n  if ((HEAP32[$8 + 44 >> 2] | 0) > ($1 | 0)) {\n   $spec$select = ($1 | 0) < 0 ? 17e3 : $8 + 48 + ($1 << 8) | 0;\n   _emscripten_asm_const_iiiiiiiidddddddddddddddddddddddddi(2, HEAP32[$spec$select >> 2] | 0, HEAP32[$spec$select + 4 >> 2] | 0, HEAP32[$spec$select + 8 >> 2] | 0, HEAP32[$spec$select + 12 >> 2] | 0, HEAP32[$spec$select + 16 >> 2] | 0, HEAP32[$spec$select + 20 >> 2] | 0, HEAP32[$spec$select + 24 >> 2] | 0, +(+HEAPF64[$spec$select + 32 >> 3]), +(+HEAPF64[$spec$select + 40 >> 3]), +(+HEAPF64[$spec$select + 48 >> 3]), +(+HEAPF64[$spec$select + 56 >> 3]), +(+HEAPF64[$spec$select + 64 >> 3]), +(+HEAPF64[$spec$select + 72 >> 3]), +(+HEAPF64[$spec$select + 80 >> 3]), +(+HEAPF64[$spec$select + 88 >> 3]), +(+HEAPF64[$spec$select + 96 >> 3]), +(+HEAPF64[$spec$select + 104 >> 3]), +(+HEAPF64[$spec$select + 112 >> 3]), +(+HEAPF64[$spec$select + 120 >> 3]), +(+HEAPF64[$spec$select + 128 >> 3]), +(+HEAPF64[$spec$select + 136 >> 3]), +(+HEAPF64[$spec$select + 144 >> 3]), +(+HEAPF64[$spec$select + 152 >> 3]), +(+HEAPF64[$spec$select + 160 >> 3]), +(+HEAPF64[$spec$select + 168 >> 3]), +(+HEAPF64[$spec$select + 176 >> 3]), +(+HEAPF64[$spec$select + 184 >> 3]), +(+HEAPF64[$spec$select + 192 >> 3]), +(+HEAPF64[$spec$select + 200 >> 3]), +(+HEAPF64[$spec$select + 208 >> 3]), +(+HEAPF64[$spec$select + 216 >> 3]), +(+HEAPF64[$spec$select + 224 >> 3]), HEAP32[$spec$select + 240 >> 2] | 0) | 0;\n   $$1 = 0;\n   break;\n  } else {\n   $$1 = HEAP32[491] | 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction _PCA($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$075 = 0, $$077 = 0, $$078 = 0, $$080 = 0, $$1 = 0, $$176 = 0, $$179 = 0, $$181 = 0, $$2 = 0, $$3 = 0, $20 = 0, $27 = 0, $4 = 0, $6 = 0, $8 = 0;\n $4 = HEAP32[$0 + 4 >> 2] | 0;\n $6 = HEAP32[$0 + 8 >> 2] | 0;\n $8 = ($6 | 0) < ($4 | 0) ? $6 : $4;\n L1 : do if (($4 | 0) < 2 | ($6 | 0) < 2) $$077 = -1; else if ((HEAP32[$1 + 8 >> 2] | 0) == ($6 | 0)) if ((HEAP32[$1 + 4 >> 2] | 0) == ($8 | 0)) if ((HEAP32[$2 + 4 >> 2] | 0) == ($8 | 0)) {\n  $20 = _arMatrixAlloc($8, $8) | 0;\n  if ((HEAP32[$20 + 4 >> 2] | 0) == ($8 | 0)) if ((HEAP32[$20 + 8 >> 2] | 0) == ($8 | 0)) {\n   $27 = ($4 | 0) < ($6 | 0);\n   if ($27) {\n    if ((_x_by_xt($0, $20) | 0) < 0) {\n     _arMatrixFree($20) | 0;\n     $$077 = -1;\n     break;\n    }\n   } else if ((_xt_by_x($0, $20) | 0) < 0) {\n    _arMatrixFree($20) | 0;\n    $$077 = -1;\n    break;\n   }\n   if ((_QRM($20, $2) | 0) < 0) {\n    _arMatrixFree($20) | 0;\n    $$077 = -1;\n    break;\n   }\n   L18 : do if ($27) {\n    if ((_EV_create($0, $20, $1, $2) | 0) < 0) {\n     _arMatrixFree($20) | 0;\n     $$077 = -1;\n     break L1;\n    }\n   } else {\n    $$075 = 0;\n    $$078 = HEAP32[$20 >> 2] | 0;\n    $$080 = HEAP32[$1 >> 2] | 0;\n    while (1) {\n     if (($$075 | 0) >= ($8 | 0)) break;\n     if (+HEAPF64[(HEAP32[$2 >> 2] | 0) + ($$075 << 3) >> 3] < 1.0e-16) break;\n     $$0 = 0;\n     $$179 = $$078;\n     $$181 = $$080;\n     while (1) {\n      if (($$0 | 0) >= ($8 | 0)) break;\n      HEAPF64[$$181 >> 3] = +HEAPF64[$$179 >> 3];\n      $$0 = $$0 + 1 | 0;\n      $$179 = $$179 + 8 | 0;\n      $$181 = $$181 + 8 | 0;\n     }\n     $$075 = $$075 + 1 | 0;\n     $$078 = $$179;\n     $$080 = $$181;\n    }\n    $$176 = $$075;\n    $$2 = $$080;\n    while (1) {\n     if (($$176 | 0) >= ($8 | 0)) break L18;\n     HEAPF64[(HEAP32[$2 >> 2] | 0) + ($$176 << 3) >> 3] = 0.0;\n     $$1 = 0;\n     $$3 = $$2;\n     while (1) {\n      if (($$1 | 0) >= ($8 | 0)) break;\n      HEAPF64[$$3 >> 3] = 0.0;\n      $$1 = $$1 + 1 | 0;\n      $$3 = $$3 + 8 | 0;\n     }\n     $$176 = $$176 + 1 | 0;\n     $$2 = $$3;\n    }\n   } while (0);\n   _arMatrixFree($20) | 0;\n   $$077 = 0;\n   break;\n  }\n  _arMatrixFree($20) | 0;\n  $$077 = -1;\n } else $$077 = -1; else $$077 = -1; else $$077 = -1; while (0);\n return $$077 | 0;\n}\n\nfunction _get_cpara($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$1 = 0, $11 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $51 = 0, $6 = 0, $64 = 0, $65 = 0, $71 = 0, $72 = 0, $8 = 0, $9 = 0;\n $3 = _arMatrixAlloc(8, 8) | 0;\n $4 = _arMatrixAlloc(8, 1) | 0;\n $5 = _arMatrixAlloc(8, 1) | 0;\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) == 4) break;\n  $6 = $0 + ($$0 << 4) | 0;\n  $8 = HEAP32[$3 >> 2] | 0;\n  $9 = $$0 << 4;\n  HEAPF64[$8 + ($9 << 3) >> 3] = +HEAPF64[$6 >> 3];\n  $11 = $0 + ($$0 << 4) + 8 | 0;\n  HEAPF64[$8 + (($9 | 1) << 3) >> 3] = +HEAPF64[$11 >> 3];\n  HEAPF64[$8 + (($9 | 2) << 3) >> 3] = 1.0;\n  HEAPF64[$8 + (($9 | 3) << 3) >> 3] = 0.0;\n  HEAPF64[$8 + (($9 | 4) << 3) >> 3] = 0.0;\n  HEAPF64[$8 + (($9 | 5) << 3) >> 3] = 0.0;\n  $24 = $1 + ($$0 << 4) | 0;\n  HEAPF64[$8 + (($9 | 6) << 3) >> 3] = -(+HEAPF64[$6 >> 3] * +HEAPF64[$24 >> 3]);\n  HEAPF64[$8 + (($9 | 7) << 3) >> 3] = -(+HEAPF64[$11 >> 3] * +HEAPF64[$24 >> 3]);\n  HEAPF64[$8 + (($9 | 8) << 3) >> 3] = 0.0;\n  HEAPF64[$8 + (($9 | 9) << 3) >> 3] = 0.0;\n  HEAPF64[$8 + (($9 | 10) << 3) >> 3] = 0.0;\n  HEAPF64[$8 + (($9 | 11) << 3) >> 3] = +HEAPF64[$6 >> 3];\n  HEAPF64[$8 + (($9 | 12) << 3) >> 3] = +HEAPF64[$11 >> 3];\n  HEAPF64[$8 + (($9 | 13) << 3) >> 3] = 1.0;\n  $51 = $1 + ($$0 << 4) + 8 | 0;\n  HEAPF64[$8 + (($9 | 14) << 3) >> 3] = -(+HEAPF64[$6 >> 3] * +HEAPF64[$51 >> 3]);\n  HEAPF64[$8 + (($9 | 15) << 3) >> 3] = -(+HEAPF64[$11 >> 3] * +HEAPF64[$51 >> 3]);\n  $64 = HEAP32[$4 >> 2] | 0;\n  $65 = $$0 << 1;\n  HEAPF64[$64 + ($65 << 3) >> 3] = +HEAPF64[$24 >> 3];\n  HEAPF64[$64 + (($65 | 1) << 3) >> 3] = +HEAPF64[$51 >> 3];\n  $$0 = $$0 + 1 | 0;\n }\n _arMatrixSelfInv($3) | 0;\n _arMatrixMul($5, $3, $4) | 0;\n $71 = HEAP32[$5 >> 2] | 0;\n $$1 = 0;\n while (1) {\n  if (($$1 | 0) == 2) break;\n  $72 = $$1 * 3 | 0;\n  HEAPF64[$2 + ($$1 * 24 | 0) >> 3] = +HEAPF64[$71 + ($72 << 3) >> 3];\n  HEAPF64[$2 + ($$1 * 24 | 0) + 8 >> 3] = +HEAPF64[$71 + ($72 + 1 << 3) >> 3];\n  HEAPF64[$2 + ($$1 * 24 | 0) + 16 >> 3] = +HEAPF64[$71 + ($72 + 2 << 3) >> 3];\n  $$1 = $$1 + 1 | 0;\n }\n HEAPF64[$2 + 48 >> 3] = +HEAPF64[$71 + 48 >> 3];\n HEAPF64[$2 + 56 >> 3] = +HEAPF64[$71 + 56 >> 3];\n HEAPF64[$2 + 64 >> 3] = 1.0;\n _arMatrixFree($3) | 0;\n _arMatrixFree($4) | 0;\n _arMatrixFree($5) | 0;\n return;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($0) {\n $0 = $0 | 0;\n var $$017$off022 = 0, $$01918 = 0, $$020153134 = 0, $$02016 = 0, $$pre$phi37Z2D = 0, $$pre$phiZ2D = 0, $1 = 0, $10 = 0, $11 = 0, $15 = 0, $17 = 0, $18 = 0, $2 = 0, $20 = 0, $23 = 0, $28 = 0, $3 = 0, $spec$select$i = 0, label = 0;\n $1 = $0 + 11 | 0;\n $2 = HEAP8[$1 >> 0] | 0;\n $3 = $2 << 24 >> 24 < 0;\n if ($3) {\n  $11 = HEAP32[$0 + 4 >> 2] | 0;\n  $15 = (HEAP32[$0 + 8 >> 2] & 2147483647) + -1 | 0;\n } else {\n  $11 = $2 & 255;\n  $15 = 10;\n }\n $10 = $11 >>> 0 < 11;\n $spec$select$i = $10 ? 10 : ($11 + 16 & -16) + -1 | 0;\n L5 : do if (($spec$select$i | 0) != ($15 | 0)) {\n  do if ($10) {\n   $23 = HEAP32[$0 >> 2] | 0;\n   if ($3) {\n    $$017$off022 = 0;\n    $$01918 = $23;\n    $$02016 = $0;\n    label = 12;\n   } else {\n    __ZNSt3__211char_traitsIcE4copyEPcPKcj($0, $23, ($2 & 255) + 1 | 0) | 0;\n    __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE10deallocateEPcj($23);\n    label = 15;\n   }\n  } else {\n   $17 = $spec$select$i + 1 | 0;\n   $18 = __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE8allocateEj($17) | 0;\n   if ($spec$select$i >>> 0 <= $15 >>> 0 & ($18 | 0) == 0) break L5;\n   $20 = HEAP8[$1 >> 0] | 0;\n   if ($20 << 24 >> 24 < 0) {\n    $$017$off022 = 1;\n    $$01918 = HEAP32[$0 >> 2] | 0;\n    $$02016 = $18;\n    label = 12;\n    break;\n   } else {\n    __ZNSt3__211char_traitsIcE4copyEPcPKcj($18, $0, ($20 & 255) + 1 | 0) | 0;\n    $$020153134 = $18;\n    $$pre$phi37Z2D = $17;\n    $$pre$phiZ2D = $0 + 4 | 0;\n    label = 14;\n    break;\n   }\n  } while (0);\n  if ((label | 0) == 12) {\n   $28 = $0 + 4 | 0;\n   __ZNSt3__211char_traitsIcE4copyEPcPKcj($$02016, $$01918, (HEAP32[$28 >> 2] | 0) + 1 | 0) | 0;\n   __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE10deallocateEPcj($$01918);\n   if ($$017$off022) {\n    $$020153134 = $$02016;\n    $$pre$phi37Z2D = $spec$select$i + 1 | 0;\n    $$pre$phiZ2D = $28;\n    label = 14;\n   } else label = 15;\n  }\n  if ((label | 0) == 14) {\n   HEAP32[$0 + 8 >> 2] = $$pre$phi37Z2D | -2147483648;\n   HEAP32[$$pre$phiZ2D >> 2] = $11;\n   HEAP32[$0 >> 2] = $$020153134;\n   break;\n  } else if ((label | 0) == 15) {\n   HEAP8[$1 >> 0] = $11;\n   break;\n  }\n } while (0);\n return;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE6removeENS_21__hash_const_iteratorIPNS_11__hash_nodeIS3_PvEEEE($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$pre$phiZ2D = 0, $10 = 0, $15 = 0, $16 = 0, $18 = 0, $20 = 0, $23 = 0, $28 = 0, $29 = 0, $3 = 0, $32 = 0, $37 = 0, $38 = 0, $40 = 0, $42 = 0, $47 = 0, $5 = 0, $50 = 0, $51 = 0, $7 = 0, $8 = 0, label = 0;\n $3 = HEAP32[$2 >> 2] | 0;\n $5 = HEAP32[$1 + 4 >> 2] | 0;\n $7 = HEAP32[$3 + 4 >> 2] | 0;\n $8 = $5 + -1 | 0;\n $10 = ($8 & $5 | 0) == 0;\n if ($10) $16 = $8 & $7; else if ($7 >>> 0 < $5 >>> 0) $16 = $7; else $16 = ($7 >>> 0) % ($5 >>> 0) | 0;\n $15 = (HEAP32[$1 >> 2] | 0) + ($16 << 2) | 0;\n $$0 = HEAP32[$15 >> 2] | 0;\n while (1) {\n  $18 = HEAP32[$$0 >> 2] | 0;\n  if (($18 | 0) == ($3 | 0)) break; else $$0 = $18;\n }\n $20 = $1 + 8 | 0;\n if (($$0 | 0) == ($20 | 0)) label = 14; else {\n  $23 = HEAP32[$$0 + 4 >> 2] | 0;\n  if ($10) $28 = $23 & $8; else if ($23 >>> 0 < $5 >>> 0) $28 = $23; else $28 = ($23 >>> 0) % ($5 >>> 0) | 0;\n  if (($28 | 0) == ($16 | 0)) $$pre$phiZ2D = $3; else label = 14;\n }\n do if ((label | 0) == 14) {\n  $29 = HEAP32[$3 >> 2] | 0;\n  if ($29 | 0) {\n   $32 = HEAP32[$29 + 4 >> 2] | 0;\n   if ($10) $37 = $32 & $8; else if ($32 >>> 0 < $5 >>> 0) $37 = $32; else $37 = ($32 >>> 0) % ($5 >>> 0) | 0;\n   if (($37 | 0) == ($16 | 0)) {\n    $$pre$phiZ2D = $3;\n    break;\n   }\n  }\n  HEAP32[$15 >> 2] = 0;\n  $$pre$phiZ2D = $3;\n } while (0);\n $38 = HEAP32[$$pre$phiZ2D >> 2] | 0;\n $40 = $38;\n if (!$38) $50 = $40; else {\n  $42 = HEAP32[$38 + 4 >> 2] | 0;\n  if ($10) $47 = $42 & $8; else if ($42 >>> 0 < $5 >>> 0) $47 = $42; else $47 = ($42 >>> 0) % ($5 >>> 0) | 0;\n  if (($47 | 0) == ($16 | 0)) $50 = $40; else {\n   HEAP32[(HEAP32[$1 >> 2] | 0) + ($47 << 2) >> 2] = $$0;\n   $50 = HEAP32[$3 >> 2] | 0;\n  }\n }\n HEAP32[$$0 >> 2] = $50;\n HEAP32[$$pre$phiZ2D >> 2] = 0;\n $51 = $1 + 12 | 0;\n HEAP32[$51 >> 2] = (HEAP32[$51 >> 2] | 0) + -1;\n HEAP32[$0 >> 2] = $3;\n HEAP32[$0 + 4 >> 2] = $20;\n HEAP8[$0 + 8 >> 0] = 1;\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_119parse_dot_star_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$idx$i = 0, $$3 = 0, $14 = 0, $15 = 0, $17 = 0, $19 = 0, $20 = 0, $27 = 0, $3 = 0, $33 = 0, $34 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp + 12 | 0;\n $4 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 100) if ((HEAP8[$0 + 1 >> 0] | 0) == 115) {\n  $14 = $0 + 2 | 0;\n  $15 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($14, $1, $2) | 0;\n  if (($15 | 0) == ($14 | 0)) $$3 = $0; else {\n   $17 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($15, $1, $2) | 0;\n   if (($17 | 0) == ($15 | 0)) $$3 = $0; else {\n    $19 = $2 + 4 | 0;\n    $20 = HEAP32[$19 >> 2] | 0;\n    if ((($20 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$3 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $20 + -24 | 0);\n     $27 = HEAP32[$19 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($27 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$19 >> 2] = $27 + -24;\n     __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($4, 15410, $3);\n     $33 = HEAP8[$4 + 11 >> 0] | 0;\n     $34 = $33 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$19 >> 2] | 0) + -24 | 0, $34 ? HEAP32[$4 >> 2] | 0 : $4, $34 ? HEAP32[$4 + 4 >> 2] | 0 : $33 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$3 = $17;\n    }\n   }\n  }\n } else $$3 = $0; else $$3 = $0; else $$3 = $0;\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_114parse_dot_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$idx$i = 0, $$3 = 0, $14 = 0, $15 = 0, $17 = 0, $19 = 0, $20 = 0, $27 = 0, $3 = 0, $33 = 0, $34 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $3 = sp + 12 | 0;\n $4 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 100) if ((HEAP8[$0 + 1 >> 0] | 0) == 116) {\n  $14 = $0 + 2 | 0;\n  $15 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($14, $1, $2) | 0;\n  if (($15 | 0) == ($14 | 0)) $$3 = $0; else {\n   $17 = __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_nameINS0_2DbEEEPKcS4_S4_RT_($15, $1, $2) | 0;\n   if (($17 | 0) == ($15 | 0)) $$3 = $0; else {\n    $19 = $2 + 4 | 0;\n    $20 = HEAP32[$19 >> 2] | 0;\n    if ((($20 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$3 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $20 + -24 | 0);\n     $27 = HEAP32[$19 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($27 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$19 >> 2] = $27 + -24;\n     __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($4, 15408, $3);\n     $33 = HEAP8[$4 + 11 >> 0] | 0;\n     $34 = $33 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$19 >> 2] | 0) + -24 | 0, $34 ? HEAP32[$4 >> 2] | 0 : $4, $34 ? HEAP32[$4 + 4 >> 2] | 0 : $33 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$3 = $17;\n    }\n   }\n  }\n } else $$3 = $0; else $$3 = $0; else $$3 = $0;\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction _memcpy(dest, src, num) {\n dest = dest | 0;\n src = src | 0;\n num = num | 0;\n var ret = 0, aligned_dest_end = 0, block_aligned_dest_end = 0, dest_end = 0;\n if ((num | 0) >= 8192) return _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0;\n ret = dest | 0;\n dest_end = dest + num | 0;\n if ((dest & 3) == (src & 3)) {\n  while (dest & 3) {\n   if (!num) return ret | 0;\n   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n   dest = dest + 1 | 0;\n   src = src + 1 | 0;\n   num = num - 1 | 0;\n  }\n  aligned_dest_end = dest_end & -4 | 0;\n  block_aligned_dest_end = aligned_dest_end - 64 | 0;\n  while ((dest | 0) <= (block_aligned_dest_end | 0)) {\n   HEAP32[dest >> 2] = HEAP32[src >> 2];\n   HEAP32[dest + 4 >> 2] = HEAP32[src + 4 >> 2];\n   HEAP32[dest + 8 >> 2] = HEAP32[src + 8 >> 2];\n   HEAP32[dest + 12 >> 2] = HEAP32[src + 12 >> 2];\n   HEAP32[dest + 16 >> 2] = HEAP32[src + 16 >> 2];\n   HEAP32[dest + 20 >> 2] = HEAP32[src + 20 >> 2];\n   HEAP32[dest + 24 >> 2] = HEAP32[src + 24 >> 2];\n   HEAP32[dest + 28 >> 2] = HEAP32[src + 28 >> 2];\n   HEAP32[dest + 32 >> 2] = HEAP32[src + 32 >> 2];\n   HEAP32[dest + 36 >> 2] = HEAP32[src + 36 >> 2];\n   HEAP32[dest + 40 >> 2] = HEAP32[src + 40 >> 2];\n   HEAP32[dest + 44 >> 2] = HEAP32[src + 44 >> 2];\n   HEAP32[dest + 48 >> 2] = HEAP32[src + 48 >> 2];\n   HEAP32[dest + 52 >> 2] = HEAP32[src + 52 >> 2];\n   HEAP32[dest + 56 >> 2] = HEAP32[src + 56 >> 2];\n   HEAP32[dest + 60 >> 2] = HEAP32[src + 60 >> 2];\n   dest = dest + 64 | 0;\n   src = src + 64 | 0;\n  }\n  while ((dest | 0) < (aligned_dest_end | 0)) {\n   HEAP32[dest >> 2] = HEAP32[src >> 2];\n   dest = dest + 4 | 0;\n   src = src + 4 | 0;\n  }\n } else {\n  aligned_dest_end = dest_end - 4 | 0;\n  while ((dest | 0) < (aligned_dest_end | 0)) {\n   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n   HEAP8[dest + 1 >> 0] = HEAP8[src + 1 >> 0] | 0;\n   HEAP8[dest + 2 >> 0] = HEAP8[src + 2 >> 0] | 0;\n   HEAP8[dest + 3 >> 0] = HEAP8[src + 3 >> 0] | 0;\n   dest = dest + 4 | 0;\n   src = src + 4 | 0;\n  }\n }\n while ((dest | 0) < (dest_end | 0)) {\n  HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n  dest = dest + 1 | 0;\n  src = src + 1 | 0;\n }\n return ret | 0;\n}\n\nfunction ___fdopen($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $19 = 0, $2 = 0, $24 = 0, $29 = 0, $31 = 0, $7 = 0, $8 = 0, $vararg_buffer = 0, $vararg_buffer12 = 0, $vararg_buffer3 = 0, $vararg_buffer7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $vararg_buffer12 = sp + 40 | 0;\n $vararg_buffer7 = sp + 24 | 0;\n $vararg_buffer3 = sp + 16 | 0;\n $vararg_buffer = sp;\n $2 = sp + 56 | 0;\n if (!(_strchr(11759, HEAP8[$1 >> 0] | 0) | 0)) {\n  $7 = ___errno_location() | 0;\n  HEAP32[$7 >> 2] = 22;\n  $$0 = 0;\n } else {\n  $8 = _malloc(1156) | 0;\n  if (!$8) $$0 = 0; else {\n   _memset($8 | 0, 0, 124) | 0;\n   if (!(_strchr($1, 43) | 0)) HEAP32[$8 >> 2] = (HEAP8[$1 >> 0] | 0) == 114 ? 8 : 4;\n   if (_strchr($1, 101) | 0) {\n    HEAP32[$vararg_buffer >> 2] = $0;\n    HEAP32[$vararg_buffer + 4 >> 2] = 2;\n    HEAP32[$vararg_buffer + 8 >> 2] = 1;\n    ___syscall221(221, $vararg_buffer | 0) | 0;\n   }\n   if ((HEAP8[$1 >> 0] | 0) == 97) {\n    HEAP32[$vararg_buffer3 >> 2] = $0;\n    HEAP32[$vararg_buffer3 + 4 >> 2] = 3;\n    $19 = ___syscall221(221, $vararg_buffer3 | 0) | 0;\n    if (!($19 & 1024)) {\n     HEAP32[$vararg_buffer7 >> 2] = $0;\n     HEAP32[$vararg_buffer7 + 4 >> 2] = 4;\n     HEAP32[$vararg_buffer7 + 8 >> 2] = $19 | 1024;\n     ___syscall221(221, $vararg_buffer7 | 0) | 0;\n    }\n    $24 = HEAP32[$8 >> 2] | 128;\n    HEAP32[$8 >> 2] = $24;\n    $31 = $24;\n   } else $31 = HEAP32[$8 >> 2] | 0;\n   HEAP32[$8 + 60 >> 2] = $0;\n   HEAP32[$8 + 44 >> 2] = $8 + 132;\n   HEAP32[$8 + 48 >> 2] = 1024;\n   $29 = $8 + 75 | 0;\n   HEAP8[$29 >> 0] = -1;\n   if (!($31 & 8)) {\n    HEAP32[$vararg_buffer12 >> 2] = $0;\n    HEAP32[$vararg_buffer12 + 4 >> 2] = 21523;\n    HEAP32[$vararg_buffer12 + 8 >> 2] = $2;\n    if (!(___syscall54(54, $vararg_buffer12 | 0) | 0)) HEAP8[$29 >> 0] = 10;\n   }\n   HEAP32[$8 + 32 >> 2] = 14;\n   HEAP32[$8 + 36 >> 2] = 1;\n   HEAP32[$8 + 40 >> 2] = 2;\n   HEAP32[$8 + 12 >> 2] = 1;\n   if (!(HEAP32[4476] | 0)) HEAP32[$8 + 76 >> 2] = -1;\n   ___ofl_add($8) | 0;\n   $$0 = $8;\n  }\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _fgets($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$05963 = 0, $$06065 = 0, $$06164 = 0, $$1 = 0, $11 = 0, $16 = 0, $19 = 0, $20 = 0, $21 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $30 = 0, $32 = 0, $34 = 0, $35 = 0, $36 = 0, $43 = 0, $50 = 0, $51 = 0, $7 = 0, $9 = 0, label = 0;\n if ((HEAP32[$2 + 76 >> 2] | 0) > -1) $16 = ___lockfile($2) | 0; else $16 = 0;\n $7 = $1 + -1 | 0;\n if (($1 | 0) < 2) {\n  $9 = $2 + 74 | 0;\n  $11 = HEAP8[$9 >> 0] | 0;\n  HEAP8[$9 >> 0] = $11 + 255 | $11;\n  if ($16 | 0) ___unlockfile($2);\n  if (!$7) {\n   HEAP8[$0 >> 0] = 0;\n   $$0 = $0;\n  } else $$0 = 0;\n } else {\n  L11 : do if (!$7) {\n   $$1 = $0;\n   label = 17;\n  } else {\n   $19 = $2 + 4 | 0;\n   $20 = $2 + 8 | 0;\n   $$06065 = $7;\n   $$06164 = $0;\n   while (1) {\n    $21 = HEAP32[$19 >> 2] | 0;\n    $23 = $21;\n    $24 = (HEAP32[$20 >> 2] | 0) - $23 | 0;\n    $25 = _memchr($21, 10, $24) | 0;\n    $26 = ($25 | 0) == 0;\n    $30 = $26 ? $24 : 1 - $23 + $25 | 0;\n    $32 = $30 >>> 0 < $$06065 >>> 0 ? $30 : $$06065;\n    _memcpy($$06164 | 0, $21 | 0, $32 | 0) | 0;\n    $34 = (HEAP32[$19 >> 2] | 0) + $32 | 0;\n    HEAP32[$19 >> 2] = $34;\n    $35 = $$06164 + $32 | 0;\n    $36 = $$06065 - $32 | 0;\n    if (!($26 & ($36 | 0) != 0)) {\n     $$1 = $35;\n     label = 17;\n     break L11;\n    }\n    if ($34 >>> 0 < (HEAP32[$20 >> 2] | 0) >>> 0) {\n     HEAP32[$19 >> 2] = $34 + 1;\n     $50 = HEAPU8[$34 >> 0] | 0;\n    } else {\n     $43 = ___uflow($2) | 0;\n     if (($43 | 0) < 0) break; else $50 = $43;\n    }\n    $51 = $35 + 1 | 0;\n    HEAP8[$35 >> 0] = $50;\n    $$06065 = $36 + -1 | 0;\n    if (($50 & 255 | 0) == 10 | ($$06065 | 0) == 0) {\n     $$1 = $51;\n     label = 17;\n     break L11;\n    } else $$06164 = $51;\n   }\n   if (($35 | 0) == ($0 | 0)) $$05963 = 0; else if (!(HEAP32[$2 >> 2] & 16)) $$05963 = 0; else {\n    $$1 = $35;\n    label = 17;\n   }\n  } while (0);\n  if ((label | 0) == 17) if (!$0) $$05963 = 0; else {\n   HEAP8[$$1 >> 0] = 0;\n   $$05963 = $0;\n  }\n  if (!$16) $$0 = $$05963; else {\n   ___unlockfile($2);\n   $$0 = $$05963;\n  }\n }\n return $$0 | 0;\n}\n\nfunction _arGetTransMatSquare($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = +$2;\n $3 = $3 | 0;\n var $$0 = 0, $$0$in = 0, $$031 = 0.0, $19 = 0, $26 = 0, $34 = 0, $4 = 0, $42 = 0, $49 = 0.0, $5 = 0, $50 = 0.0, $6 = 0, $69 = 0, $7 = 0, $8 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 288 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(288);\n $4 = sp + 200 | 0;\n $5 = sp + 104 | 0;\n $6 = sp + 264 | 0;\n $7 = sp + 8 | 0;\n $8 = sp;\n do if ((HEAP32[$1 + 12 >> 2] | 0) < 0) $$0$in = $1 + 20 | 0; else if ((HEAP32[$1 + 8 >> 2] | 0) < 0) {\n  $$0$in = $1 + 24 | 0;\n  break;\n } else {\n  $$0$in = $1 + 16 | 0;\n  break;\n } while (0);\n $$0 = HEAP32[$$0$in >> 2] | 0;\n $19 = (4 - $$0 | 0) % 4 | 0;\n HEAPF64[$4 >> 3] = +HEAPF64[$1 + 168 + ($19 << 4) >> 3];\n HEAPF64[$4 + 8 >> 3] = +HEAPF64[$1 + 168 + ($19 << 4) + 8 >> 3];\n $26 = (5 - $$0 | 0) % 4 | 0;\n HEAPF64[$4 + 16 >> 3] = +HEAPF64[$1 + 168 + ($26 << 4) >> 3];\n HEAPF64[$4 + 24 >> 3] = +HEAPF64[$1 + 168 + ($26 << 4) + 8 >> 3];\n $34 = (6 - $$0 | 0) % 4 | 0;\n HEAPF64[$4 + 32 >> 3] = +HEAPF64[$1 + 168 + ($34 << 4) >> 3];\n HEAPF64[$4 + 40 >> 3] = +HEAPF64[$1 + 168 + ($34 << 4) + 8 >> 3];\n $42 = (7 - $$0 | 0) % 4 | 0;\n HEAPF64[$4 + 48 >> 3] = +HEAPF64[$1 + 168 + ($42 << 4) >> 3];\n HEAPF64[$4 + 56 >> 3] = +HEAPF64[$1 + 168 + ($42 << 4) + 8 >> 3];\n $49 = $2 * -.5;\n HEAPF64[$5 >> 3] = $49;\n $50 = $2 * .5;\n HEAPF64[$5 + 8 >> 3] = $50;\n HEAPF64[$5 + 16 >> 3] = 0.0;\n HEAPF64[$5 + 24 >> 3] = $50;\n HEAPF64[$5 + 32 >> 3] = $50;\n HEAPF64[$5 + 40 >> 3] = 0.0;\n HEAPF64[$5 + 48 >> 3] = $50;\n HEAPF64[$5 + 56 >> 3] = $49;\n HEAPF64[$5 + 64 >> 3] = 0.0;\n HEAPF64[$5 + 72 >> 3] = $49;\n HEAPF64[$5 + 80 >> 3] = $49;\n HEAPF64[$5 + 88 >> 3] = 0.0;\n HEAP32[$6 >> 2] = $4;\n HEAP32[$6 + 4 >> 2] = $5;\n HEAP32[$6 + 8 >> 2] = 4;\n if ((_icpGetInitXw2Xc_from_PlanarData(HEAP32[$0 >> 2] | 0, $4, $5, 4, $7) | 0) < 0) $$031 = 1.0e8; else {\n  $69 = (_icpPoint(HEAP32[$0 >> 2] | 0, $6, $7, $3, $8) | 0) < 0;\n  $$031 = $69 ? 1.0e8 : +HEAPF64[$8 >> 3];\n }\n STACKTOP = sp;\n return +$$031;\n}\n\nfunction _EV_create($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$071 = 0, $$072 = 0, $$074 = 0, $$075 = 0, $$077 = 0, $$078 = 0.0, $$079 = 0, $$1 = 0, $$173 = 0, $$176 = 0, $$2 = 0, $$3 = 0, $29 = 0.0, $33 = 0.0, $34 = 0, $42 = 0.0, $5 = 0, $7 = 0;\n $5 = HEAP32[$0 + 4 >> 2] | 0;\n $7 = HEAP32[$0 + 8 >> 2] | 0;\n L1 : do if (($5 | 0) < 1 | ($7 | 0) < 1) $$074 = -1; else if ((HEAP32[$1 + 4 >> 2] | 0) == ($5 | 0)) if ((HEAP32[$1 + 8 >> 2] | 0) == ($5 | 0)) if ((HEAP32[$2 + 4 >> 2] | 0) == ($5 | 0)) if ((HEAP32[$2 + 8 >> 2] | 0) == ($7 | 0)) if ((HEAP32[$3 + 4 >> 2] | 0) == ($5 | 0)) {\n  $$072 = 0;\n  $$075 = HEAP32[$2 >> 2] | 0;\n  while (1) {\n   if (($$072 | 0) >= ($5 | 0)) break;\n   $29 = +HEAPF64[(HEAP32[$3 >> 2] | 0) + ($$072 << 3) >> 3];\n   if ($29 < 1.0e-16) break;\n   $33 = 1.0 / +Math_sqrt(+(+Math_abs(+$29)));\n   $34 = Math_imul($$072, $5) | 0;\n   $$071 = 0;\n   $$176 = $$075;\n   while (1) {\n    if (($$071 | 0) == ($7 | 0)) break;\n    $$0 = 0;\n    $$077 = (HEAP32[$1 >> 2] | 0) + ($34 << 3) | 0;\n    $$078 = 0.0;\n    $$079 = (HEAP32[$0 >> 2] | 0) + ($$071 << 3) | 0;\n    while (1) {\n     if (($$0 | 0) == ($5 | 0)) break;\n     $42 = $$078 + +HEAPF64[$$077 >> 3] * +HEAPF64[$$079 >> 3];\n     $$0 = $$0 + 1 | 0;\n     $$077 = $$077 + 8 | 0;\n     $$078 = $42;\n     $$079 = $$079 + ($7 << 3) | 0;\n    }\n    HEAPF64[$$176 >> 3] = $33 * $$078;\n    $$071 = $$071 + 1 | 0;\n    $$176 = $$176 + 8 | 0;\n   }\n   $$072 = $$072 + 1 | 0;\n   $$075 = $$075 + ($7 << 3) | 0;\n  }\n  $$173 = $$072;\n  $$2 = $$075;\n  while (1) {\n   if (($$173 | 0) >= ($5 | 0)) {\n    $$074 = 0;\n    break L1;\n   }\n   HEAPF64[(HEAP32[$3 >> 2] | 0) + ($$173 << 3) >> 3] = 0.0;\n   $$1 = 0;\n   $$3 = $$2;\n   while (1) {\n    if (($$1 | 0) >= ($7 | 0)) break;\n    HEAPF64[$$3 >> 3] = 0.0;\n    $$1 = $$1 + 1 | 0;\n    $$3 = $$3 + 8 | 0;\n   }\n   $$173 = $$173 + 1 | 0;\n   $$2 = $$3;\n  }\n } else $$074 = -1; else $$074 = -1; else $$074 = -1; else $$074 = -1; else $$074 = -1; while (0);\n return $$074 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_116parse_arrow_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$idx$i = 0, $$3 = 0, $13 = 0, $14 = 0, $16 = 0, $18 = 0, $19 = 0, $26 = 0, $3 = 0, $33 = 0, $34 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 112) if ((HEAP8[$0 + 1 >> 0] | 0) == 116) {\n  $13 = $0 + 2 | 0;\n  $14 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($13, $1, $2) | 0;\n  if (($14 | 0) == ($13 | 0)) $$3 = $0; else {\n   $16 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($14, $1, $2) | 0;\n   if (($16 | 0) == ($14 | 0)) $$3 = $0; else {\n    $18 = $2 + 4 | 0;\n    $19 = HEAP32[$18 >> 2] | 0;\n    if ((($19 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$3 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $19 + -24 | 0);\n     $26 = HEAP32[$18 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($26 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$18 >> 2] = $26 + -24;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($26 + -48 | 0, 15387) | 0;\n     $33 = HEAP8[$3 + 11 >> 0] | 0;\n     $34 = $33 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj((HEAP32[$18 >> 2] | 0) + -24 | 0, $34 ? HEAP32[$3 >> 2] | 0 : $3, $34 ? HEAP32[$3 + 4 >> 2] | 0 : $33 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$3 = $16;\n    }\n   }\n  }\n } else $$3 = $0; else $$3 = $0; else $$3 = $0;\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction __ZNSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE24__emplace_back_slow_pathIJRNS2_5arenaILj4096EEEEEEvDpOT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $10 = 0, $15 = 0, $16 = 0, $2 = 0, $20 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp + 20 | 0;\n $3 = sp;\n $4 = $0 + 4 | 0;\n $9 = ((HEAP32[$4 >> 2] | 0) - (HEAP32[$0 >> 2] | 0) >> 4) + 1 | 0;\n $10 = __ZNKSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE8max_sizeEv($0) | 0;\n if ($10 >>> 0 < $9 >>> 0) __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0); else {\n  $15 = HEAP32[$0 >> 2] | 0;\n  $16 = (HEAP32[$0 + 8 >> 2] | 0) - $15 | 0;\n  $20 = $16 >> 3;\n  __ZNSt3__214__split_bufferINS_6vectorINS1_IN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEEERNS5_IS9_Lj4096EEEEC2EjjSB_($3, $16 >> 4 >>> 0 < $10 >>> 1 >>> 0 ? ($20 >>> 0 < $9 >>> 0 ? $9 : $20) : $10, (HEAP32[$4 >> 2] | 0) - $15 >> 4, $0 + 12 | 0);\n  $25 = $3 + 8 | 0;\n  $26 = HEAP32[$25 >> 2] | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EEC2ERNS0_5arenaILj4096EEE($2, $1);\n  HEAP32[$26 >> 2] = 0;\n  HEAP32[$26 + 4 >> 2] = 0;\n  HEAP32[$26 + 8 >> 2] = 0;\n  HEAP32[$26 + 12 >> 2] = HEAP32[$2 >> 2];\n  HEAP32[$25 >> 2] = $26 + 16;\n  __ZNSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS8_RS9_EE($0, $3);\n  __ZNSt3__214__split_bufferINS_6vectorINS1_IN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEEERNS5_IS9_Lj4096EEEED2Ev($3);\n  STACKTOP = sp;\n  return;\n }\n}\n\nfunction __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE21__push_back_slow_pathIS6_EEvOT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $14 = 0, $15 = 0, $19 = 0, $2 = 0, $24 = 0, $25 = 0, $27 = 0, $28 = 0, $3 = 0, $32 = 0, $34 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp;\n $3 = $0 + 4 | 0;\n $8 = ((HEAP32[$3 >> 2] | 0) - (HEAP32[$0 >> 2] | 0) >> 4) + 1 | 0;\n $9 = __ZNKSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE8max_sizeEv($0) | 0;\n if ($9 >>> 0 < $8 >>> 0) __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0); else {\n  $14 = HEAP32[$0 >> 2] | 0;\n  $15 = (HEAP32[$0 + 8 >> 2] | 0) - $14 | 0;\n  $19 = $15 >> 3;\n  __ZNSt3__214__split_bufferINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEERNS5_IS7_Lj4096EEEEC2EjjS9_($2, $15 >> 4 >>> 0 < $9 >>> 1 >>> 0 ? ($19 >>> 0 < $8 >>> 0 ? $8 : $19) : $9, (HEAP32[$3 >> 2] | 0) - $14 >> 4, $0 + 12 | 0);\n  $24 = $2 + 8 | 0;\n  $25 = HEAP32[$24 >> 2] | 0;\n  HEAP32[$25 >> 2] = 0;\n  $27 = $25 + 4 | 0;\n  HEAP32[$27 >> 2] = 0;\n  $28 = $25 + 8 | 0;\n  HEAP32[$28 >> 2] = 0;\n  HEAP32[$25 + 12 >> 2] = HEAP32[$1 + 12 >> 2];\n  HEAP32[$25 >> 2] = HEAP32[$1 >> 2];\n  $32 = $1 + 4 | 0;\n  HEAP32[$27 >> 2] = HEAP32[$32 >> 2];\n  $34 = $1 + 8 | 0;\n  HEAP32[$28 >> 2] = HEAP32[$34 >> 2];\n  HEAP32[$34 >> 2] = 0;\n  HEAP32[$32 >> 2] = 0;\n  HEAP32[$1 >> 2] = 0;\n  HEAP32[$24 >> 2] = $25 + 16;\n  __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS6_RS7_EE($0, $2);\n  __ZNSt3__214__split_bufferINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEERNS5_IS7_Lj4096EEEED2Ev($2);\n  STACKTOP = sp;\n  return;\n }\n}\n\nfunction __ZNSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $10 = 0, $15 = 0, $16 = 0, $2 = 0, $20 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp + 20 | 0;\n $3 = sp;\n $4 = $0 + 4 | 0;\n $9 = ((HEAP32[$4 >> 2] | 0) - (HEAP32[$0 >> 2] | 0) >> 4) + 1 | 0;\n $10 = __ZNKSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE8max_sizeEv($0) | 0;\n if ($10 >>> 0 < $9 >>> 0) __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0); else {\n  $15 = HEAP32[$0 >> 2] | 0;\n  $16 = (HEAP32[$0 + 8 >> 2] | 0) - $15 | 0;\n  $20 = $16 >> 3;\n  __ZNSt3__214__split_bufferINS_6vectorINS1_IN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEEERNS5_IS9_Lj4096EEEEC2EjjSB_($3, $16 >> 4 >>> 0 < $10 >>> 1 >>> 0 ? ($20 >>> 0 < $9 >>> 0 ? $9 : $20) : $10, (HEAP32[$4 >> 2] | 0) - $15 >> 4, $0 + 12 | 0);\n  $25 = $3 + 8 | 0;\n  $26 = HEAP32[$25 >> 2] | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EEC2IS4_EERKNS1_IT_Lj4096EEE($2, $1);\n  HEAP32[$26 >> 2] = 0;\n  HEAP32[$26 + 4 >> 2] = 0;\n  HEAP32[$26 + 8 >> 2] = 0;\n  HEAP32[$26 + 12 >> 2] = HEAP32[$2 >> 2];\n  HEAP32[$25 >> 2] = $26 + 16;\n  __ZNSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS8_RS9_EE($0, $3);\n  __ZNSt3__214__split_bufferINS_6vectorINS1_IN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEEERNS5_IS9_Lj4096EEEED2Ev($3);\n  STACKTOP = sp;\n  return;\n }\n}\n\nfunction __ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$037$off038 = 0, $13 = 0, $19 = 0, $22 = 0, $23 = 0, $25 = 0, $33 = 0, $43 = 0, $45 = 0, label = 0;\n do if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 + 8 >> 2] | 0, $4) | 0) __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi(0, $1, $2, $3); else {\n  if (!(__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 >> 2] | 0, $4) | 0)) {\n   $45 = HEAP32[$0 + 8 >> 2] | 0;\n   FUNCTION_TABLE_viiiii[HEAP32[(HEAP32[$45 >> 2] | 0) + 24 >> 2] & 3]($45, $1, $2, $3, $4);\n   break;\n  }\n  if ((HEAP32[$1 + 16 >> 2] | 0) != ($2 | 0)) {\n   $13 = $1 + 20 | 0;\n   if ((HEAP32[$13 >> 2] | 0) != ($2 | 0)) {\n    HEAP32[$1 + 32 >> 2] = $3;\n    $19 = $1 + 44 | 0;\n    if ((HEAP32[$19 >> 2] | 0) == 4) break;\n    $22 = $1 + 52 | 0;\n    HEAP8[$22 >> 0] = 0;\n    $23 = $1 + 53 | 0;\n    HEAP8[$23 >> 0] = 0;\n    $25 = HEAP32[$0 + 8 >> 2] | 0;\n    FUNCTION_TABLE_viiiiii[HEAP32[(HEAP32[$25 >> 2] | 0) + 20 >> 2] & 3]($25, $1, $2, $2, 1, $4);\n    if (!(HEAP8[$23 >> 0] | 0)) {\n     $$037$off038 = 0;\n     label = 11;\n    } else if (!(HEAP8[$22 >> 0] | 0)) {\n     $$037$off038 = 1;\n     label = 11;\n    } else label = 15;\n    do if ((label | 0) == 11) {\n     HEAP32[$13 >> 2] = $2;\n     $33 = $1 + 40 | 0;\n     HEAP32[$33 >> 2] = (HEAP32[$33 >> 2] | 0) + 1;\n     if ((HEAP32[$1 + 36 >> 2] | 0) == 1) if ((HEAP32[$1 + 24 >> 2] | 0) == 2) {\n      HEAP8[$1 + 54 >> 0] = 1;\n      if ($$037$off038) {\n       label = 15;\n       break;\n      } else {\n       $43 = 4;\n       break;\n      }\n     }\n     if ($$037$off038) label = 15; else $43 = 4;\n    } while (0);\n    if ((label | 0) == 15) $43 = 3;\n    HEAP32[$19 >> 2] = $43;\n    break;\n   }\n  }\n  if (($3 | 0) == 1) HEAP32[$1 + 32 >> 2] = 1;\n } while (0);\n return;\n}\n\nfunction _icpGetJ_T_S($0) {\n $0 = $0 | 0;\n var $1 = 0, $10 = 0, $13 = 0, $15 = 0, $17 = 0, $2 = 0, $5 = 0, $7 = 0, $9 = 0, dest = 0, stop = 0;\n $1 = $0 + 64 | 0;\n dest = $0;\n stop = dest + 64 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAPF64[$1 >> 3] = -1.0;\n $2 = $0 + 72 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n HEAP32[$2 + 12 >> 2] = 0;\n HEAP32[$2 + 16 >> 2] = 0;\n HEAP32[$2 + 20 >> 2] = 0;\n HEAP32[$2 + 24 >> 2] = 0;\n HEAP32[$2 + 28 >> 2] = 0;\n HEAPF64[$0 + 104 >> 3] = 1.0;\n $5 = $0 + 160 | 0;\n dest = $0 + 112 | 0;\n stop = dest + 48 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAPF64[$5 >> 3] = 1.0;\n $7 = $0 + 240 | 0;\n dest = $0 + 168 | 0;\n stop = dest + 72 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAPF64[$7 >> 3] = -1.0;\n $9 = $0 + 296 | 0;\n dest = $0 + 248 | 0;\n stop = dest + 48 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAPF64[$9 >> 3] = -1.0;\n $10 = $0 + 304 | 0;\n HEAP32[$10 >> 2] = 0;\n HEAP32[$10 + 4 >> 2] = 0;\n HEAP32[$10 + 8 >> 2] = 0;\n HEAP32[$10 + 12 >> 2] = 0;\n HEAP32[$10 + 16 >> 2] = 0;\n HEAP32[$10 + 20 >> 2] = 0;\n HEAP32[$10 + 24 >> 2] = 0;\n HEAP32[$10 + 28 >> 2] = 0;\n HEAPF64[$0 + 336 >> 3] = 1.0;\n $13 = $0 + 456 | 0;\n dest = $0 + 344 | 0;\n stop = dest + 112 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAPF64[$13 >> 3] = 1.0;\n $15 = $0 + 512 | 0;\n dest = $0 + 464 | 0;\n stop = dest + 48 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAPF64[$15 >> 3] = 1.0;\n $17 = $0 + 568 | 0;\n dest = $0 + 520 | 0;\n stop = dest + 48 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAPF64[$17 >> 3] = 1.0;\n return;\n}\n\nfunction _arGetTransMatSquareCont($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = +$3;\n $4 = $4 | 0;\n var $$0 = 0, $$0$in = 0, $19 = 0, $26 = 0, $34 = 0, $42 = 0, $49 = 0.0, $5 = 0, $50 = 0.0, $6 = 0, $66 = 0, $7 = 0, $8 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 192 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(192);\n $5 = sp + 104 | 0;\n $6 = sp + 8 | 0;\n $7 = sp + 168 | 0;\n $8 = sp;\n do if ((HEAP32[$1 + 12 >> 2] | 0) < 0) $$0$in = $1 + 20 | 0; else if ((HEAP32[$1 + 8 >> 2] | 0) < 0) {\n  $$0$in = $1 + 24 | 0;\n  break;\n } else {\n  $$0$in = $1 + 16 | 0;\n  break;\n } while (0);\n $$0 = HEAP32[$$0$in >> 2] | 0;\n $19 = (4 - $$0 | 0) % 4 | 0;\n HEAPF64[$5 >> 3] = +HEAPF64[$1 + 168 + ($19 << 4) >> 3];\n HEAPF64[$5 + 8 >> 3] = +HEAPF64[$1 + 168 + ($19 << 4) + 8 >> 3];\n $26 = (5 - $$0 | 0) % 4 | 0;\n HEAPF64[$5 + 16 >> 3] = +HEAPF64[$1 + 168 + ($26 << 4) >> 3];\n HEAPF64[$5 + 24 >> 3] = +HEAPF64[$1 + 168 + ($26 << 4) + 8 >> 3];\n $34 = (6 - $$0 | 0) % 4 | 0;\n HEAPF64[$5 + 32 >> 3] = +HEAPF64[$1 + 168 + ($34 << 4) >> 3];\n HEAPF64[$5 + 40 >> 3] = +HEAPF64[$1 + 168 + ($34 << 4) + 8 >> 3];\n $42 = (7 - $$0 | 0) % 4 | 0;\n HEAPF64[$5 + 48 >> 3] = +HEAPF64[$1 + 168 + ($42 << 4) >> 3];\n HEAPF64[$5 + 56 >> 3] = +HEAPF64[$1 + 168 + ($42 << 4) + 8 >> 3];\n $49 = $3 * -.5;\n HEAPF64[$6 >> 3] = $49;\n $50 = $3 * .5;\n HEAPF64[$6 + 8 >> 3] = $50;\n HEAPF64[$6 + 16 >> 3] = 0.0;\n HEAPF64[$6 + 24 >> 3] = $50;\n HEAPF64[$6 + 32 >> 3] = $50;\n HEAPF64[$6 + 40 >> 3] = 0.0;\n HEAPF64[$6 + 48 >> 3] = $50;\n HEAPF64[$6 + 56 >> 3] = $49;\n HEAPF64[$6 + 64 >> 3] = 0.0;\n HEAPF64[$6 + 72 >> 3] = $49;\n HEAPF64[$6 + 80 >> 3] = $49;\n HEAPF64[$6 + 88 >> 3] = 0.0;\n HEAP32[$7 >> 2] = $5;\n HEAP32[$7 + 4 >> 2] = $6;\n HEAP32[$7 + 8 >> 2] = 4;\n $66 = (_icpPoint(HEAP32[$0 >> 2] | 0, $7, $2, $4, $8) | 0) < 0;\n STACKTOP = sp;\n return +($66 ? 1.0e8 : +HEAPF64[$8 >> 3]);\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_116parse_throw_exprINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$i = 0, $$1 = 0, $15 = 0, $16 = 0, $19 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $3 = sp + 24 | 0;\n $4 = sp;\n $5 = sp + 12 | 0;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 116) if ((HEAP8[$0 + 1 >> 0] | 0) == 119) {\n  $15 = $0 + 2 | 0;\n  $16 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($15, $1, $2) | 0;\n  if (($16 | 0) == ($15 | 0)) $$1 = $0; else {\n   $19 = $2 + 4 | 0;\n   $20 = HEAP32[$19 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($20 | 0)) $$1 = $0; else {\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($5, $20 + -24 | 0);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($5, 0, 15315) | 0;\n    HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n    HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n    HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n    $$0$i$i$i = 0;\n    while (1) {\n     if (($$0$i$i$i | 0) == 3) break;\n     HEAP32[$5 + ($$0$i$i$i << 2) >> 2] = 0;\n     $$0$i$i$i = $$0$i$i$i + 1 | 0;\n    }\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($3, $4);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_((HEAP32[$19 >> 2] | 0) + -24 | 0, $3);\n    __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($3);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($4);\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($5);\n    $$1 = $16;\n   }\n  }\n } else $$1 = $0; else $$1 = $0; else $$1 = $0;\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction _arParamLTCreate($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$057 = 0, $$058 = 0, $$059 = 0, $$1 = 0, $$160 = 0, $10 = 0, $15 = 0, $2 = 0, $20 = 0, $21 = 0, $23 = 0, $26 = 0, $28 = 0, $3 = 0, $32 = 0.0, $36 = 0.0, $4 = 0, $5 = 0, $6 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $2 = sp + 24 | 0;\n $3 = sp + 16 | 0;\n $4 = sp + 8 | 0;\n $5 = sp;\n $6 = _malloc(208) | 0;\n if (!$6) {\n  _arLog(0, 3, 5051, sp + 32 | 0);\n  _exit(1);\n }\n _memcpy($6 | 0, $0 | 0, 184) | 0;\n $9 = $1 << 1;\n $10 = (HEAP32[$0 >> 2] | 0) + $9 | 0;\n HEAP32[$6 + 192 >> 2] = $10;\n $15 = (HEAP32[$0 + 4 >> 2] | 0) + $9 | 0;\n HEAP32[$6 + 196 >> 2] = $15;\n HEAP32[$6 + 200 >> 2] = $1;\n HEAP32[$6 + 204 >> 2] = $1;\n $20 = Math_imul($10 << 3, $15) | 0;\n $21 = _malloc($20) | 0;\n HEAP32[$6 + 184 >> 2] = $21;\n if (!$21) {\n  _arLog(0, 3, 5051, sp + 40 | 0);\n  _exit(1);\n }\n $23 = _malloc($20) | 0;\n HEAP32[$6 + 188 >> 2] = $23;\n if (!$23) {\n  _arLog(0, 3, 5051, sp + 48 | 0);\n  _exit(1);\n }\n $26 = $0 + 104 | 0;\n $28 = HEAP32[$0 + 176 >> 2] | 0;\n $$0 = 0;\n $$058 = $23;\n $$059 = $21;\n while (1) {\n  if (($$0 | 0) >= ($15 | 0)) break;\n  $32 = +($$0 - $1 | 0);\n  $$057 = 0;\n  $$1 = $$058;\n  $$160 = $$059;\n  while (1) {\n   if (($$057 | 0) >= ($10 | 0)) break;\n   $36 = +($$057 - $1 | 0);\n   _arParamIdeal2Observ($26, $36, $32, $4, $5, $28) | 0;\n   HEAPF32[$$160 >> 2] = +HEAPF64[$4 >> 3];\n   HEAPF32[$$160 + 4 >> 2] = +HEAPF64[$5 >> 3];\n   _arParamObserv2Ideal($26, $36, $32, $2, $3, $28) | 0;\n   HEAPF32[$$1 >> 2] = +HEAPF64[$2 >> 3];\n   HEAPF32[$$1 + 4 >> 2] = +HEAPF64[$3 >> 3];\n   $$057 = $$057 + 1 | 0;\n   $$1 = $$1 + 8 | 0;\n   $$160 = $$160 + 8 | 0;\n  }\n  $$0 = $$0 + 1 | 0;\n  $$058 = $$1;\n  $$059 = $$160;\n }\n STACKTOP = sp;\n return $6 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_18demangleINS0_2DbEEEvPKcS4_RT_Ri($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $13 = 0, $14 = 0, $27 = 0, $28 = 0, label = 0;\n L1 : do if ($0 >>> 0 < $1 >>> 0) {\n  L3 : do if ((HEAP8[$0 >> 0] | 0) == 95) {\n   if (($1 - $0 | 0) <= 3) {\n    HEAP32[$3 >> 2] = -2;\n    break L1;\n   }\n   switch (HEAP8[$0 + 1 >> 0] | 0) {\n   case 90:\n    {\n     $13 = $0 + 2 | 0;\n     $14 = __ZN10__cxxabiv112_GLOBAL__N_114parse_encodingINS0_2DbEEEPKcS4_S4_RT_($13, $1, $2) | 0;\n     if (($14 | 0) == ($13 | 0) | ($14 | 0) == ($1 | 0)) $$0 = $14; else if ((HEAP8[$14 >> 0] | 0) == 46) $$0 = __ZN10__cxxabiv112_GLOBAL__N_116parse_dot_suffixINS0_2DbEEEPKcS4_S4_RT_($14, $1, $2) | 0; else $$0 = $14;\n     if (($$0 | 0) == ($1 | 0)) break L3;\n     HEAP32[$3 >> 2] = -2;\n     break L1;\n     break;\n    }\n   case 95:\n    {\n     label = 11;\n     break;\n    }\n   default:\n    {}\n   }\n   if ((label | 0) == 11) if ((HEAP8[$0 + 2 >> 0] | 0) == 95) if ((HEAP8[$0 + 3 >> 0] | 0) == 90) {\n    $27 = $0 + 4 | 0;\n    $28 = __ZN10__cxxabiv112_GLOBAL__N_114parse_encodingINS0_2DbEEEPKcS4_S4_RT_($27, $1, $2) | 0;\n    if (($28 | 0) == ($27 | 0) | ($28 | 0) == ($1 | 0)) {\n     HEAP32[$3 >> 2] = -2;\n     break L1;\n    }\n    if ((__ZN10__cxxabiv112_GLOBAL__N_118parse_block_invokeINS0_2DbEEEPKcS4_S4_RT_($28, $1, $2) | 0) == ($1 | 0)) break;\n    HEAP32[$3 >> 2] = -2;\n    break L1;\n   }\n   HEAP32[$3 >> 2] = -2;\n   break L1;\n  } else if ((__ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0) != ($1 | 0)) {\n   HEAP32[$3 >> 2] = -2;\n   break L1;\n  } while (0);\n  if (!(HEAP32[$3 >> 2] | 0)) if ((HEAP32[$2 >> 2] | 0) == (HEAP32[$2 + 4 >> 2] | 0)) HEAP32[$3 >> 2] = -2;\n } else HEAP32[$3 >> 2] = -2; while (0);\n return;\n}\n\nfunction _arMatrixPCA($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$064 = 0, $$065 = 0.0, $$1 = 0, $$2 = 0, $18 = 0, $24 = 0, $27 = 0.0, $32 = 0, $35 = 0, $39 = 0, $40 = 0, $49 = 0, $5 = 0, $7 = 0, $9 = 0;\n $5 = HEAP32[$0 + 4 >> 2] | 0;\n $7 = HEAP32[$0 + 8 >> 2] | 0;\n $9 = ($5 | 0) < ($7 | 0) ? $5 : $7;\n L1 : do if (($5 | 0) < 2 | ($7 | 0) < 2) $$064 = -1; else if ((HEAP32[$1 + 8 >> 2] | 0) == ($7 | 0)) if ((HEAP32[$1 + 4 >> 2] | 0) == ($9 | 0)) {\n  $18 = $2 + 4 | 0;\n  if ((HEAP32[$18 >> 2] | 0) == ($9 | 0)) if ((HEAP32[$3 + 4 >> 2] | 0) == ($7 | 0)) {\n   $24 = _arMatrixAllocDup($0) | 0;\n   if (!$24) $$064 = -1; else {\n    $27 = +Math_sqrt(+(+($5 | 0)));\n    if ((_EX($24, $3) | 0) < 0) {\n     _arMatrixFree($24) | 0;\n     $$064 = -1;\n     break;\n    }\n    if ((_CENTER($24, $3) | 0) < 0) {\n     _arMatrixFree($24) | 0;\n     $$064 = -1;\n     break;\n    }\n    $32 = Math_imul($7, $5) | 0;\n    $$0 = 0;\n    while (1) {\n     if (($$0 | 0) >= ($32 | 0)) break;\n     $35 = (HEAP32[$24 >> 2] | 0) + ($$0 << 3) | 0;\n     HEAPF64[$35 >> 3] = +HEAPF64[$35 >> 3] / $27;\n     $$0 = $$0 + 1 | 0;\n    }\n    $39 = _PCA($24, $1, $2) | 0;\n    _arMatrixFree($24) | 0;\n    $40 = HEAP32[$18 >> 2] | 0;\n    $$065 = 0.0;\n    $$1 = 0;\n    while (1) {\n     if (($$1 | 0) >= ($40 | 0)) break;\n     $$065 = $$065 + +HEAPF64[(HEAP32[$2 >> 2] | 0) + ($$1 << 3) >> 3];\n     $$1 = $$1 + 1 | 0;\n    }\n    $$2 = 0;\n    while (1) {\n     if (($$2 | 0) >= ($40 | 0)) {\n      $$064 = $39;\n      break L1;\n     }\n     $49 = (HEAP32[$2 >> 2] | 0) + ($$2 << 3) | 0;\n     HEAPF64[$49 >> 3] = +HEAPF64[$49 >> 3] / $$065;\n     $$2 = $$2 + 1 | 0;\n    }\n   }\n  } else $$064 = -1; else $$064 = -1;\n } else $$064 = -1; else $$064 = -1; while (0);\n return $$064 | 0;\n}\n\nfunction _vfprintf($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$1 = 0, $13 = 0, $14 = 0, $19 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $28 = 0, $29 = 0, $3 = 0, $35 = 0, $4 = 0, $40 = 0, $5 = 0, $6 = 0, $spec$select = 0, dest = 0, sp = 0, stop = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 224 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(224);\n $3 = sp + 120 | 0;\n $4 = sp + 80 | 0;\n $5 = sp;\n $6 = sp + 136 | 0;\n dest = $4;\n stop = dest + 40 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAP32[$3 >> 2] = HEAP32[$2 >> 2];\n if ((_printf_core(0, $1, $3, $5, $4) | 0) < 0) $$0 = -1; else {\n  if ((HEAP32[$0 + 76 >> 2] | 0) > -1) $40 = ___lockfile($0) | 0; else $40 = 0;\n  $13 = HEAP32[$0 >> 2] | 0;\n  $14 = $13 & 32;\n  if ((HEAP8[$0 + 74 >> 0] | 0) < 1) HEAP32[$0 >> 2] = $13 & -33;\n  $19 = $0 + 48 | 0;\n  if (!(HEAP32[$19 >> 2] | 0)) {\n   $23 = $0 + 44 | 0;\n   $24 = HEAP32[$23 >> 2] | 0;\n   HEAP32[$23 >> 2] = $6;\n   $25 = $0 + 28 | 0;\n   HEAP32[$25 >> 2] = $6;\n   $26 = $0 + 20 | 0;\n   HEAP32[$26 >> 2] = $6;\n   HEAP32[$19 >> 2] = 80;\n   $28 = $0 + 16 | 0;\n   HEAP32[$28 >> 2] = $6 + 80;\n   $29 = _printf_core($0, $1, $3, $5, $4) | 0;\n   if (!$24) $$1 = $29; else {\n    FUNCTION_TABLE_iiii[HEAP32[$0 + 36 >> 2] & 15]($0, 0, 0) | 0;\n    $spec$select = (HEAP32[$26 >> 2] | 0) == 0 ? -1 : $29;\n    HEAP32[$23 >> 2] = $24;\n    HEAP32[$19 >> 2] = 0;\n    HEAP32[$28 >> 2] = 0;\n    HEAP32[$25 >> 2] = 0;\n    HEAP32[$26 >> 2] = 0;\n    $$1 = $spec$select;\n   }\n  } else $$1 = _printf_core($0, $1, $3, $5, $4) | 0;\n  $35 = HEAP32[$0 >> 2] | 0;\n  HEAP32[$0 >> 2] = $35 | $14;\n  if ($40 | 0) ___unlockfile($0);\n  $$0 = ($35 & 32 | 0) == 0 ? $$1 : -1;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairaSEOS1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i$i$i = 0, $$0$i$i$i$i3 = 0, $10 = 0, $11 = 0, $12 = 0, $15 = 0, $2 = 0, $3 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = $0 + 11 | 0;\n if ((HEAP8[$3 >> 0] | 0) < 0) {\n  $6 = HEAP32[$0 >> 2] | 0;\n  HEAP8[$2 >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($6, $2);\n  HEAP32[$0 + 4 >> 2] = 0;\n } else {\n  HEAP8[$2 >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($0, $2);\n  HEAP8[$3 >> 0] = 0;\n }\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($0);\n HEAP32[$0 >> 2] = HEAP32[$1 >> 2];\n HEAP32[$0 + 4 >> 2] = HEAP32[$1 + 4 >> 2];\n HEAP32[$0 + 8 >> 2] = HEAP32[$1 + 8 >> 2];\n $$0$i$i$i$i = 0;\n while (1) {\n  if (($$0$i$i$i$i | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i$i$i << 2) >> 2] = 0;\n  $$0$i$i$i$i = $$0$i$i$i$i + 1 | 0;\n }\n $10 = $0 + 12 | 0;\n $11 = $1 + 12 | 0;\n $12 = $10 + 11 | 0;\n if ((HEAP8[$12 >> 0] | 0) < 0) {\n  $15 = HEAP32[$10 >> 2] | 0;\n  HEAP8[$2 >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($15, $2);\n  HEAP32[$0 + 16 >> 2] = 0;\n } else {\n  HEAP8[$2 >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($10, $2);\n  HEAP8[$12 >> 0] = 0;\n }\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7reserveEj($10);\n HEAP32[$10 >> 2] = HEAP32[$11 >> 2];\n HEAP32[$10 + 4 >> 2] = HEAP32[$11 + 4 >> 2];\n HEAP32[$10 + 8 >> 2] = HEAP32[$11 + 8 >> 2];\n $$0$i$i$i$i3 = 0;\n while (1) {\n  if (($$0$i$i$i$i3 | 0) == 3) break;\n  HEAP32[$11 + ($$0$i$i$i$i3 << 2) >> 2] = 0;\n  $$0$i$i$i$i3 = $$0$i$i$i$i3 + 1 | 0;\n }\n STACKTOP = sp;\n return;\n}\n\nfunction _setMarkerInfoVertex($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$1 = 0, $15 = 0.0, $17 = 0.0, $19 = 0.0, $2 = 0, $21 = 0.0, $23 = 0.0, $25 = 0.0, $27 = 0.0, $29 = 0.0, $7 = 0, $8 = 0, $spec$select = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0)) $$1 = HEAP32[489] | 0; else {\n  $7 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 216 | 0;\n  $8 = HEAP32[$7 >> 2] | 0;\n  if ((HEAP32[$8 + 44 >> 2] | 0) > ($1 | 0)) {\n   $spec$select = ($1 | 0) < 0 ? 17e3 : $8 + 48 + ($1 << 8) | 0;\n   $15 = +HEAPF64[2157];\n   HEAPF64[$spec$select + 168 >> 3] = $15;\n   $17 = +HEAPF64[2158];\n   HEAPF64[$spec$select + 176 >> 3] = $17;\n   $19 = +HEAPF64[2159];\n   HEAPF64[$spec$select + 184 >> 3] = $19;\n   $21 = +HEAPF64[2160];\n   HEAPF64[$spec$select + 192 >> 3] = $21;\n   $23 = +HEAPF64[2161];\n   HEAPF64[$spec$select + 200 >> 3] = $23;\n   $25 = +HEAPF64[2162];\n   HEAPF64[$spec$select + 208 >> 3] = $25;\n   $27 = +HEAPF64[2163];\n   HEAPF64[$spec$select + 216 >> 3] = $27;\n   $29 = +HEAPF64[2164];\n   HEAPF64[$spec$select + 224 >> 3] = $29;\n   HEAPF64[$spec$select + 56 >> 3] = ($15 + $19 + $23 + $27) * .25;\n   HEAPF64[$spec$select + 64 >> 3] = ($17 + $21 + $25 + $29) * .25;\n   $$1 = 0;\n   break;\n  } else {\n   $$1 = HEAP32[491] | 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction ___dynamic_cast($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $10 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $4 = 0, $5 = 0, $8 = 0, dest = 0, sp = 0, stop = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $4 = sp;\n $5 = HEAP32[$0 >> 2] | 0;\n $8 = $0 + (HEAP32[$5 + -8 >> 2] | 0) | 0;\n $10 = HEAP32[$5 + -4 >> 2] | 0;\n HEAP32[$4 >> 2] = $2;\n HEAP32[$4 + 4 >> 2] = $0;\n HEAP32[$4 + 8 >> 2] = $1;\n HEAP32[$4 + 12 >> 2] = $3;\n $14 = $4 + 16 | 0;\n $15 = $4 + 20 | 0;\n $16 = $4 + 24 | 0;\n $17 = $4 + 28 | 0;\n $18 = $4 + 32 | 0;\n $19 = $4 + 40 | 0;\n dest = $14;\n stop = dest + 36 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAP16[$14 + 36 >> 1] = 0;\n HEAP8[$14 + 38 >> 0] = 0;\n L1 : do if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($10, $2, 0) | 0) {\n  HEAP32[$4 + 48 >> 2] = 1;\n  FUNCTION_TABLE_viiiiii[HEAP32[(HEAP32[$10 >> 2] | 0) + 20 >> 2] & 3]($10, $4, $8, $8, 1, 0);\n  $$0 = (HEAP32[$16 >> 2] | 0) == 1 ? $8 : 0;\n } else {\n  FUNCTION_TABLE_viiiii[HEAP32[(HEAP32[$10 >> 2] | 0) + 24 >> 2] & 3]($10, $4, $8, 1, 0);\n  switch (HEAP32[$4 + 36 >> 2] | 0) {\n  case 0:\n   {\n    $$0 = (HEAP32[$19 >> 2] | 0) == 1 & (HEAP32[$17 >> 2] | 0) == 1 & (HEAP32[$18 >> 2] | 0) == 1 ? HEAP32[$15 >> 2] | 0 : 0;\n    break L1;\n    break;\n   }\n  case 1:\n   break;\n  default:\n   {\n    $$0 = 0;\n    break L1;\n   }\n  }\n  if ((HEAP32[$16 >> 2] | 0) != 1) if (!((HEAP32[$19 >> 2] | 0) == 0 & (HEAP32[$17 >> 2] | 0) == 1 & (HEAP32[$18 >> 2] | 0) == 1)) {\n   $$0 = 0;\n   break;\n  }\n  $$0 = HEAP32[$14 >> 2] | 0;\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _addMultiMarker($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$1 = 0, $14 = 0, $15 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $31 = 0, $36 = 0, $37 = 0, $6 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp + 8 | 0;\n $2 = sp + 12 | 0;\n $3 = sp;\n HEAP32[$2 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0)) $$1 = -1; else {\n  $6 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0;\n  if ((HEAP8[$1 + 11 >> 0] | 0) < 0) $15 = HEAP32[$1 >> 2] | 0; else $15 = $1;\n  $14 = $6 + 224 | 0;\n  if (!(__ZL15loadMultiMarkerPKcP8ARHandlePP12ARPattHandlePP18ARMultiMarkerInfoT($15, HEAP32[$6 + 216 >> 2] | 0, $6 + 220 | 0, $14) | 0)) {\n   _arLog(0, 3, 9892, $vararg_buffer);\n   $$1 = -1;\n   break;\n  }\n  $18 = $6 + 248 | 0;\n  $19 = $6 + 252 | 0;\n  $20 = HEAP32[$19 >> 2] | 0;\n  HEAP32[$3 >> 2] = $20 - (HEAP32[$18 >> 2] | 0) >> 3;\n  HEAP32[$3 + 4 >> 2] = HEAP32[$14 >> 2];\n  if ((HEAP32[$6 + 256 >> 2] | 0) == ($20 | 0)) __ZNSt3__26vectorI12multi_markerNS_9allocatorIS1_EEE21__push_back_slow_pathIRKS1_EEvOT_($18, $3); else {\n   $31 = $3;\n   $36 = HEAP32[$31 + 4 >> 2] | 0;\n   $37 = $20;\n   HEAP32[$37 >> 2] = HEAP32[$31 >> 2];\n   HEAP32[$37 + 4 >> 2] = $36;\n   HEAP32[$19 >> 2] = (HEAP32[$19 >> 2] | 0) + 8;\n  }\n  $$1 = HEAP32[$3 >> 2] | 0;\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_115parse_simple_idINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i$add$i = 0, $$0$i$i$idx$i = 0, $$3 = 0, $10 = 0, $17 = 0, $22 = 0, $23 = 0, $3 = 0, $5 = 0, $7 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n if (($0 | 0) == ($1 | 0)) $$3 = $0; else {\n  $5 = __ZN10__cxxabiv112_GLOBAL__N_117parse_source_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n  if (($5 | 0) == ($0 | 0)) $$3 = $0; else {\n   $7 = __ZN10__cxxabiv112_GLOBAL__N_119parse_template_argsINS0_2DbEEEPKcS4_S4_RT_($5, $1, $2) | 0;\n   if (($7 | 0) == ($5 | 0)) $$3 = $5; else {\n    $9 = $2 + 4 | 0;\n    $10 = HEAP32[$9 >> 2] | 0;\n    if ((($10 - (HEAP32[$2 >> 2] | 0) | 0) / 24 | 0) >>> 0 < 2) $$3 = $0; else {\n     __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($3, $10 + -24 | 0);\n     $17 = HEAP32[$9 >> 2] | 0;\n     $$0$i$i$idx$i = 0;\n     while (1) {\n      if (($$0$i$i$idx$i | 0) == -1) break;\n      $$0$i$i$add$i = $$0$i$i$idx$i + -1 | 0;\n      __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($17 + ($$0$i$i$add$i * 24 | 0) | 0);\n      $$0$i$i$idx$i = $$0$i$i$add$i;\n     }\n     HEAP32[$9 >> 2] = $17 + -24;\n     $22 = HEAP8[$3 + 11 >> 0] | 0;\n     $23 = $22 << 24 >> 24 < 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($17 + -48 | 0, $23 ? HEAP32[$3 >> 2] | 0 : $3, $23 ? HEAP32[$3 + 4 >> 2] | 0 : $22 & 255) | 0;\n     __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($3);\n     $$3 = $7;\n    }\n   }\n  }\n }\n STACKTOP = sp;\n return $$3 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_118parse_template_argINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$051 = 0, $$4 = 0, $13 = 0, $17 = 0, $20 = 0, $24 = 0, $25 = 0, $6 = 0, $7 = 0;\n L1 : do if (($0 | 0) == ($1 | 0)) $$4 = $0; else switch (HEAP8[$0 >> 0] | 0) {\n case 88:\n  {\n   $6 = $0 + 1 | 0;\n   $7 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($6, $1, $2) | 0;\n   if (($7 | 0) == ($6 | 0) | ($7 | 0) == ($1 | 0)) {\n    $$4 = $0;\n    break L1;\n   }\n   $$4 = (HEAP8[$7 >> 0] | 0) == 69 ? $7 + 1 | 0 : $0;\n   break L1;\n   break;\n  }\n case 74:\n  {\n   $13 = $0 + 1 | 0;\n   if (($13 | 0) == ($1 | 0)) {\n    $$4 = $0;\n    break L1;\n   }\n   $$051 = $13;\n   while (1) {\n    if ((HEAP8[$$051 >> 0] | 0) == 69) break;\n    $17 = __ZN10__cxxabiv112_GLOBAL__N_118parse_template_argINS0_2DbEEEPKcS4_S4_RT_($$051, $1, $2) | 0;\n    if (($17 | 0) == ($$051 | 0)) {\n     $$4 = $0;\n     break L1;\n    } else $$051 = $17;\n   }\n   $$4 = $$051 + 1 | 0;\n   break L1;\n   break;\n  }\n case 76:\n  {\n   $20 = $0 + 1 | 0;\n   if (($20 | 0) != ($1 | 0)) if ((HEAP8[$20 >> 0] | 0) == 90) {\n    $24 = $0 + 2 | 0;\n    $25 = __ZN10__cxxabiv112_GLOBAL__N_114parse_encodingINS0_2DbEEEPKcS4_S4_RT_($24, $1, $2) | 0;\n    if (($25 | 0) == ($24 | 0) | ($25 | 0) == ($1 | 0)) {\n     $$4 = $0;\n     break L1;\n    }\n    $$4 = (HEAP8[$25 >> 0] | 0) == 69 ? $25 + 1 | 0 : $0;\n    break L1;\n   }\n   $$4 = __ZN10__cxxabiv112_GLOBAL__N_118parse_expr_primaryINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   break L1;\n   break;\n  }\n default:\n  {\n   $$4 = __ZN10__cxxabiv112_GLOBAL__N_110parse_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   break L1;\n  }\n } while (0);\n return $$4 | 0;\n}\n\nfunction ___mo_lookup($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$090 = 0, $$094 = 0, $$4 = 0, $10 = 0, $13 = 0, $17 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $31 = 0, $35 = 0, $4 = 0, $44 = 0, $46 = 0, $49 = 0, $53 = 0, $63 = 0, $7 = 0;\n $4 = (HEAP32[$0 >> 2] | 0) + 1794895138 | 0;\n $7 = _swapc(HEAP32[$0 + 8 >> 2] | 0, $4) | 0;\n $10 = _swapc(HEAP32[$0 + 12 >> 2] | 0, $4) | 0;\n $13 = _swapc(HEAP32[$0 + 16 >> 2] | 0, $4) | 0;\n L1 : do if ($7 >>> 0 < $1 >>> 2 >>> 0) {\n  $17 = $1 - ($7 << 2) | 0;\n  if ($10 >>> 0 < $17 >>> 0 & $13 >>> 0 < $17 >>> 0) if (!(($13 | $10) & 3)) {\n   $23 = $10 >>> 2;\n   $24 = $13 >>> 2;\n   $$090 = 0;\n   $$094 = $7;\n   while (1) {\n    $25 = $$094 >>> 1;\n    $26 = $$090 + $25 | 0;\n    $27 = $26 << 1;\n    $28 = $27 + $23 | 0;\n    $31 = _swapc(HEAP32[$0 + ($28 << 2) >> 2] | 0, $4) | 0;\n    $35 = _swapc(HEAP32[$0 + ($28 + 1 << 2) >> 2] | 0, $4) | 0;\n    if (!($35 >>> 0 < $1 >>> 0 & $31 >>> 0 < ($1 - $35 | 0) >>> 0)) {\n     $$4 = 0;\n     break L1;\n    }\n    if (HEAP8[$0 + ($35 + $31) >> 0] | 0) {\n     $$4 = 0;\n     break L1;\n    }\n    $44 = _strcmp($2, $0 + $35 | 0) | 0;\n    if (!$44) break;\n    $63 = ($44 | 0) < 0;\n    if (($$094 | 0) == 1) {\n     $$4 = 0;\n     break L1;\n    }\n    $$090 = $63 ? $$090 : $26;\n    $$094 = $63 ? $25 : $$094 - $25 | 0;\n   }\n   $46 = $27 + $24 | 0;\n   $49 = _swapc(HEAP32[$0 + ($46 << 2) >> 2] | 0, $4) | 0;\n   $53 = _swapc(HEAP32[$0 + ($46 + 1 << 2) >> 2] | 0, $4) | 0;\n   if ($53 >>> 0 < $1 >>> 0 & $49 >>> 0 < ($1 - $53 | 0) >>> 0) $$4 = (HEAP8[$0 + ($53 + $49) >> 0] | 0) == 0 ? $0 + $53 | 0 : 0; else $$4 = 0;\n  } else $$4 = 0; else $$4 = 0;\n } else $$4 = 0; while (0);\n return $$4 | 0;\n}\n\nfunction _confidenceCutoff($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$049 = 0, $$150 = 0, $$2 = 0, $16 = 0, $18 = 0, $28 = 0, $30 = 0, $36 = 0, $4 = 0, $6 = 0;\n L1 : do switch (HEAP32[$0 + 24 >> 2] | 0) {\n case 1:\n case 0:\n  {\n   $4 = HEAP32[$0 + 44 >> 2] | 0;\n   $$049 = 0;\n   while (1) {\n    if (($$049 | 0) >= ($4 | 0)) break L1;\n    $6 = $0 + 48 + ($$049 << 8) + 4 | 0;\n    if ((HEAP32[$6 >> 2] | 0) > -1) if (+HEAPF64[$0 + 48 + ($$049 << 8) + 32 >> 3] < .5) {\n     HEAP32[$0 + 48 + ($$049 << 8) + 8 >> 2] = -1;\n     HEAP32[$6 >> 2] = -1;\n     HEAP32[$0 + 48 + ($$049 << 8) + 236 >> 2] = 6;\n    }\n    $$049 = $$049 + 1 | 0;\n   }\n   break;\n  }\n case 2:\n  {\n   $16 = HEAP32[$0 + 44 >> 2] | 0;\n   $$150 = 0;\n   while (1) {\n    if (($$150 | 0) >= ($16 | 0)) break L1;\n    $18 = $0 + 48 + ($$150 << 8) + 4 | 0;\n    if ((HEAP32[$18 >> 2] | 0) > -1) if (+HEAPF64[$0 + 48 + ($$150 << 8) + 32 >> 3] < .5) {\n     HEAP32[$0 + 48 + ($$150 << 8) + 12 >> 2] = -1;\n     HEAP32[$18 >> 2] = -1;\n     HEAP32[$0 + 48 + ($$150 << 8) + 236 >> 2] = 6;\n    }\n    $$150 = $$150 + 1 | 0;\n   }\n   break;\n  }\n default:\n  {\n   $28 = HEAP32[$0 + 44 >> 2] | 0;\n   $$2 = 0;\n   while (1) {\n    if (($$2 | 0) >= ($28 | 0)) break L1;\n    $30 = $0 + 48 + ($$2 << 8) + 8 | 0;\n    if ((HEAP32[$30 >> 2] | 0) > -1) if (+HEAPF64[$0 + 48 + ($$2 << 8) + 40 >> 3] < .5) {\n     HEAP32[$30 >> 2] = -1;\n     $$0 = 0;\n    } else $$0 = 1; else $$0 = 1;\n    $36 = $0 + 48 + ($$2 << 8) + 12 | 0;\n    if ((HEAP32[$36 >> 2] | 0) > -1) if (+HEAPF64[$0 + 48 + ($$2 << 8) + 48 >> 3] < .5) {\n     HEAP32[$36 >> 2] = -1;\n     if (!$$0) HEAP32[$0 + 48 + ($$2 << 8) + 236 >> 2] = 6;\n    }\n    $$2 = $$2 + 1 | 0;\n   }\n  }\n } while (0);\n return;\n}\n\nfunction _arImageProcLumaHistAndOtsu($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$062 = 0, $$064 = 0.0, $$067 = 0.0, $$068 = 0.0, $$070 = 0.0, $$169 = 0.0, $$2 = 0, $$266 = 0.0, $$3 = 0, $$pre$phiZ2D = 0, $15 = 0.0, $17 = 0, $21 = 0.0, $25 = 0.0, $3 = 0, $30 = 0.0, $32 = 0.0, $33 = 0, $34 = 0, $indvars$iv = 0, $indvars$iv71 = 0;\n $3 = _arImageProcLumaHist($0, $1) | 0;\n if (($3 | 0) < 0) $$0 = $3; else {\n  $$070 = 0.0;\n  $indvars$iv71 = 1;\n  do {\n   $$070 = $$070 + +((Math_imul(HEAP32[$0 + 12 + ($indvars$iv71 << 2) >> 2] | 0, $indvars$iv71) | 0) >>> 0);\n   $indvars$iv71 = $indvars$iv71 + 1 | 0;\n  } while (($indvars$iv71 | 0) != 256);\n  $15 = +(Math_imul(HEAP32[$0 + 8 >> 2] | 0, HEAP32[$0 + 4 >> 2] | 0) | 0);\n  $$062 = 0;\n  $$064 = 0.0;\n  $$067 = 0.0;\n  $$068 = 0.0;\n  $indvars$iv = 0;\n  while (1) {\n   $17 = HEAP32[$0 + 12 + ($indvars$iv << 2) >> 2] | 0;\n   $$067 = $$067 + +($17 >>> 0);\n   if ($$067 != 0.0) {\n    $21 = $15 - $$067;\n    if ($21 == 0.0) {\n     $$3 = $$062;\n     break;\n    }\n    $25 = $$068 + +((Math_imul($17, $indvars$iv) | 0) >>> 0);\n    $30 = $25 / $$067 - ($$070 - $25) / $21;\n    $32 = $30 * ($$067 * $21 * $30);\n    $33 = $32 > $$064;\n    $34 = $indvars$iv & 255;\n    $$169 = $25;\n    $$2 = $33 ? $34 : $$062;\n    $$266 = $33 ? $32 : $$064;\n    $$pre$phiZ2D = $34;\n   } else {\n    $$169 = $$068;\n    $$2 = $$062;\n    $$266 = $$064;\n    $$pre$phiZ2D = $indvars$iv & 255;\n   }\n   if ($$pre$phiZ2D << 24 >> 24 == -1) {\n    $$3 = $$2;\n    break;\n   } else {\n    $$062 = $$2;\n    $$064 = $$266;\n    $$068 = $$169;\n    $indvars$iv = $indvars$iv + 1 | 0;\n   }\n  }\n  HEAP8[$2 >> 0] = $$3;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE24__emplace_back_slow_pathIJS5_EEEvDpOT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $14 = 0, $15 = 0, $19 = 0, $2 = 0, $24 = 0, $25 = 0, $3 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp;\n $3 = $0 + 4 | 0;\n $8 = ((HEAP32[$3 >> 2] | 0) - (HEAP32[$0 >> 2] | 0) >> 4) + 1 | 0;\n $9 = __ZNKSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE8max_sizeEv($0) | 0;\n if ($9 >>> 0 < $8 >>> 0) __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0); else {\n  $14 = HEAP32[$0 >> 2] | 0;\n  $15 = (HEAP32[$0 + 8 >> 2] | 0) - $14 | 0;\n  $19 = $15 >> 3;\n  __ZNSt3__214__split_bufferINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEERNS5_IS7_Lj4096EEEEC2EjjS9_($2, $15 >> 4 >>> 0 < $9 >>> 1 >>> 0 ? ($19 >>> 0 < $8 >>> 0 ? $8 : $19) : $9, (HEAP32[$3 >> 2] | 0) - $14 >> 4, $0 + 12 | 0);\n  $24 = $2 + 8 | 0;\n  $25 = HEAP32[$24 >> 2] | 0;\n  HEAP32[$25 >> 2] = 0;\n  HEAP32[$25 + 4 >> 2] = 0;\n  HEAP32[$25 + 8 >> 2] = 0;\n  HEAP32[$25 + 12 >> 2] = HEAP32[$1 >> 2];\n  HEAP32[$24 >> 2] = $25 + 16;\n  __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS6_RS7_EE($0, $2);\n  __ZNSt3__214__split_bufferINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEERNS5_IS7_Lj4096EEEED2Ev($2);\n  STACKTOP = sp;\n  return;\n }\n}\n\nfunction __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE24__emplace_back_slow_pathIJEEEvDpOT_($0) {\n $0 = $0 | 0;\n var $1 = 0, $13 = 0, $15 = 0, $18 = 0, $2 = 0, $23 = 0, $24 = 0, $7 = 0, $8 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $1 = sp;\n $2 = $0 + 4 | 0;\n $7 = (((HEAP32[$2 >> 2] | 0) - (HEAP32[$0 >> 2] | 0) | 0) / 24 | 0) + 1 | 0;\n $8 = __ZNKSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE8max_sizeEv($0) | 0;\n if ($8 >>> 0 < $7 >>> 0) __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0); else {\n  $13 = HEAP32[$0 >> 2] | 0;\n  $15 = ((HEAP32[$0 + 8 >> 2] | 0) - $13 | 0) / 24 | 0;\n  $18 = $15 << 1;\n  __ZNSt3__214__split_bufferIN10__cxxabiv112_GLOBAL__N_111string_pairERNS2_11short_allocIS3_Lj4096EEEEC2EjjS6_($1, $15 >>> 0 < $8 >>> 1 >>> 0 ? ($18 >>> 0 < $7 >>> 0 ? $7 : $18) : $8, ((HEAP32[$2 >> 2] | 0) - $13 | 0) / 24 | 0, $0 + 12 | 0);\n  $23 = $1 + 8 | 0;\n  $24 = HEAP32[$23 >> 2] | 0;\n  HEAP32[$24 >> 2] = 0;\n  HEAP32[$24 + 4 >> 2] = 0;\n  HEAP32[$24 + 8 >> 2] = 0;\n  HEAP32[$24 + 12 >> 2] = 0;\n  HEAP32[$24 + 16 >> 2] = 0;\n  HEAP32[$24 + 20 >> 2] = 0;\n  __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2Ev($24);\n  HEAP32[$23 >> 2] = $24 + 24;\n  __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS5_EE($0, $1);\n  __ZNSt3__214__split_bufferIN10__cxxabiv112_GLOBAL__N_111string_pairERNS2_11short_allocIS3_Lj4096EEEED2Ev($1);\n  STACKTOP = sp;\n  return;\n }\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE21__grow_by_and_replaceEjjjjjjPKc($0, $1, $2, $3, $4, $5, $6, $7) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n $7 = $7 | 0;\n var $$sroa$speculated = 0, $16 = 0, $17 = 0, $22 = 0, $23 = 0, $25 = 0, $28 = 0, $29 = 0, $38 = 0, $8 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $8 = sp;\n if ((-18 - $1 | 0) >>> 0 < $2 >>> 0) __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv($0);\n if ((HEAP8[$0 + 11 >> 0] | 0) < 0) $25 = HEAP32[$0 >> 2] | 0; else $25 = $0;\n if ($1 >>> 0 < 2147483623) {\n  $16 = $2 + $1 | 0;\n  $17 = $1 << 1;\n  $$sroa$speculated = $16 >>> 0 < $17 >>> 0 ? $17 : $16;\n  $22 = $$sroa$speculated >>> 0 < 11 ? 11 : $$sroa$speculated + 16 & -16;\n } else $22 = -17;\n $23 = __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE8allocateEj($22) | 0;\n if ($4 | 0) __ZNSt3__211char_traitsIcE4copyEPcPKcj($23, $25, $4) | 0;\n if ($6 | 0) __ZNSt3__211char_traitsIcE4copyEPcPKcj($23 + $4 | 0, $7, $6) | 0;\n $28 = $3 - $5 | 0;\n $29 = $28 - $4 | 0;\n if ($29 | 0) __ZNSt3__211char_traitsIcE4copyEPcPKcj($23 + $4 + $6 | 0, $25 + $4 + $5 | 0, $29) | 0;\n if (($1 | 0) != 10) __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE10deallocateEPcj($25);\n HEAP32[$0 >> 2] = $23;\n HEAP32[$0 + 8 >> 2] = $22 | -2147483648;\n $38 = $28 + $6 | 0;\n HEAP32[$0 + 4 >> 2] = $38;\n HEAP8[$8 >> 0] = 0;\n __ZNSt3__211char_traitsIcE6assignERcRKc($23 + $38 | 0, $8);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZL25default_terminate_handlerv() {\n var $0 = 0, $1 = 0, $12 = 0, $22 = 0, $23 = 0, $25 = 0, $3 = 0, $30 = 0, $34 = 0, $7 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer10 = 0, $vararg_buffer3 = 0, $vararg_buffer7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $vararg_buffer10 = sp + 32 | 0;\n $vararg_buffer7 = sp + 24 | 0;\n $vararg_buffer3 = sp + 16 | 0;\n $vararg_buffer = sp;\n $0 = sp + 36 | 0;\n $1 = ___cxa_get_globals_fast() | 0;\n if ($1 | 0) {\n  $3 = HEAP32[$1 >> 2] | 0;\n  if ($3 | 0) {\n   $7 = $3 + 48 | 0;\n   $9 = HEAP32[$7 >> 2] | 0;\n   $12 = HEAP32[$7 + 4 >> 2] | 0;\n   if (!(($9 & -256 | 0) == 1126902528 & ($12 | 0) == 1129074247)) {\n    HEAP32[$vararg_buffer7 >> 2] = 14598;\n    _abort_message(14548, $vararg_buffer7);\n   }\n   if (($9 | 0) == 1126902529 & ($12 | 0) == 1129074247) $22 = HEAP32[$3 + 44 >> 2] | 0; else $22 = $3 + 80 | 0;\n   HEAP32[$0 >> 2] = $22;\n   $23 = HEAP32[$3 >> 2] | 0;\n   $25 = HEAP32[$23 + 4 >> 2] | 0;\n   if (FUNCTION_TABLE_iiii[HEAP32[(HEAP32[48] | 0) + 16 >> 2] & 15](192, $23, $0) | 0) {\n    $30 = HEAP32[$0 >> 2] | 0;\n    $34 = FUNCTION_TABLE_ii[HEAP32[(HEAP32[$30 >> 2] | 0) + 8 >> 2] & 31]($30) | 0;\n    HEAP32[$vararg_buffer >> 2] = 14598;\n    HEAP32[$vararg_buffer + 4 >> 2] = $25;\n    HEAP32[$vararg_buffer + 8 >> 2] = $34;\n    _abort_message(14462, $vararg_buffer);\n   } else {\n    HEAP32[$vararg_buffer3 >> 2] = 14598;\n    HEAP32[$vararg_buffer3 + 4 >> 2] = $25;\n    _abort_message(14507, $vararg_buffer3);\n   }\n  }\n }\n _abort_message(14586, $vararg_buffer10);\n}\n\nfunction _teardown($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$016 = 0, $1 = 0, $11 = 0, $12 = 0, $14 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$016 = -1; else {\n  $4 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0;\n  $5 = $4 + 196 | 0;\n  $6 = HEAP32[$5 >> 2] | 0;\n  if ($6 | 0) {\n   _free($6);\n   HEAP32[$5 >> 2] = 0;\n   HEAP32[$4 + 200 >> 2] = 0;\n  }\n  _deleteHandle($4);\n  _arPattDeleteHandle(HEAP32[$4 + 220 >> 2] | 0) | 0;\n  __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE14__erase_uniqueIiEEjRKT_(17356, $1) | 0;\n  $11 = $4 + 248 | 0;\n  $12 = $4 + 252 | 0;\n  $$0 = 0;\n  while (1) {\n   $14 = HEAP32[$11 >> 2] | 0;\n   if ($$0 >>> 0 >= (HEAP32[$12 >> 2] | 0) - $14 >> 3 >>> 0) break;\n   _arMultiFreeConfig(HEAP32[$14 + ($$0 << 3) + 4 >> 2] | 0) | 0;\n   $$0 = $$0 + 1 | 0;\n  }\n  __ZNSt3__213__vector_baseI12multi_markerNS_9allocatorIS1_EEED2Ev($11);\n  __ZdlPv($11);\n  __ZN12arControllerD2Ev($4);\n  __ZdlPv($4);\n  $$016 = 0;\n }\n STACKTOP = sp;\n return $$016 | 0;\n}\n\nfunction __ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $$0 = 0, $10 = 0, $11 = 0, $12 = 0, $15 = 0, $16 = 0, $19 = 0, $20 = 0, $21 = 0, $9 = 0;\n if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 + 8 >> 2] | 0, $5) | 0) __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i(0, $1, $2, $3, $4); else {\n  $9 = $1 + 52 | 0;\n  $10 = HEAP8[$9 >> 0] | 0;\n  $11 = $1 + 53 | 0;\n  $12 = HEAP8[$11 >> 0] | 0;\n  $15 = HEAP32[$0 + 12 >> 2] | 0;\n  $16 = $0 + 16 + ($15 << 3) | 0;\n  HEAP8[$9 >> 0] = 0;\n  HEAP8[$11 >> 0] = 0;\n  __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($0 + 16 | 0, $1, $2, $3, $4, $5);\n  L4 : do if (($15 | 0) > 1) {\n   $19 = $1 + 24 | 0;\n   $20 = $0 + 8 | 0;\n   $21 = $1 + 54 | 0;\n   $$0 = $0 + 24 | 0;\n   do {\n    if (HEAP8[$21 >> 0] | 0) break L4;\n    if (!(HEAP8[$9 >> 0] | 0)) {\n     if (HEAP8[$11 >> 0] | 0) if (!(HEAP32[$20 >> 2] & 1)) break L4;\n    } else {\n     if ((HEAP32[$19 >> 2] | 0) == 1) break L4;\n     if (!(HEAP32[$20 >> 2] & 2)) break L4;\n    }\n    HEAP8[$9 >> 0] = 0;\n    HEAP8[$11 >> 0] = 0;\n    __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($$0, $1, $2, $3, $4, $5);\n    $$0 = $$0 + 8 | 0;\n   } while ($$0 >>> 0 < $16 >>> 0);\n  } while (0);\n  HEAP8[$9 >> 0] = $10;\n  HEAP8[$11 >> 0] = $12;\n }\n return;\n}\n\nfunction _strspn($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$01924 = 0, $$020 = 0, $$1$lcssa = 0, $$121 = 0, $14 = 0, $15 = 0, $19 = 0, $2 = 0, $25 = 0, $27 = 0, $28 = 0, $3 = 0, $36 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n HEAP32[$2 + 12 >> 2] = 0;\n HEAP32[$2 + 16 >> 2] = 0;\n HEAP32[$2 + 20 >> 2] = 0;\n HEAP32[$2 + 24 >> 2] = 0;\n HEAP32[$2 + 28 >> 2] = 0;\n $3 = HEAP8[$1 >> 0] | 0;\n do if (!($3 << 24 >> 24)) $$0 = 0; else {\n  if (!(HEAP8[$1 + 1 >> 0] | 0)) {\n   $$020 = $0;\n   while (1) if ((HEAP8[$$020 >> 0] | 0) == $3 << 24 >> 24) $$020 = $$020 + 1 | 0; else break;\n   $$0 = $$020 - $0 | 0;\n   break;\n  }\n  $$01924 = $1;\n  $15 = $3;\n  do {\n   $14 = $15 & 255;\n   $19 = $2 + ($14 >>> 5 << 2) | 0;\n   HEAP32[$19 >> 2] = HEAP32[$19 >> 2] | 1 << ($14 & 31);\n   $$01924 = $$01924 + 1 | 0;\n   $15 = HEAP8[$$01924 >> 0] | 0;\n  } while ($15 << 24 >> 24 != 0);\n  $25 = HEAP8[$0 >> 0] | 0;\n  L12 : do if (!($25 << 24 >> 24)) $$1$lcssa = $0; else {\n   $$121 = $0;\n   $28 = $25;\n   while (1) {\n    $27 = $28 & 255;\n    if (!(HEAP32[$2 + ($27 >>> 5 << 2) >> 2] & 1 << ($27 & 31))) {\n     $$1$lcssa = $$121;\n     break L12;\n    }\n    $36 = $$121 + 1 | 0;\n    $28 = HEAP8[$36 >> 0] | 0;\n    if (!($28 << 24 >> 24)) {\n     $$1$lcssa = $36;\n     break;\n    } else $$121 = $36;\n   }\n  } while (0);\n  $$0 = $$1$lcssa - $0 | 0;\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKcj($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$1 = 0, $12 = 0, $17 = 0, $21 = 0, $23 = 0, $24 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $4 = sp;\n $5 = $0 + 11 | 0;\n $6 = HEAP8[$5 >> 0] | 0;\n $7 = $6 << 24 >> 24 < 0;\n if ($7) $12 = HEAP32[$0 + 4 >> 2] | 0; else $12 = $6 & 255;\n if ($12 >>> 0 < $1 >>> 0) __ZNKSt3__221__basic_string_commonILb1EE20__throw_out_of_rangeEv($0);\n if ($7) $17 = (HEAP32[$0 + 8 >> 2] & 2147483647) + -1 | 0; else $17 = 10;\n if (($17 - $12 | 0) >>> 0 < $3 >>> 0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE21__grow_by_and_replaceEjjjjjjPKc($0, $17, $12 + $3 - $17 | 0, $12, $1, 0, $3, $2); else if ($3 | 0) {\n  if ($7) $24 = HEAP32[$0 >> 2] | 0; else $24 = $0;\n  $21 = $12 - $1 | 0;\n  $23 = $24 + $1 | 0;\n  if (!$21) $$1 = $2; else {\n   __ZNSt3__211char_traitsIcE4moveEPcPKcj($23 + $3 | 0, $23, $21) | 0;\n   $$1 = $23 >>> 0 <= $2 >>> 0 & ($24 + $12 | 0) >>> 0 > $2 >>> 0 ? $2 + $3 | 0 : $2;\n  }\n  __ZNSt3__211char_traitsIcE4moveEPcPKcj($23, $$1, $3) | 0;\n  $30 = $12 + $3 | 0;\n  if ((HEAP8[$5 >> 0] | 0) < 0) HEAP32[$0 + 4 >> 2] = $30; else HEAP8[$5 >> 0] = $30;\n  HEAP8[$4 >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($24 + $30 | 0, $4);\n }\n STACKTOP = sp;\n return $0 | 0;\n}\n\nfunction ___strchrnul($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$029$lcssa = 0, $$02936 = 0, $$030$lcssa = 0, $$03039 = 0, $$1 = 0, $10 = 0, $13 = 0, $17 = 0, $18 = 0, $2 = 0, $24 = 0, $25 = 0, $31 = 0, $38 = 0, $39 = 0, $9 = 0;\n $2 = $1 & 255;\n L1 : do if (!$2) $$0 = $0 + (_strlen($0) | 0) | 0; else {\n  if (!($0 & 3)) $$030$lcssa = $0; else {\n   $9 = $1 & 255;\n   $$03039 = $0;\n   while (1) {\n    $10 = HEAP8[$$03039 >> 0] | 0;\n    if ($10 << 24 >> 24 == 0 ? 1 : $10 << 24 >> 24 == $9 << 24 >> 24) {\n     $$0 = $$03039;\n     break L1;\n    }\n    $13 = $$03039 + 1 | 0;\n    if (!($13 & 3)) {\n     $$030$lcssa = $13;\n     break;\n    } else $$03039 = $13;\n   }\n  }\n  $17 = Math_imul($2, 16843009) | 0;\n  $18 = HEAP32[$$030$lcssa >> 2] | 0;\n  L10 : do if (!(($18 & -2139062144 ^ -2139062144) & $18 + -16843009)) {\n   $$02936 = $$030$lcssa;\n   $25 = $18;\n   while (1) {\n    $24 = $25 ^ $17;\n    if (($24 & -2139062144 ^ -2139062144) & $24 + -16843009 | 0) {\n     $$029$lcssa = $$02936;\n     break L10;\n    }\n    $31 = $$02936 + 4 | 0;\n    $25 = HEAP32[$31 >> 2] | 0;\n    if (($25 & -2139062144 ^ -2139062144) & $25 + -16843009 | 0) {\n     $$029$lcssa = $31;\n     break;\n    } else $$02936 = $31;\n   }\n  } else $$029$lcssa = $$030$lcssa; while (0);\n  $38 = $1 & 255;\n  $$1 = $$029$lcssa;\n  while (1) {\n   $39 = HEAP8[$$1 >> 0] | 0;\n   if ($39 << 24 >> 24 == 0 ? 1 : $39 << 24 >> 24 == $38 << 24 >> 24) {\n    $$0 = $$1;\n    break;\n   } else $$1 = $$1 + 1 | 0;\n  }\n } while (0);\n return $$0 | 0;\n}\n\nfunction __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIRKS3_EEvOT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $14 = 0, $16 = 0, $19 = 0, $2 = 0, $24 = 0, $25 = 0, $3 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp;\n $3 = $0 + 4 | 0;\n $8 = (((HEAP32[$3 >> 2] | 0) - (HEAP32[$0 >> 2] | 0) | 0) / 24 | 0) + 1 | 0;\n $9 = __ZNKSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE8max_sizeEv($0) | 0;\n if ($9 >>> 0 < $8 >>> 0) __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0); else {\n  $14 = HEAP32[$0 >> 2] | 0;\n  $16 = ((HEAP32[$0 + 8 >> 2] | 0) - $14 | 0) / 24 | 0;\n  $19 = $16 << 1;\n  __ZNSt3__214__split_bufferIN10__cxxabiv112_GLOBAL__N_111string_pairERNS2_11short_allocIS3_Lj4096EEEEC2EjjS6_($2, $16 >>> 0 < $9 >>> 1 >>> 0 ? ($19 >>> 0 < $8 >>> 0 ? $8 : $19) : $9, ((HEAP32[$3 >> 2] | 0) - $14 | 0) / 24 | 0, $0 + 12 | 0);\n  $24 = $2 + 8 | 0;\n  $25 = HEAP32[$24 >> 2] | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($25, $1);\n  HEAP32[$24 >> 2] = $25 + 24;\n  __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS5_EE($0, $2);\n  __ZNSt3__214__split_bufferIN10__cxxabiv112_GLOBAL__N_111string_pairERNS2_11short_allocIS3_Lj4096EEEED2Ev($2);\n  STACKTOP = sp;\n  return;\n }\n}\n\nfunction __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE21__push_back_slow_pathIS3_EEvOT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $14 = 0, $16 = 0, $19 = 0, $2 = 0, $24 = 0, $25 = 0, $3 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp;\n $3 = $0 + 4 | 0;\n $8 = (((HEAP32[$3 >> 2] | 0) - (HEAP32[$0 >> 2] | 0) | 0) / 24 | 0) + 1 | 0;\n $9 = __ZNKSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE8max_sizeEv($0) | 0;\n if ($9 >>> 0 < $8 >>> 0) __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0); else {\n  $14 = HEAP32[$0 >> 2] | 0;\n  $16 = ((HEAP32[$0 + 8 >> 2] | 0) - $14 | 0) / 24 | 0;\n  $19 = $16 << 1;\n  __ZNSt3__214__split_bufferIN10__cxxabiv112_GLOBAL__N_111string_pairERNS2_11short_allocIS3_Lj4096EEEEC2EjjS6_($2, $16 >>> 0 < $9 >>> 1 >>> 0 ? ($19 >>> 0 < $8 >>> 0 ? $8 : $19) : $9, ((HEAP32[$3 >> 2] | 0) - $14 | 0) / 24 | 0, $0 + 12 | 0);\n  $24 = $2 + 8 | 0;\n  $25 = HEAP32[$24 >> 2] | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($25, $1);\n  HEAP32[$24 >> 2] = $25 + 24;\n  __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS5_EE($0, $2);\n  __ZNSt3__214__split_bufferIN10__cxxabiv112_GLOBAL__N_111string_pairERNS2_11short_allocIS3_Lj4096EEEED2Ev($2);\n  STACKTOP = sp;\n  return;\n }\n}\n\nfunction _x_by_xt($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$049 = 0, $$050 = 0, $$051 = 0, $$052 = 0, $$053 = 0, $$054 = 0, $$1 = 0, $12 = 0, $14 = 0, $18 = 0, $20 = 0, $23 = 0, $3 = 0, $30 = 0.0, $31 = 0.0, $5 = 0;\n $3 = HEAP32[$0 + 4 >> 2] | 0;\n $5 = HEAP32[$0 + 8 >> 2] | 0;\n L1 : do if ((HEAP32[$1 + 4 >> 2] | 0) == ($3 | 0)) if ((HEAP32[$1 + 8 >> 2] | 0) == ($3 | 0)) {\n  $12 = HEAP32[$1 >> 2] | 0;\n  $$050 = 0;\n  $$053 = $12;\n  while (1) {\n   if (($$050 | 0) >= ($3 | 0)) {\n    $$051 = 0;\n    break L1;\n   }\n   $14 = Math_imul($$050, $5) | 0;\n   $$049 = 0;\n   $$1 = $$053;\n   while (1) {\n    if (($$049 | 0) == ($3 | 0)) break;\n    L10 : do if ($$049 >>> 0 < $$050 >>> 0) {\n     $18 = $12 + ((Math_imul($$049, $3) | 0) + $$050 << 3) | 0;\n     HEAPF64[$$1 >> 3] = +HEAPF64[$18 >> 3];\n    } else {\n     $20 = HEAP32[$0 >> 2] | 0;\n     $23 = $20 + ((Math_imul($$049, $5) | 0) << 3) | 0;\n     HEAPF64[$$1 >> 3] = 0.0;\n     $$0 = 0;\n     $$052 = $20 + ($14 << 3) | 0;\n     $$054 = $23;\n     $31 = 0.0;\n     while (1) {\n      if (($$0 | 0) >= ($5 | 0)) break L10;\n      $30 = $31 + +HEAPF64[$$052 >> 3] * +HEAPF64[$$054 >> 3];\n      HEAPF64[$$1 >> 3] = $30;\n      $$0 = $$0 + 1 | 0;\n      $$052 = $$052 + 8 | 0;\n      $$054 = $$054 + 8 | 0;\n      $31 = $30;\n     }\n    } while (0);\n    $$049 = $$049 + 1 | 0;\n    $$1 = $$1 + 8 | 0;\n   }\n   $$050 = $$050 + 1 | 0;\n   $$053 = $$053 + ($3 << 3) | 0;\n  }\n } else $$051 = -1; else $$051 = -1; while (0);\n return $$051 | 0;\n}\n\nfunction _fread($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$ = 0, $$0 = 0, $$054 = 0, $$056 = 0, $$15759 = 0, $$160 = 0, $10 = 0, $12 = 0, $18 = 0, $19 = 0, $20 = 0, $29 = 0, $33 = 0, $37 = 0, $4 = 0, $40 = 0, $spec$select = 0, label = 0;\n $4 = Math_imul($2, $1) | 0;\n $spec$select = ($1 | 0) == 0 ? 0 : $2;\n if ((HEAP32[$3 + 76 >> 2] | 0) > -1) $37 = ___lockfile($3) | 0; else $37 = 0;\n $10 = $3 + 74 | 0;\n $12 = HEAP8[$10 >> 0] | 0;\n HEAP8[$10 >> 0] = $12 + 255 | $12;\n $18 = $3 + 4 | 0;\n $19 = HEAP32[$18 >> 2] | 0;\n $20 = (HEAP32[$3 + 8 >> 2] | 0) - $19 | 0;\n if (($20 | 0) > 0) {\n  $$ = $20 >>> 0 < $4 >>> 0 ? $20 : $4;\n  _memcpy($0 | 0, $19 | 0, $$ | 0) | 0;\n  HEAP32[$18 >> 2] = (HEAP32[$18 >> 2] | 0) + $$;\n  $$054 = $4 - $$ | 0;\n  $$056 = $0 + $$ | 0;\n } else {\n  $$054 = $4;\n  $$056 = $0;\n }\n L7 : do if (!$$054) label = 13; else {\n  $29 = $3 + 32 | 0;\n  $$15759 = $$056;\n  $$160 = $$054;\n  while (1) {\n   if (___toread($3) | 0) break;\n   $33 = FUNCTION_TABLE_iiii[HEAP32[$29 >> 2] & 15]($3, $$15759, $$160) | 0;\n   if (($33 + 1 | 0) >>> 0 < 2) break;\n   $40 = $$160 - $33 | 0;\n   if (!$40) {\n    label = 13;\n    break L7;\n   } else {\n    $$15759 = $$15759 + $33 | 0;\n    $$160 = $40;\n   }\n  }\n  if ($37 | 0) ___unlockfile($3);\n  $$0 = (($4 - $$160 | 0) >>> 0) / ($1 >>> 0) | 0;\n } while (0);\n if ((label | 0) == 13) if (!$37) $$0 = $spec$select; else {\n  ___unlockfile($3);\n  $$0 = $spec$select;\n }\n return $$0 | 0;\n}\n\nfunction __ZNSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS8_RS9_EE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i = 0, $11 = 0, $12 = 0, $16 = 0, $18 = 0, $2 = 0, $22 = 0, $24 = 0, $25 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $9 = 0;\n $2 = HEAP32[$0 >> 2] | 0;\n $3 = $0 + 4 | 0;\n $5 = $1 + 4 | 0;\n $$0$i = HEAP32[$3 >> 2] | 0;\n while (1) {\n  if (($$0$i | 0) == ($2 | 0)) break;\n  $7 = HEAP32[$5 >> 2] | 0;\n  $8 = $7 + -16 | 0;\n  $9 = $$0$i + -16 | 0;\n  HEAP32[$8 >> 2] = 0;\n  $11 = $7 + -12 | 0;\n  HEAP32[$11 >> 2] = 0;\n  $12 = $7 + -8 | 0;\n  HEAP32[$12 >> 2] = 0;\n  HEAP32[$7 + -4 >> 2] = HEAP32[$$0$i + -4 >> 2];\n  HEAP32[$8 >> 2] = HEAP32[$9 >> 2];\n  $16 = $$0$i + -12 | 0;\n  HEAP32[$11 >> 2] = HEAP32[$16 >> 2];\n  $18 = $$0$i + -8 | 0;\n  HEAP32[$12 >> 2] = HEAP32[$18 >> 2];\n  HEAP32[$18 >> 2] = 0;\n  HEAP32[$16 >> 2] = 0;\n  HEAP32[$9 >> 2] = 0;\n  HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + -16;\n  $$0$i = $9;\n }\n $22 = HEAP32[$0 >> 2] | 0;\n HEAP32[$0 >> 2] = HEAP32[$5 >> 2];\n HEAP32[$5 >> 2] = $22;\n $24 = $1 + 8 | 0;\n $25 = HEAP32[$3 >> 2] | 0;\n HEAP32[$3 >> 2] = HEAP32[$24 >> 2];\n HEAP32[$24 >> 2] = $25;\n $27 = $0 + 8 | 0;\n $28 = $1 + 12 | 0;\n $29 = HEAP32[$27 >> 2] | 0;\n HEAP32[$27 >> 2] = HEAP32[$28 >> 2];\n HEAP32[$28 >> 2] = $29;\n HEAP32[$1 >> 2] = HEAP32[$5 >> 2];\n return;\n}\n\nfunction __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS6_RS7_EE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i = 0, $11 = 0, $12 = 0, $16 = 0, $18 = 0, $2 = 0, $22 = 0, $24 = 0, $25 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $9 = 0;\n $2 = HEAP32[$0 >> 2] | 0;\n $3 = $0 + 4 | 0;\n $5 = $1 + 4 | 0;\n $$0$i = HEAP32[$3 >> 2] | 0;\n while (1) {\n  if (($$0$i | 0) == ($2 | 0)) break;\n  $7 = HEAP32[$5 >> 2] | 0;\n  $8 = $7 + -16 | 0;\n  $9 = $$0$i + -16 | 0;\n  HEAP32[$8 >> 2] = 0;\n  $11 = $7 + -12 | 0;\n  HEAP32[$11 >> 2] = 0;\n  $12 = $7 + -8 | 0;\n  HEAP32[$12 >> 2] = 0;\n  HEAP32[$7 + -4 >> 2] = HEAP32[$$0$i + -4 >> 2];\n  HEAP32[$8 >> 2] = HEAP32[$9 >> 2];\n  $16 = $$0$i + -12 | 0;\n  HEAP32[$11 >> 2] = HEAP32[$16 >> 2];\n  $18 = $$0$i + -8 | 0;\n  HEAP32[$12 >> 2] = HEAP32[$18 >> 2];\n  HEAP32[$18 >> 2] = 0;\n  HEAP32[$16 >> 2] = 0;\n  HEAP32[$9 >> 2] = 0;\n  HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + -16;\n  $$0$i = $9;\n }\n $22 = HEAP32[$0 >> 2] | 0;\n HEAP32[$0 >> 2] = HEAP32[$5 >> 2];\n HEAP32[$5 >> 2] = $22;\n $24 = $1 + 8 | 0;\n $25 = HEAP32[$3 >> 2] | 0;\n HEAP32[$3 >> 2] = HEAP32[$24 >> 2];\n HEAP32[$24 >> 2] = $25;\n $27 = $0 + 8 | 0;\n $28 = $1 + 12 | 0;\n $29 = HEAP32[$27 >> 2] | 0;\n HEAP32[$27 >> 2] = HEAP32[$28 >> 2];\n HEAP32[$28 >> 2] = $29;\n HEAP32[$1 >> 2] = HEAP32[$5 >> 2];\n return;\n}\n\nfunction _icpGetJ_U_Xc($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $12 = 0, $15 = 0.0, $20 = 0.0, $21 = 0, $24 = 0, $28 = 0, $3 = 0.0, $34 = 0.0, $35 = 0, $36 = 0.0, $38 = 0, $4 = 0.0, $42 = 0, $48 = 0.0, $50 = 0.0, $6 = 0, $9 = 0.0;\n $3 = +HEAPF64[$1 >> 3];\n $4 = +HEAPF64[$2 >> 3];\n $6 = $1 + 8 | 0;\n $9 = +HEAPF64[$2 + 8 >> 3];\n $12 = $1 + 16 | 0;\n $15 = +HEAPF64[$2 + 16 >> 3];\n $20 = +HEAPF64[$1 + 24 >> 3] + ($3 * $4 + +HEAPF64[$6 >> 3] * $9 + +HEAPF64[$12 >> 3] * $15);\n $21 = $1 + 32 | 0;\n $24 = $1 + 40 | 0;\n $28 = $1 + 48 | 0;\n $34 = +HEAPF64[$1 + 56 >> 3] + ($4 * +HEAPF64[$21 >> 3] + $9 * +HEAPF64[$24 >> 3] + $15 * +HEAPF64[$28 >> 3]);\n $35 = $1 + 64 | 0;\n $36 = +HEAPF64[$35 >> 3];\n $38 = $1 + 72 | 0;\n $42 = $1 + 80 | 0;\n $48 = +HEAPF64[$1 + 88 >> 3] + ($4 * $36 + $9 * +HEAPF64[$38 >> 3] + $15 * +HEAPF64[$42 >> 3]);\n if ($48 == 0.0) $$0 = -1; else {\n  $50 = $48 * $48;\n  HEAPF64[$0 >> 3] = ($3 * $48 - $20 * $36) / $50;\n  HEAPF64[$0 + 8 >> 3] = ($48 * +HEAPF64[$6 >> 3] - $20 * +HEAPF64[$38 >> 3]) / $50;\n  HEAPF64[$0 + 16 >> 3] = ($48 * +HEAPF64[$12 >> 3] - $20 * +HEAPF64[$42 >> 3]) / $50;\n  HEAPF64[$0 + 24 >> 3] = ($48 * +HEAPF64[$21 >> 3] - $34 * +HEAPF64[$35 >> 3]) / $50;\n  HEAPF64[$0 + 32 >> 3] = ($48 * +HEAPF64[$24 >> 3] - $34 * +HEAPF64[$38 >> 3]) / $50;\n  HEAPF64[$0 + 40 >> 3] = ($48 * +HEAPF64[$28 >> 3] - $34 * +HEAPF64[$42 >> 3]) / $50;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction _getMultiEachMarkerInfo($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$2 = 0, $11 = 0, $19 = 0, $25 = 0, $3 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n HEAP32[$3 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $3) | 0)) $$2 = HEAP32[489] | 0; else {\n  $7 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $3) | 0;\n  $11 = HEAP32[$7 + 248 >> 2] | 0;\n  if (($1 | 0) < 0 ? 1 : (HEAP32[$7 + 252 >> 2] | 0) - $11 >> 3 >>> 0 <= $1 >>> 0) {\n   $$2 = HEAP32[490] | 0;\n   break;\n  }\n  $19 = HEAP32[$11 + ($1 << 3) + 4 >> 2] | 0;\n  if (($2 | 0) < 0 ? 1 : (HEAP32[$19 + 4 >> 2] | 0) <= ($2 | 0)) {\n   $$2 = HEAP32[491] | 0;\n   break;\n  } else {\n   $25 = HEAP32[$19 >> 2] | 0;\n   _matrixCopy($25 + ($2 * 320 | 0) + 16 | 0, 17256);\n   _emscripten_asm_const_iiiid(1, HEAP32[$25 + ($2 * 320 | 0) + 304 >> 2] | 0, HEAP32[$25 + ($2 * 320 | 0) >> 2] | 0, HEAP32[$25 + ($2 * 320 | 0) + 4 >> 2] | 0, +(+HEAPF64[$25 + ($2 * 320 | 0) + 8 >> 3])) | 0;\n   $$2 = 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$2 | 0;\n}\n\nfunction _arLogv($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $10 = 0, $17 = 0, $18 = 0, $19 = 0, $28 = 0, $32 = 0, $4 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $vararg_buffer = sp;\n $4 = sp + 8 | 0;\n if (!(($2 | 0) == 0 | (HEAP32[484] | 0) > ($1 | 0))) if (HEAP8[$2 >> 0] | 0) {\n  HEAP32[$4 >> 2] = HEAP32[$3 >> 2];\n  $10 = _vsnprintf(0, 0, $2, $4) | 0;\n  if ($10 | 0) {\n   if ($1 >>> 0 < 4) $$0 = (_strlen(HEAP32[1940 + ($1 << 2) >> 2] | 0) | 0) + 3 | 0; else $$0 = 0;\n   $17 = $$0 + $10 | 0;\n   $18 = $17 + 1 | 0;\n   $19 = _malloc($18) | 0;\n   if ($$0 | 0) {\n    HEAP32[$vararg_buffer >> 2] = HEAP32[1940 + ($1 << 2) >> 2];\n    _snprintf($19, $$0 + 1 | 0, 5604, $vararg_buffer) | 0;\n   }\n   _vsnprintf($19 + $$0 | 0, $10 + 1 | 0, $2, $3) | 0;\n   do if (true) _fputs($19, HEAP32[520] | 0) | 0; else {} while (0);\n   _free($19);\n  }\n }\n STACKTOP = sp;\n return;\n}\n\nfunction ___fwritex($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$03846 = 0, $$1 = 0, $$139 = 0, $$141 = 0, $$143 = 0, $10 = 0, $12 = 0, $14 = 0, $23 = 0, $29 = 0, $3 = 0, $32 = 0, $4 = 0, $9 = 0, label = 0;\n $3 = $2 + 16 | 0;\n $4 = HEAP32[$3 >> 2] | 0;\n if (!$4) if (!(___towrite($2) | 0)) {\n  $12 = HEAP32[$3 >> 2] | 0;\n  label = 5;\n } else $$1 = 0; else {\n  $12 = $4;\n  label = 5;\n }\n L5 : do if ((label | 0) == 5) {\n  $9 = $2 + 20 | 0;\n  $10 = HEAP32[$9 >> 2] | 0;\n  $14 = $10;\n  if (($12 - $10 | 0) >>> 0 < $1 >>> 0) {\n   $$1 = FUNCTION_TABLE_iiii[HEAP32[$2 + 36 >> 2] & 15]($2, $0, $1) | 0;\n   break;\n  }\n  L10 : do if ((HEAP8[$2 + 75 >> 0] | 0) < 0 | ($1 | 0) == 0) {\n   $$139 = 0;\n   $$141 = $0;\n   $$143 = $1;\n   $32 = $14;\n  } else {\n   $$03846 = $1;\n   while (1) {\n    $23 = $$03846 + -1 | 0;\n    if ((HEAP8[$0 + $23 >> 0] | 0) == 10) break;\n    if (!$23) {\n     $$139 = 0;\n     $$141 = $0;\n     $$143 = $1;\n     $32 = $14;\n     break L10;\n    } else $$03846 = $23;\n   }\n   $29 = FUNCTION_TABLE_iiii[HEAP32[$2 + 36 >> 2] & 15]($2, $0, $$03846) | 0;\n   if ($29 >>> 0 < $$03846 >>> 0) {\n    $$1 = $29;\n    break L5;\n   }\n   $$139 = $$03846;\n   $$141 = $0 + $$03846 | 0;\n   $$143 = $1 - $$03846 | 0;\n   $32 = HEAP32[$9 >> 2] | 0;\n  } while (0);\n  _memcpy($32 | 0, $$141 | 0, $$143 | 0) | 0;\n  HEAP32[$9 >> 2] = (HEAP32[$9 >> 2] | 0) + $$143;\n  $$1 = $$139 + $$143 | 0;\n } while (0);\n return $$1 | 0;\n}\n\nfunction _xt_by_x($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$051 = 0, $$052 = 0, $$053 = 0, $$054 = 0, $$055 = 0, $$056 = 0, $$1 = 0, $12 = 0, $17 = 0, $19 = 0, $26 = 0.0, $27 = 0.0, $3 = 0, $5 = 0;\n $3 = HEAP32[$0 + 4 >> 2] | 0;\n $5 = HEAP32[$0 + 8 >> 2] | 0;\n L1 : do if ((HEAP32[$1 + 4 >> 2] | 0) == ($5 | 0)) if ((HEAP32[$1 + 8 >> 2] | 0) == ($5 | 0)) {\n  $12 = HEAP32[$1 >> 2] | 0;\n  $$052 = 0;\n  $$055 = $12;\n  while (1) {\n   if (($$052 | 0) >= ($5 | 0)) {\n    $$053 = 0;\n    break L1;\n   }\n   $$051 = 0;\n   $$1 = $$055;\n   while (1) {\n    if (($$051 | 0) == ($5 | 0)) break;\n    L10 : do if ($$051 >>> 0 < $$052 >>> 0) {\n     $17 = $12 + ((Math_imul($$051, $5) | 0) + $$052 << 3) | 0;\n     HEAPF64[$$1 >> 3] = +HEAPF64[$17 >> 3];\n    } else {\n     $19 = HEAP32[$0 >> 2] | 0;\n     HEAPF64[$$1 >> 3] = 0.0;\n     $$0 = 0;\n     $$054 = $19 + ($$052 << 3) | 0;\n     $$056 = $19 + ($$051 << 3) | 0;\n     $27 = 0.0;\n     while (1) {\n      if (($$0 | 0) >= ($3 | 0)) break L10;\n      $26 = $27 + +HEAPF64[$$054 >> 3] * +HEAPF64[$$056 >> 3];\n      HEAPF64[$$1 >> 3] = $26;\n      $$0 = $$0 + 1 | 0;\n      $$054 = $$054 + ($5 << 3) | 0;\n      $$056 = $$056 + ($5 << 3) | 0;\n      $27 = $26;\n     }\n    } while (0);\n    $$051 = $$051 + 1 | 0;\n    $$1 = $$1 + 8 | 0;\n   }\n   $$052 = $$052 + 1 | 0;\n   $$055 = $$055 + ($5 << 3) | 0;\n  }\n } else $$053 = -1; else $$053 = -1; while (0);\n return $$053 | 0;\n}\n\nfunction ___shgetc($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$phi$trans$insert28 = 0, $$pre = 0, $1 = 0, $10 = 0, $14 = 0, $19 = 0, $2 = 0, $21 = 0, $27 = 0, $28 = 0, $30 = 0, $36 = 0, $37 = 0, $42 = 0, $7 = 0, label = 0;\n $1 = $0 + 104 | 0;\n $2 = HEAP32[$1 >> 2] | 0;\n if (!$2) label = 3; else if ((HEAP32[$0 + 108 >> 2] | 0) < ($2 | 0)) label = 3; else label = 4;\n if ((label | 0) == 3) {\n  $7 = ___uflow($0) | 0;\n  if (($7 | 0) < 0) label = 4; else {\n   $10 = HEAP32[$1 >> 2] | 0;\n   $$pre = HEAP32[$0 + 8 >> 2] | 0;\n   if (!$10) {\n    $42 = $$pre;\n    label = 9;\n   } else {\n    $14 = HEAP32[$0 + 4 >> 2] | 0;\n    $19 = $10 - (HEAP32[$0 + 108 >> 2] | 0) | 0;\n    $21 = $$pre;\n    if (($$pre - $14 | 0) < ($19 | 0)) {\n     $42 = $21;\n     label = 9;\n    } else {\n     HEAP32[$0 + 100 >> 2] = $14 + ($19 + -1);\n     $27 = $21;\n    }\n   }\n   if ((label | 0) == 9) {\n    HEAP32[$0 + 100 >> 2] = $$pre;\n    $27 = $42;\n   }\n   $$phi$trans$insert28 = $0 + 4 | 0;\n   if (!$27) $37 = HEAP32[$$phi$trans$insert28 >> 2] | 0; else {\n    $28 = HEAP32[$$phi$trans$insert28 >> 2] | 0;\n    $30 = $0 + 108 | 0;\n    HEAP32[$30 >> 2] = $27 + 1 - $28 + (HEAP32[$30 >> 2] | 0);\n    $37 = $28;\n   }\n   $36 = $37 + -1 | 0;\n   if (($7 | 0) == (HEAPU8[$36 >> 0] | 0 | 0)) $$0 = $7; else {\n    HEAP8[$36 >> 0] = $7;\n    $$0 = $7;\n   }\n  }\n }\n if ((label | 0) == 4) {\n  HEAP32[$0 + 100 >> 2] = 0;\n  $$0 = -1;\n }\n return $$0 | 0;\n}\n\nfunction _arMatrixMul($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$040 = 0, $$041 = 0, $$042 = 0, $$043 = 0, $$044 = 0, $$045 = 0, $$1 = 0, $14 = 0, $20 = 0, $30 = 0.0, $31 = 0.0, $4 = 0, $9 = 0;\n $4 = HEAP32[$1 + 8 >> 2] | 0;\n L1 : do if (($4 | 0) == (HEAP32[$2 + 4 >> 2] | 0)) {\n  $9 = HEAP32[$0 + 4 >> 2] | 0;\n  if (($9 | 0) == (HEAP32[$1 + 4 >> 2] | 0)) {\n   $14 = HEAP32[$0 + 8 >> 2] | 0;\n   if (($14 | 0) == (HEAP32[$2 + 8 >> 2] | 0)) {\n    $$0 = HEAP32[$0 >> 2] | 0;\n    $$044 = 0;\n    while (1) {\n     if (($$044 | 0) >= ($9 | 0)) {\n      $$045 = 0;\n      break L1;\n     }\n     $20 = Math_imul($$044, $4) | 0;\n     $$043 = 0;\n     $$1 = $$0;\n     while (1) {\n      if (($$043 | 0) >= ($14 | 0)) break;\n      HEAPF64[$$1 >> 3] = 0.0;\n      $$040 = (HEAP32[$2 >> 2] | 0) + ($$043 << 3) | 0;\n      $$041 = (HEAP32[$1 >> 2] | 0) + ($20 << 3) | 0;\n      $$042 = 0;\n      $31 = 0.0;\n      while (1) {\n       if (($$042 | 0) >= ($4 | 0)) break;\n       $30 = $31 + +HEAPF64[$$041 >> 3] * +HEAPF64[$$040 >> 3];\n       HEAPF64[$$1 >> 3] = $30;\n       $$040 = $$040 + ($14 << 3) | 0;\n       $$041 = $$041 + 8 | 0;\n       $$042 = $$042 + 1 | 0;\n       $31 = $30;\n      }\n      $$043 = $$043 + 1 | 0;\n      $$1 = $$1 + 8 | 0;\n     }\n     $$0 = $$1;\n     $$044 = $$044 + 1 | 0;\n    }\n   } else $$045 = -1;\n  } else $$045 = -1;\n } else $$045 = -1; while (0);\n return $$045 | 0;\n}\n\nfunction _vsnprintf($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$014 = 0, $$015 = 0, $11 = 0, $14 = 0, $16 = 0, $17 = 0, $19 = 0, $21 = 0, $4 = 0, $5 = 0, $9 = 0, $spec$select = 0, dest = 0, label = 0, sp = 0, src = 0, stop = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 128 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(128);\n $4 = sp + 124 | 0;\n $5 = sp;\n dest = $5;\n src = 2824;\n stop = dest + 124 | 0;\n do {\n  HEAP32[dest >> 2] = HEAP32[src >> 2];\n  dest = dest + 4 | 0;\n  src = src + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n if (($1 + -1 | 0) >>> 0 > 2147483646) if (!$1) {\n  $$014 = $4;\n  $$015 = 1;\n  label = 4;\n } else {\n  $9 = ___errno_location() | 0;\n  HEAP32[$9 >> 2] = 75;\n  $$0 = -1;\n } else {\n  $$014 = $0;\n  $$015 = $1;\n  label = 4;\n }\n if ((label | 0) == 4) {\n  $11 = -2 - $$014 | 0;\n  $spec$select = $$015 >>> 0 > $11 >>> 0 ? $11 : $$015;\n  HEAP32[$5 + 48 >> 2] = $spec$select;\n  $14 = $5 + 20 | 0;\n  HEAP32[$14 >> 2] = $$014;\n  HEAP32[$5 + 44 >> 2] = $$014;\n  $16 = $$014 + $spec$select | 0;\n  $17 = $5 + 16 | 0;\n  HEAP32[$17 >> 2] = $16;\n  HEAP32[$5 + 28 >> 2] = $16;\n  $19 = _vfprintf($5, $2, $3) | 0;\n  if (!$spec$select) $$0 = $19; else {\n   $21 = HEAP32[$14 >> 2] | 0;\n   HEAP8[$21 + ((($21 | 0) == (HEAP32[$17 >> 2] | 0)) << 31 >> 31) >> 0] = 0;\n   $$0 = $19;\n  }\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _strcspn($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$01823 = 0, $$019$lcssa$sink = 0, $$01920 = 0, $10 = 0, $12 = 0, $13 = 0, $17 = 0, $2 = 0, $23 = 0, $25 = 0, $26 = 0, $3 = 0, $34 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp;\n $3 = HEAP8[$1 >> 0] | 0;\n L1 : do if (!($3 << 24 >> 24)) label = 3; else if (!(HEAP8[$1 + 1 >> 0] | 0)) label = 3; else {\n  _memset($2 | 0, 0, 32) | 0;\n  $10 = HEAP8[$1 >> 0] | 0;\n  if ($10 << 24 >> 24) {\n   $$01823 = $1;\n   $13 = $10;\n   do {\n    $12 = $13 & 255;\n    $17 = $2 + ($12 >>> 5 << 2) | 0;\n    HEAP32[$17 >> 2] = HEAP32[$17 >> 2] | 1 << ($12 & 31);\n    $$01823 = $$01823 + 1 | 0;\n    $13 = HEAP8[$$01823 >> 0] | 0;\n   } while ($13 << 24 >> 24 != 0);\n  }\n  $23 = HEAP8[$0 >> 0] | 0;\n  if (!($23 << 24 >> 24)) $$019$lcssa$sink = $0; else {\n   $$01920 = $0;\n   $26 = $23;\n   while (1) {\n    $25 = $26 & 255;\n    if (HEAP32[$2 + ($25 >>> 5 << 2) >> 2] & 1 << ($25 & 31) | 0) {\n     $$019$lcssa$sink = $$01920;\n     break L1;\n    }\n    $34 = $$01920 + 1 | 0;\n    $26 = HEAP8[$34 >> 0] | 0;\n    if (!($26 << 24 >> 24)) {\n     $$019$lcssa$sink = $34;\n     break;\n    } else $$01920 = $34;\n   }\n  }\n } while (0);\n if ((label | 0) == 3) $$019$lcssa$sink = ___strchrnul($0, $3 << 24 >> 24) | 0;\n STACKTOP = sp;\n return $$019$lcssa$sink - $0 | 0;\n}\n\nfunction _get_vertex($0, $1, $2, $3, $4, $5, $6) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = +$4;\n $5 = $5 | 0;\n $6 = $6 | 0;\n var $$0 = 0, $$071 = 0, $$072 = 0, $$073 = 0.0, $10 = 0, $12 = 0.0, $14 = 0, $16 = 0, $18 = 0.0, $22 = 0.0, $23 = 0, $34 = 0.0, $35 = 0.0, $36 = 0, $45 = 0, $8 = 0, label = 0;\n $8 = HEAP32[$1 + ($3 << 2) >> 2] | 0;\n $10 = HEAP32[$1 + ($2 << 2) >> 2] | 0;\n $12 = +($8 - $10 | 0);\n $14 = HEAP32[$0 + ($2 << 2) >> 2] | 0;\n $16 = HEAP32[$0 + ($3 << 2) >> 2] | 0;\n $18 = +($14 - $16 | 0);\n $22 = +((Math_imul($16, $10) | 0) - (Math_imul($14, $8) | 0) | 0);\n $23 = $2 + 1 | 0;\n $$0 = $23;\n $$071 = $23;\n $$073 = 0.0;\n while (1) {\n  if (($$071 | 0) >= ($3 | 0)) break;\n  $34 = $12 * +(HEAP32[$0 + ($$071 << 2) >> 2] | 0) + $18 * +(HEAP32[$1 + ($$071 << 2) >> 2] | 0) + $22;\n  $35 = $34 * $34;\n  $36 = $35 > $$073;\n  $$0 = $36 ? $$071 : $$0;\n  $$071 = $$071 + 1 | 0;\n  $$073 = $36 ? $35 : $$073;\n }\n if ($$073 / ($12 * $12 + $18 * $18) > $4) if ((_get_vertex($0, $1, $2, $$0, $4, $5, $6) | 0) < 0) $$072 = -1; else {\n  $45 = HEAP32[$6 >> 2] | 0;\n  if (($45 | 0) > 5) $$072 = -1; else {\n   HEAP32[$5 + ($45 << 2) >> 2] = $$0;\n   HEAP32[$6 >> 2] = (HEAP32[$6 >> 2] | 0) + 1;\n   if ((_get_vertex($0, $1, $$0, $3, $4, $5, $6) | 0) < 0) $$072 = -1; else label = 8;\n  }\n } else label = 8;\n if ((label | 0) == 8) $$072 = 0;\n return $$072 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_118parse_block_invokeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$031 = 0, $$032 = 0, $$2 = 0, $$2$ph = 0, $$236 = 0, $$3 = 0, $17 = 0, $28 = 0;\n L1 : do if (($1 - $0 | 0) > 12) {\n  $$031 = 0;\n  $$032 = $0;\n  while (1) {\n   if ($$031 >>> 0 >= 13) break;\n   if ((HEAP8[$$032 >> 0] | 0) != (HEAP8[16750 + $$031 >> 0] | 0)) {\n    $$236 = $0;\n    break L1;\n   }\n   $$031 = $$031 + 1 | 0;\n   $$032 = $$032 + 1 | 0;\n  }\n  L8 : do if (($$032 | 0) == ($1 | 0)) $$3 = $1; else {\n   if ((HEAP8[$$032 >> 0] | 0) == 95) {\n    $17 = $$032 + 1 | 0;\n    if (($17 | 0) == ($1 | 0)) {\n     $$236 = $0;\n     break L1;\n    }\n    if (((HEAP8[$17 >> 0] | 0) + -48 | 0) >>> 0 >= 10) {\n     $$236 = $0;\n     break L1;\n    }\n    $$2$ph = $$032 + 2 | 0;\n   } else $$2$ph = $$032;\n   $$2 = $$2$ph;\n   while (1) {\n    if (($$2 | 0) == ($1 | 0)) {\n     $$3 = $1;\n     break L8;\n    }\n    if (((HEAP8[$$2 >> 0] | 0) + -48 | 0) >>> 0 >= 10) {\n     $$3 = $$2;\n     break L8;\n    }\n    $$2 = $$2 + 1 | 0;\n   }\n  } while (0);\n  $28 = HEAP32[$2 + 4 >> 2] | 0;\n  if ((HEAP32[$2 >> 2] | 0) == ($28 | 0)) $$236 = $0; else {\n   __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($28 + -24 | 0, 0, 16764) | 0;\n   $$236 = $$3;\n  }\n } else $$236 = $0; while (0);\n return $$236 | 0;\n}\n\nfunction __ZNSt3__26vectorI12multi_markerNS_9allocatorIS1_EEE21__push_back_slow_pathIRKS1_EEvOT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $14 = 0, $15 = 0, $19 = 0, $2 = 0, $24 = 0, $26 = 0, $3 = 0, $31 = 0, $32 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $2 = sp;\n $3 = $0 + 4 | 0;\n $8 = ((HEAP32[$3 >> 2] | 0) - (HEAP32[$0 >> 2] | 0) >> 3) + 1 | 0;\n $9 = __ZNKSt3__26vectorI12multi_markerNS_9allocatorIS1_EEE8max_sizeEv($0) | 0;\n if ($9 >>> 0 < $8 >>> 0) __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0); else {\n  $14 = HEAP32[$0 >> 2] | 0;\n  $15 = (HEAP32[$0 + 8 >> 2] | 0) - $14 | 0;\n  $19 = $15 >> 2;\n  __ZNSt3__214__split_bufferI12multi_markerRNS_9allocatorIS1_EEEC2EjjS4_($2, $15 >> 3 >>> 0 < $9 >>> 1 >>> 0 ? ($19 >>> 0 < $8 >>> 0 ? $8 : $19) : $9, (HEAP32[$3 >> 2] | 0) - $14 >> 3, $0 + 8 | 0);\n  $24 = $2 + 8 | 0;\n  $26 = $1;\n  $31 = HEAP32[$26 + 4 >> 2] | 0;\n  $32 = HEAP32[$24 >> 2] | 0;\n  HEAP32[$32 >> 2] = HEAP32[$26 >> 2];\n  HEAP32[$32 + 4 >> 2] = $31;\n  HEAP32[$24 >> 2] = (HEAP32[$24 >> 2] | 0) + 8;\n  __ZNSt3__26vectorI12multi_markerNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EE($0, $2);\n  __ZNSt3__214__split_bufferI12multi_markerRNS_9allocatorIS1_EEED2Ev($2);\n  STACKTOP = sp;\n  return;\n }\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE6rehashEj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$sroa$speculated = 0, $22 = 0, $27 = 0, $30 = 0, $8 = 0;\n if (($1 | 0) == 1) $$0 = 2; else if (!($1 + -1 & $1)) $$0 = $1; else $$0 = __ZNSt3__212__next_primeEj($1) | 0;\n $8 = HEAP32[$0 + 4 >> 2] | 0;\n if ($$0 >>> 0 > $8 >>> 0) __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE8__rehashEj($0, $$0); else if ($$0 >>> 0 < $8 >>> 0) {\n  $22 = ~~+Math_ceil(+(+((HEAP32[$0 + 12 >> 2] | 0) >>> 0) / +HEAPF32[$0 + 16 >> 2])) >>> 0;\n  if ($8 >>> 0 > 2 & ($8 + -1 & $8 | 0) == 0) {\n   $27 = 1 << 32 - (Math_clz32($22 + -1 | 0) | 0);\n   $30 = $22 >>> 0 < 2 ? $22 : $27;\n  } else $30 = __ZNSt3__212__next_primeEj($22) | 0;\n  $$sroa$speculated = $$0 >>> 0 < $30 >>> 0 ? $30 : $$0;\n  if ($$sroa$speculated >>> 0 < $8 >>> 0) __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE8__rehashEj($0, $$sroa$speculated);\n }\n return;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$028 = 0, $$pn = 0, $$sroa$0$0 = 0, $14 = 0, $15 = 0, $19 = 0, $2 = 0, $25 = 0, $4 = 0, $6 = 0, $8 = 0;\n $2 = HEAP32[$1 >> 2] | 0;\n $4 = HEAP32[$0 + 4 >> 2] | 0;\n L1 : do if (!$4) $$sroa$0$0 = 0; else {\n  $6 = $4 + -1 | 0;\n  $8 = ($6 & $4 | 0) == 0;\n  if ($8) $14 = $6 & $2; else if ($2 >>> 0 < $4 >>> 0) $14 = $2; else $14 = ($2 >>> 0) % ($4 >>> 0) | 0;\n  $15 = HEAP32[(HEAP32[$0 >> 2] | 0) + ($14 << 2) >> 2] | 0;\n  if (!$15) $$sroa$0$0 = 0; else {\n   $$pn = $15;\n   while (1) {\n    $$028 = HEAP32[$$pn >> 2] | 0;\n    if (!$$028) {\n     $$sroa$0$0 = 0;\n     break L1;\n    }\n    $19 = HEAP32[$$028 + 4 >> 2] | 0;\n    if (($19 | 0) == ($2 | 0)) {\n     if ((HEAP32[$$028 + 8 >> 2] | 0) == ($2 | 0)) {\n      $$sroa$0$0 = $$028;\n      break L1;\n     }\n    } else {\n     if ($8) $25 = $19 & $6; else if ($19 >>> 0 < $4 >>> 0) $25 = $19; else $25 = ($19 >>> 0) % ($4 >>> 0) | 0;\n     if (($25 | 0) != ($14 | 0)) {\n      $$sroa$0$0 = 0;\n      break L1;\n     }\n    }\n    $$pn = $$028;\n   }\n  }\n } while (0);\n return $$sroa$0$0 | 0;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi7ARParamEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE6rehashEj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$sroa$speculated = 0, $22 = 0, $27 = 0, $30 = 0, $8 = 0;\n if (($1 | 0) == 1) $$0 = 2; else if (!($1 + -1 & $1)) $$0 = $1; else $$0 = __ZNSt3__212__next_primeEj($1) | 0;\n $8 = HEAP32[$0 + 4 >> 2] | 0;\n if ($$0 >>> 0 > $8 >>> 0) __ZNSt3__212__hash_tableINS_17__hash_value_typeIi7ARParamEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE8__rehashEj($0, $$0); else if ($$0 >>> 0 < $8 >>> 0) {\n  $22 = ~~+Math_ceil(+(+((HEAP32[$0 + 12 >> 2] | 0) >>> 0) / +HEAPF32[$0 + 16 >> 2])) >>> 0;\n  if ($8 >>> 0 > 2 & ($8 + -1 & $8 | 0) == 0) {\n   $27 = 1 << 32 - (Math_clz32($22 + -1 | 0) | 0);\n   $30 = $22 >>> 0 < 2 ? $22 : $27;\n  } else $30 = __ZNSt3__212__next_primeEj($22) | 0;\n  $$sroa$speculated = $$0 >>> 0 < $30 >>> 0 ? $30 : $$0;\n  if ($$sroa$speculated >>> 0 < $8 >>> 0) __ZNSt3__212__hash_tableINS_17__hash_value_typeIi7ARParamEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE8__rehashEj($0, $$sroa$speculated);\n }\n return;\n}\n\nfunction _setup($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $11 = 0, $12 = 0, $13 = 0, $14 = 0, $17 = 0, $18 = 0, $19 = 0, $3 = 0, $4 = 0, $6 = 0, $vararg_buffer1 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer1 = sp + 8 | 0;\n $3 = sp + 12 | 0;\n $4 = HEAP32[4350] | 0;\n HEAP32[4350] = $4 + 1;\n HEAP32[$3 >> 2] = $4;\n $6 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $3) | 0;\n HEAP32[$6 >> 2] = HEAP32[$3 >> 2];\n HEAP32[$6 + 208 >> 2] = $0;\n HEAP32[$6 + 212 >> 2] = $1;\n $11 = Math_imul($0 << 2, $1) | 0;\n $12 = $6 + 200 | 0;\n HEAP32[$12 >> 2] = $11;\n $13 = _malloc($11) | 0;\n $14 = $6 + 196 | 0;\n HEAP32[$14 >> 2] = $13;\n $17 = _malloc((HEAP32[$12 >> 2] | 0) / 4 | 0) | 0;\n $18 = $6 + 204 | 0;\n HEAP32[$18 >> 2] = $17;\n $19 = _arPattCreateHandle() | 0;\n HEAP32[$6 + 220 >> 2] = $19;\n if (!$19) _arLog(0, 3, 10064, sp);\n _setCamera(HEAP32[$3 >> 2] | 0, $2) | 0;\n HEAP32[$vararg_buffer1 >> 2] = HEAP32[$12 >> 2];\n _arLog(0, 1, 10101, $vararg_buffer1);\n _emscripten_asm_const_iiiiiii(0, HEAP32[$6 >> 2] | 0, HEAP32[$14 >> 2] | 0, HEAP32[$12 >> 2] | 0, $6 + 264 | 0, 17256, HEAP32[$18 >> 2] | 0) | 0;\n STACKTOP = sp;\n return HEAP32[$6 >> 2] | 0;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi7ARParamEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$028 = 0, $$pn = 0, $$sroa$0$0 = 0, $14 = 0, $15 = 0, $19 = 0, $2 = 0, $25 = 0, $4 = 0, $6 = 0, $8 = 0;\n $2 = HEAP32[$1 >> 2] | 0;\n $4 = HEAP32[$0 + 4 >> 2] | 0;\n L1 : do if (!$4) $$sroa$0$0 = 0; else {\n  $6 = $4 + -1 | 0;\n  $8 = ($6 & $4 | 0) == 0;\n  if ($8) $14 = $6 & $2; else if ($2 >>> 0 < $4 >>> 0) $14 = $2; else $14 = ($2 >>> 0) % ($4 >>> 0) | 0;\n  $15 = HEAP32[(HEAP32[$0 >> 2] | 0) + ($14 << 2) >> 2] | 0;\n  if (!$15) $$sroa$0$0 = 0; else {\n   $$pn = $15;\n   while (1) {\n    $$028 = HEAP32[$$pn >> 2] | 0;\n    if (!$$028) {\n     $$sroa$0$0 = 0;\n     break L1;\n    }\n    $19 = HEAP32[$$028 + 4 >> 2] | 0;\n    if (($19 | 0) == ($2 | 0)) {\n     if ((HEAP32[$$028 + 8 >> 2] | 0) == ($2 | 0)) {\n      $$sroa$0$0 = $$028;\n      break L1;\n     }\n    } else {\n     if ($8) $25 = $19 & $6; else if ($19 >>> 0 < $4 >>> 0) $25 = $19; else $25 = ($19 >>> 0) % ($4 >>> 0) | 0;\n     if (($25 | 0) != ($14 | 0)) {\n      $$sroa$0$0 = 0;\n      break L1;\n     }\n    }\n    $$pn = $$028;\n   }\n  }\n } while (0);\n return $$sroa$0$0 | 0;\n}\n\nfunction _sift($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0$lcssa = 0, $$02934 = 0, $$03133 = 0, $$035 = 0, $$1 = 0, $$130 = 0, $$132 = 0, $13 = 0, $14 = 0, $21 = 0, $5 = 0, $7 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 240 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(240);\n $5 = sp;\n HEAP32[$5 >> 2] = $0;\n L1 : do if (($3 | 0) > 1) {\n  $7 = 0 - $1 | 0;\n  $$02934 = $0;\n  $$03133 = $3;\n  $$035 = 1;\n  $14 = $0;\n  while (1) {\n   $8 = $$02934 + $7 | 0;\n   $9 = $$03133 + -2 | 0;\n   $13 = $8 + (0 - (HEAP32[$4 + ($9 << 2) >> 2] | 0)) | 0;\n   if ((FUNCTION_TABLE_iii[$2 & 15]($14, $13) | 0) > -1) if ((FUNCTION_TABLE_iii[$2 & 15]($14, $8) | 0) > -1) {\n    $$0$lcssa = $$035;\n    break L1;\n   }\n   $21 = $5 + ($$035 << 2) | 0;\n   if ((FUNCTION_TABLE_iii[$2 & 15]($13, $8) | 0) > -1) {\n    HEAP32[$21 >> 2] = $13;\n    $$130 = $13;\n    $$132 = $$03133 + -1 | 0;\n   } else {\n    HEAP32[$21 >> 2] = $8;\n    $$130 = $8;\n    $$132 = $9;\n   }\n   $$1 = $$035 + 1 | 0;\n   if (($$132 | 0) <= 1) {\n    $$0$lcssa = $$1;\n    break L1;\n   }\n   $$02934 = $$130;\n   $$03133 = $$132;\n   $$035 = $$1;\n   $14 = HEAP32[$5 >> 2] | 0;\n  }\n } else $$0$lcssa = 1; while (0);\n _cycle($1, $5, $$0$lcssa);\n STACKTOP = sp;\n return;\n}\n\nfunction ___stdio_read($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$cast = 0, $11 = 0, $18 = 0, $24 = 0, $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $vararg_buffer = sp;\n $3 = sp + 16 | 0;\n HEAP32[$3 >> 2] = $1;\n $4 = $3 + 4 | 0;\n $5 = $0 + 48 | 0;\n $6 = HEAP32[$5 >> 2] | 0;\n HEAP32[$4 >> 2] = $2 - (($6 | 0) != 0 & 1);\n $11 = $0 + 44 | 0;\n HEAP32[$3 + 8 >> 2] = HEAP32[$11 >> 2];\n HEAP32[$3 + 12 >> 2] = $6;\n HEAP32[$vararg_buffer >> 2] = HEAP32[$0 + 60 >> 2];\n HEAP32[$vararg_buffer + 4 >> 2] = $3;\n HEAP32[$vararg_buffer + 8 >> 2] = 2;\n $18 = ___syscall_ret(___syscall145(145, $vararg_buffer | 0) | 0) | 0;\n if (($18 | 0) < 1) {\n  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | $18 & 48 ^ 16;\n  $$0 = $18;\n } else {\n  $24 = HEAP32[$4 >> 2] | 0;\n  if ($18 >>> 0 > $24 >>> 0) {\n   $27 = HEAP32[$11 >> 2] | 0;\n   $28 = $0 + 4 | 0;\n   HEAP32[$28 >> 2] = $27;\n   $$cast = $27;\n   HEAP32[$0 + 8 >> 2] = $$cast + ($18 - $24);\n   if (!(HEAP32[$5 >> 2] | 0)) $$0 = $2; else {\n    HEAP32[$28 >> 2] = $$cast + 1;\n    HEAP8[$1 + ($2 + -1) >> 0] = HEAP8[$$cast >> 0] | 0;\n    $$0 = $2;\n   }\n  } else $$0 = $18;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arSetPixelFormat($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$016 = 0, $10 = 0, $11 = 0, $3 = 0, $8 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n L1 : do if (!$0) $$016 = -1; else {\n  $3 = $0 + 4 | 0;\n  if ((HEAP32[$3 >> 2] | 0) == ($1 | 0)) $$016 = 0; else {\n   if ($1 >>> 0 >= 15) {\n    HEAP32[$vararg_buffer >> 2] = $1;\n    _arLog(0, 3, 3725, $vararg_buffer);\n    $$016 = -1;\n    break;\n   }\n   HEAP32[$3 >> 2] = $1;\n   $8 = _arUtilGetPixelSize($1) | 0;\n   HEAP32[$0 + 8 >> 2] = $8;\n   $10 = $0 + 24 | 0;\n   $11 = HEAP32[$10 >> 2] | 0;\n   if (!(28704 >>> ($1 & 32767) & 1)) switch ($11 | 0) {\n   case 1:\n    {\n     HEAP32[$10 >> 2] = 4;\n     $$016 = 0;\n     break L1;\n     break;\n    }\n   case 4:\n    {\n     HEAP32[$10 >> 2] = 3;\n     $$016 = 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$016 = 0;\n     break L1;\n    }\n   } else switch ($11 | 0) {\n   case 0:\n    {\n     HEAP32[$10 >> 2] = 1;\n     $$016 = 0;\n     break L1;\n     break;\n    }\n   case 3:\n    {\n     HEAP32[$10 >> 2] = 4;\n     $$016 = 0;\n     break L1;\n     break;\n    }\n   default:\n    {\n     $$016 = 0;\n     break L1;\n    }\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return $$016 | 0;\n}\n\nfunction _arSetLabelingThreshMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$018 = 0, $13 = 0, $3 = 0, $6 = 0, $7 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer1 = sp + 8 | 0;\n $vararg_buffer = sp;\n if (!$0) $$018 = -1; else {\n  $3 = $0 + 7062388 | 0;\n  if ((HEAP32[$3 >> 2] | 0) == ($1 | 0)) $$018 = 0; else {\n   $6 = $0 + 7062408 | 0;\n   $7 = HEAP32[$6 >> 2] | 0;\n   if ($7 | 0) {\n    _arImageProcFinal($7);\n    HEAP32[$6 >> 2] = 0;\n   }\n   switch ($1 | 0) {\n   case 3:\n   case 2:\n   case 1:\n    {\n     $13 = _arImageProcInit(HEAP32[$0 + 36 >> 2] | 0, HEAP32[$0 + 40 >> 2] | 0) | 0;\n     HEAP32[$6 >> 2] = $13;\n     $$0 = $1;\n     break;\n    }\n   case 4:\n    {\n     HEAP32[$0 + 7062404 >> 2] = 1;\n     HEAP32[$0 + 7062400 >> 2] = 1;\n     $$0 = 4;\n     break;\n    }\n   case 0:\n    {\n     $$0 = $1;\n     break;\n    }\n   default:\n    {\n     _arLog(0, 3, 3556, $vararg_buffer);\n     $$0 = 0;\n    }\n   }\n   HEAP32[$3 >> 2] = $$0;\n   if ((HEAP32[$0 >> 2] | 0) == 1) {\n    HEAP32[$vararg_buffer1 >> 2] = HEAP32[424 + ($$0 << 2) >> 2];\n    _arLog(0, 3, 3630, $vararg_buffer1);\n    $$018 = 0;\n   } else $$018 = 0;\n  }\n }\n STACKTOP = sp;\n return $$018 | 0;\n}\n\nfunction _arGetTransMatRobust($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $$0 = 0, $12 = 0, $13 = 0, $6 = 0, $7 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $6 = sp + 20 | 0;\n $7 = sp;\n $9 = _malloc($4 << 4) | 0;\n HEAP32[$6 >> 2] = $9;\n if (!$9) {\n  _arLog(0, 3, 5051, sp + 8 | 0);\n  _exit(1);\n }\n $12 = _malloc($4 * 24 | 0) | 0;\n $13 = $6 + 4 | 0;\n HEAP32[$13 >> 2] = $12;\n if (!$12) {\n  _arLog(0, 3, 5051, sp + 16 | 0);\n  _exit(1);\n }\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) >= ($4 | 0)) break;\n  HEAPF64[$9 + ($$0 << 4) >> 3] = +HEAPF64[$2 + ($$0 << 4) >> 3];\n  HEAPF64[$9 + ($$0 << 4) + 8 >> 3] = +HEAPF64[$2 + ($$0 << 4) + 8 >> 3];\n  HEAPF64[$12 + ($$0 * 24 | 0) >> 3] = +HEAPF64[$3 + ($$0 * 24 | 0) >> 3];\n  HEAPF64[$12 + ($$0 * 24 | 0) + 8 >> 3] = +HEAPF64[$3 + ($$0 * 24 | 0) + 8 >> 3];\n  HEAPF64[$12 + ($$0 * 24 | 0) + 16 >> 3] = +HEAPF64[$3 + ($$0 * 24 | 0) + 16 >> 3];\n  $$0 = $$0 + 1 | 0;\n }\n HEAP32[$6 + 8 >> 2] = $4;\n if ((_icpPointRobust(HEAP32[$0 >> 2] | 0, $6, $1, $5, $7) | 0) < 0) HEAPF64[$7 >> 3] = 1.0e8;\n _free(HEAP32[$6 >> 2] | 0);\n _free(HEAP32[$13 >> 2] | 0);\n STACKTOP = sp;\n return +(+HEAPF64[$7 >> 3]);\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9push_backEc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$018 = 0, $$019 = 0, $$pn = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = sp + 1 | 0;\n HEAP8[$2 >> 0] = $1;\n $4 = $0 + 11 | 0;\n $5 = HEAP8[$4 >> 0] | 0;\n $6 = $5 << 24 >> 24 < 0;\n if ($6) {\n  $$018 = HEAP32[$0 + 4 >> 2] | 0;\n  $$019 = (HEAP32[$0 + 8 >> 2] & 2147483647) + -1 | 0;\n } else {\n  $$018 = $5 & 255;\n  $$019 = 10;\n }\n if (($$018 | 0) == ($$019 | 0)) {\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9__grow_byEjjjjjj($0, $$019, 1, $$019, $$019, 0);\n  if ((HEAP8[$4 >> 0] | 0) < 0) label = 8; else label = 7;\n } else if ($6) label = 8; else label = 7;\n if ((label | 0) == 7) {\n  HEAP8[$4 >> 0] = $$018 + 1;\n  $$pn = $0;\n } else if ((label | 0) == 8) {\n  $19 = HEAP32[$0 >> 2] | 0;\n  HEAP32[$0 + 4 >> 2] = $$018 + 1;\n  $$pn = $19;\n }\n $$0 = $$pn + $$018 | 0;\n __ZNSt3__211char_traitsIcE6assignERcRKc($$0, $2);\n HEAP8[$3 >> 0] = 0;\n __ZNSt3__211char_traitsIcE6assignERcRKc($$0 + 1 | 0, $3);\n STACKTOP = sp;\n return;\n}\n\nfunction _arLabeling($0, $1, $2, $3, $4, $5, $6, $7, $8) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n $6 = $6 | 0;\n $7 = $7 | 0;\n $8 = $8 | 0;\n var $$0 = 0, $10 = 0, $11 = 0;\n $10 = ($4 | 0) == 1;\n $11 = ($8 | 0) != 0;\n do if (!$3) if ($10) {\n  if ($11) {\n   $$0 = _arLabelingSubDBZ($0, $1, $2, $8, $7) | 0;\n   break;\n  }\n  if (!$6) {\n   $$0 = _arLabelingSubDBRC($0, $1, $2, $5, $7) | 0;\n   break;\n  } else {\n   $$0 = _arLabelingSubDBIC($0, $1, $2, $5, $7) | 0;\n   break;\n  }\n } else {\n  if ($11) {\n   $$0 = _arLabelingSubDWZ($0, $1, $2, $8, $7) | 0;\n   break;\n  }\n  if (!$6) {\n   $$0 = _arLabelingSubDWRC($0, $1, $2, $5, $7) | 0;\n   break;\n  } else {\n   $$0 = _arLabelingSubDWIC($0, $1, $2, $5, $7) | 0;\n   break;\n  }\n } else if ($10) {\n  if ($11) {\n   $$0 = _arLabelingSubEBZ($0, $1, $2, $8, $7) | 0;\n   break;\n  }\n  if (!$6) {\n   $$0 = _arLabelingSubEBRC($0, $1, $2, $5, $7) | 0;\n   break;\n  } else {\n   $$0 = _arLabelingSubEBIC($0, $1, $2, $5, $7) | 0;\n   break;\n  }\n } else {\n  if ($11) {\n   $$0 = _arLabelingSubEWZ($0, $1, $2, $8, $7) | 0;\n   break;\n  }\n  if (!$6) {\n   $$0 = _arLabelingSubEWRC($0, $1, $2, $5, $7) | 0;\n   break;\n  } else {\n   $$0 = _arLabelingSubEWIC($0, $1, $2, $5, $7) | 0;\n   break;\n  }\n } while (0);\n return $$0 | 0;\n}\n\nfunction _arCreateHandle($0) {\n $0 = $0 | 0;\n var $1 = 0, $16 = 0, $19 = 0, $27 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = _malloc(7062432) | 0;\n if (!$1) {\n  _arLog(0, 3, 5051, sp);\n  _exit(1);\n }\n HEAP32[$1 >> 2] = 0;\n HEAP32[$1 + 4834148 >> 2] = 0;\n HEAP32[$1 + 7062408 >> 2] = 0;\n HEAP32[$1 + 4 >> 2] = -1;\n HEAP32[$1 + 8 >> 2] = 0;\n HEAP32[$1 + 12 >> 2] = 1;\n HEAP32[$1 + 16 >> 2] = 100;\n HEAP32[$1 + 20 >> 2] = 0;\n HEAP32[$1 + 24 >> 2] = 0;\n HEAP32[$1 + 28 >> 2] = 2;\n HEAPF64[$1 + 7062416 >> 3] = .5;\n HEAP32[$1 + 7062424 >> 2] = 3;\n HEAP32[$1 + 32 >> 2] = $0;\n $16 = HEAP32[$0 >> 2] | 0;\n HEAP32[$1 + 36 >> 2] = $16;\n $19 = HEAP32[$0 + 4 >> 2] | 0;\n HEAP32[$1 + 40 >> 2] = $19;\n HEAP32[$1 + 44 >> 2] = 0;\n HEAP32[$1 + 15408 >> 2] = 0;\n HEAP32[$1 + 4834152 >> 2] = 0;\n HEAP32[$1 + 4818296 >> 2] = 0;\n $27 = _malloc(Math_imul($16 << 1, $19) | 0) | 0;\n HEAP32[$1 + 4834144 >> 2] = $27;\n if (!$27) {\n  _arLog(0, 3, 5051, sp + 8 | 0);\n  _exit(1);\n } else {\n  HEAP32[$1 + 7062384 >> 2] = 0;\n  _arSetDebugMode($1, 0) | 0;\n  HEAP32[$1 + 7062388 >> 2] = -1;\n  _arSetLabelingThreshMode($1, 0) | 0;\n  _arSetLabelingThreshModeAutoInterval($1, 7) | 0;\n  STACKTOP = sp;\n  return $1 | 0;\n }\n return 0;\n}\n\nfunction _arGetTransMat($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $$0 = 0, $12 = 0, $13 = 0, $6 = 0, $7 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $6 = sp + 20 | 0;\n $7 = sp;\n $9 = _malloc($4 << 4) | 0;\n HEAP32[$6 >> 2] = $9;\n if (!$9) {\n  _arLog(0, 3, 5051, sp + 8 | 0);\n  _exit(1);\n }\n $12 = _malloc($4 * 24 | 0) | 0;\n $13 = $6 + 4 | 0;\n HEAP32[$13 >> 2] = $12;\n if (!$12) {\n  _arLog(0, 3, 5051, sp + 16 | 0);\n  _exit(1);\n }\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) >= ($4 | 0)) break;\n  HEAPF64[$9 + ($$0 << 4) >> 3] = +HEAPF64[$2 + ($$0 << 4) >> 3];\n  HEAPF64[$9 + ($$0 << 4) + 8 >> 3] = +HEAPF64[$2 + ($$0 << 4) + 8 >> 3];\n  HEAPF64[$12 + ($$0 * 24 | 0) >> 3] = +HEAPF64[$3 + ($$0 * 24 | 0) >> 3];\n  HEAPF64[$12 + ($$0 * 24 | 0) + 8 >> 3] = +HEAPF64[$3 + ($$0 * 24 | 0) + 8 >> 3];\n  HEAPF64[$12 + ($$0 * 24 | 0) + 16 >> 3] = +HEAPF64[$3 + ($$0 * 24 | 0) + 16 >> 3];\n  $$0 = $$0 + 1 | 0;\n }\n HEAP32[$6 + 8 >> 2] = $4;\n if ((_icpPoint(HEAP32[$0 >> 2] | 0, $6, $1, $5, $7) | 0) < 0) HEAPF64[$7 >> 3] = 1.0e8;\n _free(HEAP32[$6 >> 2] | 0);\n _free(HEAP32[$13 >> 2] | 0);\n STACKTOP = sp;\n return +(+HEAPF64[$7 >> 3]);\n}\n\nfunction _icpUpdateMat($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$028 = 0, $$1 = 0, $$129 = 0, $2 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 256 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(256);\n $2 = sp + 192 | 0;\n $3 = sp + 96 | 0;\n $4 = sp;\n _icpGetQ_from_S($2, $1);\n _icpGetMat_from_Q($3, $2);\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) == 3) break;\n  $5 = $0 + ($$0 << 5) | 0;\n  $6 = $0 + ($$0 << 5) + 8 | 0;\n  $7 = $0 + ($$0 << 5) + 16 | 0;\n  $$028 = 0;\n  while (1) {\n   if (($$028 | 0) == 4) break;\n   HEAPF64[$4 + ($$0 << 5) + ($$028 << 3) >> 3] = +HEAPF64[$5 >> 3] * +HEAPF64[$3 + ($$028 << 3) >> 3] + +HEAPF64[$6 >> 3] * +HEAPF64[$3 + 32 + ($$028 << 3) >> 3] + +HEAPF64[$7 >> 3] * +HEAPF64[$3 + 64 + ($$028 << 3) >> 3];\n   $$028 = $$028 + 1 | 0;\n  }\n  $26 = $4 + ($$0 << 5) + 24 | 0;\n  HEAPF64[$26 >> 3] = +HEAPF64[$0 + ($$0 << 5) + 24 >> 3] + +HEAPF64[$26 >> 3];\n  $$0 = $$0 + 1 | 0;\n }\n $$1 = 0;\n while (1) {\n  if (($$1 | 0) == 3) break;\n  $$129 = 0;\n  while (1) {\n   if (($$129 | 0) == 4) break;\n   HEAPF64[$0 + ($$1 << 5) + ($$129 << 3) >> 3] = +HEAPF64[$4 + ($$1 << 5) + ($$129 << 3) >> 3];\n   $$129 = $$129 + 1 | 0;\n  }\n  $$1 = $$1 + 1 | 0;\n }\n STACKTOP = sp;\n return 0;\n}\n\nfunction _memset(ptr, value, num) {\n ptr = ptr | 0;\n value = value | 0;\n num = num | 0;\n var end = 0, aligned_end = 0, block_aligned_end = 0, value4 = 0;\n end = ptr + num | 0;\n value = value & 255;\n if ((num | 0) >= 67) {\n  while (ptr & 3) {\n   HEAP8[ptr >> 0] = value;\n   ptr = ptr + 1 | 0;\n  }\n  aligned_end = end & -4 | 0;\n  block_aligned_end = aligned_end - 64 | 0;\n  value4 = value | value << 8 | value << 16 | value << 24;\n  while ((ptr | 0) <= (block_aligned_end | 0)) {\n   HEAP32[ptr >> 2] = value4;\n   HEAP32[ptr + 4 >> 2] = value4;\n   HEAP32[ptr + 8 >> 2] = value4;\n   HEAP32[ptr + 12 >> 2] = value4;\n   HEAP32[ptr + 16 >> 2] = value4;\n   HEAP32[ptr + 20 >> 2] = value4;\n   HEAP32[ptr + 24 >> 2] = value4;\n   HEAP32[ptr + 28 >> 2] = value4;\n   HEAP32[ptr + 32 >> 2] = value4;\n   HEAP32[ptr + 36 >> 2] = value4;\n   HEAP32[ptr + 40 >> 2] = value4;\n   HEAP32[ptr + 44 >> 2] = value4;\n   HEAP32[ptr + 48 >> 2] = value4;\n   HEAP32[ptr + 52 >> 2] = value4;\n   HEAP32[ptr + 56 >> 2] = value4;\n   HEAP32[ptr + 60 >> 2] = value4;\n   ptr = ptr + 64 | 0;\n  }\n  while ((ptr | 0) < (aligned_end | 0)) {\n   HEAP32[ptr >> 2] = value4;\n   ptr = ptr + 4 | 0;\n  }\n }\n while ((ptr | 0) < (end | 0)) {\n  HEAP8[ptr >> 0] = value;\n  ptr = ptr + 1 | 0;\n }\n return end - num | 0;\n}\n\nfunction _fmt_u($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$010$lcssa$off0 = 0, $$012 = 0, $$09$lcssa = 0, $$0914 = 0, $$1$lcssa = 0, $$111 = 0, $12 = 0, $14 = 0, $30 = 0, $8 = 0, $9 = 0, $8$looptemp = 0, $9$looptemp = 0, $$012$looptemp = 0;\n if ($1 >>> 0 > 0 | ($1 | 0) == 0 & $0 >>> 0 > 4294967295) {\n  $$0914 = $2;\n  $8 = $0;\n  $9 = $1;\n  do {\n   $8$looptemp = $8;\n   $8 = ___udivdi3($8 | 0, $9 | 0, 10, 0) | 0;\n   $9$looptemp = $9;\n   $9 = tempRet0;\n   $12 = ___muldi3($8 | 0, $9 | 0, 10, 0) | 0;\n   $14 = _i64Subtract($8$looptemp | 0, $9$looptemp | 0, $12 | 0, tempRet0 | 0) | 0;\n   $$0914 = $$0914 + -1 | 0;\n   HEAP8[$$0914 >> 0] = $14 & 255 | 48;\n  } while ($9$looptemp >>> 0 > 9 | ($9$looptemp | 0) == 9 & $8$looptemp >>> 0 > 4294967295);\n  $$010$lcssa$off0 = $8;\n  $$09$lcssa = $$0914;\n } else {\n  $$010$lcssa$off0 = $0;\n  $$09$lcssa = $2;\n }\n if (!$$010$lcssa$off0) $$1$lcssa = $$09$lcssa; else {\n  $$012 = $$010$lcssa$off0;\n  $$111 = $$09$lcssa;\n  while (1) {\n   $$012$looptemp = $$012;\n   $$012 = ($$012 >>> 0) / 10 | 0;\n   $30 = $$111 + -1 | 0;\n   HEAP8[$30 >> 0] = $$012$looptemp - ($$012 * 10 | 0) | 48;\n   if ($$012$looptemp >>> 0 < 10) {\n    $$1$lcssa = $30;\n    break;\n   } else $$111 = $30;\n  }\n }\n return $$1$lcssa | 0;\n}\n\nfunction _icpGetMat_from_Q($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $12 = 0, $16 = 0, $3 = 0.0, $4 = 0.0, $40 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $72 = 0.0;\n $3 = +HEAPF64[$1 + 24 >> 3];\n $4 = +Math_cos(+$3);\n $5 = 1.0 - $4;\n $6 = +Math_sin(+$3);\n $7 = +HEAPF64[$1 >> 3];\n HEAPF64[$0 >> 3] = $4 + $7 * $7 * $5;\n $12 = $1 + 8 | 0;\n $16 = $1 + 16 | 0;\n HEAPF64[$0 + 8 >> 3] = $5 * (+HEAPF64[$1 >> 3] * +HEAPF64[$12 >> 3]) - $6 * +HEAPF64[$16 >> 3];\n HEAPF64[$0 + 16 >> 3] = $5 * (+HEAPF64[$1 >> 3] * +HEAPF64[$16 >> 3]) + $6 * +HEAPF64[$12 >> 3];\n HEAPF64[$0 + 24 >> 3] = +HEAPF64[$1 + 32 >> 3];\n HEAPF64[$0 + 32 >> 3] = $5 * (+HEAPF64[$12 >> 3] * +HEAPF64[$1 >> 3]) + $6 * +HEAPF64[$16 >> 3];\n $40 = +HEAPF64[$12 >> 3];\n HEAPF64[$0 + 40 >> 3] = $4 + $5 * ($40 * $40);\n HEAPF64[$0 + 48 >> 3] = $5 * (+HEAPF64[$12 >> 3] * +HEAPF64[$16 >> 3]) - $6 * +HEAPF64[$1 >> 3];\n HEAPF64[$0 + 56 >> 3] = +HEAPF64[$1 + 40 >> 3];\n HEAPF64[$0 + 64 >> 3] = $5 * (+HEAPF64[$16 >> 3] * +HEAPF64[$1 >> 3]) - $6 * +HEAPF64[$12 >> 3];\n HEAPF64[$0 + 72 >> 3] = $5 * (+HEAPF64[$16 >> 3] * +HEAPF64[$12 >> 3]) + $6 * +HEAPF64[$1 >> 3];\n $72 = +HEAPF64[$16 >> 3];\n HEAPF64[$0 + 80 >> 3] = $4 + $5 * ($72 * $72);\n HEAPF64[$0 + 88 >> 3] = +HEAPF64[$1 + 48 >> 3];\n return;\n}\n\nfunction _icpGetDeltaS($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $13 = 0, $15 = 0, $17 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $4 = sp + 24 | 0;\n $5 = sp + 12 | 0;\n $6 = sp;\n HEAP32[$4 + 4 >> 2] = 6;\n HEAP32[$4 + 8 >> 2] = 1;\n HEAP32[$4 >> 2] = $0;\n HEAP32[$5 + 4 >> 2] = $3;\n HEAP32[$5 + 8 >> 2] = 1;\n HEAP32[$5 >> 2] = $1;\n HEAP32[$6 + 4 >> 2] = $3;\n HEAP32[$6 + 8 >> 2] = 6;\n HEAP32[$6 >> 2] = $2;\n $13 = _arMatrixAllocTrans($6) | 0;\n do if (!$13) $$0 = -1; else {\n  $15 = _arMatrixAllocMul($13, $6) | 0;\n  if (!$15) {\n   _arMatrixFree($13) | 0;\n   $$0 = -1;\n   break;\n  }\n  $17 = _arMatrixAllocMul($13, $5) | 0;\n  if (!$17) {\n   _arMatrixFree($13) | 0;\n   _arMatrixFree($15) | 0;\n   $$0 = -1;\n   break;\n  }\n  if ((_arMatrixSelfInv($15) | 0) < 0) {\n   _arMatrixFree($13) | 0;\n   _arMatrixFree($15) | 0;\n   _arMatrixFree($17) | 0;\n   $$0 = -1;\n   break;\n  } else {\n   _arMatrixMul($4, $15, $17) | 0;\n   _arMatrixFree($13) | 0;\n   _arMatrixFree($15) | 0;\n   _arMatrixFree($17) | 0;\n   $$0 = 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _EX($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$039 = 0, $$040 = 0, $$041 = 0, $$043 = 0, $$1 = 0, $$142 = 0, $$2 = 0, $23 = 0.0, $25 = 0, $3 = 0, $5 = 0;\n $3 = HEAP32[$0 + 4 >> 2] | 0;\n $5 = HEAP32[$0 + 8 >> 2] | 0;\n L1 : do if (($3 | 0) < 1 | ($5 | 0) < 1) $$040 = -1; else if ((HEAP32[$1 + 4 >> 2] | 0) == ($5 | 0)) {\n  $$039 = 0;\n  while (1) {\n   if (($$039 | 0) == ($5 | 0)) break;\n   HEAPF64[(HEAP32[$1 >> 2] | 0) + ($$039 << 3) >> 3] = 0.0;\n   $$039 = $$039 + 1 | 0;\n  }\n  $$041 = HEAP32[$0 >> 2] | 0;\n  $$1 = 0;\n  while (1) {\n   if (($$1 | 0) == ($3 | 0)) break;\n   $$0 = 0;\n   $$043 = HEAP32[$1 >> 2] | 0;\n   $$142 = $$041;\n   while (1) {\n    if (($$0 | 0) == ($5 | 0)) break;\n    HEAPF64[$$043 >> 3] = +HEAPF64[$$142 >> 3] + +HEAPF64[$$043 >> 3];\n    $$0 = $$0 + 1 | 0;\n    $$043 = $$043 + 8 | 0;\n    $$142 = $$142 + 8 | 0;\n   }\n   $$041 = $$041 + ($5 << 3) | 0;\n   $$1 = $$1 + 1 | 0;\n  }\n  $23 = +($3 | 0);\n  $$2 = 0;\n  while (1) {\n   if (($$2 | 0) == ($5 | 0)) {\n    $$040 = 0;\n    break L1;\n   }\n   $25 = (HEAP32[$1 >> 2] | 0) + ($$2 << 3) | 0;\n   HEAPF64[$25 >> 3] = +HEAPF64[$25 >> 3] / $23;\n   $$2 = $$2 + 1 | 0;\n  }\n } else $$040 = -1; while (0);\n return $$040 | 0;\n}\n\nfunction _getTransMatMultiSquareRobust($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$1 = 0, $10 = 0, $18 = 0, $2 = 0, $22 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0)) $$1 = HEAP32[489] | 0; else {\n  $6 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0;\n  $10 = HEAP32[$6 + 248 >> 2] | 0;\n  if (($1 | 0) < 0 ? 1 : (HEAP32[$6 + 252 >> 2] | 0) - $10 >> 3 >>> 0 <= $1 >>> 0) {\n   $$1 = HEAP32[490] | 0;\n   break;\n  } else {\n   $18 = HEAP32[$10 + ($1 << 3) + 4 >> 2] | 0;\n   $22 = HEAP32[$6 + 216 >> 2] | 0;\n   +_arGetTransMatMultiSquareRobust(HEAP32[$6 + 228 >> 2] | 0, $22 + 48 | 0, HEAP32[$22 + 44 >> 2] | 0, $18);\n   _matrixCopy($18 + 8 | 0, 17256);\n   $$1 = 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction _getTransMatMultiSquare($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$1 = 0, $10 = 0, $18 = 0, $2 = 0, $22 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0)) $$1 = HEAP32[489] | 0; else {\n  $6 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0;\n  $10 = HEAP32[$6 + 248 >> 2] | 0;\n  if (($1 | 0) < 0 ? 1 : (HEAP32[$6 + 252 >> 2] | 0) - $10 >> 3 >>> 0 <= $1 >>> 0) {\n   $$1 = HEAP32[490] | 0;\n   break;\n  } else {\n   $18 = HEAP32[$10 + ($1 << 3) + 4 >> 2] | 0;\n   $22 = HEAP32[$6 + 216 >> 2] | 0;\n   +_arGetTransMatMultiSquare(HEAP32[$6 + 228 >> 2] | 0, $22 + 48 | 0, HEAP32[$22 + 44 >> 2] | 0, $18);\n   _matrixCopy($18 + 8 | 0, 17256);\n   $$1 = 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_119parse_discriminatorEPKcS2_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$029 = 0, $$1 = 0, $$pn = 0, $13 = 0, $3 = 0, $5 = 0, $7 = 0;\n L1 : do if (($0 | 0) == ($1 | 0)) $$1 = $0; else {\n  $3 = HEAP8[$0 >> 0] | 0;\n  if ($3 << 24 >> 24 != 95) {\n   if ((($3 << 24 >> 24) + -48 | 0) >>> 0 >= 10) {\n    $$1 = $0;\n    break;\n   }\n   $$pn = $0;\n   while (1) {\n    $$0 = $$pn + 1 | 0;\n    if (($$0 | 0) == ($1 | 0)) {\n     $$1 = $1;\n     break L1;\n    }\n    if (((HEAP8[$$0 >> 0] | 0) + -48 | 0) >>> 0 < 10) $$pn = $$0; else {\n     $$1 = $$0;\n     break L1;\n    }\n   }\n  }\n  $5 = $0 + 1 | 0;\n  if (($5 | 0) == ($1 | 0)) $$1 = $0; else {\n   $7 = HEAP8[$5 >> 0] | 0;\n   if ((($7 << 24 >> 24) + -48 | 0) >>> 0 < 10) {\n    $$1 = $0 + 2 | 0;\n    break;\n   }\n   if ($7 << 24 >> 24 == 95) {\n    $$029 = $0 + 2 | 0;\n    while (1) {\n     if (($$029 | 0) == ($1 | 0)) {\n      $$1 = $0;\n      break L1;\n     }\n     $13 = HEAP8[$$029 >> 0] | 0;\n     if ((($13 << 24 >> 24) + -48 | 0) >>> 0 >= 10) break;\n     $$029 = $$029 + 1 | 0;\n    }\n    return ($13 << 24 >> 24 == 95 ? $$029 + 1 | 0 : $0) | 0;\n   } else $$1 = $0;\n  }\n } while (0);\n return $$1 | 0;\n}\n\nfunction _wcrtomb($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $13 = 0, $57 = 0, $7 = 0;\n do if (!$0) $$0 = 1; else {\n  if ($1 >>> 0 < 128) {\n   HEAP8[$0 >> 0] = $1;\n   $$0 = 1;\n   break;\n  }\n  $7 = (___pthread_self_907() | 0) + 188 | 0;\n  if (!(HEAP32[HEAP32[$7 >> 2] >> 2] | 0)) if (($1 & -128 | 0) == 57216) {\n   HEAP8[$0 >> 0] = $1;\n   $$0 = 1;\n   break;\n  } else {\n   $13 = ___errno_location() | 0;\n   HEAP32[$13 >> 2] = 84;\n   $$0 = -1;\n   break;\n  }\n  if ($1 >>> 0 < 2048) {\n   HEAP8[$0 >> 0] = $1 >>> 6 | 192;\n   HEAP8[$0 + 1 >> 0] = $1 & 63 | 128;\n   $$0 = 2;\n   break;\n  }\n  if ($1 >>> 0 < 55296 | ($1 & -8192 | 0) == 57344) {\n   HEAP8[$0 >> 0] = $1 >>> 12 | 224;\n   HEAP8[$0 + 1 >> 0] = $1 >>> 6 & 63 | 128;\n   HEAP8[$0 + 2 >> 0] = $1 & 63 | 128;\n   $$0 = 3;\n   break;\n  }\n  if (($1 + -65536 | 0) >>> 0 < 1048576) {\n   HEAP8[$0 >> 0] = $1 >>> 18 | 240;\n   HEAP8[$0 + 1 >> 0] = $1 >>> 12 & 63 | 128;\n   HEAP8[$0 + 2 >> 0] = $1 >>> 6 & 63 | 128;\n   HEAP8[$0 + 3 >> 0] = $1 & 63 | 128;\n   $$0 = 4;\n   break;\n  } else {\n   $57 = ___errno_location() | 0;\n   HEAP32[$57 >> 2] = 84;\n   $$0 = -1;\n   break;\n  }\n } while (0);\n return $$0 | 0;\n}\n\nfunction _fopen($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $11 = 0, $15 = 0, $6 = 0, $7 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $vararg_buffer8 = sp + 32 | 0;\n $vararg_buffer3 = sp + 16 | 0;\n $vararg_buffer = sp;\n if (!(_strchr(11759, HEAP8[$1 >> 0] | 0) | 0)) {\n  $6 = ___errno_location() | 0;\n  HEAP32[$6 >> 2] = 22;\n  $$0 = 0;\n } else {\n  $7 = ___fmodeflags($1) | 0;\n  HEAP32[$vararg_buffer >> 2] = $0;\n  HEAP32[$vararg_buffer + 4 >> 2] = $7 | 32768;\n  HEAP32[$vararg_buffer + 8 >> 2] = 438;\n  $11 = ___syscall_ret(___syscall5(5, $vararg_buffer | 0) | 0) | 0;\n  if (($11 | 0) < 0) $$0 = 0; else {\n   if ($7 & 524288 | 0) {\n    HEAP32[$vararg_buffer3 >> 2] = $11;\n    HEAP32[$vararg_buffer3 + 4 >> 2] = 2;\n    HEAP32[$vararg_buffer3 + 8 >> 2] = 1;\n    ___syscall221(221, $vararg_buffer3 | 0) | 0;\n   }\n   $15 = ___fdopen($11, $1) | 0;\n   if (!$15) {\n    HEAP32[$vararg_buffer8 >> 2] = $11;\n    ___syscall6(6, $vararg_buffer8 | 0) | 0;\n    $$0 = 0;\n   } else $$0 = $15;\n  }\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initIPKcEENS_9enable_ifIXsr21__is_forward_iteratorIT_EE5valueEvE4typeESC_SC_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$021 = 0, $$1 = 0, $12 = 0, $13 = 0, $18 = 0, $3 = 0, $4 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = $1;\n $4 = sp;\n $6 = $2 - $3 | 0;\n if ($6 >>> 0 > 4294967279) __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv($0);\n if ($6 >>> 0 < 11) {\n  HEAP8[$0 + 11 >> 0] = $6;\n  $$021 = $0;\n } else {\n  $12 = $6 + 16 & -16;\n  $13 = __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE8allocateEj($12) | 0;\n  HEAP32[$0 >> 2] = $13;\n  HEAP32[$0 + 8 >> 2] = $12 | -2147483648;\n  HEAP32[$0 + 4 >> 2] = $6;\n  $$021 = $13;\n }\n $18 = $2 - $3 | 0;\n $$0 = $1;\n $$1 = $$021;\n while (1) {\n  if (($$0 | 0) == ($2 | 0)) break;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($$1, $$0);\n  $$0 = $$0 + 1 | 0;\n  $$1 = $$1 + 1 | 0;\n }\n HEAP8[$4 >> 0] = 0;\n __ZNSt3__211char_traitsIcE6assignERcRKc($$021 + $18 | 0, $4);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $14 = 0, $15 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n $4 = $0 + 11 | 0;\n $5 = HEAP8[$4 >> 0] | 0;\n $6 = $5 << 24 >> 24 < 0;\n if ($6) {\n  $14 = (HEAP32[$0 + 8 >> 2] & 2147483647) + -1 | 0;\n  $15 = HEAP32[$0 + 4 >> 2] | 0;\n } else {\n  $14 = 10;\n  $15 = $5 & 255;\n }\n if (($14 - $15 | 0) >>> 0 < $2 >>> 0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE21__grow_by_and_replaceEjjjjjjPKc($0, $14, $15 + $2 - $14 | 0, $15, $15, 0, $2, $1); else if ($2 | 0) {\n  if ($6) $20 = HEAP32[$0 >> 2] | 0; else $20 = $0;\n  __ZNSt3__211char_traitsIcE4copyEPcPKcj($20 + $15 | 0, $1, $2) | 0;\n  $21 = $15 + $2 | 0;\n  if ((HEAP8[$4 >> 0] | 0) < 0) HEAP32[$0 + 4 >> 2] = $21; else HEAP8[$4 >> 0] = $21;\n  HEAP8[$3 >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($20 + $21 | 0, $3);\n }\n STACKTOP = sp;\n return $0 | 0;\n}\n\nfunction _fflush($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$02325 = 0, $$02327 = 0, $$024$lcssa = 0, $$02426 = 0, $$1 = 0, $12 = 0, $26 = 0, $29 = 0, $7 = 0, $phitmp = 0;\n do if (!$0) {\n  if (!(HEAP32[583] | 0)) $29 = 0; else $29 = _fflush(HEAP32[583] | 0) | 0;\n  $12 = ___ofl_lock() | 0;\n  $$02325 = HEAP32[$12 >> 2] | 0;\n  if (!$$02325) $$024$lcssa = $29; else {\n   $$02327 = $$02325;\n   $$02426 = $29;\n   while (1) {\n    if ((HEAP32[$$02327 + 76 >> 2] | 0) > -1) $26 = ___lockfile($$02327) | 0; else $26 = 0;\n    if ((HEAP32[$$02327 + 20 >> 2] | 0) >>> 0 > (HEAP32[$$02327 + 28 >> 2] | 0) >>> 0) $$1 = ___fflush_unlocked($$02327) | 0 | $$02426; else $$1 = $$02426;\n    if ($26 | 0) ___unlockfile($$02327);\n    $$02327 = HEAP32[$$02327 + 56 >> 2] | 0;\n    if (!$$02327) {\n     $$024$lcssa = $$1;\n     break;\n    } else $$02426 = $$1;\n   }\n  }\n  ___ofl_unlock();\n  $$0 = $$024$lcssa;\n } else {\n  if ((HEAP32[$0 + 76 >> 2] | 0) <= -1) {\n   $$0 = ___fflush_unlocked($0) | 0;\n   break;\n  }\n  $phitmp = (___lockfile($0) | 0) == 0;\n  $7 = ___fflush_unlocked($0) | 0;\n  if ($phitmp) $$0 = $7; else {\n   ___unlockfile($0);\n   $$0 = $7;\n  }\n } while (0);\n return $$0 | 0;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE14__erase_uniqueIiEEjRKT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$byval_copy = 0, $2 = 0, $3 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $$byval_copy = sp + 4 | 0;\n $2 = sp;\n $3 = __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_($0, $1) | 0;\n if (!$3) $$0 = 0; else {\n  HEAP32[$2 >> 2] = $3;\n  HEAP32[$$byval_copy >> 2] = HEAP32[$2 >> 2];\n  __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE5eraseENS_21__hash_const_iteratorIPNS_11__hash_nodeIS3_PvEEEE($0, $$byval_copy) | 0;\n  $$0 = 1;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE9__grow_byEjjjjjj($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $$sroa$speculated = 0, $13 = 0, $14 = 0, $19 = 0, $20 = 0, $22 = 0, $23 = 0;\n if ((-17 - $1 | 0) >>> 0 < $2 >>> 0) __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv($0);\n if ((HEAP8[$0 + 11 >> 0] | 0) < 0) $22 = HEAP32[$0 >> 2] | 0; else $22 = $0;\n if ($1 >>> 0 < 2147483623) {\n  $13 = $2 + $1 | 0;\n  $14 = $1 << 1;\n  $$sroa$speculated = $13 >>> 0 < $14 >>> 0 ? $14 : $13;\n  $19 = $$sroa$speculated >>> 0 < 11 ? 11 : $$sroa$speculated + 16 & -16;\n } else $19 = -17;\n $20 = __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE8allocateEj($19) | 0;\n if ($4 | 0) __ZNSt3__211char_traitsIcE4copyEPcPKcj($20, $22, $4) | 0;\n $23 = $3 - $4 | 0;\n if ($23 | 0) __ZNSt3__211char_traitsIcE4copyEPcPKcj($20 + $4 + $5 | 0, $22 + $4 | 0, $23) | 0;\n if (($1 | 0) != 10) __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE10deallocateEPcj($22);\n HEAP32[$0 >> 2] = $20;\n HEAP32[$0 + 8 >> 2] = $19 | -2147483648;\n return;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKcj($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $11 = 0, $13 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n $4 = $0 + 11 | 0;\n $5 = HEAP8[$4 >> 0] | 0;\n $6 = $5 << 24 >> 24 < 0;\n if ($6) $11 = (HEAP32[$0 + 8 >> 2] & 2147483647) + -1 | 0; else $11 = 10;\n do if ($11 >>> 0 < $2 >>> 0) {\n  if ($6) $23 = HEAP32[$0 + 4 >> 2] | 0; else $23 = $5 & 255;\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE21__grow_by_and_replaceEjjjjjjPKc($0, $11, $2 - $11 | 0, $23, 0, $23, $2, $1);\n } else {\n  if ($6) $13 = HEAP32[$0 >> 2] | 0; else $13 = $0;\n  __ZNSt3__211char_traitsIcE4moveEPcPKcj($13, $1, $2) | 0;\n  HEAP8[$3 >> 0] = 0;\n  __ZNSt3__211char_traitsIcE6assignERcRKc($13 + $2 | 0, $3);\n  if ((HEAP8[$4 >> 0] | 0) < 0) {\n   HEAP32[$0 + 4 >> 2] = $2;\n   break;\n  } else {\n   HEAP8[$4 >> 0] = $2;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE5eraseENS_21__hash_const_iteratorIPNS_11__hash_nodeIS3_PvEEEE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$byval_copy = 0, $2 = 0, $3 = 0, $4 = 0, $6 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $$byval_copy = sp + 16 | 0;\n $2 = sp + 4 | 0;\n $3 = sp;\n $4 = HEAP32[$1 >> 2] | 0;\n $6 = HEAP32[$4 >> 2] | 0;\n HEAP32[$3 >> 2] = $4;\n HEAP32[$$byval_copy >> 2] = HEAP32[$3 >> 2];\n __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE6removeENS_21__hash_const_iteratorIPNS_11__hash_nodeIS3_PvEEEE($2, $0, $$byval_copy);\n $7 = HEAP32[$2 >> 2] | 0;\n HEAP32[$2 >> 2] = 0;\n if ($7 | 0) {\n  if (HEAP8[$2 + 8 >> 0] | 0) __ZNSt3__24pairIKi12arControllerED2Ev($7 + 8 | 0);\n  __ZdlPv($7);\n }\n STACKTOP = sp;\n return $6 | 0;\n}\n\nfunction _icpGetJ_U_S($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$024 = 0, $$025 = 0, $$026 = 0, $15 = 0.0, $16 = 0.0, $4 = 0, $5 = 0, $6 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 224 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(224);\n $4 = sp + 72 | 0;\n $5 = sp + 24 | 0;\n $6 = sp;\n _icpGetJ_Xc_S($4, $6, $2, $3);\n L1 : do if ((_icpGetJ_U_Xc($5, $1, $6) | 0) < 0) {\n  _arLog(0, 3, 4669, sp + 216 | 0);\n  $$026 = -1;\n } else {\n  $$024 = 0;\n  while (1) {\n   if (($$024 | 0) == 2) {\n    $$026 = 0;\n    break L1;\n   }\n   $$025 = 0;\n   while (1) {\n    if (($$025 | 0) == 6) break;\n    $9 = $0 + ($$024 * 48 | 0) + ($$025 << 3) | 0;\n    HEAPF64[$9 >> 3] = 0.0;\n    $$0 = 0;\n    $16 = 0.0;\n    while (1) {\n     if (($$0 | 0) == 3) break;\n     $15 = $16 + +HEAPF64[$5 + ($$024 * 24 | 0) + ($$0 << 3) >> 3] * +HEAPF64[$4 + ($$0 * 48 | 0) + ($$025 << 3) >> 3];\n     HEAPF64[$9 >> 3] = $15;\n     $$0 = $$0 + 1 | 0;\n     $16 = $15;\n    }\n    $$025 = $$025 + 1 | 0;\n   }\n   $$024 = $$024 + 1 | 0;\n  }\n } while (0);\n STACKTOP = sp;\n return $$026 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_12DbC2ILj4096EEERNS0_5arenaIXT_EEE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n __ZN10__cxxabiv112_GLOBAL__N_111short_allocINS0_11string_pairELj4096EEC2ERNS0_5arenaILj4096EEE($2, $1);\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n HEAP32[$0 + 12 >> 2] = HEAP32[$2 >> 2];\n __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EEC2ERNS0_5arenaILj4096EEE($2, $1);\n __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEC2EjRKS6_RKS7_($0 + 16 | 0, $2);\n __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS3_INS0_11string_pairENS1_IS4_Lj4096EEEEENS1_IS6_Lj4096EEEEELj4096EEC2ERNS0_5arenaILj4096EEE($2, $1);\n __ZNSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEEC2EjRKS8_RKS9_($0 + 32 | 0, $2);\n STACKTOP = sp;\n return;\n}\n\nfunction _addMarker($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$1 = 0, $10 = 0, $12 = 0, $2 = 0, $5 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $2 = sp + 4 | 0;\n HEAP32[$2 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0)) $$1 = -1; else {\n  $5 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0;\n  if ((HEAP8[$1 + 11 >> 0] | 0) < 0) $12 = HEAP32[$1 >> 2] | 0; else $12 = $1;\n  $10 = $5 + 260 | 0;\n  if (!(__ZL10loadMarkerPKcPiP8ARHandlePP12ARPattHandle($12, $10, $5 + 220 | 0) | 0)) {\n   _arLog(0, 3, 9968, $vararg_buffer);\n   $$1 = -1;\n   break;\n  } else {\n   $$1 = HEAP32[$10 >> 2] | 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_119parse_unscoped_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$026$off0 = 0, $$027 = 0, $$1 = 0, $12 = 0, $17 = 0, $18 = 0, $21 = 0;\n if (($1 - $0 | 0) > 1) {\n  if ((HEAP8[$0 >> 0] | 0) == 83) if ((HEAP8[$0 + 1 >> 0] | 0) == 116) {\n   $12 = $0 + 2 | 0;\n   if (($12 | 0) == ($1 | 0)) {\n    $$026$off0 = 0;\n    $$027 = $1;\n   } else {\n    $$026$off0 = 0;\n    $$027 = (HEAP8[$12 >> 0] | 0) == 76 ? $0 + 3 | 0 : $12;\n   }\n  } else {\n   $$026$off0 = 1;\n   $$027 = $0;\n  } else {\n   $$026$off0 = 1;\n   $$027 = $0;\n  }\n  $17 = __ZN10__cxxabiv112_GLOBAL__N_122parse_unqualified_nameINS0_2DbEEEPKcS4_S4_RT_($$027, $1, $2) | 0;\n  $18 = ($17 | 0) == ($$027 | 0);\n  if ($$026$off0 | $18) $$1 = $18 ? $0 : $17; else {\n   $21 = HEAP32[$2 + 4 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($21 | 0)) $$1 = $0; else {\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($21 + -24 | 0, 0, 15413) | 0;\n    $$1 = $17;\n   }\n  }\n } else $$1 = $0;\n return $$1 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_117parse_call_offsetEPKcS2_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$3 = 0, $12 = 0, $13 = 0, $18 = 0, $19 = 0, $5 = 0, $6 = 0;\n L1 : do if (($0 | 0) == ($1 | 0)) $$3 = $0; else {\n  switch (HEAP8[$0 >> 0] | 0) {\n  case 104:\n   {\n    $5 = $0 + 1 | 0;\n    $6 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($5, $1) | 0;\n    if (($6 | 0) == ($5 | 0) | ($6 | 0) == ($1 | 0)) {\n     $$3 = $0;\n     break L1;\n    }\n    return ((HEAP8[$6 >> 0] | 0) == 95 ? $6 + 1 | 0 : $0) | 0;\n   }\n  case 118:\n   break;\n  default:\n   {\n    $$3 = $0;\n    break L1;\n   }\n  }\n  $12 = $0 + 1 | 0;\n  $13 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($12, $1) | 0;\n  if (($13 | 0) == ($12 | 0) | ($13 | 0) == ($1 | 0)) $$3 = $0; else if ((HEAP8[$13 >> 0] | 0) == 95) {\n   $18 = $13 + 1 | 0;\n   $19 = __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($18, $1) | 0;\n   if (($19 | 0) == ($18 | 0) | ($19 | 0) == ($1 | 0)) $$3 = $0; else $$3 = (HEAP8[$19 >> 0] | 0) == 95 ? $19 + 1 | 0 : $0;\n  } else $$3 = $0;\n } while (0);\n return $$3 | 0;\n}\n\nfunction _arUtilMatInv($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$030 = 0, $$1 = 0, $$131 = 0, $11 = 0, $12 = 0, $14 = 0, $2 = 0, $3 = 0;\n $2 = _arMatrixAlloc(4, 4) | 0;\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) == 3) break;\n  $3 = $$0 << 2;\n  $$030 = 0;\n  while (1) {\n   if (($$030 | 0) == 4) break;\n   HEAPF64[(HEAP32[$2 >> 2] | 0) + ($$030 + $3 << 3) >> 3] = +HEAPF64[$0 + ($$0 << 5) + ($$030 << 3) >> 3];\n   $$030 = $$030 + 1 | 0;\n  }\n  $$0 = $$0 + 1 | 0;\n }\n $11 = HEAP32[$2 >> 2] | 0;\n $12 = $11 + 96 | 0;\n HEAP32[$12 >> 2] = 0;\n HEAP32[$12 + 4 >> 2] = 0;\n HEAP32[$12 + 8 >> 2] = 0;\n HEAP32[$12 + 12 >> 2] = 0;\n HEAP32[$12 + 16 >> 2] = 0;\n HEAP32[$12 + 20 >> 2] = 0;\n HEAPF64[$11 + 120 >> 3] = 1.0;\n _arMatrixSelfInv($2) | 0;\n $$1 = 0;\n while (1) {\n  if (($$1 | 0) == 3) break;\n  $14 = $$1 << 2;\n  $$131 = 0;\n  while (1) {\n   if (($$131 | 0) == 4) break;\n   HEAPF64[$1 + ($$1 << 5) + ($$131 << 3) >> 3] = +HEAPF64[(HEAP32[$2 >> 2] | 0) + ($$131 + $14 << 3) >> 3];\n   $$131 = $$131 + 1 | 0;\n  }\n  $$1 = $$1 + 1 | 0;\n }\n _arMatrixFree($2) | 0;\n return 0;\n}\n\nfunction _detectMarker($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $2 = 0, $6 = 0, dest = 0, sp = 0, stop = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 48 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48);\n $1 = sp + 40 | 0;\n $2 = sp;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$0 = HEAP32[489] | 0; else {\n  $6 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0;\n  dest = $2;\n  stop = dest + 40 | 0;\n  do {\n   HEAP32[dest >> 2] = 0;\n   dest = dest + 4 | 0;\n  } while ((dest | 0) < (stop | 0));\n  HEAP32[$2 >> 2] = HEAP32[$6 + 196 >> 2];\n  HEAP32[$2 + 16 >> 2] = 1;\n  HEAP32[$2 + 12 >> 2] = HEAP32[$6 + 204 >> 2];\n  $$0 = _arDetectMarker(HEAP32[$6 + 216 >> 2] | 0, $2) | 0;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _getTransMatSquareCont($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$1 = 0, $3 = 0, $7 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n HEAP32[$3 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $3) | 0)) $$1 = HEAP32[489] | 0; else {\n  $7 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $3) | 0;\n  $9 = HEAP32[$7 + 216 >> 2] | 0;\n  if ((HEAP32[$9 + 44 >> 2] | 0) > ($1 | 0)) {\n   +_arGetTransMatSquareCont(HEAP32[$7 + 228 >> 2] | 0, ($1 | 0) < 0 ? 17e3 : $9 + 48 + ($1 << 8) | 0, 17256, +($2 | 0), 17256);\n   $$1 = 0;\n   break;\n  } else {\n   $$1 = HEAP32[491] | 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$2 = 0, $3 = 0, $6 = 0, dest = 0, sp = 0, stop = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64);\n $3 = sp;\n if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, $1, 0) | 0) $$2 = 1; else if (!$1) $$2 = 0; else {\n  $6 = ___dynamic_cast($1, 216, 200, 0) | 0;\n  if (!$6) $$2 = 0; else {\n   dest = $3 + 4 | 0;\n   stop = dest + 52 | 0;\n   do {\n    HEAP32[dest >> 2] = 0;\n    dest = dest + 4 | 0;\n   } while ((dest | 0) < (stop | 0));\n   HEAP32[$3 >> 2] = $6;\n   HEAP32[$3 + 8 >> 2] = $0;\n   HEAP32[$3 + 12 >> 2] = -1;\n   HEAP32[$3 + 48 >> 2] = 1;\n   FUNCTION_TABLE_viiii[HEAP32[(HEAP32[$6 >> 2] | 0) + 28 >> 2] & 3]($6, $3, HEAP32[$2 >> 2] | 0, 1);\n   if ((HEAP32[$3 + 24 >> 2] | 0) == 1) {\n    HEAP32[$2 >> 2] = HEAP32[$3 + 16 >> 2];\n    $$0 = 1;\n   } else $$0 = 0;\n   $$2 = $$0;\n  }\n }\n STACKTOP = sp;\n return $$2 | 0;\n}\n\nfunction _getTransMatSquare($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$1 = 0, $3 = 0, $7 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n HEAP32[$3 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $3) | 0)) $$1 = HEAP32[489] | 0; else {\n  $7 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $3) | 0;\n  $9 = HEAP32[$7 + 216 >> 2] | 0;\n  if ((HEAP32[$9 + 44 >> 2] | 0) > ($1 | 0)) {\n   +_arGetTransMatSquare(HEAP32[$7 + 228 >> 2] | 0, ($1 | 0) < 0 ? 17e3 : $9 + 48 + ($1 << 8) | 0, +($2 | 0), 17256);\n   $$1 = 0;\n   break;\n  } else {\n   $$1 = HEAP32[491] | 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction _fputc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $13 = 0, $14 = 0, $20 = 0, $21 = 0, $26 = 0, $27 = 0, $33 = 0, $7 = 0, $8 = 0, label = 0;\n if ((HEAP32[$1 + 76 >> 2] | 0) < 0) label = 3; else if (!(___lockfile($1) | 0)) label = 3; else {\n  $20 = $0 & 255;\n  $21 = $0 & 255;\n  if (($21 | 0) == (HEAP8[$1 + 75 >> 0] | 0)) label = 10; else {\n   $26 = $1 + 20 | 0;\n   $27 = HEAP32[$26 >> 2] | 0;\n   if ($27 >>> 0 < (HEAP32[$1 + 16 >> 2] | 0) >>> 0) {\n    HEAP32[$26 >> 2] = $27 + 1;\n    HEAP8[$27 >> 0] = $20;\n    $33 = $21;\n   } else label = 10;\n  }\n  if ((label | 0) == 10) $33 = ___overflow($1, $0) | 0;\n  ___unlockfile($1);\n  $$0 = $33;\n }\n do if ((label | 0) == 3) {\n  $7 = $0 & 255;\n  $8 = $0 & 255;\n  if (($8 | 0) != (HEAP8[$1 + 75 >> 0] | 0)) {\n   $13 = $1 + 20 | 0;\n   $14 = HEAP32[$13 >> 2] | 0;\n   if ($14 >>> 0 < (HEAP32[$1 + 16 >> 2] | 0) >>> 0) {\n    HEAP32[$13 >> 2] = $14 + 1;\n    HEAP8[$14 >> 0] = $7;\n    $$0 = $8;\n    break;\n   }\n  }\n  $$0 = ___overflow($1, $0) | 0;\n } while (0);\n return $$0 | 0;\n}\n\nfunction __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $10 = 0, $11 = 0, $21 = 0, $22 = 0, $28 = 0, $30 = 0;\n HEAP8[$1 + 53 >> 0] = 1;\n do if ((HEAP32[$1 + 4 >> 2] | 0) == ($3 | 0)) {\n  HEAP8[$1 + 52 >> 0] = 1;\n  $10 = $1 + 16 | 0;\n  $11 = HEAP32[$10 >> 2] | 0;\n  if (!$11) {\n   HEAP32[$10 >> 2] = $2;\n   HEAP32[$1 + 24 >> 2] = $4;\n   HEAP32[$1 + 36 >> 2] = 1;\n   if (!(($4 | 0) == 1 ? (HEAP32[$1 + 48 >> 2] | 0) == 1 : 0)) break;\n   HEAP8[$1 + 54 >> 0] = 1;\n   break;\n  }\n  if (($11 | 0) != ($2 | 0)) {\n   $30 = $1 + 36 | 0;\n   HEAP32[$30 >> 2] = (HEAP32[$30 >> 2] | 0) + 1;\n   HEAP8[$1 + 54 >> 0] = 1;\n   break;\n  }\n  $21 = $1 + 24 | 0;\n  $22 = HEAP32[$21 >> 2] | 0;\n  if (($22 | 0) == 2) {\n   HEAP32[$21 >> 2] = $4;\n   $28 = $4;\n  } else $28 = $22;\n  if (($28 | 0) == 1 ? (HEAP32[$1 + 48 >> 2] | 0) == 1 : 0) HEAP8[$1 + 54 >> 0] = 1;\n } while (0);\n return;\n}\n\nfunction __ZNSt3__26vectorI12multi_markerNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$pre$phiZ2D = 0, $11 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $5 = 0, $7 = 0;\n $2 = HEAP32[$0 >> 2] | 0;\n $3 = $0 + 4 | 0;\n $5 = $1 + 4 | 0;\n $7 = (HEAP32[$3 >> 2] | 0) - $2 | 0;\n $11 = (HEAP32[$5 >> 2] | 0) + (0 - ($7 >> 3) << 3) | 0;\n HEAP32[$5 >> 2] = $11;\n if (($7 | 0) > 0) {\n  _memcpy($11 | 0, $2 | 0, $7 | 0) | 0;\n  $$pre$phiZ2D = $5;\n  $15 = HEAP32[$5 >> 2] | 0;\n } else {\n  $$pre$phiZ2D = $5;\n  $15 = $11;\n }\n $14 = HEAP32[$0 >> 2] | 0;\n HEAP32[$0 >> 2] = $15;\n HEAP32[$$pre$phiZ2D >> 2] = $14;\n $16 = $1 + 8 | 0;\n $17 = HEAP32[$3 >> 2] | 0;\n HEAP32[$3 >> 2] = HEAP32[$16 >> 2];\n HEAP32[$16 >> 2] = $17;\n $19 = $0 + 8 | 0;\n $20 = $1 + 12 | 0;\n $21 = HEAP32[$19 >> 2] | 0;\n HEAP32[$19 >> 2] = HEAP32[$20 >> 2];\n HEAP32[$20 >> 2] = $21;\n HEAP32[$1 >> 2] = HEAP32[$$pre$phiZ2D >> 2];\n return;\n}\n\nfunction __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS5_EE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i = 0, $12 = 0, $14 = 0, $15 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $5 = 0, $9 = 0;\n $2 = HEAP32[$0 >> 2] | 0;\n $3 = $0 + 4 | 0;\n $5 = $1 + 4 | 0;\n $$0$i = HEAP32[$3 >> 2] | 0;\n while (1) {\n  if (($$0$i | 0) == ($2 | 0)) break;\n  $9 = $$0$i + -24 | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_((HEAP32[$5 >> 2] | 0) + -24 | 0, $9);\n  HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + -24;\n  $$0$i = $9;\n }\n $12 = HEAP32[$0 >> 2] | 0;\n HEAP32[$0 >> 2] = HEAP32[$5 >> 2];\n HEAP32[$5 >> 2] = $12;\n $14 = $1 + 8 | 0;\n $15 = HEAP32[$3 >> 2] | 0;\n HEAP32[$3 >> 2] = HEAP32[$14 >> 2];\n HEAP32[$14 >> 2] = $15;\n $17 = $0 + 8 | 0;\n $18 = $1 + 12 | 0;\n $19 = HEAP32[$17 >> 2] | 0;\n HEAP32[$17 >> 2] = HEAP32[$18 >> 2];\n HEAP32[$18 >> 2] = $19;\n HEAP32[$1 >> 2] = HEAP32[$5 >> 2];\n return;\n}\n\nfunction _setMarkerInfoDir($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$1 = 0, $3 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n HEAP32[$3 >> 2] = $0;\n do if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $3) | 0)) $$1 = HEAP32[489] | 0; else {\n  $8 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $3) | 0) + 216 | 0;\n  $9 = HEAP32[$8 >> 2] | 0;\n  if ((HEAP32[$9 + 44 >> 2] | 0) > ($1 | 0)) {\n   HEAP32[(($1 | 0) < 0 ? 17e3 : $9 + 48 + ($1 << 8) | 0) + 16 >> 2] = $2;\n   $$1 = 0;\n   break;\n  } else {\n   $$1 = HEAP32[491] | 0;\n   break;\n  }\n } while (0);\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction _atoi($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$010$lcssa = 0, $$01015 = 0, $$011 = 0, $$1 = 0, $$112 = 0, $$214 = 0, $$pre$phiZ2D = 0, $14 = 0, $5 = 0, $7 = 0, label = 0;\n $$011 = $0;\n while (1) {\n  $5 = $$011 + 1 | 0;\n  if (!(_isspace(HEAP8[$$011 >> 0] | 0) | 0)) break; else $$011 = $5;\n }\n $7 = HEAP8[$$011 >> 0] | 0;\n switch ($7 | 0) {\n case 45:\n  {\n   $$0 = 1;\n   label = 5;\n   break;\n  }\n case 43:\n  {\n   $$0 = 0;\n   label = 5;\n   break;\n  }\n default:\n  {\n   $$1 = 0;\n   $$112 = $$011;\n   $$pre$phiZ2D = $7;\n  }\n }\n if ((label | 0) == 5) {\n  $$1 = $$0;\n  $$112 = $5;\n  $$pre$phiZ2D = HEAP8[$5 >> 0] | 0;\n }\n if (!(_isdigit($$pre$phiZ2D) | 0)) $$010$lcssa = 0; else {\n  $$01015 = 0;\n  $$214 = $$112;\n  while (1) {\n   $14 = ($$01015 * 10 | 0) + 48 - (HEAP8[$$214 >> 0] | 0) | 0;\n   $$214 = $$214 + 1 | 0;\n   if (!(_isdigit(HEAP8[$$214 >> 0] | 0) | 0)) {\n    $$010$lcssa = $14;\n    break;\n   } else $$01015 = $14;\n  }\n }\n return (($$1 | 0) == 0 ? 0 - $$010$lcssa | 0 : $$010$lcssa) | 0;\n}\n\nfunction _loadCamera($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $12 = 0, $13 = 0, $2 = 0, $6 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 208 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(208);\n $vararg_buffer1 = sp + 192 | 0;\n $vararg_buffer = sp + 184 | 0;\n $1 = sp;\n $2 = $0 + 11 | 0;\n if ((HEAP8[$2 >> 0] | 0) < 0) $6 = HEAP32[$0 >> 2] | 0; else $6 = $0;\n if ((_arParamLoad($6, 1, $1, $vararg_buffer) | 0) < 0) {\n  if ((HEAP8[$2 >> 0] | 0) < 0) $12 = HEAP32[$0 >> 2] | 0; else $12 = $0;\n  HEAP32[$vararg_buffer1 >> 2] = $12;\n  _arLog(0, 3, 9828, $vararg_buffer1);\n  $$0 = -1;\n } else {\n  $13 = HEAP32[4349] | 0;\n  HEAP32[4349] = $13 + 1;\n  HEAP32[$vararg_buffer >> 2] = $13;\n  _memcpy(__ZNSt3__213unordered_mapIi7ARParamNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17376, $vararg_buffer) | 0, $1 | 0, 184) | 0;\n  $$0 = HEAP32[$vararg_buffer >> 2] | 0;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $13 = 0, $19 = 0;\n do if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 + 8 >> 2] | 0, $4) | 0) __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi(0, $1, $2, $3); else if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 >> 2] | 0, $4) | 0) {\n  if ((HEAP32[$1 + 16 >> 2] | 0) != ($2 | 0)) {\n   $13 = $1 + 20 | 0;\n   if ((HEAP32[$13 >> 2] | 0) != ($2 | 0)) {\n    HEAP32[$1 + 32 >> 2] = $3;\n    HEAP32[$13 >> 2] = $2;\n    $19 = $1 + 40 | 0;\n    HEAP32[$19 >> 2] = (HEAP32[$19 >> 2] | 0) + 1;\n    if ((HEAP32[$1 + 36 >> 2] | 0) == 1) if ((HEAP32[$1 + 24 >> 2] | 0) == 2) HEAP8[$1 + 54 >> 0] = 1;\n    HEAP32[$1 + 44 >> 2] = 4;\n    break;\n   }\n  }\n  if (($3 | 0) == 1) HEAP32[$1 + 32 >> 2] = 1;\n } while (0);\n return;\n}\n\nfunction _strlen($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$015$lcssa = 0, $$01518 = 0, $$1$lcssa = 0, $$pn = 0, $$pn29 = 0, $1 = 0, $10 = 0, $19 = 0, $22 = 0, $6 = 0, label = 0;\n $1 = $0;\n L1 : do if (!($1 & 3)) {\n  $$015$lcssa = $0;\n  label = 5;\n } else {\n  $$01518 = $0;\n  $22 = $1;\n  while (1) {\n   if (!(HEAP8[$$01518 >> 0] | 0)) {\n    $$pn = $22;\n    break L1;\n   }\n   $6 = $$01518 + 1 | 0;\n   $22 = $6;\n   if (!($22 & 3)) {\n    $$015$lcssa = $6;\n    label = 5;\n    break;\n   } else $$01518 = $6;\n  }\n } while (0);\n if ((label | 0) == 5) {\n  $$0 = $$015$lcssa;\n  while (1) {\n   $10 = HEAP32[$$0 >> 2] | 0;\n   if (!(($10 & -2139062144 ^ -2139062144) & $10 + -16843009)) $$0 = $$0 + 4 | 0; else break;\n  }\n  if (!(($10 & 255) << 24 >> 24)) $$1$lcssa = $$0; else {\n   $$pn29 = $$0;\n   while (1) {\n    $19 = $$pn29 + 1 | 0;\n    if (!(HEAP8[$19 >> 0] | 0)) {\n     $$1$lcssa = $19;\n     break;\n    } else $$pn29 = $19;\n   }\n  }\n  $$pn = $$1$lcssa;\n }\n return $$pn - $1 | 0;\n}\n\nfunction _setPattRatio($0, $1) {\n $0 = $0 | 0;\n $1 = +$1;\n var $10 = 0, $2 = 0, $5 = 0, $8 = 0.0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $2 = sp + 8 | 0;\n HEAP32[$2 >> 2] = $0;\n if (__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0) {\n  $5 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0;\n  if (!($1 <= 0.0 | $1 >= 1.0)) {\n   $8 = $1;\n   $10 = HEAP32[$5 + 216 >> 2] | 0;\n   if ($10 | 0) if (!(_arSetPattRatio($10, $8) | 0)) {\n    HEAPF64[$vararg_buffer >> 3] = $8;\n    _arLog(0, 1, 7949, $vararg_buffer);\n   }\n  }\n }\n STACKTOP = sp;\n return;\n}\n\nfunction __ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $10 = 0, $13 = 0, $9 = 0;\n L1 : do if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 + 8 >> 2] | 0, 0) | 0) __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi(0, $1, $2, $3); else {\n  $9 = HEAP32[$0 + 12 >> 2] | 0;\n  $10 = $0 + 16 + ($9 << 3) | 0;\n  __ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($0 + 16 | 0, $1, $2, $3);\n  if (($9 | 0) > 1) {\n   $13 = $1 + 54 | 0;\n   $$0 = $0 + 24 | 0;\n   do {\n    __ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($$0, $1, $2, $3);\n    if (HEAP8[$13 >> 0] | 0) break L1;\n    $$0 = $$0 + 8 | 0;\n   } while ($$0 >>> 0 < $10 >>> 0);\n  }\n } while (0);\n return;\n}\n\nfunction _setDebugMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $2 = 0, $6 = 0, $8 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $2 = sp + 4 | 0;\n HEAP32[$2 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0)) $$0 = 0; else {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 216 | 0;\n  $8 = ($1 | 0) != 0;\n  _arSetDebugMode(HEAP32[$6 >> 2] | 0, $8 & 1) | 0;\n  HEAP32[$vararg_buffer >> 2] = $8 ? 8083 : 8087;\n  _arLog(0, 1, 8092, $vararg_buffer);\n  $$0 = $1;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _getMultiMarkerNum($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$1 = 0, $10 = 0, $2 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0)) $$1 = -1; else {\n  $5 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0;\n  if (($1 | 0) < 0) $$1 = -1; else {\n   $10 = HEAP32[$5 + 248 >> 2] | 0;\n   if ((HEAP32[$5 + 252 >> 2] | 0) - $10 >> 3 >>> 0 > $1 >>> 0) $$1 = HEAP32[(HEAP32[$10 + ($1 << 3) + 4 >> 2] | 0) + 4 >> 2] | 0; else $$1 = -1;\n  }\n }\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction _cycle($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$02527 = 0, $$026 = 0, $10 = 0, $11 = 0, $18 = 0, $3 = 0, $5 = 0, $8 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 256 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(256);\n $3 = sp;\n L1 : do if (($2 | 0) >= 2) {\n  $5 = $1 + ($2 << 2) | 0;\n  HEAP32[$5 >> 2] = $3;\n  if ($0 | 0) {\n   $$02527 = $0;\n   $10 = $3;\n   while (1) {\n    $8 = $$02527 >>> 0 < 256 ? $$02527 : 256;\n    _memcpy($10 | 0, HEAP32[$1 >> 2] | 0, $8 | 0) | 0;\n    $$026 = 0;\n    do {\n     $11 = $1 + ($$026 << 2) | 0;\n     $$026 = $$026 + 1 | 0;\n     _memcpy(HEAP32[$11 >> 2] | 0, HEAP32[$1 + ($$026 << 2) >> 2] | 0, $8 | 0) | 0;\n     HEAP32[$11 >> 2] = (HEAP32[$11 >> 2] | 0) + $8;\n    } while (($$026 | 0) != ($2 | 0));\n    $18 = $$02527 - $8 | 0;\n    if (!$18) break L1;\n    $$02527 = $18;\n    $10 = HEAP32[$5 >> 2] | 0;\n   }\n  }\n } while (0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE5eraseEjj($0) {\n $0 = $0 | 0;\n var $$sroa$speculated = 0, $1 = 0, $10 = 0, $11 = 0, $14 = 0, $16 = 0, $2 = 0, $3 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = $0 + 11 | 0;\n $3 = HEAP8[$2 >> 0] | 0;\n if ($3 << 24 >> 24 < 0) {\n  $10 = HEAP32[$0 + 4 >> 2] | 0;\n  $14 = HEAP32[$0 >> 2] | 0;\n } else {\n  $10 = $3 & 255;\n  $14 = $0;\n }\n $$sroa$speculated = ($10 | 0) != 0 & 1;\n $11 = $10 - $$sroa$speculated | 0;\n if (!$11) $16 = $3; else {\n  __ZNSt3__211char_traitsIcE4moveEPcPKcj($14, $14 + $$sroa$speculated | 0, $11) | 0;\n  $16 = HEAP8[$2 >> 0] | 0;\n }\n if ($16 << 24 >> 24 < 0) HEAP32[$0 + 4 >> 2] = $11; else HEAP8[$2 >> 0] = $11;\n HEAP8[$1 >> 0] = 0;\n __ZNSt3__211char_traitsIcE6assignERcRKc($14 + $11 | 0, $1);\n STACKTOP = sp;\n return;\n}\n\nfunction ___overflow($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $10 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = $1 & 255;\n HEAP8[$2 >> 0] = $3;\n $4 = $0 + 16 | 0;\n $5 = HEAP32[$4 >> 2] | 0;\n if (!$5) if (!(___towrite($0) | 0)) {\n  $12 = HEAP32[$4 >> 2] | 0;\n  label = 4;\n } else $$0 = -1; else {\n  $12 = $5;\n  label = 4;\n }\n do if ((label | 0) == 4) {\n  $9 = $0 + 20 | 0;\n  $10 = HEAP32[$9 >> 2] | 0;\n  if ($10 >>> 0 < $12 >>> 0) {\n   $13 = $1 & 255;\n   if (($13 | 0) != (HEAP8[$0 + 75 >> 0] | 0)) {\n    HEAP32[$9 >> 2] = $10 + 1;\n    HEAP8[$10 >> 0] = $3;\n    $$0 = $13;\n    break;\n   }\n  }\n  if ((FUNCTION_TABLE_iiii[HEAP32[$0 + 36 >> 2] & 15]($0, $2, 1) | 0) == 1) $$0 = HEAPU8[$2 >> 0] | 0; else $$0 = -1;\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EERKSB_PKS8_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i = 0, $11 = 0, $12 = 0, $5 = 0, $6 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$0 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n $5 = $1 + 11 | 0;\n $6 = HEAP8[$5 >> 0] | 0;\n $11 = $6 << 24 >> 24 < 0 ? HEAP32[$1 + 4 >> 2] | 0 : $6 & 255;\n $12 = __ZNSt3__211char_traitsIcE6lengthEPKc($2) | 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcjj($0, (HEAP8[$5 >> 0] | 0) < 0 ? HEAP32[$1 >> 2] | 0 : $1, $11, $11 + $12 | 0);\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($0, $2, $12) | 0;\n return;\n}\n\nfunction __ZNSt3__2plIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEENS_12basic_stringIT_T0_T1_EEPKS8_RKSB_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$i$i = 0, $12 = 0, $5 = 0, $6 = 0, $7 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$0 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n $5 = __ZNSt3__211char_traitsIcE6lengthEPKc($1) | 0;\n $6 = $2 + 11 | 0;\n $7 = HEAP8[$6 >> 0] | 0;\n $12 = $7 << 24 >> 24 < 0 ? HEAP32[$2 + 4 >> 2] | 0 : $7 & 255;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcjj($0, $1, $5, $12 + $5 | 0);\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($0, (HEAP8[$6 >> 0] | 0) < 0 ? HEAP32[$2 >> 2] | 0 : $2, $12) | 0;\n return;\n}\n\nfunction _getPattRatio($0) {\n $0 = $0 | 0;\n var $$0 = 0.0, $$1 = 0.0, $1 = 0, $10 = 0, $2 = 0, $6 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp + 8 | 0;\n $2 = sp;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$1 = -1.0; else {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  $7 = HEAP32[$6 >> 2] | 0;\n  if (!$7) $$0 = -1.0; else {\n   $10 = (_arGetPattRatio($7, $2) | 0) == 0;\n   $$0 = $10 ? +HEAPF64[$2 >> 3] : -1.0;\n  }\n  $$1 = $$0;\n }\n STACKTOP = sp;\n return +$$1;\n}\n\nfunction _arPattDeleteHandle($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$024 = 0, $$025 = 0, $12 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;\n if (!$0) $$025 = -1; else {\n  $2 = $0 + 4 | 0;\n  $3 = $0 + 8 | 0;\n  $4 = $0 + 12 | 0;\n  $5 = $0 + 20 | 0;\n  $$024 = 0;\n  while (1) {\n   if (($$024 | 0) >= (HEAP32[$2 >> 2] | 0)) break;\n   if (HEAP32[(HEAP32[$3 >> 2] | 0) + ($$024 << 2) >> 2] | 0) _arPattFree($0, $$024) | 0;\n   $12 = $$024 << 2;\n   $$0 = 0;\n   while (1) {\n    if (($$0 | 0) == 4) break;\n    $14 = $$0 + $12 | 0;\n    _free(HEAP32[(HEAP32[$4 >> 2] | 0) + ($14 << 2) >> 2] | 0);\n    _free(HEAP32[(HEAP32[$5 >> 2] | 0) + ($14 << 2) >> 2] | 0);\n    $$0 = $$0 + 1 | 0;\n   }\n   $$024 = $$024 + 1 | 0;\n  }\n  _free(HEAP32[$4 >> 2] | 0);\n  _free(HEAP32[$5 >> 2] | 0);\n  _free(HEAP32[$3 >> 2] | 0);\n  _free(HEAP32[$0 + 16 >> 2] | 0);\n  _free(HEAP32[$0 + 24 >> 2] | 0);\n  _free($0);\n  $$025 = 0;\n }\n return $$025 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcjj($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $10 = 0, $11 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $4 = sp;\n if ($3 >>> 0 > 4294967279) __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv($0);\n if ($3 >>> 0 < 11) {\n  HEAP8[$0 + 11 >> 0] = $2;\n  $$0 = $0;\n } else {\n  $10 = $3 + 16 & -16;\n  $11 = __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE8allocateEj($10) | 0;\n  HEAP32[$0 >> 2] = $11;\n  HEAP32[$0 + 8 >> 2] = $10 | -2147483648;\n  HEAP32[$0 + 4 >> 2] = $2;\n  $$0 = $11;\n }\n __ZNSt3__211char_traitsIcE4copyEPcPKcj($$0, $1, $2) | 0;\n HEAP8[$4 >> 0] = 0;\n __ZNSt3__211char_traitsIcE6assignERcRKc($$0 + $2 | 0, $4);\n STACKTOP = sp;\n return;\n}\n\nfunction _arImageProcLumaHistAndCDFAndPercentile($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = +$2;\n $3 = $3 | 0;\n var $$0 = 0, $$024 = 0, $$025 = 0, $15 = 0, $16 = 0, $18 = 0, $22 = 0, $23 = 0, $6 = 0;\n if ($2 < 0.0 | $2 > 1.0) $$025 = -1; else {\n  $6 = _arImageProcLumaHistAndCDF($0, $1) | 0;\n  if (($6 | 0) < 0) $$025 = $6; else {\n   $15 = ~~(+(Math_imul(HEAP32[$0 + 8 >> 2] | 0, HEAP32[$0 + 4 >> 2] | 0) | 0) * $2) >>> 0;\n   $$024 = 0;\n   while (1) {\n    $16 = $$024 & 255;\n    $18 = HEAP32[$0 + 1036 + ($16 << 2) >> 2] | 0;\n    if ($18 >>> 0 < $15 >>> 0) $$024 = $$024 + 1 << 24 >> 24; else break;\n   }\n   $$0 = $$024;\n   $22 = $18;\n   while (1) {\n    $23 = $$0 + 1 << 24 >> 24;\n    if (($22 | 0) != ($15 | 0)) break;\n    $$0 = $23;\n    $22 = HEAP32[$0 + 1036 + (($23 & 255) << 2) >> 2] | 0;\n   }\n   HEAP8[$3 >> 0] = (($$0 & 255) + $16 | 0) >>> 1;\n   $$025 = 0;\n  }\n }\n return $$025 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_122parse_unqualified_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$1 = 0;\n L1 : do if (($0 | 0) == ($1 | 0)) $$1 = $0; else switch (HEAP8[$0 >> 0] | 0) {\n case 68:\n case 67:\n  {\n   $$1 = __ZN10__cxxabiv112_GLOBAL__N_120parse_ctor_dtor_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   break L1;\n   break;\n  }\n case 85:\n  {\n   $$1 = __ZN10__cxxabiv112_GLOBAL__N_123parse_unnamed_type_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   break L1;\n   break;\n  }\n case 57:\n case 56:\n case 55:\n case 54:\n case 53:\n case 52:\n case 51:\n case 50:\n case 49:\n  {\n   $$1 = __ZN10__cxxabiv112_GLOBAL__N_117parse_source_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n   break L1;\n   break;\n  }\n default:\n  return __ZN10__cxxabiv112_GLOBAL__N_119parse_operator_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n } while (0);\n return $$1 | 0;\n}\n\nfunction ___strerror_l($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$012$lcssa = 0, $$01214 = 0, $$016 = 0, $$113 = 0, $$115 = 0, $$115$ph = 0, $6 = 0, label = 0, $$113$looptemp = 0;\n $$016 = 0;\n while (1) {\n  if ((HEAPU8[12570 + $$016 >> 0] | 0) == ($0 | 0)) {\n   label = 4;\n   break;\n  }\n  $6 = $$016 + 1 | 0;\n  if (($6 | 0) == 87) {\n   $$115$ph = 87;\n   label = 5;\n   break;\n  } else $$016 = $6;\n }\n if ((label | 0) == 4) if (!$$016) $$012$lcssa = 12658; else {\n  $$115$ph = $$016;\n  label = 5;\n }\n if ((label | 0) == 5) {\n  $$01214 = 12658;\n  $$115 = $$115$ph;\n  while (1) {\n   $$113 = $$01214;\n   do {\n    $$113$looptemp = $$113;\n    $$113 = $$113 + 1 | 0;\n   } while ((HEAP8[$$113$looptemp >> 0] | 0) != 0);\n   $$115 = $$115 + -1 | 0;\n   if (!$$115) {\n    $$012$lcssa = $$113;\n    break;\n   } else $$01214 = $$113;\n  }\n }\n return ___lctrans($$012$lcssa, HEAP32[$1 + 20 >> 2] | 0) | 0;\n}\n\nfunction _setPatternDetectionMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $6 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $2 = sp + 4 | 0;\n HEAP32[$2 >> 2] = $0;\n if (__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0) {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 216 | 0;\n  if (!(_arSetPatternDetectionMode(HEAP32[$6 >> 2] | 0, $1) | 0)) {\n   HEAP32[$vararg_buffer >> 2] = $1;\n   _arLog(0, 1, 7980, $vararg_buffer);\n  }\n }\n STACKTOP = sp;\n return;\n}\n\nfunction _setThreshold($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $5 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $2 = sp + 4 | 0;\n HEAP32[$2 >> 2] = $0;\n if (__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0) {\n  $5 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0;\n  if ($1 >>> 0 <= 255) if (!(_arSetLabelingThresh(HEAP32[$5 + 216 >> 2] | 0, $1) | 0)) {\n   HEAP32[$vararg_buffer >> 2] = $1;\n   _arLog(0, 1, 8015, $vararg_buffer);\n  }\n }\n STACKTOP = sp;\n return;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $10 = 0, $3 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n if ($2 >>> 0 > 4294967279) __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv($0);\n if ($2 >>> 0 < 11) {\n  HEAP8[$0 + 11 >> 0] = $2;\n  $$0 = $0;\n } else {\n  $9 = $2 + 16 & -16;\n  $10 = __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE8allocateEj($9) | 0;\n  HEAP32[$0 >> 2] = $10;\n  HEAP32[$0 + 8 >> 2] = $9 | -2147483648;\n  HEAP32[$0 + 4 >> 2] = $2;\n  $$0 = $10;\n }\n __ZNSt3__211char_traitsIcE4copyEPcPKcj($$0, $1, $2) | 0;\n HEAP8[$3 >> 0] = 0;\n __ZNSt3__211char_traitsIcE6assignERcRKc($$0 + $2 | 0, $3);\n STACKTOP = sp;\n return;\n}\n\nfunction _setThresholdMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $6 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $2 = sp + 4 | 0;\n HEAP32[$2 >> 2] = $0;\n if (__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0) {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 216 | 0;\n  if (!(_arSetLabelingThreshMode(HEAP32[$6 >> 2] | 0, $1) | 0)) {\n   HEAP32[$vararg_buffer >> 2] = $1;\n   _arLog(0, 1, 8041, $vararg_buffer);\n  }\n }\n STACKTOP = sp;\n return;\n}\n\nfunction _byteswap($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$020 = 0, $$1 = 0, $1 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 192 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(192);\n $1 = sp;\n _byteSwapInt($0, $1);\n _byteSwapInt($0 + 4 | 0, $1 + 4 | 0);\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) == 3) break;\n  $$020 = 0;\n  while (1) {\n   if (($$020 | 0) == 4) break;\n   _byteSwapDouble($0 + 8 + ($$0 << 5) + ($$020 << 3) | 0, $1 + 8 + ($$0 << 5) + ($$020 << 3) | 0);\n   $$020 = $$020 + 1 | 0;\n  }\n  $$0 = $$0 + 1 | 0;\n }\n $8 = $0 + 176 | 0;\n $$1 = 0;\n while (1) {\n  $9 = HEAP32[$8 >> 2] | 0;\n  if (($$1 | 0) >= (HEAP32[1904 + ($9 + -1 << 3) >> 2] | 0)) break;\n  _byteSwapDouble($0 + 104 + ($$1 << 3) | 0, $1 + 104 + ($$1 << 3) | 0);\n  $$1 = $$1 + 1 | 0;\n }\n HEAP32[$1 + 176 >> 2] = $9;\n _memcpy($0 | 0, $1 | 0, 184) | 0;\n STACKTOP = sp;\n return;\n}\n\nfunction _setImageProcMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $6 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $2 = sp + 4 | 0;\n HEAP32[$2 >> 2] = $0;\n if (__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0) {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 216 | 0;\n  if (!(_arSetImageProcMode(HEAP32[$6 >> 2] | 0, $1) | 0)) {\n   HEAP32[$vararg_buffer >> 2] = $1;\n   _arLog(0, 1, 7890, $vararg_buffer);\n  }\n }\n STACKTOP = sp;\n return;\n}\n\nfunction _setLabelingMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $6 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $2 = sp + 4 | 0;\n HEAP32[$2 >> 2] = $0;\n if (__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0) {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 216 | 0;\n  if (!(_arSetLabelingMode(HEAP32[$6 >> 2] | 0, $1) | 0)) {\n   HEAP32[$vararg_buffer >> 2] = $1;\n   _arLog(0, 1, 7919, $vararg_buffer);\n  }\n }\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10emscripten8internal7InvokerIiJiNSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEE6invokeEPFiiS8_EiPNS0_11BindingTypeIS8_EUt_E($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp + 12 | 0;\n $4 = sp;\n $5 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($1) | 0;\n __ZN10emscripten8internal11BindingTypeINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE12fromWireTypeEPNS9_Ut_E($4, $2);\n $6 = FUNCTION_TABLE_iii[$0 & 15]($5, $4) | 0;\n HEAP32[$3 >> 2] = $6;\n $7 = __ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($3) | 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev($4);\n STACKTOP = sp;\n return $7 | 0;\n}\n\nfunction _scalbn($0, $1) {\n $0 = +$0;\n $1 = $1 | 0;\n var $$0 = 0.0, $$020 = 0, $10 = 0.0, $12 = 0, $14 = 0, $17 = 0, $18 = 0, $3 = 0.0, $5 = 0, $7 = 0;\n if (($1 | 0) > 1023) {\n  $3 = $0 * 8988465674311579538646525.0e283;\n  $5 = ($1 | 0) > 2046;\n  $7 = $1 + -2046 | 0;\n  $$0 = $5 ? $3 * 8988465674311579538646525.0e283 : $3;\n  $$020 = $5 ? (($7 | 0) < 1023 ? $7 : 1023) : $1 + -1023 | 0;\n } else if (($1 | 0) < -1022) {\n  $10 = $0 * 2.2250738585072014e-308;\n  $12 = ($1 | 0) < -2044;\n  $14 = $1 + 2044 | 0;\n  $$0 = $12 ? $10 * 2.2250738585072014e-308 : $10;\n  $$020 = $12 ? (($14 | 0) > -1022 ? $14 : -1022) : $1 + 1022 | 0;\n } else {\n  $$0 = $0;\n  $$020 = $1;\n }\n $17 = _bitshift64Shl($$020 + 1023 | 0, 0, 52) | 0;\n $18 = tempRet0;\n HEAP32[tempDoublePtr >> 2] = $17;\n HEAP32[tempDoublePtr + 4 >> 2] = $18;\n return +($$0 * +HEAPF64[tempDoublePtr >> 3]);\n}\n\nfunction _getPatternDetectionMode($0) {\n $0 = $0 | 0;\n var $$1 = 0, $1 = 0, $2 = 0, $6 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = sp + 4 | 0;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$1 = -1; else {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  $9 = (_arGetPatternDetectionMode(HEAP32[$6 >> 2] | 0, $2) | 0) == 0;\n  $$1 = $9 ? HEAP32[$2 >> 2] | 0 : -1;\n }\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZL15loadMultiMarkerPKcP8ARHandlePP12ARPattHandlePP18ARMultiMarkerInfoT($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $5 = _arMultiReadConfigFile($0, HEAP32[$2 >> 2] | 0) | 0;\n HEAP32[$3 >> 2] = $5;\n L1 : do if (!$5) {\n  _arLog(0, 3, 9941, sp);\n  _arPattDeleteHandle(HEAP32[$2 >> 2] | 0) | 0;\n  $$0 = 0;\n } else switch (HEAP32[$5 + 108 >> 2] | 0) {\n case 0:\n  {\n   _arSetPatternDetectionMode($1, 0) | 0;\n   $$0 = 1;\n   break L1;\n   break;\n  }\n case 1:\n  {\n   _arSetPatternDetectionMode($1, 2) | 0;\n   $$0 = 1;\n   break L1;\n   break;\n  }\n default:\n  {\n   _arSetPatternDetectionMode($1, 3) | 0;\n   $$0 = 1;\n   break L1;\n  }\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _frexp($0, $1) {\n $0 = +$0;\n $1 = $1 | 0;\n var $$0 = 0.0, $$016 = 0.0, $2 = 0, $3 = 0, $4 = 0, $9 = 0.0, $storemerge = 0;\n HEAPF64[tempDoublePtr >> 3] = $0;\n $2 = HEAP32[tempDoublePtr >> 2] | 0;\n $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;\n $4 = _bitshift64Lshr($2 | 0, $3 | 0, 52) | 0;\n switch ($4 & 2047) {\n case 0:\n  {\n   if ($0 != 0.0) {\n    $9 = +_frexp($0 * 18446744073709551616.0, $1);\n    $$016 = $9;\n    $storemerge = (HEAP32[$1 >> 2] | 0) + -64 | 0;\n   } else {\n    $$016 = $0;\n    $storemerge = 0;\n   }\n   HEAP32[$1 >> 2] = $storemerge;\n   $$0 = $$016;\n   break;\n  }\n case 2047:\n  {\n   $$0 = $0;\n   break;\n  }\n default:\n  {\n   HEAP32[$1 >> 2] = ($4 & 2047) + -1022;\n   HEAP32[tempDoublePtr >> 2] = $2;\n   HEAP32[tempDoublePtr + 4 >> 2] = $3 & -2146435073 | 1071644672;\n   $$0 = +HEAPF64[tempDoublePtr >> 3];\n  }\n }\n return +$$0;\n}\n\nfunction _getThresholdMode($0) {\n $0 = $0 | 0;\n var $$1 = 0, $1 = 0, $2 = 0, $6 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = sp + 4 | 0;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$1 = -1; else {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  $9 = (_arGetLabelingThreshMode(HEAP32[$6 >> 2] | 0, $2) | 0) == 0;\n  $$1 = $9 ? HEAP32[$2 >> 2] | 0 : -1;\n }\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZNSt3__213__vector_baseINS_6vectorINS1_IN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEEENS5_IS9_Lj4096EEEED2Ev($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $1 = 0, $3 = 0, $6 = 0, $8 = 0;\n $1 = HEAP32[$0 >> 2] | 0;\n if ($1 | 0) {\n  $3 = $0 + 4 | 0;\n  $$0$i$i = HEAP32[$3 >> 2] | 0;\n  while (1) {\n   if (($$0$i$i | 0) == ($1 | 0)) break;\n   $6 = $$0$i$i + -16 | 0;\n   __ZNSt3__213__vector_baseINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEED2Ev($6);\n   $$0$i$i = $6;\n  }\n  HEAP32[$3 >> 2] = $1;\n  $8 = HEAP32[$0 >> 2] | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS3_INS0_11string_pairENS1_IS4_Lj4096EEEEENS1_IS6_Lj4096EEEEELj4096EE10deallocateEPS8_j($0 + 12 | 0, $8, (HEAP32[$0 + 8 >> 2] | 0) - $8 >> 4);\n }\n return;\n}\n\nfunction _arMatrixTrans($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$024 = 0, $$025 = 0, $$026 = 0, $$027 = 0, $$1 = 0, $3 = 0, $8 = 0;\n $3 = HEAP32[$0 + 4 >> 2] | 0;\n L1 : do if (($3 | 0) == (HEAP32[$1 + 8 >> 2] | 0)) {\n  $8 = HEAP32[$0 + 8 >> 2] | 0;\n  if (($8 | 0) == (HEAP32[$1 + 4 >> 2] | 0)) {\n   $$0 = HEAP32[$0 >> 2] | 0;\n   $$026 = 0;\n   while (1) {\n    if (($$026 | 0) >= ($3 | 0)) {\n     $$027 = 0;\n     break L1;\n    }\n    $$024 = (HEAP32[$1 >> 2] | 0) + ($$026 << 3) | 0;\n    $$025 = 0;\n    $$1 = $$0;\n    while (1) {\n     if (($$025 | 0) >= ($8 | 0)) break;\n     HEAPF64[$$1 >> 3] = +HEAPF64[$$024 >> 3];\n     $$024 = $$024 + ($3 << 3) | 0;\n     $$025 = $$025 + 1 | 0;\n     $$1 = $$1 + 8 | 0;\n    }\n    $$0 = $$1;\n    $$026 = $$026 + 1 | 0;\n   }\n  } else $$027 = -1;\n } else $$027 = -1; while (0);\n return $$027 | 0;\n}\n\nfunction _getImageProcMode($0) {\n $0 = $0 | 0;\n var $$1 = 0, $1 = 0, $2 = 0, $6 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = sp + 4 | 0;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$1 = -1; else {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  $9 = (_arGetImageProcMode(HEAP32[$6 >> 2] | 0, $2) | 0) == 0;\n  $$1 = $9 ? HEAP32[$2 >> 2] | 0 : -1;\n }\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction _getLabelingMode($0) {\n $0 = $0 | 0;\n var $$1 = 0, $1 = 0, $2 = 0, $6 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = sp + 4 | 0;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$1 = -1; else {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  $9 = (_arGetLabelingMode(HEAP32[$6 >> 2] | 0, $2) | 0) == 0;\n  $$1 = $9 ? HEAP32[$2 >> 2] | 0 : -1;\n }\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction _getThreshold($0) {\n $0 = $0 | 0;\n var $$1 = 0, $1 = 0, $2 = 0, $6 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = sp + 4 | 0;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$1 = -1; else {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  $9 = (_arGetLabelingThresh(HEAP32[$6 >> 2] | 0, $2) | 0) == 0;\n  $$1 = $9 ? HEAP32[$2 >> 2] | 0 : -1;\n }\n STACKTOP = sp;\n return $$1 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_119parse_cv_qualifiersEPKcS2_Rj($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$1 = 0, $$2 = 0, $10 = 0, $11 = 0, $13 = 0, $15 = 0, $4 = 0, $6 = 0, $8 = 0, $9 = 0;\n HEAP32[$2 >> 2] = 0;\n if (($0 | 0) == ($1 | 0)) $$2 = $0; else {\n  $4 = HEAP8[$0 >> 0] | 0;\n  if ($4 << 24 >> 24 == 114) {\n   HEAP32[$2 >> 2] = 4;\n   $6 = $0 + 1 | 0;\n   $$0 = $6;\n   $10 = 4;\n   $8 = HEAP8[$6 >> 0] | 0;\n  } else {\n   $$0 = $0;\n   $10 = 0;\n   $8 = $4;\n  }\n  if ($8 << 24 >> 24 == 86) {\n   $9 = $10 | 2;\n   HEAP32[$2 >> 2] = $9;\n   $11 = $$0 + 1 | 0;\n   $$1 = $11;\n   $13 = HEAP8[$11 >> 0] | 0;\n   $15 = $9;\n  } else {\n   $$1 = $$0;\n   $13 = $8;\n   $15 = $10;\n  }\n  if ($13 << 24 >> 24 == 75) {\n   HEAP32[$2 >> 2] = $15 | 1;\n   $$2 = $$1 + 1 | 0;\n  } else $$2 = $$1;\n }\n return $$2 | 0;\n}\n\nfunction ___fseeko_unlocked($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$019 = 0, $10 = 0, $12 = 0, label = 0;\n if (($2 | 0) == 1) $$019 = $1 - (HEAP32[$0 + 8 >> 2] | 0) + (HEAP32[$0 + 4 >> 2] | 0) | 0; else $$019 = $1;\n $10 = $0 + 20 | 0;\n $12 = $0 + 28 | 0;\n if ((HEAP32[$10 >> 2] | 0) >>> 0 > (HEAP32[$12 >> 2] | 0) >>> 0) {\n  FUNCTION_TABLE_iiii[HEAP32[$0 + 36 >> 2] & 15]($0, 0, 0) | 0;\n  if (!(HEAP32[$10 >> 2] | 0)) $$0 = -1; else label = 5;\n } else label = 5;\n if ((label | 0) == 5) {\n  HEAP32[$0 + 16 >> 2] = 0;\n  HEAP32[$12 >> 2] = 0;\n  HEAP32[$10 >> 2] = 0;\n  if ((FUNCTION_TABLE_iiii[HEAP32[$0 + 40 >> 2] & 15]($0, $$019, $2) | 0) < 0) $$0 = -1; else {\n   HEAP32[$0 + 8 >> 2] = 0;\n   HEAP32[$0 + 4 >> 2] = 0;\n   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] & -17;\n   $$0 = 0;\n  }\n }\n return $$0 | 0;\n}\n\nfunction _icpGetQ_from_S($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$sink = 0.0, $$sink1 = 0.0, $11 = 0.0, $14 = 0.0, $2 = 0.0, $4 = 0, $5 = 0.0, $8 = 0, $9 = 0.0;\n $2 = +HEAPF64[$1 >> 3];\n $4 = $1 + 8 | 0;\n $5 = +HEAPF64[$4 >> 3];\n $8 = $1 + 16 | 0;\n $9 = +HEAPF64[$8 >> 3];\n $11 = $2 * $2 + $5 * $5 + $9 * $9;\n if ($11 == 0.0) {\n  HEAPF64[$0 >> 3] = 1.0;\n  HEAPF64[$0 + 8 >> 3] = 0.0;\n  $$sink = 0.0;\n  $$sink1 = 0.0;\n } else {\n  $14 = +Math_sqrt(+$11);\n  HEAPF64[$0 >> 3] = $2 / $14;\n  HEAPF64[$0 + 8 >> 3] = +HEAPF64[$4 >> 3] / $14;\n  $$sink = $14;\n  $$sink1 = +HEAPF64[$8 >> 3] / $14;\n }\n HEAPF64[$0 + 16 >> 3] = $$sink1;\n HEAPF64[$0 + 24 >> 3] = $$sink;\n HEAPF64[$0 + 32 >> 3] = +HEAPF64[$1 + 24 >> 3];\n HEAPF64[$0 + 40 >> 3] = +HEAPF64[$1 + 32 >> 3];\n HEAPF64[$0 + 48 >> 3] = +HEAPF64[$1 + 40 >> 3];\n return;\n}\n\nfunction _fclose($0) {\n $0 = $0 | 0;\n var $$pre = 0, $10 = 0, $15 = 0, $21 = 0, $25 = 0, $27 = 0, $30 = 0, $7 = 0, $8 = 0;\n if ((HEAP32[$0 + 76 >> 2] | 0) > -1) $30 = ___lockfile($0) | 0; else $30 = 0;\n ___unlist_locked_file($0);\n $7 = (HEAP32[$0 >> 2] & 1 | 0) != 0;\n if (!$7) {\n  $8 = ___ofl_lock() | 0;\n  $10 = HEAP32[$0 + 52 >> 2] | 0;\n  $$pre = $0 + 56 | 0;\n  if ($10 | 0) HEAP32[$10 + 56 >> 2] = HEAP32[$$pre >> 2];\n  $15 = HEAP32[$$pre >> 2] | 0;\n  if ($15 | 0) HEAP32[$15 + 52 >> 2] = $10;\n  if ((HEAP32[$8 >> 2] | 0) == ($0 | 0)) HEAP32[$8 >> 2] = $15;\n  ___ofl_unlock();\n }\n $21 = _fflush($0) | 0;\n $25 = FUNCTION_TABLE_ii[HEAP32[$0 + 12 >> 2] & 31]($0) | 0 | $21;\n $27 = HEAP32[$0 + 92 >> 2] | 0;\n if ($27 | 0) _free($27);\n if ($7) {\n  if ($30 | 0) ___unlockfile($0);\n } else _free($0);\n return $25 | 0;\n}\n\nfunction __ZNSt3__214__split_bufferINS_6vectorINS1_IN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEEERNS5_IS9_Lj4096EEEED2Ev($0) {\n $0 = $0 | 0;\n var $2 = 0, $3 = 0, $4 = 0, $6 = 0, $7 = 0;\n $2 = HEAP32[$0 + 4 >> 2] | 0;\n $3 = $0 + 8 | 0;\n while (1) {\n  $4 = HEAP32[$3 >> 2] | 0;\n  if (($4 | 0) == ($2 | 0)) break;\n  $6 = $4 + -16 | 0;\n  HEAP32[$3 >> 2] = $6;\n  __ZNSt3__213__vector_baseINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEED2Ev($6);\n }\n $7 = HEAP32[$0 >> 2] | 0;\n if ($7 | 0) __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS3_INS0_11string_pairENS1_IS4_Lj4096EEEEENS1_IS6_Lj4096EEEEELj4096EE10deallocateEPS8_j(HEAP32[$0 + 16 >> 2] | 0, $7, (HEAP32[$0 + 12 >> 2] | 0) - $7 >> 4);\n return;\n}\n\nfunction _getMatrixCodeType($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $2 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = sp + 4 | 0;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$0 = -1; else {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  _arGetMatrixCodeType(HEAP32[$6 >> 2] | 0, $2) | 0;\n  $$0 = HEAP32[$2 >> 2] | 0;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_112parse_numberEPKcS2_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$pn = 0, $$017 = 0, $$2 = 0, $7 = 0, $spec$select = 0;\n L1 : do if (($0 | 0) == ($1 | 0)) $$2 = $0; else {\n  $spec$select = (HEAP8[$0 >> 0] | 0) == 110 ? $0 + 1 | 0 : $0;\n  if (($spec$select | 0) == ($1 | 0)) $$2 = $0; else {\n   $7 = HEAP8[$spec$select >> 0] | 0;\n   if ($7 << 24 >> 24 == 48) {\n    $$2 = $spec$select + 1 | 0;\n    break;\n   }\n   if (($7 + -49 & 255) < 9) {\n    $$0$pn = $spec$select;\n    while (1) {\n     $$017 = $$0$pn + 1 | 0;\n     if (($$017 | 0) == ($1 | 0)) {\n      $$2 = $1;\n      break L1;\n     }\n     if (((HEAP8[$$017 >> 0] | 0) + -48 | 0) >>> 0 < 10) $$0$pn = $$017; else {\n      $$2 = $$017;\n      break;\n     }\n    }\n   } else $$2 = $0;\n  }\n } while (0);\n return $$2 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcj($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $10 = 0, $3 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n if ($2 >>> 0 > 4294967279) __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv($0);\n if ($2 >>> 0 < 11) {\n  HEAP8[$0 + 11 >> 0] = $2;\n  $$0 = $0;\n } else {\n  $9 = $2 + 16 & -16;\n  $10 = __Znwj($9) | 0;\n  HEAP32[$0 >> 2] = $10;\n  HEAP32[$0 + 8 >> 2] = $9 | -2147483648;\n  HEAP32[$0 + 4 >> 2] = $2;\n  $$0 = $10;\n }\n __ZNSt3__211char_traitsIcE4copyEPcPKcj($$0, $1, $2) | 0;\n HEAP8[$3 >> 0] = 0;\n __ZNSt3__211char_traitsIcE6assignERcRKc($$0 + $2 | 0, $3);\n STACKTOP = sp;\n return;\n}\n\nfunction _getDebugMode($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $2 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = sp + 4 | 0;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$0 = 0; else {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  _arGetDebugMode(HEAP32[$6 >> 2] | 0, $2) | 0;\n  $$0 = HEAP32[$2 >> 2] | 0;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE21__construct_node_hashIRKNS_21piecewise_construct_tEJNS_5tupleIJRKiEEENSJ_IJEEEEEENS_10unique_ptrINS_11__hash_nodeIS3_PvEENS_22__hash_node_destructorINSC_ISR_EEEEEEjOT_DpOT0_($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $13 = 0, $7 = 0;\n $7 = __Znwj(416) | 0;\n HEAP32[$0 >> 2] = $7;\n HEAP32[$0 + 4 >> 2] = $1 + 8;\n HEAP32[$7 + 8 >> 2] = HEAP32[HEAP32[$4 >> 2] >> 2];\n $13 = $7 + 16 | 0;\n _memset($13 | 0, 0, 400) | 0;\n __ZN12arControllerC2Ev($13);\n HEAP8[$0 + 8 >> 0] = 1;\n HEAP32[$7 + 4 >> 2] = $2;\n HEAP32[$7 >> 2] = 0;\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_121parse_destructor_nameINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$019 = 0, $$1 = 0, $10 = 0, $4 = 0;\n if (($0 | 0) == ($1 | 0)) $$1 = $0; else {\n  $4 = __ZN10__cxxabiv112_GLOBAL__N_121parse_unresolved_typeINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n  if (($4 | 0) == ($0 | 0)) $$019 = __ZN10__cxxabiv112_GLOBAL__N_115parse_simple_idINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0; else $$019 = $4;\n  if (($$019 | 0) == ($0 | 0)) $$1 = $0; else {\n   $10 = HEAP32[$2 + 4 >> 2] | 0;\n   if ((HEAP32[$2 >> 2] | 0) == ($10 | 0)) $$1 = $0; else {\n    __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($10 + -24 | 0, 0, 15189) | 0;\n    $$1 = $$019;\n   }\n  }\n }\n return $$1 | 0;\n}\n\nfunction __ZN10emscripten8functionIiJiNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJiiiiEEEPKcv() | 0, 12, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10emscripten8functionIiJNSt3__212basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJiiiEEEPKcv() | 0, 11, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction _cat($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $10 = 0, $3 = 0, $4 = 0, $6 = 0, $7 = 0, $8 = 0;\n do if (!$0) {\n  $3 = ___errno_location() | 0;\n  HEAP32[$3 >> 2] = 22;\n  $$0 = 0;\n } else {\n  $4 = _fopen($0, 5635) | 0;\n  if (!$4) $$0 = 0; else {\n   _fseek($4, 0, 2) | 0;\n   $6 = _ftell($4) | 0;\n   _fseek($4, 0, 0) | 0;\n   $7 = $6 + 1 | 0;\n   $8 = _malloc($7) | 0;\n   if (!$8) {\n    _fclose($4) | 0;\n    $10 = ___errno_location() | 0;\n    HEAP32[$10 >> 2] = 12;\n    $$0 = 0;\n    break;\n   }\n   if (!(_fread($8, $6, 1, $4) | 0)) {\n    _free($8);\n    _fclose($4) | 0;\n    $$0 = 0;\n    break;\n   }\n   HEAP8[$8 + $6 >> 0] = 0;\n   _fclose($4) | 0;\n   if (!$1) $$0 = $8; else {\n    HEAP32[$1 >> 2] = $7;\n    $$0 = $8;\n   }\n  }\n } while (0);\n return $$0 | 0;\n}\n\nfunction _arMatrixDup($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$021 = 0, $$022 = 0, $13 = 0, $16 = 0, $3 = 0, $8 = 0;\n $3 = HEAP32[$0 + 4 >> 2] | 0;\n L1 : do if (($3 | 0) == (HEAP32[$1 + 4 >> 2] | 0)) {\n  $8 = HEAP32[$0 + 8 >> 2] | 0;\n  if (($8 | 0) == (HEAP32[$1 + 8 >> 2] | 0)) {\n   $$021 = 0;\n   while (1) {\n    if (($$021 | 0) >= ($3 | 0)) {\n     $$022 = 0;\n     break L1;\n    }\n    $13 = Math_imul($$021, $8) | 0;\n    $$0 = 0;\n    while (1) {\n     if (($$0 | 0) >= ($8 | 0)) break;\n     $16 = $$0 + $13 | 0;\n     HEAPF64[(HEAP32[$0 >> 2] | 0) + ($16 << 3) >> 3] = +HEAPF64[(HEAP32[$1 >> 2] | 0) + ($16 << 3) >> 3];\n     $$0 = $$0 + 1 | 0;\n    }\n    $$021 = $$021 + 1 | 0;\n   }\n  } else $$022 = -1;\n } else $$022 = -1; while (0);\n return $$022 | 0;\n}\n\nfunction _getMultiMarkerCount($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$0 = -1; else {\n  $4 = __ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0;\n  $$0 = (HEAP32[$4 + 252 >> 2] | 0) - (HEAP32[$4 + 248 >> 2] | 0) >> 3;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _getMarkerNum($0) {\n $0 = $0 | 0;\n var $$0$in = 0, $1 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$0$in = 1956; else {\n  $5 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  $$0$in = (HEAP32[$5 >> 2] | 0) + 44 | 0;\n }\n STACKTOP = sp;\n return HEAP32[$$0$in >> 2] | 0;\n}\n\nfunction __ZNSt3__213__vector_baseINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEED2Ev($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $1 = 0, $3 = 0, $6 = 0, $8 = 0;\n $1 = HEAP32[$0 >> 2] | 0;\n if ($1 | 0) {\n  $3 = $0 + 4 | 0;\n  $$0$i$i = HEAP32[$3 >> 2] | 0;\n  while (1) {\n   if (($$0$i$i | 0) == ($1 | 0)) break;\n   $6 = $$0$i$i + -16 | 0;\n   __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($6);\n   $$0$i$i = $6;\n  }\n  HEAP32[$3 >> 2] = $1;\n  $8 = HEAP32[$0 >> 2] | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EE10deallocateEPS6_j($0 + 12 | 0, $8, (HEAP32[$0 + 8 >> 2] | 0) - $8 >> 4);\n }\n return;\n}\n\nfunction __ZN10emscripten8internal7InvokerIiJNSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEE6invokeEPFiS8_EPNS0_11BindingTypeIS8_EUt_E($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp + 12 | 0;\n $3 = sp;\n __ZN10emscripten8internal11BindingTypeINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE12fromWireTypeEPNS9_Ut_E($3, $1);\n $4 = FUNCTION_TABLE_ii[$0 & 31]($3) | 0;\n HEAP32[$2 >> 2] = $4;\n $5 = __ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($2) | 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev($3);\n STACKTOP = sp;\n return $5 | 0;\n}\n\nfunction _getProcessingImage($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$0 = 0; else {\n  $5 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 216 | 0;\n  $$0 = HEAP32[(HEAP32[$5 >> 2] | 0) + 4834148 >> 2] | 0;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction ___fflush_unlocked($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $3 = 0, label = 0;\n $1 = $0 + 20 | 0;\n $3 = $0 + 28 | 0;\n if ((HEAP32[$1 >> 2] | 0) >>> 0 > (HEAP32[$3 >> 2] | 0) >>> 0) {\n  FUNCTION_TABLE_iiii[HEAP32[$0 + 36 >> 2] & 15]($0, 0, 0) | 0;\n  if (!(HEAP32[$1 >> 2] | 0)) $$0 = -1; else label = 3;\n } else label = 3;\n if ((label | 0) == 3) {\n  $10 = $0 + 4 | 0;\n  $11 = HEAP32[$10 >> 2] | 0;\n  $12 = $0 + 8 | 0;\n  $13 = HEAP32[$12 >> 2] | 0;\n  if ($11 >>> 0 < $13 >>> 0) FUNCTION_TABLE_iiii[HEAP32[$0 + 40 >> 2] & 15]($0, $11 - $13 | 0, 1) | 0;\n  HEAP32[$0 + 16 >> 2] = 0;\n  HEAP32[$3 >> 2] = 0;\n  HEAP32[$1 >> 2] = 0;\n  HEAP32[$12 >> 2] = 0;\n  HEAP32[$10 >> 2] = 0;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction _arPattLoad($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $2 = 0, $4 = 0, $6 = 0, $7 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer1 = sp + 8 | 0;\n $vararg_buffer = sp;\n $2 = _cat($1, 0) | 0;\n if (!$2) {\n  HEAP32[$vararg_buffer >> 2] = $1;\n  _arLog(0, 3, 4333, $vararg_buffer);\n  $4 = ___errno_location() | 0;\n  $6 = _strerror(HEAP32[$4 >> 2] | 0) | 0;\n  HEAP32[$vararg_buffer1 >> 2] = 19061;\n  HEAP32[$vararg_buffer1 + 4 >> 2] = $6;\n  _arLog(0, 3, 4941, $vararg_buffer1);\n  $$0 = -1;\n } else {\n  $7 = _arPattLoadFromBuffer($0, $2) | 0;\n  _free($2);\n  $$0 = $7;\n }\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _arUtilMatMul($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$023 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0;\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) == 3) break;\n  $3 = $0 + ($$0 << 5) | 0;\n  $4 = $0 + ($$0 << 5) + 8 | 0;\n  $5 = $0 + ($$0 << 5) + 16 | 0;\n  $$023 = 0;\n  while (1) {\n   if (($$023 | 0) == 4) break;\n   HEAPF64[$2 + ($$0 << 5) + ($$023 << 3) >> 3] = +HEAPF64[$3 >> 3] * +HEAPF64[$1 + ($$023 << 3) >> 3] + +HEAPF64[$4 >> 3] * +HEAPF64[$1 + 32 + ($$023 << 3) >> 3] + +HEAPF64[$5 >> 3] * +HEAPF64[$1 + 64 + ($$023 << 3) >> 3];\n   $$023 = $$023 + 1 | 0;\n  }\n  $24 = $2 + ($$0 << 5) + 24 | 0;\n  HEAPF64[$24 >> 3] = +HEAPF64[$0 + ($$0 << 5) + 24 >> 3] + +HEAPF64[$24 >> 3];\n  $$0 = $$0 + 1 | 0;\n }\n return 0;\n}\n\nfunction _setMatrixCodeType($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = $0;\n if (__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0) {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 216 | 0;\n  _arSetMatrixCodeType(HEAP32[$6 >> 2] | 0, $1) | 0;\n }\n STACKTOP = sp;\n return;\n}\n\nfunction __ZNSt3__212__hash_tableINS_17__hash_value_typeIi7ARParamEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE21__construct_node_hashIRKNS_21piecewise_construct_tEJNS_5tupleIJRKiEEENSJ_IJEEEEEENS_10unique_ptrINS_11__hash_nodeIS3_PvEENS_22__hash_node_destructorINSC_ISR_EEEEEEjOT_DpOT0_($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $7 = 0;\n $7 = __Znwj(200) | 0;\n HEAP32[$0 >> 2] = $7;\n HEAP32[$0 + 4 >> 2] = $1 + 8;\n HEAP32[$7 + 8 >> 2] = HEAP32[HEAP32[$4 >> 2] >> 2];\n _memset($7 + 16 | 0, 0, 184) | 0;\n HEAP8[$0 + 8 >> 0] = 1;\n HEAP32[$7 + 4 >> 2] = $2;\n HEAP32[$7 >> 2] = 0;\n return;\n}\n\nfunction _arSetDebugMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $13 = 0, $6 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n do if (!$0) $$0 = -1; else if ((HEAP32[$0 >> 2] | 0) == ($1 | 0)) $$0 = 0; else {\n  HEAP32[$0 >> 2] = $1;\n  if (!$1) {\n   $6 = $0 + 4834148 | 0;\n   _free(HEAP32[$6 >> 2] | 0);\n   HEAP32[$6 >> 2] = 0;\n   $$0 = 0;\n   break;\n  }\n  $13 = _malloc(Math_imul(HEAP32[$0 + 40 >> 2] | 0, HEAP32[$0 + 36 >> 2] | 0) | 0) | 0;\n  HEAP32[$0 + 4834148 >> 2] = $13;\n  if (!$13) {\n   _arLog(0, 3, 5051, $vararg_buffer);\n   _exit(1);\n  } else $$0 = 0;\n } while (0);\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _getProjectionNearPlane($0) {\n $0 = $0 | 0;\n var $$0 = 0.0, $1 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$0 = -1.0; else {\n  $5 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 232 | 0;\n  $$0 = +HEAPF64[$5 >> 3];\n }\n STACKTOP = sp;\n return +$$0;\n}\n\nfunction _getProjectionFarPlane($0) {\n $0 = $0 | 0;\n var $$0 = 0.0, $1 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n HEAP32[$1 >> 2] = $0;\n if (!(__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $1) | 0)) $$0 = -1.0; else {\n  $5 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $1) | 0) + 240 | 0;\n  $$0 = +HEAPF64[$5 >> 3];\n }\n STACKTOP = sp;\n return +$$0;\n}\n\nfunction _CENTER($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$025 = 0, $$026 = 0, $$027 = 0, $$028 = 0, $$1 = 0, $3 = 0, $5 = 0;\n $3 = HEAP32[$0 + 4 >> 2] | 0;\n $5 = HEAP32[$0 + 8 >> 2] | 0;\n L1 : do if ((HEAP32[$1 + 4 >> 2] | 0) == ($5 | 0)) {\n  $$025 = 0;\n  $$027 = HEAP32[$0 >> 2] | 0;\n  while (1) {\n   if (($$025 | 0) >= ($3 | 0)) {\n    $$026 = 0;\n    break L1;\n   }\n   $$0 = 0;\n   $$028 = HEAP32[$1 >> 2] | 0;\n   $$1 = $$027;\n   while (1) {\n    if (($$0 | 0) >= ($5 | 0)) break;\n    HEAPF64[$$1 >> 3] = +HEAPF64[$$1 >> 3] - +HEAPF64[$$028 >> 3];\n    $$0 = $$0 + 1 | 0;\n    $$028 = $$028 + 8 | 0;\n    $$1 = $$1 + 8 | 0;\n   }\n   $$025 = $$025 + 1 | 0;\n   $$027 = $$1;\n  }\n } else $$026 = -1; while (0);\n return $$026 | 0;\n}\n\nfunction __ZNSt3__214__split_bufferINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEERNS5_IS7_Lj4096EEEED2Ev($0) {\n $0 = $0 | 0;\n var $2 = 0, $3 = 0, $4 = 0, $6 = 0, $7 = 0;\n $2 = HEAP32[$0 + 4 >> 2] | 0;\n $3 = $0 + 8 | 0;\n while (1) {\n  $4 = HEAP32[$3 >> 2] | 0;\n  if (($4 | 0) == ($2 | 0)) break;\n  $6 = $4 + -16 | 0;\n  HEAP32[$3 >> 2] = $6;\n  __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($6);\n }\n $7 = HEAP32[$0 >> 2] | 0;\n if ($7 | 0) __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EE10deallocateEPS6_j(HEAP32[$0 + 16 >> 2] | 0, $7, (HEAP32[$0 + 12 >> 2] | 0) - $7 >> 4);\n return;\n}\n\nfunction _icpGetU_from_X_by_MatX2U($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $21 = 0.0, $3 = 0.0, $36 = 0.0, $5 = 0.0, $7 = 0.0;\n $3 = +HEAPF64[$2 >> 3];\n $5 = +HEAPF64[$2 + 8 >> 3];\n $7 = +HEAPF64[$2 + 16 >> 3];\n $21 = +HEAPF64[$1 + 88 >> 3] + ($3 * +HEAPF64[$1 + 64 >> 3] + $5 * +HEAPF64[$1 + 72 >> 3] + $7 * +HEAPF64[$1 + 80 >> 3]);\n if ($21 == 0.0) $$0 = -1; else {\n  $36 = +HEAPF64[$1 + 56 >> 3] + ($3 * +HEAPF64[$1 + 32 >> 3] + $5 * +HEAPF64[$1 + 40 >> 3] + $7 * +HEAPF64[$1 + 48 >> 3]);\n  HEAPF64[$0 >> 3] = (+HEAPF64[$1 + 24 >> 3] + ($3 * +HEAPF64[$1 >> 3] + $5 * +HEAPF64[$1 + 8 >> 3] + $7 * +HEAPF64[$1 + 16 >> 3])) / $21;\n  HEAPF64[$0 + 8 >> 3] = $36 / $21;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction __ZN10emscripten8internal7InvokerIiJiiiEE6invokeEPFiiiiEiii($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $4 = sp;\n $5 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($1) | 0;\n $6 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($2) | 0;\n $7 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($3) | 0;\n $8 = FUNCTION_TABLE_iiii[$0 & 15]($5, $6, $7) | 0;\n HEAP32[$4 >> 2] = $8;\n $9 = __ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($4) | 0;\n STACKTOP = sp;\n return $9 | 0;\n}\n\nfunction _pad_676($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0$lcssa = 0, $$011 = 0, $14 = 0, $5 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 256 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(256);\n $5 = sp;\n if (($2 | 0) > ($3 | 0) & ($4 & 73728 | 0) == 0) {\n  $9 = $2 - $3 | 0;\n  _memset($5 | 0, $1 << 24 >> 24 | 0, ($9 >>> 0 < 256 ? $9 : 256) | 0) | 0;\n  if ($9 >>> 0 > 255) {\n   $14 = $2 - $3 | 0;\n   $$011 = $9;\n   do {\n    _out_670($0, $5, 256);\n    $$011 = $$011 + -256 | 0;\n   } while ($$011 >>> 0 > 255);\n   $$0$lcssa = $14 & 255;\n  } else $$0$lcssa = $9;\n  _out_670($0, $5, $$0$lcssa);\n }\n STACKTOP = sp;\n return;\n}\n\nfunction _setProjectionNearPlane($0, $1) {\n $0 = $0 | 0;\n $1 = +$1;\n var $2 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = $0;\n if (__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0) {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 232 | 0;\n  HEAPF64[$6 >> 3] = $1;\n }\n STACKTOP = sp;\n return;\n}\n\nfunction _setProjectionFarPlane($0, $1) {\n $0 = $0 | 0;\n $1 = +$1;\n var $2 = 0, $6 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = $0;\n if (__ZNSt3__212__hash_tableINS_17__hash_value_typeIi12arControllerEENS_22__unordered_map_hasherIiS3_NS_4hashIiEELb1EEENS_21__unordered_map_equalIiS3_NS_8equal_toIiEELb1EEENS_9allocatorIS3_EEE4findIiEENS_15__hash_iteratorIPNS_11__hash_nodeIS3_PvEEEERKT_(17356, $2) | 0) {\n  $6 = (__ZNSt3__213unordered_mapIi12arControllerNS_4hashIiEENS_8equal_toIiEENS_9allocatorINS_4pairIKiS1_EEEEEixERS8_(17356, $2) | 0) + 240 | 0;\n  HEAPF64[$6 >> 3] = $1;\n }\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2EOS1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $$0$i$i3 = 0, $4 = 0, $5 = 0;\n HEAP32[$0 >> 2] = HEAP32[$1 >> 2];\n HEAP32[$0 + 4 >> 2] = HEAP32[$1 + 4 >> 2];\n HEAP32[$0 + 8 >> 2] = HEAP32[$1 + 8 >> 2];\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n $4 = $0 + 12 | 0;\n $5 = $1 + 12 | 0;\n HEAP32[$4 >> 2] = HEAP32[$5 >> 2];\n HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 4 >> 2];\n HEAP32[$4 + 8 >> 2] = HEAP32[$5 + 8 >> 2];\n $$0$i$i3 = 0;\n while (1) {\n  if (($$0$i$i3 | 0) == 3) break;\n  HEAP32[$5 + ($$0$i$i3 << 2) >> 2] = 0;\n  $$0$i$i3 = $$0$i$i3 + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ENSt3__212basic_stringIcNS2_11char_traitsIcEENS0_12malloc_allocIcEEEE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $$0$i$i1 = 0, $4 = 0;\n HEAP32[$0 >> 2] = HEAP32[$1 >> 2];\n HEAP32[$0 + 4 >> 2] = HEAP32[$1 + 4 >> 2];\n HEAP32[$0 + 8 >> 2] = HEAP32[$1 + 8 >> 2];\n $$0$i$i1 = 0;\n while (1) {\n  if (($$0$i$i1 | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i1 << 2) >> 2] = 0;\n  $$0$i$i1 = $$0$i$i1 + 1 | 0;\n }\n $4 = $0 + 12 | 0;\n HEAP32[$4 >> 2] = 0;\n HEAP32[$4 + 4 >> 2] = 0;\n HEAP32[$4 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$4 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction _realloc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$1 = 0, $11 = 0, $14 = 0, $17 = 0, $22 = 0, $5 = 0;\n if (!$0) {\n  $$1 = _malloc($1) | 0;\n  return $$1 | 0;\n }\n if ($1 >>> 0 > 4294967231) {\n  $5 = ___errno_location() | 0;\n  HEAP32[$5 >> 2] = 12;\n  $$1 = 0;\n  return $$1 | 0;\n }\n $11 = _try_realloc_chunk($0 + -8 | 0, $1 >>> 0 < 11 ? 16 : $1 + 11 & -8) | 0;\n if ($11 | 0) {\n  $$1 = $11 + 8 | 0;\n  return $$1 | 0;\n }\n $14 = _malloc($1) | 0;\n if (!$14) {\n  $$1 = 0;\n  return $$1 | 0;\n }\n $17 = HEAP32[$0 + -4 >> 2] | 0;\n $22 = ($17 & -8) - (($17 & 3 | 0) == 0 ? 8 : 4) | 0;\n _memcpy($14 | 0, $0 | 0, ($22 >>> 0 < $1 >>> 0 ? $22 : $1) | 0) | 0;\n _free($0);\n $$1 = $14;\n return $$1 | 0;\n}\n\nfunction __ZNKSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7compareEjjPKcj($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $11 = 0, $12 = 0, $13 = 0, $14 = 0, $4 = 0, $5 = 0;\n $4 = HEAP8[$0 + 11 >> 0] | 0;\n $5 = $4 << 24 >> 24 < 0;\n if ($5) $12 = HEAP32[$0 + 4 >> 2] | 0; else $12 = $4 & 255;\n if (($2 | 0) == -1) __ZNKSt3__221__basic_string_commonILb1EE20__throw_out_of_rangeEv($0);\n if ($5) $13 = HEAP32[$0 >> 2] | 0; else $13 = $0;\n $11 = $12 >>> 0 > $2 >>> 0;\n $14 = __ZNSt3__211char_traitsIcE7compareEPKcS3_j($13, $1, $11 ? $2 : $12) | 0;\n if (!$14) return ($12 >>> 0 < $2 >>> 0 ? -1 : $11 & 1) | 0; else return $14 | 0;\n return 0;\n}\n\nfunction ___toread($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $15 = 0, $23 = 0, $3 = 0, $7 = 0, $9 = 0;\n $1 = $0 + 74 | 0;\n $3 = HEAP8[$1 >> 0] | 0;\n HEAP8[$1 >> 0] = $3 + 255 | $3;\n $7 = $0 + 20 | 0;\n $9 = $0 + 28 | 0;\n if ((HEAP32[$7 >> 2] | 0) >>> 0 > (HEAP32[$9 >> 2] | 0) >>> 0) FUNCTION_TABLE_iiii[HEAP32[$0 + 36 >> 2] & 15]($0, 0, 0) | 0;\n HEAP32[$0 + 16 >> 2] = 0;\n HEAP32[$9 >> 2] = 0;\n HEAP32[$7 >> 2] = 0;\n $15 = HEAP32[$0 >> 2] | 0;\n if (!($15 & 4)) {\n  $23 = (HEAP32[$0 + 44 >> 2] | 0) + (HEAP32[$0 + 48 >> 2] | 0) | 0;\n  HEAP32[$0 + 8 >> 2] = $23;\n  HEAP32[$0 + 4 >> 2] = $23;\n  $$0 = $15 << 27 >> 31;\n } else {\n  HEAP32[$0 >> 2] = $15 | 32;\n  $$0 = -1;\n }\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pair9move_fullEv($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i$i = 0, $2 = 0, $4 = 0, $5 = 0;\n $2 = $1 + 12 | 0;\n $4 = HEAP8[$2 + 11 >> 0] | 0;\n $5 = $4 << 24 >> 24 < 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($1, $5 ? HEAP32[$2 >> 2] | 0 : $2, $5 ? HEAP32[$1 + 16 >> 2] | 0 : $4 & 255) | 0;\n HEAP32[$0 >> 2] = HEAP32[$1 >> 2];\n HEAP32[$0 + 4 >> 2] = HEAP32[$1 + 4 >> 2];\n HEAP32[$0 + 8 >> 2] = HEAP32[$1 + 8 >> 2];\n $$0$i$i$i = 0;\n while (1) {\n  if (($$0$i$i$i | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i$i << 2) >> 2] = 0;\n  $$0$i$i$i = $$0$i$i$i + 1 | 0;\n }\n return;\n}\n\nfunction _arVecHousehold($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$020 = 0.0, $$1 = 0.0, $11 = 0.0, $13 = 0, $15 = 0, $2 = 0.0, $4 = 0, $5 = 0.0, $8 = 0.0;\n $2 = +Math_sqrt(+(+_arVecInnerproduct($0, $0)));\n L1 : do if ($2 != 0.0) {\n  $4 = HEAP32[$0 >> 2] | 0;\n  $5 = +HEAPF64[$4 >> 3];\n  $$020 = $5 < 0.0 ? -$2 : $2;\n  $8 = $5 + $$020;\n  HEAPF64[$4 >> 3] = $8;\n  $11 = 1.0 / +Math_sqrt(+($$020 * $8));\n  $13 = HEAP32[$0 + 4 >> 2] | 0;\n  $$0 = 0;\n  while (1) {\n   if (($$0 | 0) >= ($13 | 0)) {\n    $$1 = $$020;\n    break L1;\n   }\n   $15 = $4 + ($$0 << 3) | 0;\n   HEAPF64[$15 >> 3] = $11 * +HEAPF64[$15 >> 3];\n   $$0 = $$0 + 1 | 0;\n  }\n } else $$1 = $2; while (0);\n return +-$$1;\n}\n\nfunction ___stdio_seek($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $10 = 0, $3 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $vararg_buffer = sp;\n $3 = sp + 20 | 0;\n HEAP32[$vararg_buffer >> 2] = HEAP32[$0 + 60 >> 2];\n HEAP32[$vararg_buffer + 4 >> 2] = 0;\n HEAP32[$vararg_buffer + 8 >> 2] = $1;\n HEAP32[$vararg_buffer + 12 >> 2] = $3;\n HEAP32[$vararg_buffer + 16 >> 2] = $2;\n if ((___syscall_ret(___syscall140(140, $vararg_buffer | 0) | 0) | 0) < 0) {\n  HEAP32[$3 >> 2] = -1;\n  $10 = -1;\n } else $10 = HEAP32[$3 >> 2] | 0;\n STACKTOP = sp;\n return $10 | 0;\n}\n\nfunction __ZNSt3__214__split_bufferINS_6vectorINS1_IN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEEERNS5_IS9_Lj4096EEEEC2EjjSB_($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $4 = 0, $8 = 0, $9 = 0;\n $4 = $0 + 12 | 0;\n HEAP32[$4 >> 2] = 0;\n HEAP32[$0 + 16 >> 2] = $3;\n if (!$1) $8 = 0; else $8 = __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS3_INS0_11string_pairENS1_IS4_Lj4096EEEEENS1_IS6_Lj4096EEEEELj4096EE8allocateEj($3, $1) | 0;\n HEAP32[$0 >> 2] = $8;\n $9 = $8 + ($2 << 4) | 0;\n HEAP32[$0 + 8 >> 2] = $9;\n HEAP32[$0 + 4 >> 2] = $9;\n HEAP32[$4 >> 2] = $8 + ($1 << 4);\n return;\n}\n\nfunction __ZNSt3__214__split_bufferI12multi_markerRNS_9allocatorIS1_EEEC2EjjS4_($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $11 = 0, $12 = 0, $4 = 0, $8 = 0;\n $4 = $0 + 12 | 0;\n HEAP32[$4 >> 2] = 0;\n HEAP32[$0 + 16 >> 2] = $3;\n do if (!$1) $11 = 0; else if ($1 >>> 0 > 536870911) {\n  $8 = ___cxa_allocate_exception(8) | 0;\n  __ZNSt11logic_errorC2EPKc($8, 7822);\n  HEAP32[$8 >> 2] = 3444;\n  ___cxa_throw($8 | 0, 272, 6);\n } else {\n  $11 = __Znwj($1 << 3) | 0;\n  break;\n } while (0);\n HEAP32[$0 >> 2] = $11;\n $12 = $11 + ($2 << 3) | 0;\n HEAP32[$0 + 8 >> 2] = $12;\n HEAP32[$0 + 4 >> 2] = $12;\n HEAP32[$4 >> 2] = $11 + ($1 << 3);\n return;\n}\n\nfunction _arParamObserv2IdealLTf($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = +$1;\n $2 = +$2;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $14 = 0, $17 = 0, $28 = 0, $9 = 0;\n $9 = (HEAP32[$0 + 16 >> 2] | 0) + ~~($1 + .5) | 0;\n $14 = (HEAP32[$0 + 20 >> 2] | 0) + ~~($2 + .5) | 0;\n if (($9 | 0) < 0) $$0 = -1; else {\n  $17 = HEAP32[$0 + 8 >> 2] | 0;\n  if (($14 | 0) < 0 | ($9 | 0) >= ($17 | 0)) $$0 = -1; else if (($14 | 0) < (HEAP32[$0 + 12 >> 2] | 0)) {\n   $28 = (HEAP32[$0 + 4 >> 2] | 0) + ((Math_imul($17, $14) | 0) + $9 << 1 << 2) | 0;\n   HEAP32[$3 >> 2] = HEAP32[$28 >> 2];\n   HEAP32[$4 >> 2] = HEAP32[$28 + 4 >> 2];\n   $$0 = 0;\n  } else $$0 = -1;\n }\n return $$0 | 0;\n}\n\nfunction _strtok($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$010 = 0, $10 = 0, $3 = 0, $6 = 0, label = 0;\n if (!$0) {\n  $3 = HEAP32[4496] | 0;\n  if (!$3) $$0 = 0; else {\n   $$010 = $3;\n   label = 3;\n  }\n } else {\n  $$010 = $0;\n  label = 3;\n }\n do if ((label | 0) == 3) {\n  $6 = $$010 + (_strspn($$010, $1) | 0) | 0;\n  if (!(HEAP8[$6 >> 0] | 0)) {\n   HEAP32[4496] = 0;\n   $$0 = 0;\n   break;\n  }\n  $10 = $6 + (_strcspn($6, $1) | 0) | 0;\n  HEAP32[4496] = $10;\n  if (!(HEAP8[$10 >> 0] | 0)) {\n   HEAP32[4496] = 0;\n   $$0 = $6;\n   break;\n  } else {\n   HEAP32[4496] = $10 + 1;\n   HEAP8[$10 >> 0] = 0;\n   $$0 = $6;\n   break;\n  }\n } while (0);\n return $$0 | 0;\n}\n\nfunction _arParamIdeal2ObservLTf($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = +$1;\n $2 = +$2;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $14 = 0, $17 = 0, $27 = 0, $9 = 0;\n $9 = (HEAP32[$0 + 16 >> 2] | 0) + ~~($1 + .5) | 0;\n $14 = (HEAP32[$0 + 20 >> 2] | 0) + ~~($2 + .5) | 0;\n if (($9 | 0) < 0) $$0 = -1; else {\n  $17 = HEAP32[$0 + 8 >> 2] | 0;\n  if (($14 | 0) < 0 | ($9 | 0) >= ($17 | 0)) $$0 = -1; else if (($14 | 0) < (HEAP32[$0 + 12 >> 2] | 0)) {\n   $27 = (HEAP32[$0 >> 2] | 0) + ((Math_imul($17, $14) | 0) + $9 << 1 << 2) | 0;\n   HEAP32[$3 >> 2] = HEAP32[$27 >> 2];\n   HEAP32[$4 >> 2] = HEAP32[$27 + 4 >> 2];\n   $$0 = 0;\n  } else $$0 = -1;\n }\n return $$0 | 0;\n}\n\nfunction __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $1 = 0, $3 = 0, $6 = 0, $8 = 0;\n $1 = HEAP32[$0 >> 2] | 0;\n if ($1 | 0) {\n  $3 = $0 + 4 | 0;\n  $$0$i$i = HEAP32[$3 >> 2] | 0;\n  while (1) {\n   if (($$0$i$i | 0) == ($1 | 0)) break;\n   $6 = $$0$i$i + -24 | 0;\n   __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($6);\n   $$0$i$i = $6;\n  }\n  HEAP32[$3 >> 2] = $1;\n  $8 = HEAP32[$0 >> 2] | 0;\n  __ZN10__cxxabiv112_GLOBAL__N_111short_allocINS0_11string_pairELj4096EE10deallocateEPS2_j($0 + 12 | 0, $8, ((HEAP32[$0 + 8 >> 2] | 0) - $8 | 0) / 24 | 0);\n }\n return;\n}\n\nfunction _strncat($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$lcssa = 0, $$01013 = 0, $$01112 = 0, $$014 = 0, $10 = 0, $4 = 0, $6 = 0;\n $4 = $0 + (_strlen($0) | 0) | 0;\n L1 : do if (!$2) $$0$lcssa = $4; else {\n  $$01013 = $2;\n  $$01112 = $1;\n  $$014 = $4;\n  while (1) {\n   $6 = HEAP8[$$01112 >> 0] | 0;\n   if (!($6 << 24 >> 24)) {\n    $$0$lcssa = $$014;\n    break L1;\n   }\n   $$01013 = $$01013 + -1 | 0;\n   $10 = $$014 + 1 | 0;\n   HEAP8[$$014 >> 0] = $6;\n   if (!$$01013) {\n    $$0$lcssa = $10;\n    break;\n   } else {\n    $$01112 = $$01112 + 1 | 0;\n    $$014 = $10;\n   }\n  }\n } while (0);\n HEAP8[$$0$lcssa >> 0] = 0;\n return $0 | 0;\n}\n\nfunction __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $10 = 0, $13 = 0, $4 = 0, $5 = 0;\n $4 = $1 + 16 | 0;\n $5 = HEAP32[$4 >> 2] | 0;\n do if (!$5) {\n  HEAP32[$4 >> 2] = $2;\n  HEAP32[$1 + 24 >> 2] = $3;\n  HEAP32[$1 + 36 >> 2] = 1;\n } else {\n  if (($5 | 0) != ($2 | 0)) {\n   $13 = $1 + 36 | 0;\n   HEAP32[$13 >> 2] = (HEAP32[$13 >> 2] | 0) + 1;\n   HEAP32[$1 + 24 >> 2] = 2;\n   HEAP8[$1 + 54 >> 0] = 1;\n   break;\n  }\n  $10 = $1 + 24 | 0;\n  if ((HEAP32[$10 >> 2] | 0) == 2) HEAP32[$10 >> 2] = $3;\n } while (0);\n return;\n}\n\nfunction _icpCreateHandle($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$022 = 0, $$023 = 0, $1 = 0;\n $1 = _malloc(136) | 0;\n if (!$1) $$023 = 0; else {\n  $$0 = 0;\n  while (1) {\n   if (($$0 | 0) == 3) break;\n   $$022 = 0;\n   while (1) {\n    if (($$022 | 0) == 4) break;\n    HEAPF64[$1 + ($$0 << 5) + ($$022 << 3) >> 3] = +HEAPF64[$0 + ($$0 << 5) + ($$022 << 3) >> 3];\n    $$022 = $$022 + 1 | 0;\n   }\n   $$0 = $$0 + 1 | 0;\n  }\n  HEAP32[$1 + 96 >> 2] = 10;\n  HEAPF64[$1 + 104 >> 3] = .10000000149011612;\n  HEAPF64[$1 + 112 >> 3] = .9900000095367432;\n  HEAPF64[$1 + 120 >> 3] = 4.0;\n  HEAPF64[$1 + 128 >> 3] = .5;\n  $$023 = $1;\n }\n return $$023 | 0;\n}\n\nfunction __ZNSt3__214__split_bufferIN10__cxxabiv112_GLOBAL__N_111string_pairERNS2_11short_allocIS3_Lj4096EEEED2Ev($0) {\n $0 = $0 | 0;\n var $2 = 0, $3 = 0, $4 = 0, $6 = 0, $7 = 0;\n $2 = HEAP32[$0 + 4 >> 2] | 0;\n $3 = $0 + 8 | 0;\n while (1) {\n  $4 = HEAP32[$3 >> 2] | 0;\n  if (($4 | 0) == ($2 | 0)) break;\n  $6 = $4 + -24 | 0;\n  HEAP32[$3 >> 2] = $6;\n  __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($6);\n }\n $7 = HEAP32[$0 >> 2] | 0;\n if ($7 | 0) __ZN10__cxxabiv112_GLOBAL__N_111short_allocINS0_11string_pairELj4096EE10deallocateEPS2_j(HEAP32[$0 + 16 >> 2] | 0, $7, ((HEAP32[$0 + 12 >> 2] | 0) - $7 | 0) / 24 | 0);\n return;\n}\nfunction __ZNSt3__214__split_bufferINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEERNS5_IS7_Lj4096EEEEC2EjjS9_($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $4 = 0, $8 = 0, $9 = 0;\n $4 = $0 + 12 | 0;\n HEAP32[$4 >> 2] = 0;\n HEAP32[$0 + 16 >> 2] = $3;\n if (!$1) $8 = 0; else $8 = __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EE8allocateEj($3, $1) | 0;\n HEAP32[$0 >> 2] = $8;\n $9 = $8 + ($2 << 4) | 0;\n HEAP32[$0 + 8 >> 2] = $9;\n HEAP32[$0 + 4 >> 2] = $9;\n HEAP32[$4 >> 2] = $8 + ($1 << 4);\n return;\n}\n\nfunction __ZN10emscripten8internal7InvokerIiJiiEE6invokeEPFiiiEii($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n $4 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($1) | 0;\n $5 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($2) | 0;\n $6 = FUNCTION_TABLE_iii[$0 & 15]($4, $5) | 0;\n HEAP32[$3 >> 2] = $6;\n $7 = __ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($3) | 0;\n STACKTOP = sp;\n return $7 | 0;\n}\n\nfunction _strcmp($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$011 = 0, $$0710 = 0, $$lcssa = 0, $$lcssa8 = 0, $2 = 0, $3 = 0, $8 = 0, $9 = 0;\n $2 = HEAP8[$0 >> 0] | 0;\n $3 = HEAP8[$1 >> 0] | 0;\n if ($2 << 24 >> 24 == 0 ? 1 : $2 << 24 >> 24 != $3 << 24 >> 24) {\n  $$lcssa = $3;\n  $$lcssa8 = $2;\n } else {\n  $$011 = $1;\n  $$0710 = $0;\n  do {\n   $$0710 = $$0710 + 1 | 0;\n   $$011 = $$011 + 1 | 0;\n   $8 = HEAP8[$$0710 >> 0] | 0;\n   $9 = HEAP8[$$011 >> 0] | 0;\n  } while (!($8 << 24 >> 24 == 0 ? 1 : $8 << 24 >> 24 != $9 << 24 >> 24));\n  $$lcssa = $9;\n  $$lcssa8 = $8;\n }\n return ($$lcssa8 & 255) - ($$lcssa & 255) | 0;\n}\n\nfunction ___stdout_write($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $14 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32);\n $vararg_buffer = sp;\n HEAP32[$0 + 36 >> 2] = 1;\n if (!(HEAP32[$0 >> 2] & 64)) {\n  HEAP32[$vararg_buffer >> 2] = HEAP32[$0 + 60 >> 2];\n  HEAP32[$vararg_buffer + 4 >> 2] = 21523;\n  HEAP32[$vararg_buffer + 8 >> 2] = sp + 16;\n  if (___syscall54(54, $vararg_buffer | 0) | 0) HEAP8[$0 + 75 >> 0] = -1;\n }\n $14 = ___stdio_write($0, $1, $2) | 0;\n STACKTOP = sp;\n return $14 | 0;\n}\n\nfunction __ZN10emscripten8functionIiJiiiEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiiiEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiiiEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJiiiiiEEEPKcv() | 0, 1, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction _sbrk(increment) {\n increment = increment | 0;\n var oldDynamicTop = 0, newDynamicTop = 0;\n oldDynamicTop = HEAP32[DYNAMICTOP_PTR >> 2] | 0;\n newDynamicTop = oldDynamicTop + increment | 0;\n if ((increment | 0) > 0 & (newDynamicTop | 0) < (oldDynamicTop | 0) | (newDynamicTop | 0) < 0) {\n  abortOnCannotGrowMemory() | 0;\n  ___setErrNo(12);\n  return -1;\n }\n HEAP32[DYNAMICTOP_PTR >> 2] = newDynamicTop;\n if ((newDynamicTop | 0) > (getTotalMemory() | 0)) if (!(enlargeMemory() | 0)) {\n  HEAP32[DYNAMICTOP_PTR >> 2] = oldDynamicTop;\n  ___setErrNo(12);\n  return -1;\n }\n return oldDynamicTop | 0;\n}\n\nfunction __ZN10emscripten8functionIiJiiEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiiEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiiEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJiiiiEEEPKcv() | 0, 13, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10emscripten8functionIvJiiEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJviiEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJviiEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJviiiEEEPKcv() | 0, 1, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10emscripten8functionIvJifEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvifEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvifEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJviifEEEPKcv() | 0, 2, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10emscripten8functionIvJidEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvidEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvidEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJviidEEEPKcv() | 0, 1, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10emscripten8functionIiJiEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJiiiEEEPKcv() | 0, 10, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10emscripten8functionIvJiEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJviEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJviEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJviiEEEPKcv() | 0, 7, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10emscripten8functionIdJiEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJdiEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJdiEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJdiiEEEPKcv() | 0, 1, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction __ZN10emscripten8functionIiJEJEEEvPKcPFT_DpT0_EDpT1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiEE8getCountEv($2) | 0;\n $4 = __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiEE8getTypesEv($2) | 0;\n __embind_register_function($0 | 0, $3 | 0, $4 | 0, __ZN10emscripten8internal19getGenericSignatureIJiiEEEPKcv() | 0, 16, $1 | 0);\n STACKTOP = sp;\n return;\n}\n\nfunction ___fmodeflags($0) {\n $0 = $0 | 0;\n var $$0 = 0, $$2 = 0, $$4 = 0, $2 = 0, $3 = 0, $6 = 0, $9 = 0, $spec$select = 0, $spec$select13 = 0;\n $2 = (_strchr($0, 43) | 0) == 0;\n $3 = HEAP8[$0 >> 0] | 0;\n $$0 = $2 ? $3 << 24 >> 24 != 114 & 1 : 2;\n $6 = (_strchr($0, 120) | 0) == 0;\n $spec$select = $6 ? $$0 : $$0 | 128;\n $9 = (_strchr($0, 101) | 0) == 0;\n $$2 = $9 ? $spec$select : $spec$select | 524288;\n $spec$select13 = $3 << 24 >> 24 == 114 ? $$2 : $$2 | 64;\n $$4 = $3 << 24 >> 24 == 119 ? $spec$select13 | 512 : $spec$select13;\n return ($3 << 24 >> 24 == 97 ? $$4 | 1024 : $$4) | 0;\n}\n\nfunction __ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $10 = 0;\n if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 + 8 >> 2] | 0, $5) | 0) __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i(0, $1, $2, $3, $4); else {\n  $10 = HEAP32[$0 + 8 >> 2] | 0;\n  FUNCTION_TABLE_viiiiii[HEAP32[(HEAP32[$10 >> 2] | 0) + 20 >> 2] & 3]($10, $1, $2, $3, $4, $5);\n }\n return;\n}\n\nfunction __ZL10loadMarkerPKcPiP8ARHandlePP12ARPattHandle($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $4 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $4 = _arPattLoad(HEAP32[$2 >> 2] | 0, $0) | 0;\n HEAP32[$1 >> 2] = $4;\n if (($4 | 0) < 0) {\n  HEAP32[$vararg_buffer >> 2] = $0;\n  _arLog(0, 3, 10012, $vararg_buffer);\n  _arPattDeleteHandle(HEAP32[$2 >> 2] | 0) | 0;\n  $$0 = 0;\n } else $$0 = 1;\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _memcmp($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$01318 = 0, $$01417 = 0, $$019 = 0, $14 = 0, $4 = 0, $5 = 0;\n L1 : do if (!$2) $14 = 0; else {\n  $$01318 = $0;\n  $$01417 = $2;\n  $$019 = $1;\n  while (1) {\n   $4 = HEAP8[$$01318 >> 0] | 0;\n   $5 = HEAP8[$$019 >> 0] | 0;\n   if ($4 << 24 >> 24 != $5 << 24 >> 24) break;\n   $$01417 = $$01417 + -1 | 0;\n   if (!$$01417) {\n    $14 = 0;\n    break L1;\n   } else {\n    $$01318 = $$01318 + 1 | 0;\n    $$019 = $$019 + 1 | 0;\n   }\n  }\n  $14 = ($4 & 255) - ($5 & 255) | 0;\n } while (0);\n return $14 | 0;\n}\n\nfunction _fwrite($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $11 = 0, $13 = 0, $15 = 0, $4 = 0, $phitmp = 0, $spec$select = 0;\n $4 = Math_imul($2, $1) | 0;\n $spec$select = ($1 | 0) == 0 ? 0 : $2;\n if ((HEAP32[$3 + 76 >> 2] | 0) > -1) {\n  $phitmp = (___lockfile($3) | 0) == 0;\n  $11 = ___fwritex($0, $4, $3) | 0;\n  if ($phitmp) $13 = $11; else {\n   ___unlockfile($3);\n   $13 = $11;\n  }\n } else $13 = ___fwritex($0, $4, $3) | 0;\n if (($13 | 0) == ($4 | 0)) $15 = $spec$select; else $15 = ($13 >>> 0) / ($1 >>> 0) | 0;\n return $15 | 0;\n}\n\nfunction __ZNSt3__214__split_bufferIN10__cxxabiv112_GLOBAL__N_111string_pairERNS2_11short_allocIS3_Lj4096EEEEC2EjjS6_($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $4 = 0, $8 = 0, $9 = 0;\n $4 = $0 + 12 | 0;\n HEAP32[$4 >> 2] = 0;\n HEAP32[$0 + 16 >> 2] = $3;\n if (!$1) $8 = 0; else $8 = __ZN10__cxxabiv112_GLOBAL__N_111short_allocINS0_11string_pairELj4096EE8allocateEj($3, $1) | 0;\n HEAP32[$0 >> 2] = $8;\n $9 = $8 + ($2 * 24 | 0) | 0;\n HEAP32[$0 + 8 >> 2] = $9;\n HEAP32[$0 + 4 >> 2] = $9;\n HEAP32[$4 >> 2] = $8 + ($1 * 24 | 0);\n return;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_jjRKS6_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $10 = 0, $4 = 0, $5 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n $4 = HEAP8[$1 + 11 >> 0] | 0;\n $5 = $4 << 24 >> 24 < 0;\n $10 = $5 ? HEAP32[$1 + 4 >> 2] | 0 : $4 & 255;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $5 ? HEAP32[$1 >> 2] | 0 : $1, $10 >>> 0 < $2 >>> 0 ? $10 : $2);\n return;\n}\n\nfunction _store_int_725($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $7 = 0;\n L1 : do if ($0 | 0) switch ($1 | 0) {\n case -2:\n  {\n   HEAP8[$0 >> 0] = $2;\n   break L1;\n   break;\n  }\n case -1:\n  {\n   HEAP16[$0 >> 1] = $2;\n   break L1;\n   break;\n  }\n case 0:\n  {\n   HEAP32[$0 >> 2] = $2;\n   break L1;\n   break;\n  }\n case 1:\n  {\n   HEAP32[$0 >> 2] = $2;\n   break L1;\n   break;\n  }\n case 3:\n  {\n   $7 = $0;\n   HEAP32[$7 >> 2] = $2;\n   HEAP32[$7 + 4 >> 2] = $3;\n   break L1;\n   break;\n  }\n default:\n  break L1;\n } while (0);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2Ev($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $$0$i$i1 = 0, $3 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$0 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n $3 = $0 + 12 | 0;\n HEAP32[$3 >> 2] = 0;\n HEAP32[$3 + 4 >> 2] = 0;\n HEAP32[$3 + 8 >> 2] = 0;\n $$0$i$i1 = 0;\n while (1) {\n  if (($$0$i$i1 | 0) == 3) break;\n  HEAP32[$3 + ($$0$i$i1 << 2) >> 2] = 0;\n  $$0$i$i1 = $$0$i$i1 + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj18EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 17);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj15EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 14);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj14EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 13);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj13EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 12);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj12EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 11);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj11EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 10);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n if ((HEAP8[$1 + 11 >> 0] | 0) < 0) __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, HEAP32[$1 >> 2] | 0, HEAP32[$1 + 4 >> 2] | 0); else {\n  HEAP32[$0 >> 2] = HEAP32[$1 >> 2];\n  HEAP32[$0 + 4 >> 2] = HEAP32[$1 + 4 >> 2];\n  HEAP32[$0 + 8 >> 2] = HEAP32[$1 + 8 >> 2];\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj10EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 9);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj9EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 8);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj6EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 5);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj5EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 4);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj4EEERAT__Kc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0$i$i = 0, $2 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, $1, 3);\n $2 = $0 + 12 | 0;\n HEAP32[$2 >> 2] = 0;\n HEAP32[$2 + 4 >> 2] = 0;\n HEAP32[$2 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$2 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEC2EjRKS3_RKS5_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $3 = 0;\n HEAP32[$0 >> 2] = 0;\n $3 = $0 + 4 | 0;\n HEAP32[$3 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n HEAP32[$0 + 12 >> 2] = HEAP32[$2 >> 2];\n __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE8allocateEj($0);\n __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_(HEAP32[$3 >> 2] | 0, $1);\n HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) + 24;\n return;\n}\n\nfunction _vsscanf($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $3 = 0, $8 = 0, dest = 0, sp = 0, stop = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 128 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(128);\n $3 = sp;\n dest = $3;\n stop = dest + 124 | 0;\n do {\n  HEAP32[dest >> 2] = 0;\n  dest = dest + 4 | 0;\n } while ((dest | 0) < (stop | 0));\n HEAP32[$3 + 32 >> 2] = 15;\n HEAP32[$3 + 44 >> 2] = $0;\n HEAP32[$3 + 76 >> 2] = -1;\n HEAP32[$3 + 84 >> 2] = $0;\n $8 = _vfscanf($3, $1, $2) | 0;\n STACKTOP = sp;\n return $8 | 0;\n}\n\nfunction _arImageProcLumaHist($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$013 = 0, $12 = 0, $8 = 0;\n L1 : do if (($0 | 0) != 0 & ($1 | 0) != 0) {\n  _memset($0 + 12 | 0, 0, 1024) | 0;\n  $8 = $1 + (Math_imul(HEAP32[$0 + 8 >> 2] | 0, HEAP32[$0 + 4 >> 2] | 0) | 0) | 0;\n  $$0 = $1;\n  while (1) {\n   if ($$0 >>> 0 >= $8 >>> 0) {\n    $$013 = 0;\n    break L1;\n   }\n   $12 = $0 + 12 + ((HEAPU8[$$0 >> 0] | 0) << 2) | 0;\n   HEAP32[$12 >> 2] = (HEAP32[$12 >> 2] | 0) + 1;\n   $$0 = $$0 + 1 | 0;\n  }\n } else $$013 = -1; while (0);\n return $$013 | 0;\n}\n\nfunction __ZNSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE8allocateEj($0) {\n $0 = $0 | 0;\n var $4 = 0;\n if (!(__ZNKSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE8max_sizeEv($0) | 0)) __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0); else {\n  $4 = __ZN10__cxxabiv112_GLOBAL__N_111short_allocINS0_11string_pairELj4096EE8allocateEj($0 + 12 | 0, 1) | 0;\n  HEAP32[$0 + 4 >> 2] = $4;\n  HEAP32[$0 >> 2] = $4;\n  HEAP32[$0 + 8 >> 2] = $4 + 24;\n  return;\n }\n}\n\nfunction __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n var $$0 = 0, $14 = 0, $7 = 0, $8 = 0;\n $7 = HEAP32[$0 + 4 >> 2] | 0;\n $8 = $7 >> 8;\n if (!($7 & 1)) $$0 = $8; else $$0 = HEAP32[(HEAP32[$3 >> 2] | 0) + $8 >> 2] | 0;\n $14 = HEAP32[$0 >> 2] | 0;\n FUNCTION_TABLE_viiiiii[HEAP32[(HEAP32[$14 >> 2] | 0) + 20 >> 2] & 3]($14, $1, $2, $3 + $$0 | 0, ($7 & 2 | 0) == 0 ? 2 : $4, $5);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj22EEERAT__Kc($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $1 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 16510, 21);\n $1 = $0 + 12 | 0;\n HEAP32[$1 >> 2] = 0;\n HEAP32[$1 + 4 >> 2] = 0;\n HEAP32[$1 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj19EEERAT__Kc($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $1 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 16731, 18);\n $1 = $0 + 12 | 0;\n HEAP32[$1 >> 2] = 0;\n HEAP32[$1 + 4 >> 2] = 0;\n HEAP32[$1 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj16EEERAT__Kc($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $1 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 15904, 15);\n $1 = $0 + 12 | 0;\n HEAP32[$1 >> 2] = 0;\n HEAP32[$1 + 4 >> 2] = 0;\n HEAP32[$1 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj8EEERAT__Kc($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $1 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 16311, 7);\n $1 = $0 + 12 | 0;\n HEAP32[$1 >> 2] = 0;\n HEAP32[$1 + 4 >> 2] = 0;\n HEAP32[$1 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj7EEERAT__Kc($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $1 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 16724, 6);\n $1 = $0 + 12 | 0;\n HEAP32[$1 >> 2] = 0;\n HEAP32[$1 + 4 >> 2] = 0;\n HEAP32[$1 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ILj3EEERAT__Kc($0) {\n $0 = $0 | 0;\n var $$0$i$i = 0, $1 = 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6__initEPKcj($0, 16535, 2);\n $1 = $0 + 12 | 0;\n HEAP32[$1 >> 2] = 0;\n HEAP32[$1 + 4 >> 2] = 0;\n HEAP32[$1 + 8 >> 2] = 0;\n $$0$i$i = 0;\n while (1) {\n  if (($$0$i$i | 0) == 3) break;\n  HEAP32[$1 + ($$0$i$i << 2) >> 2] = 0;\n  $$0$i$i = $$0$i$i + 1 | 0;\n }\n return;\n}\n\nfunction _fmt_x($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$05$lcssa = 0, $$056 = 0, $14 = 0, $15 = 0, $8 = 0;\n if (($0 | 0) == 0 & ($1 | 0) == 0) $$05$lcssa = $2; else {\n  $$056 = $2;\n  $15 = $1;\n  $8 = $0;\n  while (1) {\n   $14 = $$056 + -1 | 0;\n   HEAP8[$14 >> 0] = HEAPU8[12554 + ($8 & 15) >> 0] | 0 | $3;\n   $8 = _bitshift64Lshr($8 | 0, $15 | 0, 4) | 0;\n   $15 = tempRet0;\n   if (($8 | 0) == 0 & ($15 | 0) == 0) {\n    $$05$lcssa = $14;\n    break;\n   } else $$056 = $14;\n  }\n }\n return $$05$lcssa | 0;\n}\n\nfunction ___string_read($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$027 = 0, $14 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $spec$select = 0;\n $3 = $0 + 84 | 0;\n $4 = HEAP32[$3 >> 2] | 0;\n $5 = $2 + 256 | 0;\n $6 = _memchr($4, 0, $5) | 0;\n $$027 = ($6 | 0) == 0 ? $5 : $6 - $4 | 0;\n $spec$select = $$027 >>> 0 < $2 >>> 0 ? $$027 : $2;\n _memcpy($1 | 0, $4 | 0, $spec$select | 0) | 0;\n HEAP32[$0 + 4 >> 2] = $4 + $spec$select;\n $14 = $4 + $$027 | 0;\n HEAP32[$0 + 8 >> 2] = $14;\n HEAP32[$3 >> 2] = $14;\n return $spec$select | 0;\n}\n\nfunction ___muldi3($a$0, $a$1, $b$0, $b$1) {\n $a$0 = $a$0 | 0;\n $a$1 = $a$1 | 0;\n $b$0 = $b$0 | 0;\n $b$1 = $b$1 | 0;\n var $x_sroa_0_0_extract_trunc = 0, $y_sroa_0_0_extract_trunc = 0, $1$0 = 0, $1$1 = 0;\n $x_sroa_0_0_extract_trunc = $a$0;\n $y_sroa_0_0_extract_trunc = $b$0;\n $1$0 = ___muldsi3($x_sroa_0_0_extract_trunc, $y_sroa_0_0_extract_trunc) | 0;\n $1$1 = tempRet0;\n return (tempRet0 = (Math_imul($a$1, $y_sroa_0_0_extract_trunc) | 0) + (Math_imul($b$1, $x_sroa_0_0_extract_trunc) | 0) + $1$1 | $1$1 & 0, $1$0 | 0 | 0) | 0;\n}\n\nfunction __ZN12arControllerC2Ev($0) {\n $0 = $0 | 0;\n var $3 = 0, $6 = 0;\n HEAP32[$0 + 192 >> 2] = 0;\n HEAP32[$0 + 196 >> 2] = 0;\n $3 = $0 + 204 | 0;\n HEAP32[$3 >> 2] = 0;\n HEAP32[$3 + 4 >> 2] = 0;\n HEAP32[$3 + 8 >> 2] = 0;\n HEAP32[$3 + 12 >> 2] = 0;\n HEAP32[$3 + 16 >> 2] = 0;\n HEAP32[$3 + 20 >> 2] = 0;\n HEAPF64[$0 + 232 >> 3] = .0001;\n HEAPF64[$0 + 240 >> 3] = 1.0e3;\n $6 = $0 + 248 | 0;\n HEAP32[$6 >> 2] = 0;\n HEAP32[$6 + 4 >> 2] = 0;\n HEAP32[$6 + 8 >> 2] = 0;\n HEAP32[$6 + 12 >> 2] = 0;\n HEAP32[$0 + 392 >> 2] = 2;\n return;\n}\n\nfunction __ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $8 = 0;\n if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 + 8 >> 2] | 0, 0) | 0) __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi(0, $1, $2, $3); else {\n  $8 = HEAP32[$0 + 8 >> 2] | 0;\n  FUNCTION_TABLE_viiii[HEAP32[(HEAP32[$8 >> 2] | 0) + 28 >> 2] & 3]($8, $1, $2, $3);\n }\n return;\n}\n\nfunction __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($0, $1, $2, $3, $4) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n var $$0 = 0, $13 = 0, $6 = 0, $7 = 0;\n $6 = HEAP32[$0 + 4 >> 2] | 0;\n $7 = $6 >> 8;\n if (!($6 & 1)) $$0 = $7; else $$0 = HEAP32[(HEAP32[$2 >> 2] | 0) + $7 >> 2] | 0;\n $13 = HEAP32[$0 >> 2] | 0;\n FUNCTION_TABLE_viiiii[HEAP32[(HEAP32[$13 >> 2] | 0) + 24 >> 2] & 3]($13, $1, $2 + $$0 | 0, ($6 & 2 | 0) == 0 ? 2 : $3, $4);\n return;\n}\n\nfunction _arUtilGetDirectoryNameFromPath($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $14 = 0, $7 = 0;\n do if (($0 | 0) != 0 & ($1 | 0) != 0 & ($2 | 0) != 0) {\n  $7 = _strrchr($1, 47) | 0;\n  if (!$7) {\n   HEAP8[$0 >> 0] = 0;\n   $$0 = $0;\n   break;\n  }\n  $14 = $7 + (($3 | 0) != 0 & 1) - $1 | 0;\n  if (($14 + 1 | 0) >>> 0 > $2 >>> 0) $$0 = 0; else {\n   _strncpy($0, $1, $14) | 0;\n   HEAP8[$0 + $14 >> 0] = 0;\n   $$0 = $0;\n  }\n } else $$0 = 0; while (0);\n return $$0 | 0;\n}\n\nfunction __ZN10emscripten8internal7InvokerIiJiEE6invokeEPFiiEi($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0, $5 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($1) | 0;\n $4 = FUNCTION_TABLE_ii[$0 & 31]($3) | 0;\n HEAP32[$2 >> 2] = $4;\n $5 = __ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($2) | 0;\n STACKTOP = sp;\n return $5 | 0;\n}\n\nfunction __ZNSt3__213__lower_boundIRNS_6__lessIjjEEPKjjEET0_S6_S6_RKT1_T_($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $$014 = 0, $10 = 0, $11 = 0, $13 = 0, $8 = 0;\n $8 = HEAP32[$2 >> 2] | 0;\n $$0 = $0;\n $$014 = $1 - $0 >> 2;\n while (1) {\n  if (!$$014) break;\n  $10 = ($$014 | 0) / 2 | 0;\n  $11 = $$0 + ($10 << 2) | 0;\n  $13 = (HEAP32[$11 >> 2] | 0) >>> 0 < $8 >>> 0;\n  $$0 = $13 ? $11 + 4 | 0 : $$0;\n  $$014 = $13 ? $$014 + -1 - $10 | 0 : $10;\n }\n return $$0 | 0;\n}\n\nfunction __ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $$0 = 0, $12 = 0, $5 = 0, $6 = 0;\n $5 = HEAP32[$0 + 4 >> 2] | 0;\n $6 = $5 >> 8;\n if (!($5 & 1)) $$0 = $6; else $$0 = HEAP32[(HEAP32[$2 >> 2] | 0) + $6 >> 2] | 0;\n $12 = HEAP32[$0 >> 2] | 0;\n FUNCTION_TABLE_viiii[HEAP32[(HEAP32[$12 >> 2] | 0) + 28 >> 2] & 3]($12, $1, $2 + $$0 | 0, ($5 & 2 | 0) == 0 ? 2 : $3);\n return;\n}\n\nfunction __ZN10emscripten8internal7InvokerIdJiEE6invokeEPFdiEi($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $3 = 0, $4 = 0.0, $5 = 0.0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n $3 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($1) | 0;\n $4 = +FUNCTION_TABLE_di[$0 & 3]($3);\n HEAPF64[$2 >> 3] = $4;\n $5 = +__ZN10emscripten8internal11BindingTypeIdE10toWireTypeERKd($2);\n STACKTOP = sp;\n return +$5;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_12DbD2Ev($0) {\n $0 = $0 | 0;\n __ZNSt3__213__vector_baseINS_6vectorINS1_IN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEEENS5_IS9_Lj4096EEEED2Ev($0 + 32 | 0);\n __ZNSt3__213__vector_baseINS_6vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS3_11short_allocIS4_Lj4096EEEEENS5_IS7_Lj4096EEEED2Ev($0 + 16 | 0);\n __ZNSt3__213__vector_baseIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEED2Ev($0);\n return;\n}\n\nfunction ___towrite($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $14 = 0, $3 = 0, $7 = 0;\n $1 = $0 + 74 | 0;\n $3 = HEAP8[$1 >> 0] | 0;\n HEAP8[$1 >> 0] = $3 + 255 | $3;\n $7 = HEAP32[$0 >> 2] | 0;\n if (!($7 & 8)) {\n  HEAP32[$0 + 8 >> 2] = 0;\n  HEAP32[$0 + 4 >> 2] = 0;\n  $14 = HEAP32[$0 + 44 >> 2] | 0;\n  HEAP32[$0 + 28 >> 2] = $14;\n  HEAP32[$0 + 20 >> 2] = $14;\n  HEAP32[$0 + 16 >> 2] = $14 + (HEAP32[$0 + 48 >> 2] | 0);\n  $$0 = 0;\n } else {\n  HEAP32[$0 >> 2] = $7 | 32;\n  $$0 = -1;\n }\n return $$0 | 0;\n}\n\nfunction _get_buff($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $6 = 0, $7 = 0;\n L1 : while (1) {\n  if (!(_fgets($0, 256, $1) | 0)) break;\n  $$0 = _strlen($0) | 0;\n  L4 : while (1) {\n   if (!$$0) break;\n   $6 = $$0 + -1 | 0;\n   $7 = $0 + $6 | 0;\n   switch (HEAP8[$7 >> 0] | 0) {\n   case 13:\n   case 10:\n    break;\n   default:\n    break L4;\n   }\n   HEAP8[$7 >> 0] = 0;\n   $$0 = $6;\n  }\n  switch (HEAP8[$0 >> 0] | 0) {\n  case 0:\n  case 35:\n   break;\n  default:\n   break L1;\n  }\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_120parse_pack_expansionINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$1 = 0, $12 = 0, $13 = 0;\n if (($1 - $0 | 0) > 2) if ((HEAP8[$0 >> 0] | 0) == 115) if ((HEAP8[$0 + 1 >> 0] | 0) == 112) {\n  $12 = $0 + 2 | 0;\n  $13 = __ZN10__cxxabiv112_GLOBAL__N_116parse_expressionINS0_2DbEEEPKcS4_S4_RT_($12, $1, $2) | 0;\n  $$1 = ($13 | 0) == ($12 | 0) ? $0 : $13;\n } else $$1 = $0; else $$1 = $0; else $$1 = $0;\n return $$1 | 0;\n}\n\nfunction _fmt_o($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0$lcssa = 0, $$06 = 0, $10 = 0, $11 = 0, $7 = 0;\n if (($0 | 0) == 0 & ($1 | 0) == 0) $$0$lcssa = $2; else {\n  $$06 = $2;\n  $11 = $1;\n  $7 = $0;\n  while (1) {\n   $10 = $$06 + -1 | 0;\n   HEAP8[$10 >> 0] = $7 & 7 | 48;\n   $7 = _bitshift64Lshr($7 | 0, $11 | 0, 3) | 0;\n   $11 = tempRet0;\n   if (($7 | 0) == 0 & ($11 | 0) == 0) {\n    $$0$lcssa = $10;\n    break;\n   } else $$06 = $10;\n  }\n }\n return $$0$lcssa | 0;\n}\n\nfunction _arg_n_724($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $10 = 0, $2 = 0, $9 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = HEAP32[$0 >> 2];\n $$0 = $1;\n while (1) {\n  $9 = (HEAP32[$2 >> 2] | 0) + (4 - 1) & ~(4 - 1);\n  $10 = HEAP32[$9 >> 2] | 0;\n  HEAP32[$2 >> 2] = $9 + 4;\n  if ($$0 >>> 0 > 1) $$0 = $$0 + -1 | 0; else break;\n }\n STACKTOP = sp;\n return $10 | 0;\n}\n\nfunction _arImageProcLumaHistAndCDF($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$017 = 0, $2 = 0, $indvars$iv = 0;\n $2 = _arImageProcLumaHist($0, $1) | 0;\n if (($2 | 0) < 0) $$0 = $2; else {\n  $$017 = 0;\n  $indvars$iv = 0;\n  do {\n   $$017 = (HEAP32[$0 + 12 + ($indvars$iv << 2) >> 2] | 0) + $$017 | 0;\n   HEAP32[$0 + 1036 + ($indvars$iv << 2) >> 2] = $$017;\n   $indvars$iv = $indvars$iv + 1 | 0;\n  } while (($indvars$iv | 0) != 256);\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction _getint_671($0) {\n $0 = $0 | 0;\n var $$0$lcssa = 0, $$04 = 0, $11 = 0, $12 = 0, $7 = 0;\n if (!(_isdigit(HEAP8[HEAP32[$0 >> 2] >> 0] | 0) | 0)) $$0$lcssa = 0; else {\n  $$04 = 0;\n  while (1) {\n   $7 = HEAP32[$0 >> 2] | 0;\n   $11 = ($$04 * 10 | 0) + -48 + (HEAP8[$7 >> 0] | 0) | 0;\n   $12 = $7 + 1 | 0;\n   HEAP32[$0 >> 2] = $12;\n   if (!(_isdigit(HEAP8[$12 >> 0] | 0) | 0)) {\n    $$0$lcssa = $11;\n    break;\n   } else $$04 = $11;\n  }\n }\n return $$0$lcssa | 0;\n}\n\nfunction runPostSets() {}\nfunction ___muldsi3($a, $b) {\n $a = $a | 0;\n $b = $b | 0;\n var $1 = 0, $2 = 0, $3 = 0, $6 = 0, $8 = 0, $11 = 0, $12 = 0;\n $1 = $a & 65535;\n $2 = $b & 65535;\n $3 = Math_imul($2, $1) | 0;\n $6 = $a >>> 16;\n $8 = ($3 >>> 16) + (Math_imul($2, $6) | 0) | 0;\n $11 = $b >>> 16;\n $12 = Math_imul($11, $1) | 0;\n return (tempRet0 = ($8 >>> 16) + (Math_imul($11, $6) | 0) + ((($8 & 65535) + $12 | 0) >>> 16) | 0, $8 + $12 << 16 | $3 & 65535 | 0) | 0;\n}\n\nfunction ___ftello_unlocked($0) {\n $0 = $0 | 0;\n var $$0 = 0, $11 = 0, $12 = 0;\n if (!(HEAP32[$0 >> 2] & 128)) $11 = 1; else $11 = (HEAP32[$0 + 20 >> 2] | 0) >>> 0 > (HEAP32[$0 + 28 >> 2] | 0) >>> 0 ? 2 : 1;\n $12 = FUNCTION_TABLE_iiii[HEAP32[$0 + 40 >> 2] & 15]($0, 0, $11) | 0;\n if (($12 | 0) < 0) $$0 = $12; else $$0 = $12 - (HEAP32[$0 + 8 >> 2] | 0) + (HEAP32[$0 + 4 >> 2] | 0) + (HEAP32[$0 + 20 >> 2] | 0) - (HEAP32[$0 + 28 >> 2] | 0) | 0;\n return $$0 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEaSERKS7_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $4 = 0, $5 = 0;\n if (($0 | 0) != ($1 | 0)) {\n  $4 = HEAP8[$1 + 11 >> 0] | 0;\n  $5 = $4 << 24 >> 24 < 0;\n  __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKcj($0, $5 ? HEAP32[$1 >> 2] | 0 : $1, $5 ? HEAP32[$1 + 4 >> 2] | 0 : $4 & 255);\n }\n return;\n}\n\nfunction _deleteHandle($0) {\n $0 = $0 | 0;\n var $1 = 0, $2 = 0, $5 = 0, $8 = 0;\n $1 = $0 + 216 | 0;\n $2 = HEAP32[$1 >> 2] | 0;\n if ($2 | 0) {\n  _arPattDetach($2) | 0;\n  _arDeleteHandle(HEAP32[$1 >> 2] | 0) | 0;\n  HEAP32[$1 >> 2] = 0;\n }\n $5 = $0 + 228 | 0;\n if (HEAP32[$5 >> 2] | 0) {\n  _ar3DDeleteHandle($5) | 0;\n  HEAP32[$5 >> 2] = 0;\n }\n $8 = $0 + 192 | 0;\n if (HEAP32[$8 >> 2] | 0) {\n  _arParamLTFree($8) | 0;\n  HEAP32[$8 >> 2] = 0;\n }\n return;\n}\n\nfunction _arVecInnerproduct($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$013 = 0.0, $15 = 0.0, $3 = 0;\n $3 = HEAP32[$0 + 4 >> 2] | 0;\n if (($3 | 0) != (HEAP32[$1 + 4 >> 2] | 0)) _exit(0);\n $$0 = 0;\n $$013 = 0.0;\n while (1) {\n  if (($$0 | 0) >= ($3 | 0)) break;\n  $15 = $$013 + +HEAPF64[(HEAP32[$0 >> 2] | 0) + ($$0 << 3) >> 3] * +HEAPF64[(HEAP32[$1 >> 2] | 0) + ($$0 << 3) >> 3];\n  $$0 = $$0 + 1 | 0;\n  $$013 = $15;\n }\n return +$$013;\n}\n\nfunction _shl($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $10 = 0, $3 = 0, $5 = 0, $7 = 0;\n $3 = $0 + 4 | 0;\n if ($1 >>> 0 > 31) {\n  $5 = HEAP32[$0 >> 2] | 0;\n  HEAP32[$3 >> 2] = $5;\n  HEAP32[$0 >> 2] = 0;\n  $$0 = $1 + -32 | 0;\n  $10 = 0;\n  $7 = $5;\n } else {\n  $$0 = $1;\n  $10 = HEAP32[$0 >> 2] | 0;\n  $7 = HEAP32[$3 >> 2] | 0;\n }\n HEAP32[$3 >> 2] = $10 >>> (32 - $$0 | 0) | $7 << $$0;\n HEAP32[$0 >> 2] = $10 << $$0;\n return;\n}\n\nfunction _memmove(dest, src, num) {\n dest = dest | 0;\n src = src | 0;\n num = num | 0;\n var ret = 0;\n if ((src | 0) < (dest | 0) & (dest | 0) < (src + num | 0)) {\n  ret = dest;\n  src = src + num | 0;\n  dest = dest + num | 0;\n  while ((num | 0) > 0) {\n   dest = dest - 1 | 0;\n   src = src - 1 | 0;\n   num = num - 1 | 0;\n   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n  }\n  dest = ret;\n } else _memcpy(dest, src, num) | 0;\n return dest | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE10deallocateEPcj($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $5 = 0, $6 = 0;\n if (__ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE17pointer_in_bufferEPc($0, $1) | 0) {\n  $5 = $1 + (__ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE8align_upEj($2) | 0) | 0;\n  $6 = $0 + 4096 | 0;\n  if (($5 | 0) == (HEAP32[$6 >> 2] | 0)) HEAP32[$6 >> 2] = $1;\n } else _free($1);\n return;\n}\n\nfunction _shr($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $10 = 0, $3 = 0, $5 = 0, $7 = 0;\n $3 = $0 + 4 | 0;\n if ($1 >>> 0 > 31) {\n  $5 = HEAP32[$3 >> 2] | 0;\n  HEAP32[$0 >> 2] = $5;\n  HEAP32[$3 >> 2] = 0;\n  $$0 = $1 + -32 | 0;\n  $10 = 0;\n  $7 = $5;\n } else {\n  $$0 = $1;\n  $10 = HEAP32[$3 >> 2] | 0;\n  $7 = HEAP32[$0 >> 2] | 0;\n }\n HEAP32[$0 >> 2] = $10 << 32 - $$0 | $7 >>> $$0;\n HEAP32[$3 >> 2] = $10 >>> $$0;\n return;\n}\n\nfunction __ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($0, $1, $2, $3, $4, $5) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n $4 = $4 | 0;\n $5 = $5 | 0;\n if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 + 8 >> 2] | 0, $5) | 0) __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i(0, $1, $2, $3, $4);\n return;\n}\n\nfunction _ar3DCreateHandle2($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $3 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = _malloc(4) | 0;\n if (!$1) {\n  _arLog(0, 3, 5051, sp);\n  _exit(1);\n }\n $3 = _icpCreateHandle($0) | 0;\n HEAP32[$1 >> 2] = $3;\n if (!$3) {\n  _free($1);\n  $$0 = 0;\n } else $$0 = $1;\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _copysign($0, $1) {\n $0 = +$0;\n $1 = +$1;\n var $2 = 0, $3 = 0, $8 = 0;\n HEAPF64[tempDoublePtr >> 3] = $0;\n $2 = HEAP32[tempDoublePtr >> 2] | 0;\n $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;\n HEAPF64[tempDoublePtr >> 3] = $1;\n $8 = HEAP32[tempDoublePtr + 4 >> 2] & -2147483648 | $3 & 2147483647;\n HEAP32[tempDoublePtr >> 2] = $2;\n HEAP32[tempDoublePtr + 4 >> 2] = $8;\n return +(+HEAPF64[tempDoublePtr >> 3]);\n}\n\nfunction _arLog($0, $1, $2, $varargs) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $varargs = $varargs | 0;\n var $3 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n if (($2 | 0) != 0 & (HEAP32[484] | 0) <= ($1 | 0)) if (HEAP8[$2 >> 0] | 0) {\n  HEAP32[$3 >> 2] = $varargs;\n  _arLogv(0, $1, $2, $3);\n }\n STACKTOP = sp;\n return;\n}\n\nfunction ___unlist_locked_file($0) {\n $0 = $0 | 0;\n var $$pre = 0, $$sink = 0, $10 = 0, $5 = 0;\n if (HEAP32[$0 + 68 >> 2] | 0) {\n  $5 = HEAP32[$0 + 116 >> 2] | 0;\n  $$pre = $0 + 112 | 0;\n  if ($5 | 0) HEAP32[$5 + 112 >> 2] = HEAP32[$$pre >> 2];\n  $10 = HEAP32[$$pre >> 2] | 0;\n  if (!$10) $$sink = (___pthread_self_699() | 0) + 232 | 0; else $$sink = $10 + 116 | 0;\n  HEAP32[$$sink >> 2] = $5;\n }\n return;\n}\n\nfunction __ZNSt3__218__libcpp_refstringC2EPKc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0, $4 = 0, $7 = 0;\n $2 = _strlen($1) | 0;\n $4 = __Znwj($2 + 13 | 0) | 0;\n HEAP32[$4 >> 2] = $2;\n HEAP32[$4 + 4 >> 2] = $2;\n HEAP32[$4 + 8 >> 2] = 0;\n $7 = __ZNSt3__215__refstring_imp12_GLOBAL__N_113data_from_repEPNS1_9_Rep_baseE($4) | 0;\n _memcpy($7 | 0, $1 | 0, $2 + 1 | 0) | 0;\n HEAP32[$0 >> 2] = $7;\n return;\n}\n\nfunction __ZN10emscripten8internal7InvokerIiJEE6invokeEPFivE($0) {\n $0 = $0 | 0;\n var $1 = 0, $2 = 0, $3 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n $2 = FUNCTION_TABLE_i[$0 & 1]() | 0;\n HEAP32[$1 >> 2] = $2;\n $3 = __ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($1) | 0;\n STACKTOP = sp;\n return $3 | 0;\n}\n\nfunction ___stdio_close($0) {\n $0 = $0 | 0;\n var $3 = 0, $5 = 0, $vararg_buffer = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $vararg_buffer = sp;\n $3 = _dummy(HEAP32[$0 + 60 >> 2] | 0) | 0;\n HEAP32[$vararg_buffer >> 2] = $3;\n $5 = ___syscall_ret(___syscall6(6, $vararg_buffer | 0) | 0) | 0;\n STACKTOP = sp;\n return $5 | 0;\n}\n\nfunction _calloc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $3 = 0, $8 = 0;\n if (!$0) $$0 = 0; else {\n  $3 = Math_imul($1, $0) | 0;\n  if (($1 | $0) >>> 0 > 65535) $$0 = (($3 >>> 0) / ($0 >>> 0) | 0 | 0) == ($1 | 0) ? $3 : -1; else $$0 = $3;\n }\n $8 = _malloc($$0) | 0;\n if (!$8) return $8 | 0;\n if (!(HEAP32[$8 + -4 >> 2] & 3)) return $8 | 0;\n _memset($8 | 0, 0, $$0 | 0) | 0;\n return $8 | 0;\n}\n\nfunction __ZN10emscripten8internal11BindingTypeINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE12fromWireTypeEPNS9_Ut_E($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $3 = 0;\n $3 = HEAP32[$1 >> 2] | 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcj($0, $1 + 4 | 0, $3);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE8allocateEj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $2 = 0, $4 = 0, $5 = 0;\n $2 = __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE8align_upEj($1) | 0;\n $4 = $0 + 4096 | 0;\n $5 = HEAP32[$4 >> 2] | 0;\n if (($0 + 4096 - $5 | 0) >>> 0 < $2 >>> 0) $$0 = _malloc($2) | 0; else {\n  HEAP32[$4 >> 2] = $5 + $2;\n  $$0 = $5;\n }\n return $$0 | 0;\n}\n\nfunction _arMatrixAlloc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $2 = 0, $6 = 0;\n $2 = _malloc(12) | 0;\n do if (!$2) $$0 = 0; else {\n  $6 = _malloc(Math_imul($0 << 3, $1) | 0) | 0;\n  HEAP32[$2 >> 2] = $6;\n  if (!$6) {\n   _free($2);\n   $$0 = 0;\n   break;\n  } else {\n   HEAP32[$2 + 4 >> 2] = $0;\n   HEAP32[$2 + 8 >> 2] = $1;\n   $$0 = $2;\n   break;\n  }\n } while (0);\n return $$0 | 0;\n}\n\nfunction __ZSt9terminatev() {\n var $0 = 0, $2 = 0, $5 = 0;\n $0 = ___cxa_get_globals_fast() | 0;\n if ($0 | 0) {\n  $2 = HEAP32[$0 >> 2] | 0;\n  if ($2 | 0) {\n   $5 = $2 + 48 | 0;\n   if ((HEAP32[$5 >> 2] & -256 | 0) == 1126902528 ? (HEAP32[$5 + 4 >> 2] | 0) == 1129074247 : 0) __ZSt11__terminatePFvvE(HEAP32[$2 + 12 >> 2] | 0);\n  }\n }\n __ZSt11__terminatePFvvE(__ZSt13get_terminatev() | 0);\n}\n\nfunction __ZNSt3__214__split_bufferI12multi_markerRNS_9allocatorIS1_EEED2Ev($0) {\n $0 = $0 | 0;\n var $2 = 0, $3 = 0, $5 = 0, $6 = 0, $7 = 0;\n $2 = HEAP32[$0 + 4 >> 2] | 0;\n $3 = $0 + 8 | 0;\n $5 = HEAP32[$3 >> 2] | 0;\n while (1) {\n  if (($5 | 0) == ($2 | 0)) break;\n  $6 = $5 + -8 | 0;\n  HEAP32[$3 >> 2] = $6;\n  $5 = $6;\n }\n $7 = HEAP32[$0 >> 2] | 0;\n if ($7 | 0) __ZdlPv($7);\n return;\n}\n\nfunction __ZNSt3__218__libcpp_refstringD2Ev($0) {\n $0 = $0 | 0;\n var $3 = 0, $4 = 0, $5 = 0;\n if (__ZNKSt3__218__libcpp_refstring15__uses_refcountEv($0) | 0) {\n  $3 = __ZNSt3__215__refstring_imp12_GLOBAL__N_113rep_from_dataEPKc_350(HEAP32[$0 >> 2] | 0) | 0;\n  $4 = $3 + 8 | 0;\n  $5 = HEAP32[$4 >> 2] | 0;\n  HEAP32[$4 >> 2] = $5 + -1;\n  if (($5 + -1 | 0) < 0) __ZdlPv($3);\n }\n return;\n}\n\nfunction __ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n if (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, HEAP32[$1 + 8 >> 2] | 0, 0) | 0) __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi(0, $1, $2, $3);\n return;\n}\n\nfunction _arUtilGetPixelSize($0) {\n $0 = $0 | 0;\n var $$0 = 0;\n switch ($0 | 0) {\n case 1:\n case 0:\n  {\n   $$0 = 3;\n   break;\n  }\n case 6:\n case 4:\n case 3:\n case 2:\n  {\n   $$0 = 4;\n   break;\n  }\n case 14:\n case 13:\n case 12:\n case 5:\n  {\n   $$0 = 1;\n   break;\n  }\n case 11:\n case 10:\n case 9:\n case 8:\n case 7:\n  {\n   $$0 = 2;\n   break;\n  }\n default:\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction ___uflow($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n if (!(___toread($0) | 0)) if ((FUNCTION_TABLE_iiii[HEAP32[$0 + 32 >> 2] & 15]($0, $1, 1) | 0) == 1) $$0 = HEAPU8[$1 >> 0] | 0; else $$0 = -1; else $$0 = -1;\n STACKTOP = sp;\n return $$0 | 0;\n}\n\nfunction _sn_write($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $5 = 0, $6 = 0, $7 = 0, $spec$select = 0;\n $5 = $0 + 20 | 0;\n $6 = HEAP32[$5 >> 2] | 0;\n $7 = (HEAP32[$0 + 16 >> 2] | 0) - $6 | 0;\n $spec$select = $7 >>> 0 > $2 >>> 0 ? $2 : $7;\n _memcpy($6 | 0, $1 | 0, $spec$select | 0) | 0;\n HEAP32[$5 >> 2] = (HEAP32[$5 >> 2] | 0) + $spec$select;\n return $2 | 0;\n}\n\nfunction ___memrchr($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0, $$in = 0, $4 = 0;\n L1 : do if (!$2) $$0 = 0; else {\n  $4 = $1 & 255;\n  $$in = $2;\n  while (1) {\n   $$in = $$in + -1 | 0;\n   if ((HEAP8[$0 + $$in >> 0] | 0) == $4 << 24 >> 24) break;\n   if (!$$in) {\n    $$0 = 0;\n    break L1;\n   }\n  }\n  $$0 = $0 + $$in | 0;\n } while (0);\n return $$0 | 0;\n}\n\nfunction __Znwj($0) {\n $0 = $0 | 0;\n var $$lcssa = 0, $2 = 0, $4 = 0, $spec$store$select = 0;\n $spec$store$select = ($0 | 0) == 0 ? 1 : $0;\n while (1) {\n  $2 = _malloc($spec$store$select) | 0;\n  if ($2 | 0) {\n   $$lcssa = $2;\n   break;\n  }\n  $4 = __ZSt15get_new_handlerv() | 0;\n  if (!$4) {\n   $$lcssa = 0;\n   break;\n  }\n  FUNCTION_TABLE_v[$4 & 3]();\n }\n return $$lcssa | 0;\n}\n\nfunction _ferror($0) {\n $0 = $0 | 0;\n var $$lobit = 0, $$lobit9 = 0, $phitmp = 0;\n if ((HEAP32[$0 + 76 >> 2] | 0) > -1) {\n  $phitmp = (___lockfile($0) | 0) == 0;\n  $$lobit = (HEAP32[$0 >> 2] | 0) >>> 5 & 1;\n  if ($phitmp) $$lobit9 = $$lobit; else {\n   ___unlockfile($0);\n   $$lobit9 = $$lobit;\n  }\n } else $$lobit9 = (HEAP32[$0 >> 2] | 0) >>> 5 & 1;\n return $$lobit9 | 0;\n}\n\nfunction ___fseeko($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $8 = 0, $9 = 0, $phitmp = 0;\n if ((HEAP32[$0 + 76 >> 2] | 0) > -1) {\n  $phitmp = (___lockfile($0) | 0) == 0;\n  $8 = ___fseeko_unlocked($0, $1, $2) | 0;\n  if ($phitmp) $9 = $8; else {\n   ___unlockfile($0);\n   $9 = $8;\n  }\n } else $9 = ___fseeko_unlocked($0, $1, $2) | 0;\n return $9 | 0;\n}\n\nfunction __ZNK10__cxxabiv112_GLOBAL__N_111string_pair4sizeEv($0) {\n $0 = $0 | 0;\n var $15 = 0, $16 = 0, $2 = 0, $9 = 0;\n $2 = HEAP8[$0 + 11 >> 0] | 0;\n if ($2 << 24 >> 24 < 0) $16 = HEAP32[$0 + 4 >> 2] | 0; else $16 = $2 & 255;\n $9 = HEAP8[$0 + 12 + 11 >> 0] | 0;\n if ($9 << 24 >> 24 < 0) $15 = HEAP32[$0 + 16 >> 2] | 0; else $15 = $9 & 255;\n return $15 + $16 | 0;\n}\n\nfunction _snprintf($0, $1, $2, $varargs) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $varargs = $varargs | 0;\n var $3 = 0, $4 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $3 = sp;\n HEAP32[$3 >> 2] = $varargs;\n $4 = _vsnprintf($0, $1, $2, $3) | 0;\n STACKTOP = sp;\n return $4 | 0;\n}\n\nfunction _matrixCopy($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $$012 = 0;\n $$012 = 0;\n while (1) {\n  if (($$012 | 0) == 3) break;\n  $$0 = 0;\n  while (1) {\n   if (($$0 | 0) == 4) break;\n   HEAPF64[$1 + ($$012 << 5) + ($$0 << 3) >> 3] = +HEAPF64[$0 + ($$012 << 5) + ($$0 << 3) >> 3];\n   $$0 = $$0 + 1 | 0;\n  }\n  $$012 = $$012 + 1 | 0;\n }\n return;\n}\n\nfunction _rewind($0) {\n $0 = $0 | 0;\n var $phitmp = 0;\n if ((HEAP32[$0 + 76 >> 2] | 0) > -1) {\n  $phitmp = (___lockfile($0) | 0) == 0;\n  ___fseeko_unlocked($0, 0, 0) | 0;\n  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] & -33;\n  if (!$phitmp) ___unlockfile($0);\n } else {\n  ___fseeko_unlocked($0, 0, 0) | 0;\n  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] & -33;\n }\n return;\n}\n\nfunction _arDeleteHandle($0) {\n $0 = $0 | 0;\n var $$0 = 0, $2 = 0, $3 = 0;\n if (!$0) $$0 = -1; else {\n  $2 = $0 + 7062408 | 0;\n  $3 = HEAP32[$2 >> 2] | 0;\n  if ($3 | 0) {\n   _arImageProcFinal($3);\n   HEAP32[$2 >> 2] = 0;\n  }\n  _free(HEAP32[$0 + 4834144 >> 2] | 0);\n  _free(HEAP32[$0 + 4834148 >> 2] | 0);\n  _free($0);\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKc($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n return __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6insertEjPKcj($0, $1, $2, __ZNSt3__211char_traitsIcE6lengthEPKc($2) | 0) | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairC2ERKS1_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_($0, $1);\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEEC2ERKS7_($0 + 12 | 0, $1 + 12 | 0);\n return;\n}\n\nfunction _abort_message($0, $varargs) {\n $0 = $0 | 0;\n $varargs = $varargs | 0;\n var $1 = 0, $2 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $1 = sp;\n HEAP32[$1 >> 2] = $varargs;\n $2 = HEAP32[520] | 0;\n _vfprintf($2, $0, $1) | 0;\n _fputc(10, $2) | 0;\n _abort();\n}\n\nfunction ___shlim($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $4 = 0, $6 = 0, $7 = 0;\n HEAP32[$0 + 104 >> 2] = $1;\n $4 = HEAP32[$0 + 8 >> 2] | 0;\n $6 = HEAP32[$0 + 4 >> 2] | 0;\n $7 = $4 - $6 | 0;\n HEAP32[$0 + 108 >> 2] = $7;\n if (($1 | 0) != 0 & ($7 | 0) > ($1 | 0)) HEAP32[$0 + 100 >> 2] = $6 + $1; else HEAP32[$0 + 100 >> 2] = $4;\n return;\n}\n\nfunction ___cxa_get_globals_fast() {\n var $3 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n if (!(_pthread_once(18008, 2) | 0)) {\n  $3 = _pthread_getspecific(HEAP32[4503] | 0) | 0;\n  STACKTOP = sp;\n  return $3 | 0;\n } else _abort_message(14737, sp);\n return 0;\n}\n\nfunction _a_ctz_l_811($0) {\n $0 = $0 | 0;\n var $$068 = 0, $$07 = 0, $$09 = 0, $4 = 0;\n if (!$0) $$07 = 32; else if (!($0 & 1)) {\n  $$068 = $0;\n  $$09 = 0;\n  while (1) {\n   $4 = $$09 + 1 | 0;\n   if (!($$068 & 2)) {\n    $$068 = $$068 >>> 1;\n    $$09 = $4;\n   } else {\n    $$07 = $4;\n    break;\n   }\n  }\n } else $$07 = 0;\n return $$07 | 0;\n}\n\nfunction __ZN10emscripten8internal7InvokerIvJiiEE6invokeEPFviiEii($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $3 = 0, $4 = 0;\n $3 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($1) | 0;\n $4 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($2) | 0;\n FUNCTION_TABLE_vii[$0 & 7]($3, $4);\n return;\n}\n\nfunction _sscanf($0, $1, $varargs) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $varargs = $varargs | 0;\n var $2 = 0, $3 = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n $2 = sp;\n HEAP32[$2 >> 2] = $varargs;\n $3 = _vsscanf($0, $1, $2) | 0;\n STACKTOP = sp;\n return $3 | 0;\n}\n\nfunction _arParamLTFree($0) {\n $0 = $0 | 0;\n var $$0 = 0, $2 = 0;\n if (!$0) $$0 = -1; else {\n  $2 = HEAP32[$0 >> 2] | 0;\n  if (!$2) $$0 = -1; else {\n   _free(HEAP32[$2 + 184 >> 2] | 0);\n   _free(HEAP32[(HEAP32[$0 >> 2] | 0) + 188 >> 2] | 0);\n   _free(HEAP32[$0 >> 2] | 0);\n   HEAP32[$0 >> 2] = 0;\n   $$0 = 0;\n  }\n }\n return $$0 | 0;\n}\n\nfunction __ZN10emscripten8internal7InvokerIvJifEE6invokeEPFvifEif($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = +$2;\n var $3 = 0, $4 = 0.0;\n $3 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($1) | 0;\n $4 = +__ZN10emscripten8internal11BindingTypeIfE12fromWireTypeEf($2);\n FUNCTION_TABLE_vid[$0 & 3]($3, $4);\n return;\n}\n\nfunction __ZN10emscripten8internal7InvokerIvJidEE6invokeEPFvidEid($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = +$2;\n var $3 = 0, $4 = 0.0;\n $3 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($1) | 0;\n $4 = +__ZN10emscripten8internal11BindingTypeIdE12fromWireTypeEd($2);\n FUNCTION_TABLE_vid[$0 & 3]($3, $4);\n return;\n}\n\nfunction __ZN10emscripten8constantIiEEvPKcRKT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0;\n $2 = __ZN10emscripten8internal6TypeIDIRKiE3getEv() | 0;\n __embind_register_constant($0 | 0, $2 | 0, __ZN10emscripten8internal14asGenericValueIiEEjT_(__ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($1) | 0) | 0);\n return;\n}\n\nfunction __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n var $7 = 0;\n if ((HEAP32[$1 + 4 >> 2] | 0) == ($2 | 0)) {\n  $7 = $1 + 28 | 0;\n  if ((HEAP32[$7 >> 2] | 0) != 1) HEAP32[$7 >> 2] = $3;\n }\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_19destruct_EPv($0) {\n $0 = $0 | 0;\n var sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n _free($0);\n if (!(_pthread_setspecific(HEAP32[4503] | 0, 0) | 0)) {\n  STACKTOP = sp;\n  return;\n } else _abort_message(14836, sp);\n}\n\nfunction __ZN10emscripten8constantIdEEvPKcRKT_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0;\n $2 = __ZN10emscripten8internal6TypeIDIRKdE3getEv() | 0;\n __embind_register_constant($0 | 0, $2 | 0, __ZN10emscripten8internal14asGenericValueIdEEjT_(+__ZN10emscripten8internal11BindingTypeIdE10toWireTypeERKd($1)) | 0);\n return;\n}\n\nfunction __ZNSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEEC2EjRKS8_RKS9_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n HEAP32[$0 + 12 >> 2] = HEAP32[$1 >> 2];\n return;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n return __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6appendEPKcj($0, $1, __ZNSt3__211char_traitsIcE6lengthEPKc($1) | 0) | 0;\n}\n\nfunction _arVecAlloc($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0, $4 = 0;\n $1 = _malloc(8) | 0;\n do if (!$1) $$0 = 0; else {\n  $4 = _malloc($0 << 3) | 0;\n  HEAP32[$1 >> 2] = $4;\n  if (!$4) {\n   _free($1);\n   $$0 = 0;\n   break;\n  } else {\n   HEAP32[$1 + 4 >> 2] = $0;\n   $$0 = $1;\n   break;\n  }\n } while (0);\n return $$0 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE6assignEPKcj($0, $1, __ZNSt3__211char_traitsIcE6lengthEPKc($1) | 0);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS3_INS0_11string_pairENS1_IS4_Lj4096EEEEENS1_IS6_Lj4096EEEEELj4096EE10deallocateEPS8_j($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE10deallocateEPcj(HEAP32[$0 >> 2] | 0, $1, $2 << 4);\n return;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiiNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEEE3getEv() | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEEE3getEv() | 0;\n}\n\nfunction ___ftello($0) {\n $0 = $0 | 0;\n var $6 = 0, $7 = 0, $phitmp = 0;\n if ((HEAP32[$0 + 76 >> 2] | 0) > -1) {\n  $phitmp = (___lockfile($0) | 0) == 0;\n  $6 = ___ftello_unlocked($0) | 0;\n  if ($phitmp) $7 = $6; else {\n   ___unlockfile($0);\n   $7 = $6;\n  }\n } else $7 = ___ftello_unlocked($0) | 0;\n return $7 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7replaceEjjPKc($0) {\n $0 = $0 | 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEE7replaceEjjPKcj($0, __ZNSt3__211char_traitsIcE6lengthEPKc(16538) | 0);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111string_pairD2Ev($0) {\n $0 = $0 | 0;\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($0 + 12 | 0);\n __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($0);\n return;\n}\n\nfunction _arMatrixAllocMul($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $6 = 0;\n $6 = _arMatrixAlloc(HEAP32[$0 + 4 >> 2] | 0, HEAP32[$1 + 8 >> 2] | 0) | 0;\n if (!$6) $$0 = 0; else if ((_arMatrixMul($6, $0, $1) | 0) < 0) {\n  _arMatrixFree($6) | 0;\n  $$0 = 0;\n } else $$0 = $6;\n return $$0 | 0;\n}\n\nfunction __ZNSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEC2EjRKS6_RKS7_($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = 0;\n HEAP32[$0 + 4 >> 2] = 0;\n HEAP32[$0 + 8 >> 2] = 0;\n HEAP32[$0 + 12 >> 2] = HEAP32[$1 >> 2];\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EE10deallocateEPS6_j($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE10deallocateEPcj(HEAP32[$0 >> 2] | 0, $1, $2 << 4);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_110construct_Ev() {\n var sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n if (!(_pthread_key_create(18012, 12) | 0)) {\n  STACKTOP = sp;\n  return;\n } else _abort_message(14786, sp);\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS3_INS0_11string_pairENS1_IS4_Lj4096EEEEENS1_IS6_Lj4096EEEEELj4096EE8allocateEj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n return __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE8allocateEj(HEAP32[$0 >> 2] | 0, $1 << 4) | 0;\n}\n\nfunction _arMatrixAllocTrans($0) {\n $0 = $0 | 0;\n var $$0 = 0, $5 = 0;\n $5 = _arMatrixAlloc(HEAP32[$0 + 8 >> 2] | 0, HEAP32[$0 + 4 >> 2] | 0) | 0;\n if (!$5) $$0 = 0; else if ((_arMatrixTrans($5, $0) | 0) < 0) {\n  _arMatrixFree($5) | 0;\n  $$0 = 0;\n } else $$0 = $5;\n return $$0 | 0;\n}\n\nfunction _arPattFree($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $4 = 0;\n $4 = (HEAP32[$0 + 8 >> 2] | 0) + ($1 << 2) | 0;\n if (!(HEAP32[$4 >> 2] | 0)) $$0 = -1; else {\n  HEAP32[$4 >> 2] = 0;\n  HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + -1;\n  $$0 = 1;\n }\n return $$0 | 0;\n}\n\nfunction _arMatrixAllocDup($0) {\n $0 = $0 | 0;\n var $$0 = 0, $5 = 0;\n $5 = _arMatrixAlloc(HEAP32[$0 + 4 >> 2] | 0, HEAP32[$0 + 8 >> 2] | 0) | 0;\n if (!$5) $$0 = 0; else if ((_arMatrixDup($5, $0) | 0) < 0) {\n  _arMatrixFree($5) | 0;\n  $$0 = 0;\n } else $$0 = $5;\n return $$0 | 0;\n}\n\nfunction _bitshift64Shl(low, high, bits) {\n low = low | 0;\n high = high | 0;\n bits = bits | 0;\n if ((bits | 0) < 32) {\n  tempRet0 = high << bits | (low & (1 << bits) - 1 << 32 - bits) >>> 32 - bits;\n  return low << bits;\n }\n tempRet0 = low << bits - 32;\n return 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINS0_11string_pairELj4096EE10deallocateEPS2_j($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE10deallocateEPcj(HEAP32[$0 >> 2] | 0, $1, $2 * 24 | 0);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EE8allocateEj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n return __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE8allocateEj(HEAP32[$0 >> 2] | 0, $1 << 4) | 0;\n}\n\nfunction _bitshift64Lshr(low, high, bits) {\n low = low | 0;\n high = high | 0;\n bits = bits | 0;\n if ((bits | 0) < 32) {\n  tempRet0 = high >>> bits;\n  return low >>> bits | (high & (1 << bits) - 1) << 32 - bits;\n }\n tempRet0 = 0;\n return high >>> bits - 32 | 0;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEEN10__cxxabiv112_GLOBAL__N_112malloc_allocIcEEED2Ev($0) {\n $0 = $0 | 0;\n if ((HEAP8[$0 + 11 >> 0] | 0) < 0) __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE10deallocateEPcj(HEAP32[$0 >> 2] | 0);\n return;\n}\n\nfunction _pntz($0) {\n $0 = $0 | 0;\n var $3 = 0, $7 = 0;\n $3 = _a_ctz_l_811((HEAP32[$0 >> 2] | 0) + -1 | 0) | 0;\n if (!$3) {\n  $7 = _a_ctz_l_811(HEAP32[$0 + 4 >> 2] | 0) | 0;\n  return (($7 | 0) == 0 ? 0 : $7 + 32 | 0) | 0;\n } else return $3 | 0;\n return 0;\n}\n\nfunction ___ofl_add($0) {\n $0 = $0 | 0;\n var $1 = 0, $4 = 0;\n $1 = ___ofl_lock() | 0;\n HEAP32[$0 + 56 >> 2] = HEAP32[$1 >> 2];\n $4 = HEAP32[$1 >> 2] | 0;\n if ($4 | 0) HEAP32[$4 + 52 >> 2] = $0;\n HEAP32[$1 >> 2] = $0;\n ___ofl_unlock();\n return $0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_132parse_unresolved_qualifier_levelINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n return __ZN10__cxxabiv112_GLOBAL__N_115parse_simple_idINS0_2DbEEEPKcS4_S4_RT_($0, $1, $2) | 0;\n}\n\nfunction dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n a3 = a3 | 0;\n a4 = a4 | 0;\n a5 = a5 | 0;\n a6 = a6 | 0;\n FUNCTION_TABLE_viiiiii[index & 3](a1 | 0, a2 | 0, a3 | 0, a4 | 0, a5 | 0, a6 | 0);\n}\n\nfunction __ZN10emscripten8internal6TypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv() | 0;\n}\n\nfunction _arPattAttach($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0, $3 = 0;\n if (!$0) $$0 = -1; else {\n  $3 = $0 + 7062384 | 0;\n  if (!(HEAP32[$3 >> 2] | 0)) {\n   HEAP32[$3 >> 2] = $1;\n   $$0 = 0;\n  } else $$0 = -1;\n }\n return $$0 | 0;\n}\n\nfunction _ar3DDeleteHandle($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0;\n $1 = HEAP32[$0 >> 2] | 0;\n if (!$1) $$0 = -1; else {\n  _icpDeleteHandle($1) | 0;\n  _free(HEAP32[$0 >> 2] | 0);\n  HEAP32[$0 >> 2] = 0;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction __ZSt11__terminatePFvvE($0) {\n $0 = $0 | 0;\n var sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16 | 0;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16);\n FUNCTION_TABLE_v[$0 & 3]();\n _abort_message(14889, sp);\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINS0_11string_pairELj4096EE8allocateEj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n return __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE8allocateEj(HEAP32[$0 >> 2] | 0, $1 * 24 | 0) | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS3_INS0_11string_pairENS1_IS4_Lj4096EEEEENS1_IS6_Lj4096EEEEELj4096EEC2ERNS0_5arenaILj4096EEE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = $1;\n return;\n}\nfunction stackAlloc(size) {\n size = size | 0;\n var ret = 0;\n ret = STACKTOP;\n STACKTOP = STACKTOP + size | 0;\n STACKTOP = STACKTOP + 15 & -16;\n if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(size | 0);\n return ret | 0;\n}\n\nfunction __ZN10emscripten8internal7InvokerIvJiEE6invokeEPFviEi($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0;\n $2 = __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($1) | 0;\n FUNCTION_TABLE_vi[$0 & 15]($2);\n return;\n}\n\nfunction _arPattDetach($0) {\n $0 = $0 | 0;\n var $$0 = 0, $2 = 0;\n if (!$0) $$0 = -1; else {\n  $2 = $0 + 7062384 | 0;\n  if (!(HEAP32[$2 >> 2] | 0)) $$0 = -1; else {\n   HEAP32[$2 >> 2] = 0;\n   $$0 = 0;\n  }\n }\n return $$0 | 0;\n}\n\nfunction _arSetLabelingThreshModeAutoInterval($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (!$0) $$0 = -1; else {\n  HEAP32[$0 + 7062392 >> 2] = $1;\n  HEAP32[$0 + 7062396 >> 2] = 0;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EEC2IS4_EERKNS1_IT_Lj4096EEE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = HEAP32[$1 >> 2];\n return;\n}\n\nfunction _byteSwapDouble($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) == 8) break;\n  HEAP8[$1 + $$0 >> 0] = HEAP8[$0 + (7 - $$0) >> 0] | 0;\n  $$0 = $$0 + 1 | 0;\n }\n return;\n}\n\nfunction dynCall_viiiii(index, a1, a2, a3, a4, a5) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n a3 = a3 | 0;\n a4 = a4 | 0;\n a5 = a5 | 0;\n FUNCTION_TABLE_viiiii[index & 3](a1 | 0, a2 | 0, a3 | 0, a4 | 0, a5 | 0);\n}\n\nfunction _arGetLabelingThreshMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (($0 | 0) != 0 & ($1 | 0) != 0) {\n  HEAP32[$1 >> 2] = HEAP32[$0 + 7062388 >> 2];\n  $$0 = 0;\n } else $$0 = -1;\n return $$0 | 0;\n}\n\nfunction _byteSwapInt($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n $$0 = 0;\n while (1) {\n  if (($$0 | 0) == 4) break;\n  HEAP8[$1 + $$0 >> 0] = HEAP8[$0 + (3 - $$0) >> 0] | 0;\n  $$0 = $$0 + 1 | 0;\n }\n return;\n}\n\nfunction ___lctrans_impl($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (!$1) $$0 = 0; else $$0 = ___mo_lookup(HEAP32[$1 >> 2] | 0, HEAP32[$1 + 4 >> 2] | 0, $0) | 0;\n return (($$0 | 0) == 0 ? $0 : $$0) | 0;\n}\n\nfunction _arImageProcInit($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0;\n $2 = _malloc(2064) | 0;\n if ($2 | 0) {\n  HEAP32[$2 >> 2] = 0;\n  HEAP32[$2 + 4 >> 2] = $0;\n  HEAP32[$2 + 8 >> 2] = $1;\n }\n return $2 | 0;\n}\n\nfunction __ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n return __ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, $1, 0) | 0;\n}\n\nfunction _arGetMatrixCodeType($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (($0 | 0) != 0 & ($1 | 0) != 0) {\n  HEAP32[$1 >> 2] = HEAP32[$0 + 7062424 >> 2];\n  $$0 = 0;\n } else $$0 = -1;\n return $$0 | 0;\n}\n\nfunction _arSetPattRatio($0, $1) {\n $0 = $0 | 0;\n $1 = +$1;\n var $$0 = 0;\n if (!$0) $$0 = -1; else if ($1 <= 0.0 | $1 >= 1.0) $$0 = -1; else {\n  HEAPF64[$0 + 7062416 >> 3] = $1;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction ___strdup($0) {\n $0 = $0 | 0;\n var $$0 = 0, $2 = 0, $3 = 0;\n $2 = (_strlen($0) | 0) + 1 | 0;\n $3 = _malloc($2) | 0;\n if (!$3) $$0 = 0; else $$0 = _memcpy($3 | 0, $0 | 0, $2 | 0) | 0;\n return $$0 | 0;\n}\n\nfunction _arGetLabelingThresh($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (($0 | 0) != 0 & ($1 | 0) != 0) {\n  HEAP32[$1 >> 2] = HEAP32[$0 + 16 >> 2];\n  $$0 = 0;\n } else $$0 = -1;\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINSt3__26vectorINS0_11string_pairENS1_IS4_Lj4096EEEEELj4096EEC2ERNS0_5arenaILj4096EEE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = $1;\n return;\n}\n\nfunction _arGetLabelingMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (($0 | 0) != 0 & ($1 | 0) != 0) {\n  HEAP32[$1 >> 2] = HEAP32[$0 + 12 >> 2];\n  $$0 = 0;\n } else $$0 = -1;\n return $$0 | 0;\n}\n\nfunction __ZNSt3__213__vector_baseI12multi_markerNS_9allocatorIS1_EEED2Ev($0) {\n $0 = $0 | 0;\n var $1 = 0;\n $1 = HEAP32[$0 >> 2] | 0;\n if ($1 | 0) {\n  HEAP32[$0 + 4 >> 2] = $1;\n  __ZdlPv($1);\n }\n return;\n}\n\nfunction _i64Subtract(a, b, c, d) {\n a = a | 0;\n b = b | 0;\n c = c | 0;\n d = d | 0;\n var h = 0;\n h = b - d >>> 0;\n h = b - d - (c >>> 0 > a >>> 0 | 0) >>> 0;\n return (tempRet0 = h, a - c >>> 0 | 0) | 0;\n}\n\nfunction ___syscall_ret($0) {\n $0 = $0 | 0;\n var $$0 = 0, $3 = 0;\n if ($0 >>> 0 > 4294963200) {\n  $3 = ___errno_location() | 0;\n  HEAP32[$3 >> 2] = 0 - $0;\n  $$0 = -1;\n } else $$0 = $0;\n return $$0 | 0;\n}\n\nfunction dynCall_iiiii(index, a1, a2, a3, a4) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n a3 = a3 | 0;\n a4 = a4 | 0;\n return FUNCTION_TABLE_iiiii[index & 1](a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0;\n}\n\nfunction _arSetPatternDetectionMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (($0 | 0) != 0 & $1 >>> 0 < 5) {\n  HEAP32[$0 + 24 >> 2] = $1;\n  $$0 = 0;\n } else $$0 = -1;\n return $$0 | 0;\n}\n\nfunction __ZNKSt3__26vectorINS0_INS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEEENS4_IS8_Lj4096EEEE8max_sizeEv($0) {\n $0 = $0 | 0;\n return 268435455;\n}\n\nfunction _arGetDebugMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (($0 | 0) != 0 & ($1 | 0) != 0) {\n  HEAP32[$1 >> 2] = HEAP32[$0 >> 2];\n  $$0 = 0;\n } else $$0 = -1;\n return $$0 | 0;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewItEEvPKc($0) {\n $0 = $0 | 0;\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewItEEE3getEv() | 0, 3, $0 | 0);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIsEEvPKc($0) {\n $0 = $0 | 0;\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIsEEE3getEv() | 0, 2, $0 | 0);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIjEEvPKc($0) {\n $0 = $0 | 0;\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIjEEE3getEv() | 0, 5, $0 | 0);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIiEEvPKc($0) {\n $0 = $0 | 0;\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIiEEE3getEv() | 0, 4, $0 | 0);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIhEEvPKc($0) {\n $0 = $0 | 0;\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIhEEE3getEv() | 0, 1, $0 | 0);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIaEEvPKc($0) {\n $0 = $0 | 0;\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIaEEE3getEv() | 0, 0, $0 | 0);\n return;\n}\n\nfunction _arSetLabelingThresh($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (($0 | 0) == 0 | $1 >>> 0 > 255) $$0 = -1; else {\n  HEAP32[$0 + 16 >> 2] = $1;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction ___DOUBLE_BITS_677($0) {\n $0 = +$0;\n var $1 = 0;\n HEAPF64[tempDoublePtr >> 3] = $0;\n $1 = HEAP32[tempDoublePtr >> 2] | 0;\n tempRet0 = HEAP32[tempDoublePtr + 4 >> 2] | 0;\n return $1 | 0;\n}\n\nfunction ___DOUBLE_BITS_563($0) {\n $0 = +$0;\n var $1 = 0;\n HEAPF64[tempDoublePtr >> 3] = $0;\n $1 = HEAP32[tempDoublePtr >> 2] | 0;\n tempRet0 = HEAP32[tempDoublePtr + 4 >> 2] | 0;\n return $1 | 0;\n}\n\nfunction __ZNSt3__211char_traitsIcE7compareEPKcS3_j($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n var $$0 = 0;\n if (!$2) $$0 = 0; else $$0 = _memcmp($0, $1, $2) | 0;\n return $$0 | 0;\n}\n\nfunction _arSetImageProcMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (($0 | 0) != 0 & $1 >>> 0 < 2) {\n  HEAP32[$0 + 20 >> 2] = $1;\n  $$0 = 0;\n } else $$0 = -1;\n return $$0 | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiiiEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiiiiEEEE3getEv() | 0;\n}\n\nfunction _arSetLabelingMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (($0 | 0) != 0 & $1 >>> 0 < 2) {\n  HEAP32[$0 + 12 >> 2] = $1;\n  $$0 = 0;\n } else $$0 = -1;\n return $$0 | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJviiEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJviiEEEE3getEv() | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvifEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvifEEEE3getEv() | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvidEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvidEEEE3getEv() | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiiEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiiiEEEE3getEv() | 0;\n}\n\nfunction dynCall_viiii(index, a1, a2, a3, a4) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n a3 = a3 | 0;\n a4 = a4 | 0;\n FUNCTION_TABLE_viiii[index & 3](a1 | 0, a2 | 0, a3 | 0, a4 | 0);\n}\n\nfunction _icpDeleteHandle($0) {\n $0 = $0 | 0;\n var $$0 = 0, $1 = 0;\n $1 = HEAP32[$0 >> 2] | 0;\n if (!$1) $$0 = -1; else {\n  _free($1);\n  HEAP32[$0 >> 2] = 0;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJviEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJviEEEE3getEv() | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiiEEEE3getEv() | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJdiEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJdiEEEE3getEv() | 0;\n}\n\nfunction _arGetPatternDetectionMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (!$0) $$0 = -1; else {\n  HEAP32[$1 >> 2] = HEAP32[$0 + 24 >> 2];\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiEE8getTypesEv($0) {\n $0 = $0 | 0;\n return __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiEEEE3getEv() | 0;\n}\n\nfunction _arGetPattRatio($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (!$0) $$0 = -1; else {\n  HEAPF64[$1 >> 3] = +HEAPF64[$0 + 7062416 >> 3];\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE17pointer_in_bufferEPc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n return ($0 + 4096 | 0) >>> 0 >= $1 >>> 0 & $0 >>> 0 <= $1 >>> 0 | 0;\n}\n\nfunction _arGetImageProcMode($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (!$0) $$0 = -1; else {\n  HEAP32[$1 >> 2] = HEAP32[$0 + 20 >> 2];\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewImEEvPKc() {\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewImEEE3getEv() | 0, 5, 11236);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIlEEvPKc() {\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIlEEE3getEv() | 0, 4, 11306);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIfEEvPKc() {\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIfEEE3getEv() | 0, 6, 11174);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIeEEvPKc() {\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIeEEE3getEv() | 0, 7, 11043);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIdEEvPKc() {\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIdEEE3getEv() | 0, 7, 11111);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_120register_memory_viewIcEEvPKc() {\n __embind_register_memory_view(__ZN10emscripten8internal6TypeIDINS_11memory_viewIcEEE3getEv() | 0, 0, 11553);\n return;\n}\n\nfunction _i64Add(a, b, c, d) {\n a = a | 0;\n b = b | 0;\n c = c | 0;\n d = d | 0;\n var l = 0;\n l = a + c >>> 0;\n return (tempRet0 = b + d + (l >>> 0 < a >>> 0 | 0) >>> 0, l | 0) | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEEE8getCountEv($0) {\n $0 = $0 | 0;\n return 3;\n}\n\nfunction __ZN12_GLOBAL__N_116register_integerIlEEvPKc() {\n __embind_register_integer(__ZN10emscripten8internal6TypeIDIlE3getEv() | 0, 16583, 4, -2147483648, 2147483647);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_116register_integerIiEEvPKc() {\n __embind_register_integer(__ZN10emscripten8internal6TypeIDIiE3getEv() | 0, 16566, 4, -2147483648, 2147483647);\n return;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiNSt3__212basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEEEE8getCountEv($0) {\n $0 = $0 | 0;\n return 2;\n}\n\nfunction __ZNKSt3__26vectorINS0_IN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEEENS4_IS6_Lj4096EEEE8max_sizeEv($0) {\n $0 = $0 | 0;\n return 268435455;\n}\n\nfunction dynCall_iiii(index, a1, a2, a3) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n a3 = a3 | 0;\n return FUNCTION_TABLE_iiii[index & 15](a1 | 0, a2 | 0, a3 | 0) | 0;\n}\n\nfunction _arSetMatrixCodeType($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (!$0) $$0 = -1; else {\n  HEAP32[$0 + 7062424 >> 2] = $1;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction _arGetTransMatMultiSquareRobust($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n return +(+_arGetTransMatMultiSquare2($0, $1, $2, $3, 1));\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_111short_allocINS0_11string_pairELj4096EEC2ERNS0_5arenaILj4096EEE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = $1;\n return;\n}\n\nfunction __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev($0) {\n $0 = $0 | 0;\n if ((HEAP8[$0 + 11 >> 0] | 0) < 0) __ZdlPv(HEAP32[$0 >> 2] | 0);\n return;\n}\n\nfunction _icpSetInlierProbability($0, $1) {\n $0 = $0 | 0;\n $1 = +$1;\n var $$0 = 0;\n if (!$0) $$0 = -1; else {\n  HEAPF64[$0 + 128 >> 3] = $1;\n  $$0 = 0;\n }\n return $$0 | 0;\n}\n\nfunction ___udivdi3($a$0, $a$1, $b$0, $b$1) {\n $a$0 = $a$0 | 0;\n $a$1 = $a$1 | 0;\n $b$0 = $b$0 | 0;\n $b$1 = $b$1 | 0;\n return ___udivmoddi4($a$0, $a$1, $b$0, $b$1, 0) | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_110save_valueIbEC2ERb($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = $1;\n HEAP8[$0 + 4 >> 0] = HEAP8[$1 >> 0] | 0;\n return;\n}\n\nfunction _strchr($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0;\n $2 = ___strchrnul($0, $1) | 0;\n return ((HEAP8[$2 >> 0] | 0) == ($1 & 255) << 24 >> 24 ? $2 : 0) | 0;\n}\n\nfunction __ZNSt3__211char_traitsIcE4moveEPcPKcj($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n if ($2 | 0) _memmove($0 | 0, $1 | 0, $2 | 0) | 0;\n return $0 | 0;\n}\n\nfunction _arImageProcLumaHistAndCDFAndMedian($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n return _arImageProcLumaHistAndCDFAndPercentile($0, $1, .5, $2) | 0;\n}\n\nfunction __ZNSt3__211char_traitsIcE4copyEPcPKcj($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n if ($2 | 0) _memcpy($0 | 0, $1 | 0, $2 | 0) | 0;\n return $0 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_110save_valueIjEC2ERj($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = $1;\n HEAP32[$0 + 4 >> 2] = HEAP32[$1 >> 2];\n return;\n}\n\nfunction __ZN12_GLOBAL__N_116register_integerIsEEvPKc() {\n __embind_register_integer(__ZN10emscripten8internal6TypeIDIsE3getEv() | 0, 16361, 2, -32768, 32767);\n return;\n}\n\nfunction _arGetTransMatMultiSquare($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n return +(+_arGetTransMatMultiSquare2($0, $1, $2, $3, 0));\n}\n\nfunction __ZN12_GLOBAL__N_116register_integerIcEEvPKc() {\n __embind_register_integer(__ZN10emscripten8internal6TypeIDIcE3getEv() | 0, 16330, 1, -128, 127);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_116register_integerIaEEvPKc() {\n __embind_register_integer(__ZN10emscripten8internal6TypeIDIaE3getEv() | 0, 16335, 1, -128, 127);\n return;\n}\n\nfunction _icpGetXw2XcCleanup_221($0, $1, $2, $3) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n $3 = $3 | 0;\n _free($0);\n _free($1);\n _free($2);\n _free($3);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_116register_integerItEEvPKc() {\n __embind_register_integer(__ZN10emscripten8internal6TypeIDItE3getEv() | 0, 16367, 2, 0, 65535);\n return;\n}\n\nfunction _arMatrixSelfInv($0) {\n $0 = $0 | 0;\n var $3 = 0;\n $3 = HEAP32[$0 + 4 >> 2] | 0;\n return ((_minv(HEAP32[$0 >> 2] | 0, $3, $3) | 0) == 0) << 31 >> 31 | 0;\n}\n\nfunction __ZNSt3__214__ptr_in_rangeIcEEbPKT_S3_S3_($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n return $1 >>> 0 <= $0 >>> 0 & $0 >>> 0 < $2 >>> 0 | 0;\n}\n\nfunction dynCall_viii(index, a1, a2, a3) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n a3 = a3 | 0;\n FUNCTION_TABLE_viii[index & 1](a1 | 0, a2 | 0, a3 | 0);\n}\n\nfunction __ZNSt11logic_errorC2EPKc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP32[$0 >> 2] = 3424;\n __ZNSt3__218__libcpp_refstringC2EPKc($0 + 4 | 0, $1);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_116register_integerIhEEvPKc() {\n __embind_register_integer(__ZN10emscripten8internal6TypeIDIhE3getEv() | 0, 16347, 1, 0, 255);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_116register_integerImEEvPKc() {\n __embind_register_integer(__ZN10emscripten8internal6TypeIDImE3getEv() | 0, 16588, 4, 0, -1);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_116register_integerIjEEvPKc() {\n __embind_register_integer(__ZN10emscripten8internal6TypeIDIjE3getEv() | 0, 16570, 4, 0, -1);\n return;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiiNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEEE3getEv() {\n return 2044;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiNSt3__212basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEEEEE3getEv() {\n return 2024;\n}\n\nfunction _fputs($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $2 = 0;\n $2 = _strlen($0) | 0;\n return ((_fwrite($0, 1, $2, $1) | 0) != ($2 | 0)) << 31 >> 31 | 0;\n}\n\nfunction _compE($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $4 = 0.0;\n $4 = +HEAPF64[$0 >> 3] - +HEAPF64[$1 >> 3];\n return ($4 < 0.0 ? -1 : $4 > 0.0 & 1) | 0;\n}\n\nfunction dynCall_viid(index, a1, a2, a3) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n a3 = +a3;\n FUNCTION_TABLE_viid[index & 3](a1 | 0, a2 | 0, +a3);\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewItEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewItEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIsEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIsEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewImEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewImEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIlEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIlEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIjEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIjEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIiEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIiEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIhEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIhEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIfEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIfEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIeEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIeEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIdEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIdEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIcEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIcEEE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_11memory_viewIaEEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIaEEE3getEv() | 0;\n}\n\nfunction establishStackSpace(stackBase, stackMax) {\n stackBase = stackBase | 0;\n stackMax = stackMax | 0;\n STACKTOP = stackBase;\n STACK_MAX = stackMax;\n}\n\nfunction ___cxx_global_var_init_1() {\n HEAP32[4344] = 0;\n HEAP32[4345] = 0;\n HEAP32[4346] = 0;\n HEAP32[4347] = 0;\n HEAP32[4348] = 1065353216;\n return;\n}\n\nfunction __ZNKSt3__26vectorIN10__cxxabiv112_GLOBAL__N_111string_pairENS2_11short_allocIS3_Lj4096EEEE8max_sizeEv($0) {\n $0 = $0 | 0;\n return 178956970;\n}\n\nfunction __ZN12_GLOBAL__N_114register_floatIfEEvPKc() {\n __embind_register_float(__ZN10emscripten8internal6TypeIDIfE3getEv() | 0, 16612, 4);\n return;\n}\n\nfunction __ZN12_GLOBAL__N_114register_floatIdEEvPKc() {\n __embind_register_float(__ZN10emscripten8internal6TypeIDIdE3getEv() | 0, 16724, 8);\n return;\n}\n\nfunction ___cxx_global_var_init() {\n HEAP32[4339] = 0;\n HEAP32[4340] = 0;\n HEAP32[4341] = 0;\n HEAP32[4342] = 0;\n HEAP32[4343] = 1065353216;\n return;\n}\n\nfunction _strerror($0) {\n $0 = $0 | 0;\n var $2 = 0;\n $2 = (___pthread_self_85() | 0) + 188 | 0;\n return ___strerror_l($0, HEAP32[$2 >> 2] | 0) | 0;\n}\n\nfunction dynCall_iii(index, a1, a2) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n return FUNCTION_TABLE_iii[index & 15](a1 | 0, a2 | 0) | 0;\n}\n\nfunction b15(p0, p1, p2, p3, p4, p5) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n p2 = p2 | 0;\n p3 = p3 | 0;\n p4 = p4 | 0;\n p5 = p5 | 0;\n nullFunc_viiiiii(15);\n}\n\nfunction _dot($0, $1, $2, $3, $4, $5) {\n $0 = +$0;\n $1 = +$1;\n $2 = +$2;\n $3 = +$3;\n $4 = +$4;\n $5 = +$5;\n return +($0 * $3 + $1 * $4 + $2 * $5);\n}\n\nfunction __ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n return ($0 | 0) == ($1 | 0) | 0;\n}\n\nfunction __ZN10__cxxabiv123__fundamental_type_infoD0Ev($0) {\n $0 = $0 | 0;\n __ZN10__cxxabiv116__shim_type_infoD2Ev($0);\n __ZdlPv($0);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_110save_valueIbED2Ev($0) {\n $0 = $0 | 0;\n HEAP8[HEAP32[$0 >> 2] >> 0] = HEAP8[$0 + 4 >> 0] | 0;\n return;\n}\n\nfunction dynCall_dii(index, a1, a2) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n return +FUNCTION_TABLE_dii[index & 1](a1 | 0, a2 | 0);\n}\n\nfunction __ZN12arControllerD2Ev($0) {\n $0 = $0 | 0;\n __ZNSt3__213__vector_baseI12multi_markerNS_9allocatorIS1_EEED2Ev($0 + 248 | 0);\n return;\n}\n\nfunction _wctomb($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $$0 = 0;\n if (!$0) $$0 = 0; else $$0 = _wcrtomb($0, $1, 0) | 0;\n return $$0 | 0;\n}\n\nfunction _out_670($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n if (!(HEAP32[$0 >> 2] & 32)) ___fwritex($1, $2, $0) | 0;\n return;\n}\n\nfunction __ZN10__cxxabiv121__vmi_class_type_infoD0Ev($0) {\n $0 = $0 | 0;\n __ZN10__cxxabiv116__shim_type_infoD2Ev($0);\n __ZdlPv($0);\n return;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_110save_valueIjED2Ev($0) {\n $0 = $0 | 0;\n HEAP32[HEAP32[$0 >> 2] >> 2] = HEAP32[$0 + 4 >> 2];\n return;\n}\nfunction _swapc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n var $3 = 0;\n $3 = _llvm_bswap_i32($0 | 0) | 0;\n return (($1 | 0) == 0 ? $0 : $3) | 0;\n}\n\nfunction __ZN10__cxxabiv120__si_class_type_infoD0Ev($0) {\n $0 = $0 | 0;\n __ZN10__cxxabiv116__shim_type_infoD2Ev($0);\n __ZdlPv($0);\n return;\n}\n\nfunction __GLOBAL__sub_I_ARToolKitJS_cpp() {\n ___cxx_global_var_init();\n ___cxx_global_var_init_1();\n ___cxx_global_var_init_22();\n return;\n}\n\nfunction setThrew(threw, value) {\n threw = threw | 0;\n value = value | 0;\n if (!__THREW__) {\n  __THREW__ = threw;\n  threwValue = value;\n }\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv() {\n return 144;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv() {\n return 168;\n}\n\nfunction __ZN10__cxxabiv117__class_type_infoD0Ev($0) {\n $0 = $0 | 0;\n __ZN10__cxxabiv116__shim_type_infoD2Ev($0);\n __ZdlPv($0);\n return;\n}\n\nfunction __ZNSt11logic_errorD2Ev($0) {\n $0 = $0 | 0;\n HEAP32[$0 >> 2] = 3424;\n __ZNSt3__218__libcpp_refstringD2Ev($0 + 4 | 0);\n return;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv() {\n return 8;\n}\n\nfunction dynCall_vii(index, a1, a2) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = a2 | 0;\n FUNCTION_TABLE_vii[index & 7](a1 | 0, a2 | 0);\n}\n\nfunction __ZNSt3__211char_traitsIcE6assignERcRKc($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n HEAP8[$0 >> 0] = HEAP8[$1 >> 0] | 0;\n return;\n}\n\nfunction __ZN10emscripten8internal6TypeIDINS_3valEE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDINS_3valEE3getEv() | 0;\n}\n\nfunction dynCall_vid(index, a1, a2) {\n index = index | 0;\n a1 = a1 | 0;\n a2 = +a2;\n FUNCTION_TABLE_vid[index & 3](a1 | 0, +a2);\n}\n\nfunction _llvm_bswap_i32(x) {\n x = x | 0;\n return (x & 255) << 24 | (x >> 8 & 255) << 16 | (x >> 16 & 255) << 8 | x >>> 24 | 0;\n}\n\nfunction b14(p0, p1, p2, p3, p4) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n p2 = p2 | 0;\n p3 = p3 | 0;\n p4 = p4 | 0;\n nullFunc_viiiii(14);\n}\n\nfunction _mbsinit($0) {\n $0 = $0 | 0;\n var $4 = 0;\n if (!$0) $4 = 1; else $4 = (HEAP32[$0 >> 2] | 0) == 0 & 1;\n return $4 | 0;\n}\n\nfunction __ZNSt3__215__refstring_imp12_GLOBAL__N_113data_from_repEPNS1_9_Rep_baseE($0) {\n $0 = $0 | 0;\n return $0 + 12 | 0;\n}\n\nfunction __ZNKSt11logic_error4whatEv($0) {\n $0 = $0 | 0;\n return __ZNKSt3__218__libcpp_refstring5c_strEv($0 + 4 | 0) | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIRKiE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIRKiE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIRKdE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIRKdE3getEv() | 0;\n}\n\nfunction _strncpy($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n ___stpncpy($0, $1, $2) | 0;\n return $0 | 0;\n}\n\nfunction dynCall_ii(index, a1) {\n index = index | 0;\n a1 = a1 | 0;\n return FUNCTION_TABLE_ii[index & 31](a1 | 0) | 0;\n}\n\nfunction ___cxx_global_var_init_125() {\n __ZN53EmscriptenBindingInitializer_native_and_builtin_typesC2Ev(0);\n return;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIvE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIvE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDItE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDItE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIsE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIsE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDImE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDImE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIlE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIlE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIjE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIjE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIiE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIiE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIhE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIhE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIfE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIfE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIdE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIdE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIcE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIcE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIbE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIbE3getEv() | 0;\n}\n\nfunction __ZN10emscripten8internal6TypeIDIaE3getEv() {\n return __ZN10emscripten8internal11LightTypeIDIaE3getEv() | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EEC2Ev($0) {\n $0 = $0 | 0;\n HEAP32[$0 + 4096 >> 2] = $0;\n return;\n}\n\nfunction b6(p0, p1, p2, p3) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n p2 = p2 | 0;\n p3 = p3 | 0;\n nullFunc_iiiii(6);\n return 0;\n}\n\nfunction _norm($0, $1, $2) {\n $0 = +$0;\n $1 = +$1;\n $2 = +$2;\n return +(+Math_sqrt(+($0 * $0 + $1 * $1 + $2 * $2)));\n}\n\nfunction _arImageProcFinal($0) {\n $0 = $0 | 0;\n if ($0 | 0) {\n  _free(HEAP32[$0 >> 2] | 0);\n  _free($0);\n }\n return;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiiiEE8getCountEv($0) {\n $0 = $0 | 0;\n return 4;\n}\n\nfunction __ZN10emscripten8internal11BindingTypeIdE10toWireTypeERKd($0) {\n $0 = $0 | 0;\n return +(+HEAPF64[$0 >> 3]);\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EED2Ev($0) {\n $0 = $0 | 0;\n HEAP32[$0 + 4096 >> 2] = 0;\n return;\n}\n\nfunction _isxdigit($0) {\n $0 = $0 | 0;\n return ((($0 | 32) + -97 | 0) >>> 0 < 6 | (_isdigit($0) | 0) != 0) & 1 | 0;\n}\n\nfunction __ZNSt3__215__refstring_imp12_GLOBAL__N_113rep_from_dataEPKc_350($0) {\n $0 = $0 | 0;\n return $0 + -12 | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJviiEE8getCountEv($0) {\n $0 = $0 | 0;\n return 3;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvifEE8getCountEv($0) {\n $0 = $0 | 0;\n return 3;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvidEE8getCountEv($0) {\n $0 = $0 | 0;\n return 3;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiiEE8getCountEv($0) {\n $0 = $0 | 0;\n return 3;\n}\n\nfunction __ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($0) {\n $0 = $0 | 0;\n return HEAP32[$0 >> 2] | 0;\n}\n\nfunction _strrchr($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n return ___memrchr($0, $1, (_strlen($0) | 0) + 1 | 0) | 0;\n}\n\nfunction _arMatrixFree($0) {\n $0 = $0 | 0;\n if ($0 | 0) {\n  _free(HEAP32[$0 >> 2] | 0);\n  _free($0);\n }\n return 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJviEE8getCountEv($0) {\n $0 = $0 | 0;\n return 2;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiiEE8getCountEv($0) {\n $0 = $0 | 0;\n return 2;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJdiEE8getCountEv($0) {\n $0 = $0 | 0;\n return 2;\n}\n\nfunction dynCall_di(index, a1) {\n index = index | 0;\n a1 = a1 | 0;\n return +FUNCTION_TABLE_di[index & 3](a1 | 0);\n}\n\nfunction _do_read($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n return ___string_read($0, $1, $2) | 0;\n}\n\nfunction __ZSt15get_new_handlerv() {\n var $0 = 0;\n $0 = HEAP32[4504] | 0;\n HEAP32[4504] = $0 + 0;\n return $0 | 0;\n}\n\nfunction __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiEE8getCountEv($0) {\n $0 = $0 | 0;\n return 1;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE10deallocateEPcj($0) {\n $0 = $0 | 0;\n _free($0);\n return;\n}\n\nfunction __ZNSt3__24pairIKi12arControllerED2Ev($0) {\n $0 = $0 | 0;\n __ZN12arControllerD2Ev($0 + 8 | 0);\n return;\n}\n\nfunction __ZNKSt3__26vectorI12multi_markerNS_9allocatorIS1_EEE8max_sizeEv($0) {\n $0 = $0 | 0;\n return 536870911;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_15arenaILj4096EE8align_upEj($0) {\n $0 = $0 | 0;\n return $0 + 15 & -16 | 0;\n}\n\nfunction __ZN10__cxxabiv112_GLOBAL__N_112malloc_allocIcE8allocateEj($0) {\n $0 = $0 | 0;\n return _malloc($0) | 0;\n}\n\nfunction ___cxx_global_var_init_22() {\n __ZN46EmscriptenBindingInitializer_constant_bindingsC2Ev(0);\n return;\n}\n\nfunction __ZSt13get_terminatev() {\n var $0 = 0;\n $0 = HEAP32[833] | 0;\n HEAP32[833] = $0 + 0;\n return $0 | 0;\n}\n\nfunction b13(p0, p1, p2, p3) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n p2 = p2 | 0;\n p3 = p3 | 0;\n nullFunc_viiii(13);\n}\n\nfunction dynCall_vi(index, a1) {\n index = index | 0;\n a1 = a1 | 0;\n FUNCTION_TABLE_vi[index & 15](a1 | 0);\n}\n\nfunction _fseek($0, $1, $2) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n $2 = $2 | 0;\n return ___fseeko($0, $1, $2) | 0;\n}\n\nfunction ___clang_call_terminate($0) {\n $0 = $0 | 0;\n ___cxa_begin_catch($0 | 0) | 0;\n __ZSt9terminatev();\n}\n\nfunction __ZNSt12length_errorD0Ev($0) {\n $0 = $0 | 0;\n __ZNSt11logic_errorD2Ev($0);\n __ZdlPv($0);\n return;\n}\n\nfunction __ZNSt11logic_errorD0Ev($0) {\n $0 = $0 | 0;\n __ZNSt11logic_errorD2Ev($0);\n __ZdlPv($0);\n return;\n}\n\nfunction __ZNKSt3__221__basic_string_commonILb1EE20__throw_out_of_rangeEv($0) {\n $0 = $0 | 0;\n _abort();\n}\n\nfunction __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv($0) {\n $0 = $0 | 0;\n _abort();\n}\n\nfunction __ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv($0) {\n $0 = $0 | 0;\n _abort();\n}\n\nfunction __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($0) {\n $0 = $0 | 0;\n return $0 | 0;\n}\n\nfunction _llvm_cttz_i32(x) {\n x = x | 0;\n return (x ? 31 - (Math_clz32(x ^ x - 1) | 0) | 0 : 32) | 0;\n}\n\nfunction _icpGetXw2XcCleanup($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n _free($0);\n _free($1);\n return;\n}\n\nfunction _arMultiFreeConfig($0) {\n $0 = $0 | 0;\n _free(HEAP32[$0 >> 2] | 0);\n _free($0);\n return 0;\n}\n\nfunction __ZN10emscripten8internal14asGenericValueIdEEjT_($0) {\n $0 = +$0;\n return ~~$0 >>> 0 | 0;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiiiiEEEE3getEv() {\n return 2064;\n}\n\nfunction b5(p0, p1, p2) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n p2 = p2 | 0;\n nullFunc_iiii(5);\n return 0;\n}\n\nfunction _isspace($0) {\n $0 = $0 | 0;\n return (($0 | 0) == 32 | ($0 + -9 | 0) >>> 0 < 5) & 1 | 0;\n}\n\nfunction __ZNKSt3__218__libcpp_refstring5c_strEv($0) {\n $0 = $0 | 0;\n return HEAP32[$0 >> 2] | 0;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJviiEEEE3getEv() {\n return 1980;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvifEEEE3getEv() {\n return 1968;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiiiEEEE3getEv() {\n return 2032;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvidEEEE3getEv() {\n return 2e3;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJviEEEE3getEv() {\n return 2016;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiiEEEE3getEv() {\n return 2056;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJdiEEEE3getEv() {\n return 1992;\n}\n\nfunction __ZN10emscripten8internal11BindingTypeIfE12fromWireTypeEf($0) {\n $0 = +$0;\n return +$0;\n}\n\nfunction __ZN10emscripten8internal11BindingTypeIdE12fromWireTypeEd($0) {\n $0 = +$0;\n return +$0;\n}\n\nfunction __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiEEEE3getEv() {\n return 2012;\n}\n\nfunction ___lctrans($0, $1) {\n $0 = $0 | 0;\n $1 = $1 | 0;\n return ___lctrans_impl($0, $1) | 0;\n}\n\nfunction __ZN10emscripten8internal14asGenericValueIiEEjT_($0) {\n $0 = $0 | 0;\n return $0 | 0;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIsEEE3getEv() {\n return 104;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIhEEE3getEv() {\n return 112;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIcEEE3getEv() {\n return 128;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIaEEE3getEv() {\n return 120;\n}\n\nfunction _arVecFree($0) {\n $0 = $0 | 0;\n _free(HEAP32[$0 >> 2] | 0);\n _free($0);\n return 0;\n}\n\nfunction ___getTypeName($0) {\n $0 = $0 | 0;\n return ___strdup(HEAP32[$0 + 4 >> 2] | 0) | 0;\n}\n\nfunction __ZNSt3__211char_traitsIcE6lengthEPKc($0) {\n $0 = $0 | 0;\n return _strlen($0) | 0;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewItEEE3getEv() {\n return 96;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewImEEE3getEv() {\n return 64;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIlEEE3getEv() {\n return 72;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIjEEE3getEv() {\n return 80;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIiEEE3getEv() {\n return 88;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIfEEE3getEv() {\n return 56;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIeEEE3getEv() {\n return 40;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIdEEE3getEv() {\n return 48;\n}\n\nfunction dynCall_i(index) {\n index = index | 0;\n return FUNCTION_TABLE_i[index & 1]() | 0;\n}\n\nfunction _ar3DCreateHandle($0) {\n $0 = $0 | 0;\n return _ar3DCreateHandle2($0 + 8 | 0) | 0;\n}\n\nfunction __ZNKSt3__218__libcpp_refstring15__uses_refcountEv($0) {\n $0 = $0 | 0;\n return 1;\n}\n\nfunction b12(p0, p1, p2) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n p2 = p2 | 0;\n nullFunc_viii(12);\n}\n\nfunction __ZN10emscripten8internal19getGenericSignatureIJiiiiiEEEPKcv() {\n return 10058;\n}\n\nfunction __ZN10emscripten8internal19getGenericSignatureIJviiiEEEPKcv() {\n return 8036;\n}\n\nfunction __ZN10emscripten8internal19getGenericSignatureIJviifEEEPKcv() {\n return 7944;\n}\n\nfunction __ZN10emscripten8internal19getGenericSignatureIJviidEEEPKcv() {\n return 8071;\n}\n\nfunction __ZN10emscripten8internal19getGenericSignatureIJiiiiEEEPKcv() {\n return 9887;\n}\n\nfunction b11(p0, p1, p2) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n p2 = +p2;\n nullFunc_viid(11);\n}\n\nfunction __ZN10emscripten8internal19getGenericSignatureIJviiEEEPKcv() {\n return 8079;\n}\n\nfunction __ZN10emscripten8internal19getGenericSignatureIJiiiEEEPKcv() {\n return 9723;\n}\n\nfunction __ZN10emscripten8internal19getGenericSignatureIJdiiEEEPKcv() {\n return 8067;\n}\n\nfunction ___emscripten_environ_constructor() {\n ___buildEnvironment(18004);\n return;\n}\n\nfunction __ZN10emscripten8internal19getGenericSignatureIJiiEEEPKcv() {\n return 8076;\n}\n\nfunction _copysignl($0, $1) {\n $0 = +$0;\n $1 = +$1;\n return +(+_copysign($0, $1));\n}\n\nfunction _scalbnl($0, $1) {\n $0 = +$0;\n $1 = $1 | 0;\n return +(+_scalbn($0, $1));\n}\n\nfunction __ZNK10__cxxabiv116__shim_type_info5noop2Ev($0) {\n $0 = $0 | 0;\n return;\n}\n\nfunction __ZNK10__cxxabiv116__shim_type_info5noop1Ev($0) {\n $0 = $0 | 0;\n return;\n}\n\nfunction b1(p0, p1) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n nullFunc_dii(1);\n return 0.0;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDINS_3valEE3getEv() {\n return 136;\n}\n\nfunction dynCall_v(index) {\n index = index | 0;\n FUNCTION_TABLE_v[index & 3]();\n}\n\nfunction _frexpl($0, $1) {\n $0 = +$0;\n $1 = $1 | 0;\n return +(+_frexp($0, $1));\n}\n\nfunction b4(p0, p1) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n nullFunc_iii(4);\n return 0;\n}\n\nfunction __GLOBAL__sub_I_bind_cpp() {\n ___cxx_global_var_init_125();\n return;\n}\n\nfunction _isupper($0) {\n $0 = $0 | 0;\n return ($0 + -65 | 0) >>> 0 < 26 | 0;\n}\n\nfunction _isdigit($0) {\n $0 = $0 | 0;\n return ($0 + -48 | 0) >>> 0 < 10 | 0;\n}\n\nfunction __ZN10__cxxabiv116__shim_type_infoD2Ev($0) {\n $0 = $0 | 0;\n return;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIRKiE3getEv() {\n return 360;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIRKdE3getEv() {\n return 400;\n}\n\nfunction _fmodl($0, $1) {\n $0 = +$0;\n $1 = +$1;\n return +(+_fmod($0, $1));\n}\n\nfunction _arPattCreateHandle() {\n return _arPattCreateHandle2(16, 50) | 0;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIvE3getEv() {\n return 304;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDItE3getEv() {\n return 352;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIsE3getEv() {\n return 344;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDImE3getEv() {\n return 384;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIlE3getEv() {\n return 376;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIjE3getEv() {\n return 368;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIiE3getEv() {\n return 360;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIhE3getEv() {\n return 328;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIfE3getEv() {\n return 392;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIdE3getEv() {\n return 400;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIcE3getEv() {\n return 320;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIbE3getEv() {\n return 312;\n}\n\nfunction __ZN10emscripten8internal11LightTypeIDIaE3getEv() {\n return 336;\n}\n\nfunction b10(p0, p1) {\n p0 = p0 | 0;\n p1 = p1 | 0;\n nullFunc_vii(10);\n}\n\nfunction _setLogLevel($0) {\n $0 = $0 | 0;\n HEAP32[484] = $0;\n return;\n}\n\nfunction setTempRet0(value) {\n value = value | 0;\n tempRet0 = value;\n}\n\nfunction b9(p0, p1) {\n p0 = p0 | 0;\n p1 = +p1;\n nullFunc_vid(9);\n}\n\nfunction _ftell($0) {\n $0 = $0 | 0;\n return ___ftello($0) | 0;\n}\n\nfunction stackRestore(top) {\n top = top | 0;\n STACKTOP = top;\n}\n\nfunction b0(p0) {\n p0 = p0 | 0;\n nullFunc_di(0);\n return 0.0;\n}\n\nfunction ___pthread_self_910() {\n return _pthread_self() | 0;\n}\n\nfunction ___pthread_self_907() {\n return _pthread_self() | 0;\n}\n\nfunction ___pthread_self_699() {\n return _pthread_self() | 0;\n}\n\nfunction ___pthread_self_85() {\n return _pthread_self() | 0;\n}\n\nfunction b3(p0) {\n p0 = p0 | 0;\n nullFunc_ii(3);\n return 0;\n}\n\nfunction __ZNSt9type_infoD2Ev($0) {\n $0 = $0 | 0;\n return;\n}\n\nfunction __ZNSt9exceptionD2Ev($0) {\n $0 = $0 | 0;\n return;\n}\n\nfunction __ZdlPv($0) {\n $0 = $0 | 0;\n _free($0);\n return;\n}\n\nfunction ___ofl_lock() {\n ___lock(17968);\n return 17976;\n}\n\nfunction ___ofl_unlock() {\n ___unlock(17968);\n return;\n}\n\nfunction _dummy($0) {\n $0 = $0 | 0;\n return $0 | 0;\n}\n\nfunction ___unlockfile($0) {\n $0 = $0 | 0;\n return;\n}\n\nfunction ___lockfile($0) {\n $0 = $0 | 0;\n return 0;\n}\n\nfunction _getLogLevel() {\n return HEAP32[484] | 0;\n}\n\nfunction b8(p0) {\n p0 = p0 | 0;\n nullFunc_vi(8);\n}\n\nfunction getTempRet0() {\n return tempRet0 | 0;\n}\n\nfunction ___errno_location() {\n return 17964;\n}\n\nfunction stackSave() {\n return STACKTOP | 0;\n}\n\nfunction b2() {\n nullFunc_i(2);\n return 0;\n}\n\nfunction __get_daylight() {\n return 17996;\n}\n\nfunction __get_timezone() {\n return 18e3;\n}\n\nfunction __get_environ() {\n return 18004;\n}\n\nfunction _pthread_self() {\n return 2540;\n}\n\nfunction __get_tzname() {\n return 17988;\n}\n\nfunction b7() {\n nullFunc_v(7);\n}\n\n// EMSCRIPTEN_END_FUNCS\nvar FUNCTION_TABLE_di = [b0,_getProjectionNearPlane,_getProjectionFarPlane,_getPattRatio];\nvar FUNCTION_TABLE_dii = [b1,__ZN10emscripten8internal7InvokerIdJiEE6invokeEPFdiEi];\nvar FUNCTION_TABLE_i = [b2,_getLogLevel];\nvar FUNCTION_TABLE_ii = [b3,___stdio_close,__ZNKSt11logic_error4whatEv,_teardown,_getMultiMarkerCount,_loadCamera,_detectMarker,_getMarkerNum,_getDebugMode,_getProcessingImage,_getThresholdMode,_getThreshold,_getPatternDetectionMode,_getMatrixCodeType,_getLabelingMode,_getImageProcMode,__ZN10emscripten8internal7InvokerIiJEE6invokeEPFivE,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3\n,b3,b3,b3];\nvar FUNCTION_TABLE_iii = [b4,_compE,_addMarker,_addMultiMarker,_getMultiMarkerNum,_setMarkerInfoVertex,_getTransMatMultiSquare,_getTransMatMultiSquareRobust,_getMarkerInfo,_setDebugMode,__ZN10emscripten8internal7InvokerIiJiEE6invokeEPFiiEi,__ZN10emscripten8internal7InvokerIiJNSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEE6invokeEPFiS8_EPNS0_11BindingTypeIS8_EUt_E,b4,b4,b4,b4];\nvar FUNCTION_TABLE_iiii = [b5,___stdio_write,___stdio_seek,___stdout_write,_sn_write,__ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv,__ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv,_setup,_setMarkerInfoDir,_getTransMatSquare,_getTransMatSquareCont,_getMultiEachMarkerInfo,__ZN10emscripten8internal7InvokerIiJiNSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEE6invokeEPFiiS8_EiPNS0_11BindingTypeIS8_EUt_E,__ZN10emscripten8internal7InvokerIiJiiEE6invokeEPFiiiEii,___stdio_read,_do_read];\nvar FUNCTION_TABLE_iiiii = [b6,__ZN10emscripten8internal7InvokerIiJiiiEE6invokeEPFiiiiEiii];\nvar FUNCTION_TABLE_v = [b7,__ZL25default_terminate_handlerv,__ZN10__cxxabiv112_GLOBAL__N_110construct_Ev,b7];\nvar FUNCTION_TABLE_vi = [b8,__ZN10__cxxabiv116__shim_type_infoD2Ev,__ZN10__cxxabiv117__class_type_infoD0Ev,__ZNK10__cxxabiv116__shim_type_info5noop1Ev,__ZNK10__cxxabiv116__shim_type_info5noop2Ev,__ZN10__cxxabiv120__si_class_type_infoD0Ev,__ZNSt11logic_errorD2Ev,__ZNSt11logic_errorD0Ev,__ZNSt12length_errorD0Ev,__ZN10__cxxabiv123__fundamental_type_infoD0Ev,__ZN10__cxxabiv121__vmi_class_type_infoD0Ev,_setLogLevel,__ZN10__cxxabiv112_GLOBAL__N_19destruct_EPv,b8,b8,b8];\nvar FUNCTION_TABLE_vid = [b9,_setProjectionNearPlane,_setProjectionFarPlane,_setPattRatio];\nvar FUNCTION_TABLE_vii = [b10,_setThresholdMode,_setThreshold,_setPatternDetectionMode,_setMatrixCodeType,_setLabelingMode,_setImageProcMode,__ZN10emscripten8internal7InvokerIvJiEE6invokeEPFviEi];\nvar FUNCTION_TABLE_viid = [b11,__ZN10emscripten8internal7InvokerIvJidEE6invokeEPFvidEid,__ZN10emscripten8internal7InvokerIvJifEE6invokeEPFvifEif,b11];\nvar FUNCTION_TABLE_viii = [b12,__ZN10emscripten8internal7InvokerIvJiiEE6invokeEPFviiEii];\nvar FUNCTION_TABLE_viiii = [b13,__ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi,__ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi,__ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi];\nvar FUNCTION_TABLE_viiiii = [b14,__ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib,__ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib,__ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib];\nvar FUNCTION_TABLE_viiiiii = [b15,__ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib,__ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib,__ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib];\n\n  return { __GLOBAL__sub_I_ARToolKitJS_cpp: __GLOBAL__sub_I_ARToolKitJS_cpp, __GLOBAL__sub_I_bind_cpp: __GLOBAL__sub_I_bind_cpp, ___cxa_demangle: ___cxa_demangle, ___emscripten_environ_constructor: ___emscripten_environ_constructor, ___errno_location: ___errno_location, ___getTypeName: ___getTypeName, ___muldi3: ___muldi3, ___udivdi3: ___udivdi3, __get_daylight: __get_daylight, __get_environ: __get_environ, __get_timezone: __get_timezone, __get_tzname: __get_tzname, _bitshift64Lshr: _bitshift64Lshr, _bitshift64Shl: _bitshift64Shl, _emscripten_replace_memory: _emscripten_replace_memory, _fflush: _fflush, _free: _free, _i64Add: _i64Add, _i64Subtract: _i64Subtract, _llvm_bswap_i32: _llvm_bswap_i32, _malloc: _malloc, _memcpy: _memcpy, _memmove: _memmove, _memset: _memset, _sbrk: _sbrk, dynCall_di: dynCall_di, dynCall_dii: dynCall_dii, dynCall_i: dynCall_i, dynCall_ii: dynCall_ii, dynCall_iii: dynCall_iii, dynCall_iiii: dynCall_iiii, dynCall_iiiii: dynCall_iiiii, dynCall_v: dynCall_v, dynCall_vi: dynCall_vi, dynCall_vid: dynCall_vid, dynCall_vii: dynCall_vii, dynCall_viid: dynCall_viid, dynCall_viii: dynCall_viii, dynCall_viiii: dynCall_viiii, dynCall_viiiii: dynCall_viiiii, dynCall_viiiiii: dynCall_viiiiii, establishStackSpace: establishStackSpace, getTempRet0: getTempRet0, runPostSets: runPostSets, setTempRet0: setTempRet0, setThrew: setThrew, stackAlloc: stackAlloc, stackRestore: stackRestore, stackSave: stackSave };\n})\n// EMSCRIPTEN_END_ASM\n(Module.asmGlobalArg, Module.asmLibraryArg, buffer);\n\nvar real___GLOBAL__sub_I_ARToolKitJS_cpp = asm[\"__GLOBAL__sub_I_ARToolKitJS_cpp\"]; asm[\"__GLOBAL__sub_I_ARToolKitJS_cpp\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___GLOBAL__sub_I_ARToolKitJS_cpp.apply(null, arguments);\n};\n\nvar real___GLOBAL__sub_I_bind_cpp = asm[\"__GLOBAL__sub_I_bind_cpp\"]; asm[\"__GLOBAL__sub_I_bind_cpp\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___GLOBAL__sub_I_bind_cpp.apply(null, arguments);\n};\n\nvar real____cxa_demangle = asm[\"___cxa_demangle\"]; asm[\"___cxa_demangle\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____cxa_demangle.apply(null, arguments);\n};\n\nvar real____emscripten_environ_constructor = asm[\"___emscripten_environ_constructor\"]; asm[\"___emscripten_environ_constructor\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____emscripten_environ_constructor.apply(null, arguments);\n};\n\nvar real____errno_location = asm[\"___errno_location\"]; asm[\"___errno_location\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____errno_location.apply(null, arguments);\n};\n\nvar real____getTypeName = asm[\"___getTypeName\"]; asm[\"___getTypeName\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____getTypeName.apply(null, arguments);\n};\n\nvar real____muldi3 = asm[\"___muldi3\"]; asm[\"___muldi3\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____muldi3.apply(null, arguments);\n};\n\nvar real____udivdi3 = asm[\"___udivdi3\"]; asm[\"___udivdi3\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____udivdi3.apply(null, arguments);\n};\n\nvar real___get_daylight = asm[\"__get_daylight\"]; asm[\"__get_daylight\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___get_daylight.apply(null, arguments);\n};\n\nvar real___get_environ = asm[\"__get_environ\"]; asm[\"__get_environ\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___get_environ.apply(null, arguments);\n};\n\nvar real___get_timezone = asm[\"__get_timezone\"]; asm[\"__get_timezone\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___get_timezone.apply(null, arguments);\n};\n\nvar real___get_tzname = asm[\"__get_tzname\"]; asm[\"__get_tzname\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___get_tzname.apply(null, arguments);\n};\n\nvar real__bitshift64Lshr = asm[\"_bitshift64Lshr\"]; asm[\"_bitshift64Lshr\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__bitshift64Lshr.apply(null, arguments);\n};\n\nvar real__bitshift64Shl = asm[\"_bitshift64Shl\"]; asm[\"_bitshift64Shl\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__bitshift64Shl.apply(null, arguments);\n};\n\nvar real__fflush = asm[\"_fflush\"]; asm[\"_fflush\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__fflush.apply(null, arguments);\n};\n\nvar real__free = asm[\"_free\"]; asm[\"_free\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__free.apply(null, arguments);\n};\n\nvar real__i64Add = asm[\"_i64Add\"]; asm[\"_i64Add\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__i64Add.apply(null, arguments);\n};\n\nvar real__i64Subtract = asm[\"_i64Subtract\"]; asm[\"_i64Subtract\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__i64Subtract.apply(null, arguments);\n};\n\nvar real__llvm_bswap_i32 = asm[\"_llvm_bswap_i32\"]; asm[\"_llvm_bswap_i32\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__llvm_bswap_i32.apply(null, arguments);\n};\n\nvar real__malloc = asm[\"_malloc\"]; asm[\"_malloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__malloc.apply(null, arguments);\n};\n\nvar real__memmove = asm[\"_memmove\"]; asm[\"_memmove\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__memmove.apply(null, arguments);\n};\n\nvar real__sbrk = asm[\"_sbrk\"]; asm[\"_sbrk\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__sbrk.apply(null, arguments);\n};\n\nvar real_establishStackSpace = asm[\"establishStackSpace\"]; asm[\"establishStackSpace\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_establishStackSpace.apply(null, arguments);\n};\n\nvar real_getTempRet0 = asm[\"getTempRet0\"]; asm[\"getTempRet0\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_getTempRet0.apply(null, arguments);\n};\n\nvar real_setTempRet0 = asm[\"setTempRet0\"]; asm[\"setTempRet0\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_setTempRet0.apply(null, arguments);\n};\n\nvar real_setThrew = asm[\"setThrew\"]; asm[\"setThrew\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_setThrew.apply(null, arguments);\n};\n\nvar real_stackAlloc = asm[\"stackAlloc\"]; asm[\"stackAlloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackAlloc.apply(null, arguments);\n};\n\nvar real_stackRestore = asm[\"stackRestore\"]; asm[\"stackRestore\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackRestore.apply(null, arguments);\n};\n\nvar real_stackSave = asm[\"stackSave\"]; asm[\"stackSave\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackSave.apply(null, arguments);\n};\nvar __GLOBAL__sub_I_ARToolKitJS_cpp = Module[\"__GLOBAL__sub_I_ARToolKitJS_cpp\"] = asm[\"__GLOBAL__sub_I_ARToolKitJS_cpp\"];\nvar __GLOBAL__sub_I_bind_cpp = Module[\"__GLOBAL__sub_I_bind_cpp\"] = asm[\"__GLOBAL__sub_I_bind_cpp\"];\nvar ___cxa_demangle = Module[\"___cxa_demangle\"] = asm[\"___cxa_demangle\"];\nvar ___emscripten_environ_constructor = Module[\"___emscripten_environ_constructor\"] = asm[\"___emscripten_environ_constructor\"];\nvar ___errno_location = Module[\"___errno_location\"] = asm[\"___errno_location\"];\nvar ___getTypeName = Module[\"___getTypeName\"] = asm[\"___getTypeName\"];\nvar ___muldi3 = Module[\"___muldi3\"] = asm[\"___muldi3\"];\nvar ___udivdi3 = Module[\"___udivdi3\"] = asm[\"___udivdi3\"];\nvar __get_daylight = Module[\"__get_daylight\"] = asm[\"__get_daylight\"];\nvar __get_environ = Module[\"__get_environ\"] = asm[\"__get_environ\"];\nvar __get_timezone = Module[\"__get_timezone\"] = asm[\"__get_timezone\"];\nvar __get_tzname = Module[\"__get_tzname\"] = asm[\"__get_tzname\"];\nvar _bitshift64Lshr = Module[\"_bitshift64Lshr\"] = asm[\"_bitshift64Lshr\"];\nvar _bitshift64Shl = Module[\"_bitshift64Shl\"] = asm[\"_bitshift64Shl\"];\nvar _emscripten_replace_memory = Module[\"_emscripten_replace_memory\"] = asm[\"_emscripten_replace_memory\"];\nvar _fflush = Module[\"_fflush\"] = asm[\"_fflush\"];\nvar _free = Module[\"_free\"] = asm[\"_free\"];\nvar _i64Add = Module[\"_i64Add\"] = asm[\"_i64Add\"];\nvar _i64Subtract = Module[\"_i64Subtract\"] = asm[\"_i64Subtract\"];\nvar _llvm_bswap_i32 = Module[\"_llvm_bswap_i32\"] = asm[\"_llvm_bswap_i32\"];\nvar _malloc = Module[\"_malloc\"] = asm[\"_malloc\"];\nvar _memcpy = Module[\"_memcpy\"] = asm[\"_memcpy\"];\nvar _memmove = Module[\"_memmove\"] = asm[\"_memmove\"];\nvar _memset = Module[\"_memset\"] = asm[\"_memset\"];\nvar _sbrk = Module[\"_sbrk\"] = asm[\"_sbrk\"];\nvar establishStackSpace = Module[\"establishStackSpace\"] = asm[\"establishStackSpace\"];\nvar getTempRet0 = Module[\"getTempRet0\"] = asm[\"getTempRet0\"];\nvar runPostSets = Module[\"runPostSets\"] = asm[\"runPostSets\"];\nvar setTempRet0 = Module[\"setTempRet0\"] = asm[\"setTempRet0\"];\nvar setThrew = Module[\"setThrew\"] = asm[\"setThrew\"];\nvar stackAlloc = Module[\"stackAlloc\"] = asm[\"stackAlloc\"];\nvar stackRestore = Module[\"stackRestore\"] = asm[\"stackRestore\"];\nvar stackSave = Module[\"stackSave\"] = asm[\"stackSave\"];\nvar dynCall_di = Module[\"dynCall_di\"] = asm[\"dynCall_di\"];\nvar dynCall_dii = Module[\"dynCall_dii\"] = asm[\"dynCall_dii\"];\nvar dynCall_i = Module[\"dynCall_i\"] = asm[\"dynCall_i\"];\nvar dynCall_ii = Module[\"dynCall_ii\"] = asm[\"dynCall_ii\"];\nvar dynCall_iii = Module[\"dynCall_iii\"] = asm[\"dynCall_iii\"];\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = asm[\"dynCall_iiii\"];\nvar dynCall_iiiii = Module[\"dynCall_iiiii\"] = asm[\"dynCall_iiiii\"];\nvar dynCall_v = Module[\"dynCall_v\"] = asm[\"dynCall_v\"];\nvar dynCall_vi = Module[\"dynCall_vi\"] = asm[\"dynCall_vi\"];\nvar dynCall_vid = Module[\"dynCall_vid\"] = asm[\"dynCall_vid\"];\nvar dynCall_vii = Module[\"dynCall_vii\"] = asm[\"dynCall_vii\"];\nvar dynCall_viid = Module[\"dynCall_viid\"] = asm[\"dynCall_viid\"];\nvar dynCall_viii = Module[\"dynCall_viii\"] = asm[\"dynCall_viii\"];\nvar dynCall_viiii = Module[\"dynCall_viiii\"] = asm[\"dynCall_viiii\"];\nvar dynCall_viiiii = Module[\"dynCall_viiiii\"] = asm[\"dynCall_viiiii\"];\nvar dynCall_viiiiii = Module[\"dynCall_viiiiii\"] = asm[\"dynCall_viiiiii\"];\n;\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule['asm'] = asm;\n\nif (!Module[\"intArrayFromString\"]) Module[\"intArrayFromString\"] = function() { abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"intArrayToString\"]) Module[\"intArrayToString\"] = function() { abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"ccall\"]) Module[\"ccall\"] = function() { abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"cwrap\"]) Module[\"cwrap\"] = function() { abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"setValue\"]) Module[\"setValue\"] = function() { abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getValue\"]) Module[\"getValue\"] = function() { abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"allocate\"]) Module[\"allocate\"] = function() { abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getMemory\"]) Module[\"getMemory\"] = function() { abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"Pointer_stringify\"]) Module[\"Pointer_stringify\"] = function() { abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"AsciiToString\"]) Module[\"AsciiToString\"] = function() { abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToAscii\"]) Module[\"stringToAscii\"] = function() { abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"UTF8ArrayToString\"]) Module[\"UTF8ArrayToString\"] = function() { abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"UTF8ToString\"]) Module[\"UTF8ToString\"] = function() { abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToUTF8Array\"]) Module[\"stringToUTF8Array\"] = function() { abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToUTF8\"]) Module[\"stringToUTF8\"] = function() { abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"lengthBytesUTF8\"]) Module[\"lengthBytesUTF8\"] = function() { abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"UTF16ToString\"]) Module[\"UTF16ToString\"] = function() { abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToUTF16\"]) Module[\"stringToUTF16\"] = function() { abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"lengthBytesUTF16\"]) Module[\"lengthBytesUTF16\"] = function() { abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"UTF32ToString\"]) Module[\"UTF32ToString\"] = function() { abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stringToUTF32\"]) Module[\"stringToUTF32\"] = function() { abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"lengthBytesUTF32\"]) Module[\"lengthBytesUTF32\"] = function() { abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"allocateUTF8\"]) Module[\"allocateUTF8\"] = function() { abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stackTrace\"]) Module[\"stackTrace\"] = function() { abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnPreRun\"]) Module[\"addOnPreRun\"] = function() { abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnInit\"]) Module[\"addOnInit\"] = function() { abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnPreMain\"]) Module[\"addOnPreMain\"] = function() { abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnExit\"]) Module[\"addOnExit\"] = function() { abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addOnPostRun\"]) Module[\"addOnPostRun\"] = function() { abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"writeStringToMemory\"]) Module[\"writeStringToMemory\"] = function() { abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"writeArrayToMemory\"]) Module[\"writeArrayToMemory\"] = function() { abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"writeAsciiToMemory\"]) Module[\"writeAsciiToMemory\"] = function() { abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addRunDependency\"]) Module[\"addRunDependency\"] = function() { abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"removeRunDependency\"]) Module[\"removeRunDependency\"] = function() { abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS\"]) Module[\"FS\"] = function() { abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"FS_createFolder\"]) Module[\"FS_createFolder\"] = function() { abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createPath\"]) Module[\"FS_createPath\"] = function() { abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createDataFile\"]) Module[\"FS_createDataFile\"] = function() { abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createPreloadedFile\"]) Module[\"FS_createPreloadedFile\"] = function() { abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createLazyFile\"]) Module[\"FS_createLazyFile\"] = function() { abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createLink\"]) Module[\"FS_createLink\"] = function() { abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_createDevice\"]) Module[\"FS_createDevice\"] = function() { abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"FS_unlink\"]) Module[\"FS_unlink\"] = function() { abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Module[\"GL\"]) Module[\"GL\"] = function() { abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"staticAlloc\"]) Module[\"staticAlloc\"] = function() { abort(\"'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"dynamicAlloc\"]) Module[\"dynamicAlloc\"] = function() { abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"warnOnce\"]) Module[\"warnOnce\"] = function() { abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"loadDynamicLibrary\"]) Module[\"loadDynamicLibrary\"] = function() { abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"loadWebAssemblyModule\"]) Module[\"loadWebAssemblyModule\"] = function() { abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getLEB\"]) Module[\"getLEB\"] = function() { abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getFunctionTables\"]) Module[\"getFunctionTables\"] = function() { abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"alignFunctionTables\"]) Module[\"alignFunctionTables\"] = function() { abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"registerFunctions\"]) Module[\"registerFunctions\"] = function() { abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"addFunction\"]) Module[\"addFunction\"] = function() { abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"removeFunction\"]) Module[\"removeFunction\"] = function() { abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getFuncWrapper\"]) Module[\"getFuncWrapper\"] = function() { abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"prettyPrint\"]) Module[\"prettyPrint\"] = function() { abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"makeBigInt\"]) Module[\"makeBigInt\"] = function() { abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"dynCall\"]) Module[\"dynCall\"] = function() { abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"getCompilerSetting\"]) Module[\"getCompilerSetting\"] = function() { abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stackSave\"]) Module[\"stackSave\"] = function() { abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stackRestore\"]) Module[\"stackRestore\"] = function() { abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"stackAlloc\"]) Module[\"stackAlloc\"] = function() { abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"intArrayFromBase64\"]) Module[\"intArrayFromBase64\"] = function() { abort(\"'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Module[\"tryParseAsDataURI\"]) Module[\"tryParseAsDataURI\"] = function() { abort(\"'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };if (!Module[\"ALLOC_NORMAL\"]) Object.defineProperty(Module, \"ALLOC_NORMAL\", { get: function() { abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Module[\"ALLOC_STACK\"]) Object.defineProperty(Module, \"ALLOC_STACK\", { get: function() { abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Module[\"ALLOC_STATIC\"]) Object.defineProperty(Module, \"ALLOC_STATIC\", { get: function() { abort(\"'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", { get: function() { abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Module[\"ALLOC_NONE\"]) Object.defineProperty(Module, \"ALLOC_NONE\", { get: function() { abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\n\nif (memoryInitializer) {\n  if (!isDataURI(memoryInitializer)) {\n    if (typeof Module['locateFile'] === 'function') {\n      memoryInitializer = Module['locateFile'](memoryInitializer);\n    } else if (Module['memoryInitializerPrefixURL']) {\n      memoryInitializer = Module['memoryInitializerPrefixURL'] + memoryInitializer;\n    }\n  }\n  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {\n    var data = Module['readBinary'](memoryInitializer);\n    HEAPU8.set(data, GLOBAL_BASE);\n  } else {\n    addRunDependency('memory initializer');\n    var applyMemoryInitializer = function(data) {\n      if (data.byteLength) data = new Uint8Array(data);\n      for (var i = 0; i < data.length; i++) {\n        assert(HEAPU8[GLOBAL_BASE + i] === 0, \"area for memory initializer should not have been touched before it's loaded\");\n      }\n      HEAPU8.set(data, GLOBAL_BASE);\n      // Delete the typed array that contains the large blob of the memory initializer request response so that\n      // we won't keep unnecessary memory lying around. However, keep the XHR object itself alive so that e.g.\n      // its .status field can still be accessed later.\n      if (Module['memoryInitializerRequest']) delete Module['memoryInitializerRequest'].response;\n      removeRunDependency('memory initializer');\n    }\n    function doBrowserLoad() {\n      Module['readAsync'](memoryInitializer, applyMemoryInitializer, function() {\n        throw 'could not load memory initializer ' + memoryInitializer;\n      });\n    }\n    var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);\n    if (memoryInitializerBytes) {\n      applyMemoryInitializer(memoryInitializerBytes.buffer);\n    } else\n    if (Module['memoryInitializerRequest']) {\n      // a network request has already been created, just use that\n      function useRequest() {\n        var request = Module['memoryInitializerRequest'];\n        var response = request.response;\n        if (request.status !== 200 && request.status !== 0) {\n          var data = tryParseAsDataURI(Module['memoryInitializerRequestURL']);\n          if (data) {\n            response = data.buffer;\n          } else {\n            // If you see this warning, the issue may be that you are using locateFile or memoryInitializerPrefixURL, and defining them in JS. That\n            // means that the HTML file doesn't know about them, and when it tries to create the mem init request early, does it to the wrong place.\n            // Look in your browser's devtools network console to see what's going on.\n            console.warn('a problem seems to have happened with Module.memoryInitializerRequest, status: ' + request.status + ', retrying ' + memoryInitializer);\n            doBrowserLoad();\n            return;\n          }\n        }\n        applyMemoryInitializer(response);\n      }\n      if (Module['memoryInitializerRequest'].response) {\n        setTimeout(useRequest, 0); // it's already here; but, apply it asynchronously\n      } else {\n        Module['memoryInitializerRequest'].addEventListener('load', useRequest); // wait for it\n      }\n    } else {\n      // fetch it from the network ourselves\n      doBrowserLoad();\n    }\n  }\n}\n\n\n\n/**\n * @constructor\n * @extends {Error}\n * @this {ExitStatus}\n */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n};\nExitStatus.prototype = new Error();\nExitStatus.prototype.constructor = ExitStatus;\n\nvar initialStackTop;\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!Module['calledRun']) run();\n  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n}\n\n\n\n\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || Module['arguments'];\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  writeStackCookie();\n\n  preRun();\n\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n  function doRun() {\n    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    ensureInitRuntime();\n\n    preMain();\n\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n  checkStackCookie();\n}\nModule['run'] = run;\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in NO_FILESYSTEM\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var print = Module['print'];\n  var printErr = Module['printErr'];\n  var has = false;\n  Module['print'] = Module['printErr'] = function(x) {\n    has = true;\n  }\n  try { // it doesn't matter if it fails\n    var flush = Module['_fflush'];\n    if (flush) flush(0);\n    // also flush in the JS FS layer\n    var hasFS = true;\n    if (hasFS) {\n      ['stdout', 'stderr'].forEach(function(name) {\n        var info = FS.analyzePath('/dev/' + name);\n        if (!info) return;\n        var stream = info.object;\n        var rdev = stream.rdev;\n        var tty = TTY.ttys[rdev];\n        if (tty && tty.output && tty.output.length) {\n          has = true;\n        }\n      });\n    }\n  } catch(e) {}\n  Module['print'] = print;\n  Module['printErr'] = printErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.');\n  }\n}\n\nfunction exit(status, implicit) {\n  checkUnflushedContent();\n\n  // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n  if (implicit && Module['noExitRuntime'] && status === 0) {\n    return;\n  }\n\n  if (Module['noExitRuntime']) {\n    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n    if (!implicit) {\n      Module.printErr('exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)');\n    }\n  } else {\n\n    ABORT = true;\n    EXITSTATUS = status;\n    STACKTOP = initialStackTop;\n\n    exitRuntime();\n\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  if (ENVIRONMENT_IS_NODE) {\n    process['exit'](status);\n  }\n  Module['quit'](status, new ExitStatus(status));\n}\nModule['exit'] = exit;\n\nvar abortDecorators = [];\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  if (what !== undefined) {\n    Module.print(what);\n    Module.printErr(what);\n    what = JSON.stringify(what)\n  } else {\n    what = '';\n  }\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  var extra = '';\n  var output = 'abort(' + what + ') at ' + stackTrace() + extra;\n  if (abortDecorators) {\n    abortDecorators.forEach(function(decorator) {\n      output = decorator(output, what);\n    });\n  }\n  throw output;\n}\nModule['abort'] = abort;\n\n// {{PRE_RUN_ADDITIONS}}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\n\nModule[\"noExitRuntime\"] = true;\n\nrun();\n\n// {{POST_RUN_ADDITIONS}}\n\n\n// {{MODULE_ADDITIONS}}\n\n// FS.writeFile is not exported\nModule[\"FS\"] = {\n    writeFile: FS.writeFile\n}\n\n// Needs to be exported as ES6 Module\n/* harmony default export */ __webpack_exports__[\"default\"] = (Module); \n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://THREEAR/./src/vendor/artoolkitx.js?");

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack://THREEAR/util_(ignored)?");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack://THREEAR/util_(ignored)?");

/***/ }),

/***/ 2:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack://THREEAR/buffer_(ignored)?");

/***/ }),

/***/ 3:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack://THREEAR/crypto_(ignored)?");

/***/ })

/******/ });
});